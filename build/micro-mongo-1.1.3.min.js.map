{"version":3,"file":"micro-mongo-1.1.3.min.js","sources":["../src/ObjectId.js","../src/utils.js","../src/Cursor.js","../src/SortedCursor.js","../node_modules/stemmer/index.js","../src/TextIndex.js","../src/queryMatcher.js","../src/updates.js","../src/CollectionIndex.js","../src/RegularCollectionIndex.js","../src/TextCollectionIndex.js","../src/RTree.js","../src/GeospatialCollectionIndex.js","../src/QueryPlanner.js","../src/Collection.js","../src/StorageEngine.js","../src/ObjectStorageEngine.js","../src/DB.js","../src/MongoClient.js","../src/IndexedDbStorageEngine.js","../main.js"],"sourcesContent":["/**\r\n * ObjectId class - MongoDB-compatible 24-character hex string identifier\r\n * Format: 8-char timestamp + 16-char random data\r\n */\r\nexport class ObjectId {\r\n  constructor(id) {\r\n    if (id === undefined || id === null) {\r\n      // Generate new ObjectId\r\n      this.id = ObjectId.generate();\r\n    } else if (typeof id === 'string') {\r\n      // Create from hex string\r\n      if (!ObjectId.isValid(id)) {\r\n        throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${id}`);\r\n      }\r\n      this.id = id.toLowerCase();\r\n    } else if (id instanceof ObjectId) {\r\n      // Copy constructor\r\n      this.id = id.id;\r\n    } else {\r\n      throw new Error(`Argument passed in must be a string of 24 hex characters or an ObjectId`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the ObjectId as a 24-character hex string\r\n   */\r\n  toString() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the ObjectId as a 24-character hex string (alias for toString)\r\n   */\r\n  toHexString() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the timestamp portion of the ObjectId as a Date\r\n   */\r\n  getTimestamp() {\r\n    const timestamp = parseInt(this.id.substring(0, 8), 16);\r\n    return new Date(timestamp * 1000);\r\n  }\r\n\r\n  /**\r\n   * Compares this ObjectId with another for equality\r\n   */\r\n  equals(other) {\r\n    if (!other) return false;\r\n    \r\n    if (other instanceof ObjectId) {\r\n      return this.id === other.id;\r\n    }\r\n    \r\n    if (typeof other === 'string') {\r\n      return this.id === other.toLowerCase();\r\n    }\r\n    \r\n    // Handle objects with id property\r\n    if (other.id) {\r\n      return this.id === other.id;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns the ObjectId in JSON format (as hex string)\r\n   */\r\n  toJSON() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Custom inspect for Node.js console.log\r\n   */\r\n  inspect() {\r\n    return `ObjectId(\"${this.id}\")`;\r\n  }\r\n\r\n  /**\r\n   * Validates if a string is a valid ObjectId hex string\r\n   */\r\n  static isValid(id) {\r\n    if (!id) return false;\r\n    if (typeof id !== 'string') return false;\r\n    if (id.length !== 24) return false;\r\n    return /^[0-9a-fA-F]{24}$/.test(id);\r\n  }\r\n\r\n  /**\r\n   * Creates an ObjectId from a timestamp\r\n   */\r\n  static createFromTime(timestamp) {\r\n    const ts = Math.floor(timestamp / 1000);\r\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\r\n    const tail = '0000000000000000'; // Zero out the random portion\r\n    return new ObjectId(tsHex + tail);\r\n  }\r\n\r\n  /**\r\n   * Generates a new ObjectId hex string\r\n   * Format: 8-char timestamp (4 bytes) + 16-char random data (8 bytes)\r\n   */\r\n  static generate() {\r\n    const ts = Math.floor(Date.now() / 1000);\r\n    \r\n    // Generate 8 random bytes\r\n    const rand = typeof crypto !== 'undefined' && crypto.getRandomValues ? new Uint8Array(8) : null;\r\n    let tail = '';\r\n    \r\n    if (rand) {\r\n      crypto.getRandomValues(rand);\r\n      for (let i = 0; i < rand.length; i++) {\r\n        tail += ('0' + rand[i].toString(16)).slice(-2);\r\n      }\r\n    } else {\r\n      // Fallback for environments without crypto\r\n      // Generate two 8-character hex strings\r\n      tail = Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8) +\r\n             Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8);\r\n    }\r\n    \r\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\r\n    return (tsHex + tail).slice(0, 24);\r\n  }\r\n}","/**\n * Utility functions for MicroMongoDB\n */\n\nimport { ObjectId } from './ObjectId.js';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Deep copy an object or array\n */\nexport function copy(o) {\n\t// Handle ObjectId\n\tif (o instanceof ObjectId) {\n\t\treturn new ObjectId(o.id);\n\t}\n\t\n\tvar out, v, key;\n\tout = Array.isArray(o) ? [] : {};\n\tfor (key in o) {\n\t\tv = o[key];\n\t\tout[key] = (typeof v === \"object\" && v !== null) ? copy(v) : v;\n\t}\n\treturn out;\n}\n\n/**\n * Get a property from an object using dot notation\n */\nexport function getProp(obj, name) {\n\tvar path = name.split(\".\");\n\tvar result = obj[path[0]];\n\tfor (var i = 1; i < path.length; i++) {\n\t\tif (result == undefined || result == null) return result;\n\t\tresult = result[path[i]];\n\t}\n\treturn result;\n}\n\n/**\n * Check if value is an array\n */\nexport function isArray(o) {\n\treturn Array == o.constructor;\n}\n\n/**\n * Convert object to array of key-value pairs\n */\nexport function toArray(obj) {\n\tvar arr = [];\n\tfor (var key in obj) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar el = {};\n\t\t\tel[key] = obj[key];\n\t\t\tarr.push(el);\n\t\t}\n\t}\n\treturn arr;\n}\n\n/**\n * Check if a value is in an array\n */\nexport function isIn(val, values) {\n\tfor (var i = 0; i < values.length; i++) {\n\t\tif (valuesEqual(values[i], val)) return true;\n\t}\n\treturn false;\n}\n\n/**\n * Check if two arrays match\n */\nexport function arrayMatches(x, y) {\n\tif (x.length != y.length) return false;\n\tfor (var i = 0; i < x.length; i++) {\n\t\tif (valuesEqual(x[i], y[i])) continue;\n\t\tif (typeof (x[i]) != typeof (y[i])) return false;\n\t\tif (typeof (x[i]) == \"object\" && x[i] !== null) {\n\t\t\tif (isArray(x[i])) {\n\t\t\t\tif (!arrayMatches(x[i], y[i])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[i], y[i])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[i], y[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Check if two objects match\n */\nexport function objectMatches(x, y) {\n\tfor (var p in x) {\n\t\tif (!x.hasOwnProperty(p)) continue;\n\t\tif (!y.hasOwnProperty(p)) return false;\n\t\tif (valuesEqual(x[p], y[p])) continue;\n\t\tif (typeof (x[p]) != typeof (y[p])) return false;\n\t\tif (typeof (x[p]) == \"object\" && x[p] !== null) {\n\t\t\tif (isArray(x[p])) {\n\t\t\t\tif (!arrayMatches(x[p], y[p])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[p], y[p])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[p], y[p])) return false;\n\t\t}\n\t}\n\tfor (var p in y) {\n\t\tif (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Apply projection to a document\n */\nexport function applyProjection(projection, doc) {\n\tvar result = {};\n\tvar keys = Object.keys(projection);\n\tif (keys.length == 0) return doc;\n\t\n\t// Check for mixed inclusion/exclusion (except _id which can be excluded in inclusion projection)\n\tvar hasInclusion = false;\n\tvar hasExclusion = false;\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (keys[i] === '_id') continue; // _id is special\n\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\telse hasExclusion = true;\n\t}\n\t\n\tif (hasInclusion && hasExclusion) {\n\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t}\n\t\n\tif (projection[keys[0]] || hasInclusion) {\n\t\t// inclusion with _id (unless explicitly excluded)\n\t\tif (projection._id !== 0) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i] === '_id') continue;\n\t\t\tif (!projection[keys[i]]) continue;\n\t\t\tresult[keys[i]] = doc[keys[i]];\n\t\t}\n\t} else {\n\t\t// exclusion\n\t\tfor (var key in doc) {\n\t\t\tresult[key] = doc[key];\n\t\t}\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (projection[keys[i]]) continue;\n\t\t\tdelete result[keys[i]];\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Convert bbox to GeoJSON\n */\nexport function bboxToGeojson(bbox) {\n\tconst minLon = bbox[0][0];\n\tconst maxLat = bbox[0][1];\n\tconst maxLon = bbox[1][0];\n\tconst minLat = bbox[1][1];\n\treturn {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: [{\n\t\t\ttype: 'Feature',\n\t\t\tproperties: {},\n\t\t\tgeometry: {\n\t\t\t\ttype: 'Polygon',\n\t\t\t\tcoordinates: [[\n\t\t\t\t\t[minLon, maxLat],\n\t\t\t\t\t[minLon, minLat],\n\t\t\t\t\t[maxLon, minLat],\n\t\t\t\t\t[maxLon, maxLat],\n\t\t\t\t\t[minLon, maxLat]\n\t\t\t\t]]\n\t\t\t}\n\t\t}]\n\t};\n}\n","import { applyProjection } from './utils.js';\n\n/**\n * Cursor class for iterating over query results\n */\nexport class Cursor {\n\tconstructor(collection, query, projection, matches, storage, indexes, planQuery, SortedCursor) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.projection = projection;\n\t\tthis.matches = matches;\n\t\tthis.storage = storage;\n\t\tthis.indexes = indexes;\n\t\tthis.planQuery = planQuery;\n\t\tthis.SortedCursor = SortedCursor;\n\t\t\n\t\t// Validate projection if provided\n\t\tif (projection && Object.keys(projection).length > 0) {\n\t\t\tconst keys = Object.keys(projection);\n\t\t\tlet hasInclusion = false;\n\t\t\tlet hasExclusion = false;\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tif (keys[i] === '_id') continue; // _id is special\n\t\t\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\t\t\telse hasExclusion = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (hasInclusion && hasExclusion) {\n\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.pos = 0;\n\t\tthis.max = 0;\n\t\tthis._next = false; // false == unknown, null == no more, !null == next\n\t\t\n\t\t// Query planning - check if we can use an index\n\t\tconst queryPlan = this.planQuery(this.query);\n\t\tthis.useIndex = queryPlan && queryPlan.useIndex;\n\t\tthis.planType = queryPlan ? queryPlan.planType : 'full_scan';\n\t\tthis.indexDocIds = null;\n\t\tthis.indexPos = 0;\n\t\tthis.fullScanDocIds = {}; // Track which docs we've seen to avoid duplicates\n\n\t\t// If using index, get the document IDs from the query plan\n\t\tif (this.useIndex && queryPlan.docIds) {\n\t\t\tthis.indexDocIds = queryPlan.docIds.slice();\n\t\t}\n\t\t\n\t\t// Initialize by finding first document\n\t\tthis._findNext();\n\t}\n\n\t_findNext() {\n\t\t// First, try to get documents from index\n\t\twhile (this.indexDocIds !== null && this.indexPos < this.indexDocIds.length) {\n\t\t\tconst docId = this.indexDocIds[this.indexPos++];\n\t\t\tconst doc = this.storage.getStore()[docId];\n\t\t\tif (doc && this.matches(doc, this.query)) {\n\t\t\t\tthis.fullScanDocIds[doc._id] = true;\n\t\t\t\tthis._next = doc;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If doc doesn't match (shouldn't happen with good index), continue to next\n\t\t}\n\n\t\t// Then fall back to full scan for remaining documents\n\t\t// This handles complex queries where index only partially matches\n\t\twhile (this.pos < this.storage.size() && (this.max == 0 || this.pos < this.max)) {\n\t\t\tconst cur = this.storage.get(this.pos++);\n\t\t\t// Skip docs we already returned from index\n\t\t\tif (cur && !this.fullScanDocIds[cur._id] && this.matches(cur, this.query)) {\n\t\t\t\tthis.fullScanDocIds[cur._id] = true;\n\t\t\t\tthis._next = cur;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._next = null;\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\tlet num = 0;\n\t\tconst c = new Cursor(this.collection, this.query, null, this.matches, this.storage, this.indexes, this.planQuery, this.SortedCursor);\n\t\twhile (c.hasNext()) {\n\t\t\tnum++;\n\t\t\tc.next();\n\t\t}\n\t\treturn num;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\tif (this._next === false) this._findNext();\n\t\treturn this._next != null;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(_max) {\n\t\tthis.max = _max;\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\tif (this._next == null) throw \"Error: error hasNext: false\";\n\t\tconst result = this._next;\n\t\tthis._findNext();\n\t\tif (this.projection) return applyProjection(this.projection, result);\n\t\telse return result;\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new this.SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","/**\n * SortedCursor class for iterating over sorted query results\n */\nexport class SortedCursor {\n\tconstructor(collection, query, cursor, sort) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.sortSpec = sort;\n\t\tthis.pos = 0;\n\t\tthis.items = [];\n\t\t\n\t\t// Collect all items from the cursor\n\t\twhile (cursor.hasNext()) {\n\t\t\tthis.items.push(cursor.next());\n\t\t}\n\t\t\n\t\t// Sort the items\n\t\tconst sortKeys = Object.keys(sort);\n\t\tthis.items.sort(function(a, b) {\n\t\t\tfor (let i = 0; i < sortKeys.length; i++) {\n\t\t\t\tif (a[sortKeys[i]] == undefined && b[sortKeys[i]] != undefined) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] != undefined && b[sortKeys[i]] == undefined) return 1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] < b[sortKeys[i]]) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] > b[sortKeys[i]]) return 1 * sort[sortKeys[i]];\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\treturn this.items.length;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\treturn this.pos < this.items.length;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(max) {\n\t\tthis.items = this.items.slice(0, max);\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\treturn this.items[this.pos++];\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","// Standard suffix manipulations.\n/** @type {Record<string, string>} */\nconst step2list = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant-vowel sequences.\nconst consonant = '[^aeiou]'\nconst vowel = '[aeiouy]'\nconst consonants = '(' + consonant + '[^aeiouy]*)'\nconst vowels = '(' + vowel + '[aeiou]*)'\n\nconst gt0 = new RegExp('^' + consonants + '?' + vowels + consonants)\nconst eq1 = new RegExp(\n  '^' + consonants + '?' + vowels + consonants + vowels + '?$'\n)\nconst gt1 = new RegExp('^' + consonants + '?(' + vowels + consonants + '){2,}')\nconst vowelInStem = new RegExp('^' + consonants + '?' + vowel)\nconst consonantLike = new RegExp('^' + consonants + vowel + '[^aeiouwxy]$')\n\n// Exception expressions.\nconst sfxLl = /ll$/\nconst sfxE = /^(.+?)e$/\nconst sfxY = /^(.+?)y$/\nconst sfxIon = /^(.+?(s|t))(ion)$/\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/\nconst sfxEED = /^(.+?)eed$/\nconst sfxS = /^.+?[^s]s$/\nconst sfxSsesOrIes = /^.+?(ss|i)es$/\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nexport function stemmer(value) {\n  let result = String(value).toLowerCase()\n\n  // Exit early.\n  if (result.length < 3) {\n    return result\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true\n    result = 'Y' + result.slice(1)\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2)\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1)\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1]\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += 'e'\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += 'e'\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + 'i'\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]]\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]]\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1]\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1]\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1]\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1)\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = 'y' + result.slice(1)\n  }\n\n  return result\n}\n","import { stemmer } from 'stemmer';\n\n// Common English stop words that don't add semantic value to searches\nconst STOPWORDS = new Set([\n  'a', 'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', \n  'around', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'between', 'both', \n  'but', 'by', 'came', 'can', 'come', 'could', 'did', 'do', 'each', 'for', 'from', \n  'get', 'got', 'has', 'had', 'he', 'have', 'her', 'here', 'him', 'himself', 'his', \n  'how', 'i', 'if', 'in', 'into', 'is', 'it', 'like', 'make', 'many', 'me', 'might', \n  'more', 'most', 'much', 'must', 'my', 'never', 'now', 'of', 'on', 'only', 'or', \n  'other', 'our', 'out', 'over', 'said', 'same', 'see', 'should', 'since', 'some', \n  'still', 'such', 'take', 'than', 'that', 'the', 'their', 'them', 'then', 'there', \n  'these', 'they', 'this', 'those', 'through', 'to', 'too', 'under', 'up', 'very', \n  'was', 'way', 'we', 'well', 'were', 'what', 'where', 'which', 'while', 'who', \n  'with', 'would', 'you', 'your'\n]);\n\n/**\n * TextIndex - A text index implementation using Porter stemmer algorithm\n * \n * This class provides full-text search capabilities by indexing terms\n * and associating them with document IDs. It uses the Porter stemmer\n * algorithm to normalize words to their root forms.\n */\nexport class TextIndex {\n  constructor(options = {}) {\n    // Map from stemmed term to Map of document IDs to term frequency\n    // Structure: term -> { docId: frequency }\n    this.index = new Map();\n    // Map from document ID to Map of stemmed terms to their frequency\n    // Structure: docId -> { term: frequency }\n    this.documentTerms = new Map();\n    // Map from document ID to total term count (for normalization)\n    this.documentLengths = new Map();\n    // Stop words configuration\n    this.useStopWords = options.useStopWords !== false; // default: true\n    // Create a copy of STOPWORDS to avoid mutating the global set\n    this.stopWords = options.stopWords || new Set(STOPWORDS);\n  }\n\n  /**\n   * Tokenize text into individual words\n   * @param {string} text - The text to tokenize\n   * @returns {string[]} Array of words\n   */\n  _tokenize(text) {\n    if (typeof text !== 'string') {\n      return [];\n    }\n    // Split on non-word characters and filter out empty strings\n    const words = text.toLowerCase()\n      .split(/\\W+/)\n      .filter(word => word.length > 0);\n    \n    // Filter stop words if enabled\n    if (this.useStopWords) {\n      return words.filter(word => !this.stopWords.has(word));\n    }\n    \n    return words;\n  }\n\n  /**\n   * Add terms from text to the index for a given document ID\n   * @param {string} docId - The document identifier\n   * @param {string} text - The text content to index\n   */\n  add(docId, text) {\n    if (!docId) {\n      throw new Error('Document ID is required');\n    }\n\n    const words = this._tokenize(text);\n    const termFrequency = new Map();\n\n    // Count term frequencies\n    words.forEach(word => {\n      const stem = stemmer(word);\n      termFrequency.set(stem, (termFrequency.get(stem) || 0) + 1);\n    });\n\n    // Add to index\n    termFrequency.forEach((frequency, stem) => {\n      if (!this.index.has(stem)) {\n        this.index.set(stem, new Map());\n      }\n      this.index.get(stem).set(docId, frequency);\n    });\n\n    // Track document terms and frequencies\n    this.documentTerms.set(docId, termFrequency);\n    this.documentLengths.set(docId, words.length);\n  }\n\n  /**\n   * Remove all indexed terms for a given document ID\n   * @param {string} docId - The document identifier to remove\n   * @returns {boolean} True if document was found and removed, false otherwise\n   */\n  remove(docId) {\n    if (!this.documentTerms.has(docId)) {\n      return false;\n    }\n\n    // Get all terms associated with this document\n    const terms = this.documentTerms.get(docId);\n\n    // Remove document ID from each term's posting list\n    terms.forEach((frequency, term) => {\n      if (this.index.has(term)) {\n        this.index.get(term).delete(docId);\n        // Clean up empty term entries\n        if (this.index.get(term).size === 0) {\n          this.index.delete(term);\n        }\n      }\n    });\n\n    // Remove document from tracking\n    this.documentTerms.delete(docId);\n    this.documentLengths.delete(docId);\n    return true;\n  }\n\n  /**\n   * Query the index for documents containing the given terms with relevance scoring\n   * @param {string} queryText - The search query text\n   * @param {Object} options - Query options\n   * @param {boolean} options.scored - If true, return scored results; if false, return just IDs (default: true)\n   * @param {boolean} options.requireAll - If true, require ALL terms; if false, rank by relevance (default: false)\n   * @returns {Array} Array of document IDs (if scored=false) or objects with {id, score} (if scored=true)\n   */\n  query(queryText, options = { scored: true, requireAll: false }) {\n    const words = this._tokenize(queryText);\n    if (words.length === 0) {\n      return [];\n    }\n\n    // Get stemmed versions of query terms\n    const stemmedTerms = words.map(word => stemmer(word));\n    const uniqueTerms = [...new Set(stemmedTerms)];\n\n    if (options.requireAll) {\n      // Strict AND logic - document must contain ALL terms\n      const docSets = uniqueTerms.map(term => {\n        const termDocs = this.index.get(term);\n        return termDocs ? new Set(termDocs.keys()) : new Set();\n      });\n\n      if (docSets.length === 0) {\n        return [];\n      }\n\n      // Compute intersection of all document sets\n      const intersection = new Set(docSets[0]);\n      for (let i = 1; i < docSets.length; i++) {\n        for (const docId of intersection) {\n          if (!docSets[i].has(docId)) {\n            intersection.delete(docId);\n          }\n        }\n      }\n\n      return Array.from(intersection);\n    }\n\n    // Relevance-based scoring (OR logic with ranking)\n    // Calculate IDF (Inverse Document Frequency) for each term\n    const totalDocs = this.documentLengths.size;\n    const idf = new Map();\n    \n    uniqueTerms.forEach(term => {\n      const docsWithTerm = this.index.get(term)?.size || 0;\n      if (docsWithTerm > 0) {\n        // IDF = log(totalDocs / docsWithTerm)\n        idf.set(term, Math.log(totalDocs / docsWithTerm));\n      }\n    });\n\n    // Collect all documents that contain at least one query term\n    const docScores = new Map();\n\n    uniqueTerms.forEach(term => {\n      const termDocs = this.index.get(term);\n      if (!termDocs) return;\n\n      termDocs.forEach((termFreq, docId) => {\n        if (!docScores.has(docId)) {\n          docScores.set(docId, 0);\n        }\n\n        // Calculate TF-IDF score\n        // TF = term frequency in document / total terms in document\n        const docLength = this.documentLengths.get(docId) || 1;\n        const tf = termFreq / docLength;\n        \n        // Add to document's total score\n        const termIdf = idf.get(term) || 0;\n        const tfIdf = tf * termIdf;\n        \n        docScores.set(docId, docScores.get(docId) + tfIdf);\n      });\n    });\n\n    // Bonus for documents containing multiple query terms\n    docScores.forEach((score, docId) => {\n      const docTerms = this.documentTerms.get(docId);\n      if (docTerms) {\n        const matchingTerms = uniqueTerms.filter(term => docTerms.has(term)).length;\n        // Boost score based on term coverage (what % of query terms are present)\n        const coverage = matchingTerms / uniqueTerms.length;\n        docScores.set(docId, score * (1 + coverage));\n      }\n    });\n\n    // Sort by score (highest first)\n    const results = Array.from(docScores.entries())\n      .map(([id, score]) => ({ id, score }))\n      .sort((a, b) => b.score - a.score);\n\n    // Return based on options\n    if (options.scored === false) {\n      return results.map(r => r.id);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Get the number of unique terms in the index\n   * @returns {number} Number of unique terms\n   */\n  getTermCount() {\n    return this.index.size;\n  }\n\n  /**\n   * Get the number of documents in the index\n   * @returns {number} Number of indexed documents\n   */\n  getDocumentCount() {\n    return this.documentTerms.size;\n  }\n\n  /**\n   * Clear all data from the index\n   */\n  clear() {\n    this.index.clear();\n    this.documentTerms.clear();\n    this.documentLengths.clear();\n  }\n\n  /**\n   * Add custom stop words\n   * @param {...string} words - Words to add to stop word list\n   * @returns {TextIndex} this for chaining\n   */\n  addStopWords(...words) {\n    words.forEach(word => this.stopWords.add(word.toLowerCase()));\n    return this;\n  }\n\n  /**\n   * Remove words from stop word list\n   * @param {...string} words - Words to remove from stop word list\n   * @returns {TextIndex} this for chaining\n   */\n  removeStopWords(...words) {\n    words.forEach(word => this.stopWords.delete(word.toLowerCase()));\n    return this;\n  }\n\n  /**\n   * Enable or disable stop word filtering\n   * @param {boolean} enabled - Whether to filter stop words\n   * @returns {TextIndex} this for chaining\n   */\n  setStopWordFiltering(enabled) {\n    this.useStopWords = enabled;\n    return this;\n  }\n\n  /**\n   * Serialize the text index state for storage\n   * @returns {Object} Serializable state\n   */\n  serialize() {\n    // Convert Maps to plain objects for JSON serialization\n    const indexObj = {};\n    this.index.forEach((docs, term) => {\n      const docsObj = {};\n      docs.forEach((freq, docId) => {\n        docsObj[docId] = freq;\n      });\n      indexObj[term] = docsObj;\n    });\n\n    const documentTermsObj = {};\n    this.documentTerms.forEach((terms, docId) => {\n      const termsObj = {};\n      terms.forEach((freq, term) => {\n        termsObj[term] = freq;\n      });\n      documentTermsObj[docId] = termsObj;\n    });\n\n    const documentLengthsObj = {};\n    this.documentLengths.forEach((length, docId) => {\n      documentLengthsObj[docId] = length;\n    });\n\n    return {\n      index: indexObj,\n      documentTerms: documentTermsObj,\n      documentLengths: documentLengthsObj,\n      useStopWords: this.useStopWords,\n      stopWords: Array.from(this.stopWords)\n    };\n  }\n\n  /**\n   * Restore the text index state from serialized data\n   * @param {Object} state - Serialized state\n   */\n  deserialize(state) {\n    // Restore index\n    this.index = new Map();\n    for (const term in state.index) {\n      const docs = new Map();\n      for (const docId in state.index[term]) {\n        docs.set(docId, state.index[term][docId]);\n      }\n      this.index.set(term, docs);\n    }\n\n    // Restore documentTerms\n    this.documentTerms = new Map();\n    for (const docId in state.documentTerms) {\n      const terms = new Map();\n      for (const term in state.documentTerms[docId]) {\n        terms.set(term, state.documentTerms[docId][term]);\n      }\n      this.documentTerms.set(docId, terms);\n    }\n\n    // Restore documentLengths\n    this.documentLengths = new Map();\n    for (const docId in state.documentLengths) {\n      this.documentLengths.set(docId, state.documentLengths[docId]);\n    }\n\n    // Restore settings\n    this.useStopWords = state.useStopWords !== false;\n    if (state.stopWords) {\n      this.stopWords = new Set(state.stopWords);\n    }\n  }\n}\n","import { getProp, isArray, arrayMatches, objectMatches, toArray, isIn, bboxToGeojson } from './utils.js';\nimport { TextIndex } from './TextIndex.js';\nimport { ObjectId } from './ObjectId.js';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Compare two values with a comparison operator, handling ObjectId instances\n */\nfunction compareValues(a, b, operator) {\n\t// Convert ObjectIds to comparable values (use timestamp for ordering)\n\tlet aVal = a;\n\tlet bVal = b;\n\t\n\tif (a instanceof ObjectId) {\n\t\taVal = a.toString();\n\t}\n\tif (b instanceof ObjectId) {\n\t\tbVal = b.toString();\n\t}\n\t\n\tswitch(operator) {\n\t\tcase '>': return aVal > bVal;\n\t\tcase '>=': return aVal >= bVal;\n\t\tcase '<': return aVal < bVal;\n\t\tcase '<=': return aVal <= bVal;\n\t\tdefault: return false;\n\t}\n}\n\n/**\n * Text search helper\n * Creates a temporary TextIndex to check if the text matches the query\n */\nexport function text(prop, query) {\n\tconst textIndex = new TextIndex();\n\ttextIndex.add('id', prop);\n\tconst results = textIndex.query(query, { scored: false });\n\treturn results.length === 1;\n}\n\n/**\n * Geo within helper - using bounding box logic instead of de9im\n * This is a simpler implementation that doesn't require de9im dependency\n */\nexport function geoWithin(prop, query) {\n\ttry {\n\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\tif (!Array.isArray(query) || query.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst minLon = query[0][0];\n\t\tconst maxLat = query[0][1];\n\t\tconst maxLon = query[1][0];\n\t\tconst minLat = query[1][1];\n\n\t\t// Check if geometry is within bounding box\n\t\treturn isGeometryWithinBBox(prop, minLon, maxLon, minLat, maxLat);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if a GeoJSON geometry is within a bounding box\n * For Points: checks if the point is within the bbox\n * For Polygons: checks if ALL vertices are within the bbox\n */\nfunction isGeometryWithinBBox(geoJson, minLon, maxLon, minLat, maxLat) {\n\tif (!geoJson) return false;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t// All features must be within the bbox\n\t\tfor (const feature of geoJson.features) {\n\t\t\tif (feature.geometry) {\n\t\t\t\tif (!isGeometryWithinBBox(feature.geometry, minLon, maxLon, minLat, maxLat)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn isGeometryWithinBBox(geoJson.geometry, minLon, maxLon, minLat, maxLat);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn lng >= minLon && lng <= maxLon && lat >= minLat && lat <= maxLat;\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - ALL vertices must be within the bbox\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tfor (const ring of geoJson.coordinates) {\n\t\t\tfor (const coord of ring) {\n\t\t\t\tconst lng = coord[0];\n\t\t\t\tconst lat = coord[1];\n\t\t\t\tif (lng < minLon || lng > maxLon || lat < minLat || lat > maxLat) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Extract coordinates from a GeoJSON object for indexing purposes\n * This uses centroid for polygons to get a single point to index\n * @param {Object} geoJson - The GeoJSON object\n * @returns {Object|null} Object with lat and lng, or null if invalid\n */\nfunction extractCoordinatesFromGeoJSON(geoJson) {\n\tif (!geoJson) return null;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\tconst feature = geoJson.features[0];\n\t\tif (feature.geometry) {\n\t\t\treturn extractCoordinatesFromGeoJSON(feature.geometry);\n\t\t}\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn extractCoordinatesFromGeoJSON(geoJson.geometry);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn { lat, lng };\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - use centroid of first coordinate ring\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tconst ring = geoJson.coordinates[0];\n\t\tif (ring.length > 0) {\n\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\tfor (const coord of ring) {\n\t\t\t\tsumLng += coord[0];\n\t\t\t\tsumLat += coord[1];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\tlng: sumLng / ring.length\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * $where operator implementation\n * SECURITY NOTE: This uses Function constructor which can execute arbitrary code.\n * This is acceptable for a local/in-memory database but should NOT be used\n * in environments where untrusted user input is processed.\n */\nexport function where(doc, value) {\n\tif (typeof value === 'function') {\n\t\ttry {\n\t\t\treturn value.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t} else if (typeof value === 'string') {\n\t\t// Evaluate the string as a function\n\t\ttry {\n\t\t\tvar fn = new Function('return ' + value);\n\t\t\treturn fn.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Top-level match function\n */\nexport function tlMatches(doc, query) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return and(doc, value);\n\t\telse if (key == \"$or\") return or(doc, value);\n\t\telse if (key == \"$not\") return not(doc, value);\n\t\telse if (key == \"$nor\") return nor(doc, value);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatches(doc, key, value);\n\t}\n}\n\n/**\n * Operator match function\n */\nexport function opMatches(doc, key, value) {\n\tif (typeof (value) == \"string\") return valuesEqual(getProp(doc, key), value);\n\telse if (typeof (value) == \"number\") return valuesEqual(getProp(doc, key), value);\n\telse if (typeof (value) == \"boolean\") return valuesEqual(getProp(doc, key), value);\n\telse if (value instanceof ObjectId) return valuesEqual(getProp(doc, key), value);\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return getProp(doc, key) && getProp(doc, key).match(value);\n\t\telse if (isArray(value)) return getProp(doc, key) && arrayMatches(getProp(doc, key), value);\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = Object.keys(value)[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !valuesEqual(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '>')) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '>=')) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '<')) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '<=')) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !(!valuesEqual(getProp(doc, key), operand))) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !isIn(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || isIn(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$exists\") {\n\t\t\t\t\t\tif (operand ? getProp(doc, key) == undefined : getProp(doc, key) != undefined) return false;\n\t\t\t\t\t} else if (operator == \"$type\") {\n\t\t\t\t\t\tif (typeof (getProp(doc, key)) != operand) return false;\n\t\t\t\t\t} else if (operator == \"$mod\") {\n\t\t\t\t\t\tif (operand.length != 2) throw { $err: \"Can't canonicalize query: BadValue malformed mod, not enough elements\", code: 17287 };\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || (getProp(doc, key) % operand[0] != operand[1])) return false;\n\t\t\t\t\t} else if (operator == \"$regex\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !getProp(doc, key).match(operand)) return false;\n\t\t\t\t\t} else if (operator == \"$text\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !text(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$geoWithin\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !geoWithin(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$not\") {\n\t\t\t\t\t\tif (opMatches(doc, key, operand)) return false;\n\t\t\t\t\t} else if (operator == \"$all\") {\n\t\t\t\t\t\tvar fieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (fieldValue == undefined || !isArray(fieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < operand.length; j++) {\n\t\t\t\t\t\t\tif (!isIn(operand[j], fieldValue)) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\tvar fieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (fieldValue == undefined || !isArray(fieldValue)) return false;\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor (var j = 0; j < fieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = fieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && !(element == opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && !(element != opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$in\" && !isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$nin\" && isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found) return false;\n\t\t\t\t\t} else if (operator == \"$size\") {\n\t\t\t\t\t\tvar fieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (fieldValue == undefined || !isArray(fieldValue)) return false;\n\t\t\t\t\t\tif (fieldValue.length != operand) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue unknown operator: \" + operator, code: 17287 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn getProp(doc, key) && objectMatches(getProp(doc, key), value);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * $not operator\n */\nexport function not(doc, value) {\n\treturn !tlMatches(doc, value);\n}\n\n/**\n * $and operator\n */\nexport function and(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatches(doc, els[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * $or operator\n */\nexport function or(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return true;\n\t}\n\treturn false;\n}\n\n/**\n * $nor operator\n */\nexport function nor(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Main matches function - query structure: (top level operators ( \"age\" : (operators) ))\n * top, top level query, implicit $and\n */\nexport function matches(doc, query) {\n\treturn and(doc, toArray(query));\n}\n","/**\n * Update operations module\n */\n\n/**\n * Apply update operators to a document\n */\nexport function applyUpdates(updates, doc, setOnInsert) {\n\tvar keys = Object.keys(updates);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar value = updates[key];\n\t\tif (key == \"$inc\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = doc[field] + amount;\n\t\t\t}\n\t\t} else if (key == \"$mul\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = doc[field] * amount;\n\t\t\t}\n\t\t} else if (key == \"$rename\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar newName = value[field];\n\t\t\t\tdoc[newName] = doc[field];\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$setOnInsert\" && setOnInsert) {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdoc[fields[j]] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$set\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdoc[fields[j]] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$unset\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdelete doc[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$min\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = Math.min(doc[field], amount);\n\t\t\t}\n\t\t} else if (key == \"$max\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = Math.max(doc[field], amount);\n\t\t\t}\n\t\t} else if (key == \"$currentDate\") {  // TODO not the same as mongo\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdoc[fields[j]] = new Date();\n\t\t\t}\n\t\t} else if (key == \"$addToSet\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar value = value[field];\n\t\t\t\tdoc[field].push(value);\n\t\t\t}\n\t\t} else if (key == \"$pop\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar value = value[field];\n\t\t\t\tif (value == 1) {\n\t\t\t\t\tdoc[field].pop();\n\t\t\t\t} else if (value == -1) {\n\t\t\t\t\tdoc[field].shift();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pullAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar src = doc[fields[j]];\n\t\t\t\tvar toRemove = value[fields[j]];\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar removed = false;\n\t\t\t\t\tfor (var l = 0; l < toRemove.length; l++) {\n\t\t\t\t\t\tif (src[k] == toRemove[l]) {\n\t\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!removed) notRemoved.push(src[k]);\n\t\t\t\t}\n\t\t\t\tdoc[fields[j]] = notRemoved;\n\t\t\t}\n\t\t} else if (key == \"$pushAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar values = value[field];\n\t\t\t\tfor (var k = 0; k < values.length; k++) {\n\t\t\t\t\tdoc[field].push(values[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$push\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tdoc[field].push(value[field]);\n\t\t\t}\n\t\t} else if (key == \"$bit\") {\n\t\t\tvar field = Object.keys(value)[0];\n\t\t\tvar operation = value[field];\n\t\t\tvar operator = Object.keys(operation)[0];\n\t\t\tvar operand = operation[operator];\n\t\t\tif (operator == \"and\") {\n\t\t\t\tdoc[field] = doc[field] & operand;\n\t\t\t} else if (operator == \"or\") {\n\t\t\t\tdoc[field] = doc[field] | operand;\n\t\t\t} else if (operator == \"xor\") {\n\t\t\t\tdoc[field] = doc[field] ^ operand;\n\t\t\t} else {\n\t\t\t\tthrow \"unknown $bit operator: \" + operator;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow \"unknown update operator: \" + key;\n\t\t}\n\t}\n}\n\n/**\n * Create a new document from query and update operators for upsert\n */\nexport function createDocFromUpdate(query, updates, idGenerator) {\n\tvar newDoc = { _id: idGenerator() };\n\tvar onlyFields = true;\n\tvar updateKeys = Object.keys(updates);\n\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\tif (updateKeys[i].charAt(0) == \"$\") {\n\t\t\tonlyFields = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (onlyFields) {\n\t\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\t\tnewDoc[updateKeys[i]] = updates[updateKeys[i]];\n\t\t}\n\t} else {\n\t\tvar queryKeys = Object.keys(query);\n\t\tfor (var i = 0; i < queryKeys.length; i++) {\n\t\t\tnewDoc[queryKeys[i]] = query[queryKeys[i]];\n\t\t}\n\t\tapplyUpdates(updates, newDoc, true);\n\t}\n\treturn newDoc;\n}\n","/**\n * Base class for collection indexes\n * Provides a common interface for different types of indexes (e.g., regular, text, geo)\n */\nexport class CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tthis.keys = keys;\n\t\tthis.options = options;\n\t\tthis.name = options.name || this.generateIndexName(keys);\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tthrow new Error('add() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tthrow new Error('remove() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Update a document in the index (remove old, add new)\n\t * @param {Object} oldDoc - The old document\n\t * @param {Object} newDoc - The new document\n\t */\n\tupdate(oldDoc, newDoc) {\n\t\tthis.remove(oldDoc);\n\t\tthis.add(newDoc);\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query to execute\n\t * @returns {Array} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tthrow new Error('query() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthrow new Error('clear() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Get index specification (for getIndexes())\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\tthrow new Error('serialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} data - Serialized index state\n\t */\n\tdeserialize(data) {\n\t\tthrow new Error('deserialize() must be implemented by subclass');\n\t}\n}\n","import { CollectionIndex } from './CollectionIndex.js';\nimport { getProp } from './utils.js';\n\n/**\n * Regular (B-tree style) index implementation\n * Supports equality queries on indexed fields\n */\nexport class RegularCollectionIndex extends CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tsuper(keys, options);\n\t\t// Map of key value to array of document _ids\n\t\tthis.data = {};\n\t}\n\n\t/**\n\t * Extract index key value from a document\n\t */\n\textractIndexKey(doc) {\n\t\tconst keyFields = Object.keys(this.keys);\n\t\tif (keyFields.length === 0) return null;\n\n\t\t// For simple single-field index\n\t\tif (keyFields.length === 1) {\n\t\t\tconst field = keyFields[0];\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value === undefined) return null;\n\t\t\t// Preserve type information in the key\n\t\t\treturn JSON.stringify({ t: typeof value, v: value });\n\t\t}\n\n\t\t// For compound index, concatenate values with type preservation\n\t\tconst keyParts = [];\n\t\tfor (let i = 0; i < keyFields.length; i++) {\n\t\t\tconst value = getProp(doc, keyFields[i]);\n\t\t\tif (value === undefined) return null;\n\t\t\tkeyParts.push(JSON.stringify(value));\n\t\t}\n\t\t// Use a separator that won't appear in JSON\n\t\treturn keyParts.join('\\x00');\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tif (!this.data[indexKey]) {\n\t\t\t\tthis.data[indexKey] = [];\n\t\t\t}\n\t\t\tthis.data[indexKey].push(doc._id);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null && this.data[indexKey]) {\n\t\t\tconst arr = this.data[indexKey];\n\t\t\tconst idx = arr.indexOf(doc._id);\n\t\t\tif (idx !== -1) {\n\t\t\t\tarr.splice(idx, 1);\n\t\t\t}\n\t\t\tif (arr.length === 0) {\n\t\t\t\tdelete this.data[indexKey];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(this.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst queryValue = query[field];\n\n\t\t// Case 1: Simple equality\n\t\tif (typeof queryValue !== 'object' || queryValue === null) {\n\t\t\tconst indexKey = JSON.stringify({ t: typeof queryValue, v: queryValue });\n\t\t\treturn this.data[indexKey] || [];\n\t\t}\n\n\t\t// Case 2: Query with operators\n\t\tif (typeof queryValue === 'object' && !Array.isArray(queryValue)) {\n\t\t\treturn this._queryWithOperators(field, queryValue);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Query index with comparison operators\n\t * @private\n\t */\n\t_queryWithOperators(field, operators) {\n\t\tconst ops = Object.keys(operators);\n\t\tconst results = new Set();\n\n\t\t// Handle range queries: $gt, $gte, $lt, $lte\n\t\tconst hasRangeOp = ops.some(op => ['$gt', '$gte', '$lt', '$lte'].includes(op));\n\t\t\n\t\tif (hasRangeOp) {\n\t\t\t// Scan all entries and filter by range\n\t\t\tfor (const indexKey in this.data) {\n\t\t\t\ttry {\n\t\t\t\t\tconst parsed = JSON.parse(indexKey);\n\t\t\t\t\tconst value = parsed.v;\n\t\t\t\t\tconst type = parsed.t;\n\t\t\t\t\t\n\t\t\t\t\t// Check if value matches all operators\n\t\t\t\t\tlet matches = true;\n\t\t\t\t\tfor (const op of ops) {\n\t\t\t\t\t\tconst operand = operators[op];\n\t\t\t\t\t\tif (op === '$gt' && !(value > operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$gte' && !(value >= operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$lt' && !(value < operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$lte' && !(value <= operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$eq' && !(value === operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$ne' && !(value !== operand)) matches = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\t// Add all document IDs for this index entry\n\t\t\t\t\t\tthis.data[indexKey].forEach(id => results.add(id));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Skip malformed entries\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Array.from(results);\n\t\t}\n\n\t\t// Handle $in operator\n\t\tif (ops.includes('$in')) {\n\t\t\tconst values = operators['$in'];\n\t\t\tif (Array.isArray(values)) {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tconst indexKey = JSON.stringify({ t: typeof value, v: value });\n\t\t\t\t\tif (this.data[indexKey]) {\n\t\t\t\t\t\tthis.data[indexKey].forEach(id => results.add(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $eq operator\n\t\tif (ops.includes('$eq')) {\n\t\t\tconst value = operators['$eq'];\n\t\t\tconst indexKey = JSON.stringify({ t: typeof value, v: value });\n\t\t\treturn this.data[indexKey] || [];\n\t\t}\n\n\t\t// Handle $ne operator (requires full scan, not optimal)\n\t\tif (ops.includes('$ne')) {\n\t\t\tconst excludeValue = operators['$ne'];\n\t\t\tconst excludeKey = JSON.stringify({ t: typeof excludeValue, v: excludeValue });\n\t\t\tfor (const indexKey in this.data) {\n\t\t\t\tif (indexKey !== excludeKey) {\n\t\t\t\t\tthis.data[indexKey].forEach(id => results.add(id));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Array.from(results);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.data = {};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\ttype: 'regular',\n\t\t\tkeys: this.keys,\n\t\t\toptions: this.options,\n\t\t\tdata: this.data\n\t\t};\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} state - Serialized index state\n\t */\n\tdeserialize(state) {\n\t\tthis.data = state.data || {};\n\t}\n}\n","import { CollectionIndex } from './CollectionIndex.js';\nimport { TextIndex } from './TextIndex.js';\nimport { getProp } from './utils.js';\n\n/**\n * Text index implementation using TextIndex\n * Supports full-text search on one or more fields\n */\nexport class TextCollectionIndex extends CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tsuper(keys, options);\n\t\t// Create the underlying TextIndex\n\t\tthis.textIndex = new TextIndex(options);\n\t\t// Track which fields are indexed\n\t\tthis.indexedFields = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\tthis.indexedFields.push(field);\n\t\t\t}\n\t\t}\n\t\tif (this.indexedFields.length === 0) {\n\t\t\tthrow new Error('Text index must have at least one field with type \"text\"');\n\t\t}\n\t}\n\n\t/**\n\t * Extract text content from a document for the indexed fields\n\t * @param {Object} doc - The document\n\t * @returns {string} Combined text from all indexed fields\n\t */\n\t_extractText(doc) {\n\t\tconst textParts = [];\n\t\tfor (const field of this.indexedFields) {\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\ttextParts.push(String(value));\n\t\t\t}\n\t\t}\n\t\treturn textParts.join(' ');\n\t}\n\n\t/**\n\t * Add a document to the text index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst text = this._extractText(doc);\n\t\tif (text) {\n\t\t\tthis.textIndex.add(String(doc._id), text);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the text index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tthis.textIndex.remove(String(doc._id));\n\t}\n\n\t/**\n\t * Query the text index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a text search\n\t */\n\tquery(query) {\n\t\t// This method is used for query planning\n\t\t// Text queries are handled separately in queryMatcher\n\t\treturn null;\n\t}\n\n\t/**\n\t * Search the text index\n\t * @param {string} searchText - The text to search for\n\t * @param {Object} options - Search options\n\t * @returns {Array} Array of document IDs\n\t */\n\tsearch(searchText, options = {}) {\n\t\tconst results = this.textIndex.query(searchText, { scored: false, ...options });\n\t\treturn results;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.textIndex.clear();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\ttextIndexVersion: 3,\n\t\t\tweights: this._getWeights()\n\t\t};\n\t}\n\n\t/**\n\t * Get field weights (all default to 1 for now)\n\t */\n\t_getWeights() {\n\t\tconst weights = {};\n\t\tfor (const field of this.indexedFields) {\n\t\t\tweights[field] = 1;\n\t\t}\n\t\treturn weights;\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\ttype: 'text',\n\t\t\tkeys: this.keys,\n\t\t\toptions: this.options,\n\t\t\tindexedFields: this.indexedFields,\n\t\t\ttextIndexState: this.textIndex.serialize()\n\t\t};\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} state - Serialized index state\n\t */\n\tdeserialize(state) {\n\t\tthis.indexedFields = state.indexedFields || [];\n\t\tif (state.textIndexState) {\n\t\t\tthis.textIndex.deserialize(state.textIndexState);\n\t\t}\n\t}\n}\n","/**\n * R-tree implementation for geospatial indexing\n * \n * This implementation supports:\n * - Adding points with lat/lng coordinates\n * - Removing points\n * - Bounding box queries\n * - Location + radius queries (converted to bounding box)\n */\n\n/**\n * Calculate distance between two points using Haversine formula\n * @param {number} lat1 - Latitude of first point\n * @param {number} lng1 - Longitude of first point\n * @param {number} lat2 - Latitude of second point\n * @param {number} lng2 - Longitude of second point\n * @returns {number} Distance in kilometers\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Convert radius query to bounding box\n * Approximation: 1 degree latitude  111 km\n * @param {number} lat - Center latitude\n * @param {number} lng - Center longitude\n * @param {number} radiusKm - Radius in kilometers\n * @returns {Object} Bounding box {minLat, maxLat, minLng, maxLng}\n */\nfunction radiusToBoundingBox(lat, lng, radiusKm) {\n\tconst latDelta = radiusKm / 111; // degrees\n\tconst lngDelta = radiusKm / (111 * Math.cos(lat * Math.PI / 180)); // degrees\n\t\n\treturn {\n\t\tminLat: lat - latDelta,\n\t\tmaxLat: lat + latDelta,\n\t\tminLng: lng - lngDelta,\n\t\tmaxLng: lng + lngDelta\n\t};\n}\n\n/**\n * Check if two bounding boxes intersect\n */\nfunction intersects(bbox1, bbox2) {\n\treturn !(bbox1.maxLat < bbox2.minLat ||\n\t\tbbox1.minLat > bbox2.maxLat ||\n\t\tbbox1.maxLng < bbox2.minLng ||\n\t\tbbox1.minLng > bbox2.maxLng);\n}\n\n/**\n * Check if bbox1 contains bbox2\n */\nfunction contains(bbox1, bbox2) {\n\treturn bbox1.minLat <= bbox2.minLat &&\n\t\tbbox1.maxLat >= bbox2.maxLat &&\n\t\tbbox1.minLng <= bbox2.minLng &&\n\t\tbbox1.maxLng >= bbox2.maxLng;\n}\n\n/**\n * Calculate the area of a bounding box\n */\nfunction area(bbox) {\n\treturn (bbox.maxLat - bbox.minLat) * (bbox.maxLng - bbox.minLng);\n}\n\n/**\n * Calculate the bounding box that contains both input boxes\n */\nfunction union(bbox1, bbox2) {\n\treturn {\n\t\tminLat: Math.min(bbox1.minLat, bbox2.minLat),\n\t\tmaxLat: Math.max(bbox1.maxLat, bbox2.maxLat),\n\t\tminLng: Math.min(bbox1.minLng, bbox2.minLng),\n\t\tmaxLng: Math.max(bbox1.maxLng, bbox2.maxLng)\n\t};\n}\n\n/**\n * Calculate the enlargement needed to include bbox2 in bbox1\n */\nfunction enlargement(bbox1, bbox2) {\n\tconst unionBox = union(bbox1, bbox2);\n\treturn area(unionBox) - area(bbox1);\n}\n\n/**\n * R-tree Node class\n */\nclass RTreeNode {\n\tconstructor(isLeaf = false) {\n\t\tthis.isLeaf = isLeaf;\n\t\tthis.children = []; // For internal nodes: child nodes; For leaf nodes: data entries\n\t\tthis.bbox = null;\n\t}\n\n\t/**\n\t * Update the bounding box to contain all children\n\t */\n\tupdateBBox() {\n\t\tif (this.children.length === 0) {\n\t\t\tthis.bbox = null;\n\t\t\treturn;\n\t\t}\n\n\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\tlet minLng = Infinity, maxLng = -Infinity;\n\n\t\tfor (const child of this.children) {\n\t\t\tconst bbox = child.bbox;\n\t\t\tminLat = Math.min(minLat, bbox.minLat);\n\t\t\tmaxLat = Math.max(maxLat, bbox.maxLat);\n\t\t\tminLng = Math.min(minLng, bbox.minLng);\n\t\t\tmaxLng = Math.max(maxLng, bbox.maxLng);\n\t\t}\n\n\t\tthis.bbox = { minLat, maxLat, minLng, maxLng };\n\t}\n}\n\n/**\n * R-tree implementation\n */\nexport class RTree {\n\tconstructor(maxEntries = 9) {\n\t\tthis.maxEntries = maxEntries;\n\t\tthis.minEntries = Math.max(2, Math.ceil(maxEntries / 2));\n\t\tthis.root = new RTreeNode(true);\n\t\tthis._size = 0; // Track size for O(1) queries\n\t}\n\n\t/**\n\t * Insert a point into the R-tree\n\t * @param {number} lat - Latitude\n\t * @param {number} lng - Longitude\n\t * @param {*} data - Associated data\n\t */\n\tinsert(lat, lng, data) {\n\t\t// Create a point bounding box (bbox with zero area)\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst entry = { bbox, lat, lng, data };\n\t\tthis._insert(entry, this.root, 1);\n\t\tthis._size++;\n\t}\n\n\t/**\n\t * Internal insert method\n\t */\n\t_insert(entry, node, level) {\n\t\tif (node.isLeaf) {\n\t\t\tnode.children.push(entry);\n\t\t\tnode.updateBBox();\n\n\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\treturn this._split(node);\n\t\t\t}\n\t\t} else {\n\t\t\t// Choose subtree\n\t\t\tconst target = this._chooseSubtree(entry.bbox, node);\n\t\t\tconst splitNode = this._insert(entry, target, level + 1);\n\n\t\t\tif (splitNode) {\n\t\t\t\tnode.children.push(splitNode);\n\t\t\t\tnode.updateBBox();\n\n\t\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\t\treturn this._split(node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.updateBBox();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Choose the best subtree to insert an entry\n\t */\n\t_chooseSubtree(bbox, node) {\n\t\tlet minEnlargement = Infinity;\n\t\tlet minArea = Infinity;\n\t\tlet targetNode = null;\n\n\t\tfor (const child of node.children) {\n\t\t\tconst enl = enlargement(child.bbox, bbox);\n\t\t\tconst ar = area(child.bbox);\n\n\t\t\tif (enl < minEnlargement || (enl === minEnlargement && ar < minArea)) {\n\t\t\t\tminEnlargement = enl;\n\t\t\t\tminArea = ar;\n\t\t\t\ttargetNode = child;\n\t\t\t}\n\t\t}\n\n\t\treturn targetNode;\n\t}\n\n\t/**\n\t * Split an overflowing node\n\t */\n\t_split(node) {\n\t\t// Simple linear split algorithm\n\t\tconst children = node.children;\n\t\tconst isLeaf = node.isLeaf;\n\n\t\t// Find two seeds (most distant entries)\n\t\tlet maxDist = -Infinity;\n\t\tlet seed1Idx = 0, seed2Idx = 1;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tfor (let j = i + 1; j < children.length; j++) {\n\t\t\t\tconst bbox1 = children[i].bbox;\n\t\t\t\tconst bbox2 = children[j].bbox;\n\t\t\t\tconst combinedBox = union(bbox1, bbox2);\n\t\t\t\tconst waste = area(combinedBox) - area(bbox1) - area(bbox2);\n\t\t\t\t\n\t\t\t\tif (waste > maxDist) {\n\t\t\t\t\tmaxDist = waste;\n\t\t\t\t\tseed1Idx = i;\n\t\t\t\t\tseed2Idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create two new nodes\n\t\tconst node1 = new RTreeNode(isLeaf);\n\t\tconst node2 = new RTreeNode(isLeaf);\n\n\t\tnode1.children.push(children[seed1Idx]);\n\t\tnode2.children.push(children[seed2Idx]);\n\n\t\t// Distribute remaining entries\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tif (i === seed1Idx || i === seed2Idx) continue;\n\n\t\t\tconst child = children[i];\n\t\t\tconst bbox = child.bbox;\n\t\t\t\n\t\t\tconst enl1 = node1.children.length === 0 ? Infinity : enlargement(node1.bbox || bbox, bbox);\n\t\t\tconst enl2 = node2.children.length === 0 ? Infinity : enlargement(node2.bbox || bbox, bbox);\n\n\t\t\tif (node1.children.length < this.minEntries && \n\t\t\t\tchildren.length - i + node1.children.length <= this.minEntries) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (node2.children.length < this.minEntries && \n\t\t\t\tchildren.length - i + node2.children.length <= this.minEntries) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else if (enl1 < enl2) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (enl2 < enl1) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else {\n\t\t\t\t// Equal enlargement, choose the one with smaller area\n\t\t\t\tconst area1 = node1.bbox ? area(node1.bbox) : 0;\n\t\t\t\tconst area2 = node2.bbox ? area(node2.bbox) : 0;\n\t\t\t\tif (area1 < area2) {\n\t\t\t\t\tnode1.children.push(child);\n\t\t\t\t} else {\n\t\t\t\t\tnode2.children.push(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode1.updateBBox();\n\t\t\tnode2.updateBBox();\n\t\t}\n\n\t\t// Update the original node with one group\n\t\tnode.children = node1.children;\n\t\tnode.updateBBox();\n\n\t\t// If this was the root, create a new root\n\t\tif (node === this.root) {\n\t\t\tconst newRoot = new RTreeNode(false);\n\t\t\tnewRoot.children = [node1, node2];\n\t\t\tnewRoot.updateBBox();\n\t\t\tthis.root = newRoot;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn node2;\n\t}\n\n\t/**\n\t * Search for points within a bounding box\n\t * @param {Object} bbox - Bounding box {minLat, maxLat, minLng, maxLng}\n\t * @returns {Array} Array of matching entries\n\t */\n\tsearchBBox(bbox) {\n\t\tconst results = [];\n\t\tthis._searchBBox(bbox, this.root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search\n\t */\n\t_searchBBox(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tthis._searchBBox(bbox, child, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search for points within a radius of a location\n\t * @param {number} lat - Center latitude\n\t * @param {number} lng - Center longitude\n\t * @param {number} radiusKm - Radius in kilometers\n\t * @returns {Array} Array of matching entries\n\t */\n\tsearchRadius(lat, lng, radiusKm) {\n\t\t// Convert radius to bounding box for initial filtering\n\t\tconst bbox = radiusToBoundingBox(lat, lng, radiusKm);\n\t\tconst candidates = this.searchBBox(bbox);\n\n\t\t// Filter by actual distance\n\t\tconst results = [];\n\t\tfor (const entry of candidates) {\n\t\t\tconst dist = haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\tif (dist <= radiusKm) {\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Remove a point from the R-tree\n\t * @param {number} lat - Latitude\n\t * @param {number} lng - Longitude\n\t * @param {*} data - Associated data (optional, for exact match)\n\t * @returns {boolean} True if removed, false if not found\n\t */\n\tremove(lat, lng, data = null) {\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst removed = this._remove(bbox, data, this.root, null, -1);\n\t\t\n\t\tif (removed) {\n\t\t\tthis._size--;\n\t\t}\n\t\t\n\t\t// If root has only one child after removal, make that child the new root\n\t\tif (this.root.children.length === 1 && !this.root.isLeaf) {\n\t\t\tthis.root = this.root.children[0];\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Internal remove method\n\t */\n\t_remove(bbox, data, node, parent, indexInParent) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst entry = node.children[i];\n\t\t\t\tif (entry.lat === bbox.minLat && entry.lng === bbox.minLng) {\n\t\t\t\t\t// If data is specified, check for match\n\t\t\t\t\tconst dataMatches = data === null || \n\t\t\t\t\t\tJSON.stringify(entry.data) === JSON.stringify(data);\n\t\t\t\t\t\n\t\t\t\t\tif (dataMatches) {\n\t\t\t\t\t\tnode.children.splice(i, 1);\n\t\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Handle underflow\n\t\t\t\t\t\tif (node.children.length < this.minEntries && node !== this.root) {\n\t\t\t\t\t\t\t// Simple approach: reinsert all entries from this node\n\t\t\t\t\t\t\tconst entries = node.children.slice();\n\t\t\t\t\t\t\tnode.children = [];\n\t\t\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Remove this node from parent\n\t\t\t\t\t\t\tif (parent) {\n\t\t\t\t\t\t\t\tparent.children.splice(indexInParent, 1);\n\t\t\t\t\t\t\t\tparent.updateBBox();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Reinsert entries\n\t\t\t\t\t\t\tfor (const e of entries) {\n\t\t\t\t\t\t\t\tthis._insert(e, this.root, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\t\t\t\tif (this._remove(bbox, data, child, node, i)) {\n\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get all entries in the tree\n\t * @returns {Array} All entries\n\t */\n\tgetAll() {\n\t\tconst results = [];\n\t\tthis._getAll(this.root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal method to get all entries\n\t */\n\t_getAll(node, results) {\n\t\tif (node.isLeaf) {\n\t\t\tresults.push(...node.children);\n\t\t} else {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tthis._getAll(child, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the number of entries in the tree\n\t * @returns {number} Number of entries\n\t */\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Clear all entries from the tree\n\t */\n\tclear() {\n\t\tthis.root = new RTreeNode(true);\n\t\tthis._size = 0;\n\t}\n\n\t/**\n\t * Serialize the R-tree state for storage\n\t * @returns {Object} Serializable state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\tmaxEntries: this.maxEntries,\n\t\t\tminEntries: this.minEntries,\n\t\t\tsize: this._size,\n\t\t\troot: this._serializeNode(this.root)\n\t\t};\n\t}\n\n\t/**\n\t * Serialize a node recursively\n\t */\n\t_serializeNode(node) {\n\t\tconst serialized = {\n\t\t\tisLeaf: node.isLeaf,\n\t\t\tbbox: node.bbox,\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (node.isLeaf) {\n\t\t\t// Leaf nodes contain entries\n\t\t\tserialized.children = node.children.map(entry => ({\n\t\t\t\tbbox: entry.bbox,\n\t\t\t\tlat: entry.lat,\n\t\t\t\tlng: entry.lng,\n\t\t\t\tdata: entry.data\n\t\t\t}));\n\t\t} else {\n\t\t\t// Internal nodes contain child nodes\n\t\t\tserialized.children = node.children.map(child => this._serializeNode(child));\n\t\t}\n\n\t\treturn serialized;\n\t}\n\n\t/**\n\t * Restore the R-tree state from serialized data\n\t * @param {Object} state - Serialized state\n\t */\n\tdeserialize(state) {\n\t\tthis.maxEntries = state.maxEntries || 9;\n\t\tthis.minEntries = state.minEntries || Math.ceil(this.maxEntries / 2);\n\t\tthis._size = state.size || 0;\n\t\tthis.root = this._deserializeNode(state.root);\n\t}\n\n\t/**\n\t * Deserialize a node recursively\n\t */\n\t_deserializeNode(serialized) {\n\t\tconst node = new RTreeNode(serialized.isLeaf);\n\t\tnode.bbox = serialized.bbox;\n\n\t\tif (serialized.isLeaf) {\n\t\t\t// Restore leaf entries\n\t\t\tnode.children = serialized.children.map(entry => ({\n\t\t\t\tbbox: entry.bbox,\n\t\t\t\tlat: entry.lat,\n\t\t\t\tlng: entry.lng,\n\t\t\t\tdata: entry.data\n\t\t\t}));\n\t\t} else {\n\t\t\t// Restore child nodes\n\t\t\tnode.children = serialized.children.map(child => this._deserializeNode(child));\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\nexport default RTree;\n","import { CollectionIndex } from './CollectionIndex.js';\nimport { RTree } from './RTree.js';\nimport { getProp } from './utils.js';\n\n/**\n * Geospatial index implementation using RTree\n * Supports geospatial queries on GeoJSON fields\n */\nexport class GeospatialCollectionIndex extends CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tsuper(keys, options);\n\t\t// Create the underlying RTree\n\t\tthis.rtree = new RTree();\n\t\t// Track which field is the geospatial field\n\t\tthis.geoField = null;\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\tthis.geoField = field;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!this.geoField) {\n\t\t\tthrow new Error('Geospatial index must have at least one field with type \"2dsphere\" or \"2d\"');\n\t\t}\n\t}\n\n\t/**\n\t * Extract coordinates from a GeoJSON object\n\t * @param {Object} geoJson - The GeoJSON object\n\t * @returns {Object|null} Object with lat and lng, or null if invalid\n\t */\n\t_extractCoordinates(geoJson) {\n\t\tif (!geoJson) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t\tconst feature = geoJson.features[0];\n\t\t\tif (feature.geometry) {\n\t\t\t\treturn this._extractCoordinates(feature.geometry);\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\t\treturn this._extractCoordinates(geoJson.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\t\tconst [lng, lat] = geoJson.coordinates;\n\t\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Polygon - use centroid of first coordinate\n\t\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\t\tconst ring = geoJson.coordinates[0];\n\t\t\tif (ring.length > 0) {\n\t\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tsumLng += coord[0];\n\t\t\t\t\tsumLat += coord[1];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\t\tlng: sumLng / ring.length\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add a document to the geospatial index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\tthis.rtree.insert(coords.lat, coords.lng, { \n\t\t\t\t_id: doc._id, \n\t\t\t\tgeoJson: geoValue \n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the geospatial index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\tthis.rtree.remove(coords.lat, coords.lng, { \n\t\t\t\t_id: doc._id, \n\t\t\t\tgeoJson: geoValue \n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Query the geospatial index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a geospatial query\n\t */\n\tquery(query) {\n\t\t// Check if this is a geospatial query on our indexed field\n\t\tif (!query[this.geoField]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geoQuery = query[this.geoField];\n\n\t\t// Handle $geoWithin with bounding box\n\t\tif (geoQuery.$geoWithin) {\n\t\t\tconst bbox = geoQuery.$geoWithin;\n\t\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\t\tif (Array.isArray(bbox) && bbox.length === 2) {\n\t\t\t\tconst minLon = bbox[0][0];\n\t\t\t\tconst maxLat = bbox[0][1];\n\t\t\t\tconst maxLon = bbox[1][0];\n\t\t\t\tconst minLat = bbox[1][1];\n\n\t\t\t\tconst results = this.rtree.searchBBox({\n\t\t\t\t\tminLat: minLat,\n\t\t\t\t\tmaxLat: maxLat,\n\t\t\t\t\tminLng: minLon,\n\t\t\t\t\tmaxLng: maxLon\n\t\t\t\t});\n\n\t\t\t\t// Extract document IDs\n\t\t\t\treturn results.map(entry => entry.data._id);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $near with radius (future enhancement)\n\t\t// if (geoQuery.$near) {\n\t\t//   const center = geoQuery.$near;\n\t\t//   const maxDistance = geoQuery.$maxDistance || 1000; // default 1000km\n\t\t//   // Implementation would use rtree.searchRadius\n\t\t// }\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.rtree.clear();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\t'2dsphereIndexVersion': 3\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\ttype: 'geospatial',\n\t\t\tkeys: this.keys,\n\t\t\toptions: this.options,\n\t\t\tgeoField: this.geoField,\n\t\t\trtreeState: this.rtree.serialize()\n\t\t};\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} state - Serialized index state\n\t */\n\tdeserialize(state) {\n\t\tthis.geoField = state.geoField;\n\t\tif (state.rtreeState) {\n\t\t\tthis.rtree.deserialize(state.rtreeState);\n\t\t}\n\t}\n}\n","import { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\n\n/**\n * Query execution plan\n */\nclass QueryPlan {\n\tconstructor() {\n\t\tthis.type = 'full_scan'; // 'full_scan', 'index_scan', 'index_intersection', 'index_union'\n\t\tthis.indexes = []; // Indexes to use\n\t\tthis.indexScans = []; // Array of { indexName, docIds }\n\t\tthis.estimatedCost = Infinity;\n\t}\n}\n\n/**\n * Query planner - analyzes queries and generates optimal execution plans\n */\nexport class QueryPlanner {\n\tconstructor(indexes) {\n\t\tthis.indexes = indexes;\n\t}\n\n\t/**\n\t * Generate an execution plan for a query\n\t * @param {Object} query - MongoDB query object\n\t * @returns {QueryPlan} Execution plan\n\t */\n\tplan(query) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Empty query - full scan\n\t\tif (!query || Object.keys(query).length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Analyze query structure\n\t\tconst analysis = this._analyzeQuery(query);\n\n\t\t// Check for text search\n\t\tif (analysis.hasTextSearch) {\n\t\t\tconst textPlan = this._planTextSearch(query, analysis);\n\t\t\tif (textPlan) {\n\t\t\t\treturn textPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for geospatial query\n\t\tif (analysis.hasGeoQuery) {\n\t\t\tconst geoPlan = this._planGeoQuery(query, analysis);\n\t\t\tif (geoPlan) {\n\t\t\t\treturn geoPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $and queries - can use index intersection\n\t\tif (analysis.type === 'and') {\n\t\t\tconst andPlan = this._planAndQuery(query, analysis);\n\t\t\tif (andPlan.type !== 'full_scan') {\n\t\t\t\treturn andPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $or queries - can use index union\n\t\tif (analysis.type === 'or') {\n\t\t\tconst orPlan = this._planOrQuery(query, analysis);\n\t\t\tif (orPlan.type !== 'full_scan') {\n\t\t\t\treturn orPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Try to find a single index for simple queries\n\t\tconst simplePlan = this._planSimpleQuery(query);\n\t\tif (simplePlan.type !== 'full_scan') {\n\t\t\treturn simplePlan;\n\t\t}\n\n\t\t// Fall back to full scan\n\t\treturn plan;\n\t}\n\n\t/**\n\t * Analyze query structure\n\t * @private\n\t */\n\t_analyzeQuery(query) {\n\t\tconst analysis = {\n\t\t\ttype: 'simple', // 'simple', 'and', 'or', 'complex'\n\t\t\tfields: [],\n\t\t\toperators: {},\n\t\t\thasTextSearch: false,\n\t\t\thasGeoQuery: false,\n\t\t\tconditions: []\n\t\t};\n\n\t\tconst keys = Object.keys(query);\n\n\t\t// Check for top-level logical operators\n\t\tif (keys.length === 1) {\n\t\t\tconst key = keys[0];\n\t\t\tif (key === '$and') {\n\t\t\t\tanalysis.type = 'and';\n\t\t\t\tanalysis.conditions = query.$and;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t} else if (key === '$or') {\n\t\t\t\tanalysis.type = 'or';\n\t\t\t\tanalysis.conditions = query.$or;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t}\n\t\t}\n\n\t\t// Analyze simple field conditions\n\t\tfor (const field of keys) {\n\t\t\tif (field.startsWith('$')) {\n\t\t\t\tcontinue; // Skip top-level operators we don't handle yet\n\t\t\t}\n\n\t\t\tanalysis.fields.push(field);\n\t\t\tconst value = query[field];\n\n\t\t\t// Check for operators\n\t\t\tif (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n\t\t\t\tconst ops = Object.keys(value);\n\t\t\t\tanalysis.operators[field] = ops;\n\n\t\t\t\t// Check for text search\n\t\t\t\tif (ops.includes('$text')) {\n\t\t\t\t\tanalysis.hasTextSearch = true;\n\t\t\t\t}\n\n\t\t\t\t// Check for geospatial operators\n\t\t\t\tif (ops.some(op => ['$geoWithin', '$geoIntersects', '$near', '$nearSphere'].includes(op))) {\n\t\t\t\t\tanalysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If multiple fields, it's an implicit $and\n\t\tif (keys.length > 1) {\n\t\t\tanalysis.type = 'and';\n\t\t}\n\n\t\treturn analysis;\n\t}\n\n\t/**\n\t * Plan for text search queries\n\t * @private\n\t */\n\t_planTextSearch(query, analysis) {\n\t\t// Find text index\n\t\tfor (const indexName in this.indexes) {\n\t\t\tconst index = this.indexes[indexName];\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Look for $text operator in query\n\t\t\t\tconst textQuery = this._extractTextQuery(query);\n\t\t\t\tif (textQuery) {\n\t\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\t\tplan.type = 'index_scan';\n\t\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t\tconst docIds = index.search(textQuery);\n\t\t\t\t\tplan.indexScans = [{ indexName, docIds }];\n\t\t\t\t\tplan.estimatedCost = docIds.length;\n\t\t\t\t\treturn plan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extract $text query from query object\n\t * @private\n\t */\n\t_extractTextQuery(query) {\n\t\tfor (const field in query) {\n\t\t\tconst value = query[field];\n\t\t\tif (typeof value === 'object' && value !== null && value.$text) {\n\t\t\t\treturn typeof value.$text === 'string' ? value.$text : value.$text.$search;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for geospatial queries\n\t * @private\n\t */\n\t_planGeoQuery(query, analysis) {\n\t\t// Find geospatial index\n\t\tfor (const indexName in this.indexes) {\n\t\t\tconst index = this.indexes[indexName];\n\t\t\tif (index instanceof GeospatialCollectionIndex) {\n\t\t\t\tconst docIds = index.query(query);\n\t\t\t\tif (docIds !== null) {\n\t\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\t\tplan.type = 'index_scan';\n\t\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t\tplan.indexScans = [{ indexName, docIds }];\n\t\t\t\t\tplan.estimatedCost = docIds.length;\n\t\t\t\t\treturn plan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for $and queries (index intersection)\n\t * @private\n\t */\n\t_planAndQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Extract conditions\n\t\tlet conditions;\n\t\tif (query.$and) {\n\t\t\tconditions = query.$and;\n\t\t} else {\n\t\t\t// Implicit AND - convert to array of conditions\n\t\t\tconditions = Object.keys(query).map(field => ({ [field]: query[field] }));\n\t\t}\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have multiple indexable conditions, use index intersection\n\t\tif (indexableConditions.length > 1) {\n\t\t\tplan.type = 'index_intersection';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost as the smallest set\n\t\t\tplan.estimatedCost = Math.min(...indexableConditions.map(scan => scan.docIds.length));\n\t\t\treturn plan;\n\t\t}\n\n\t\t// If we have one indexable condition, use it\n\t\tif (indexableConditions.length === 1) {\n\t\t\tplan.type = 'index_scan';\n\t\t\tplan.indexScans = [indexableConditions[0]];\n\t\t\tplan.indexes = [indexableConditions[0].indexName];\n\t\t\tplan.estimatedCost = indexableConditions[0].docIds.length;\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for $or queries (index union)\n\t * @private\n\t */\n\t_planOrQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\tif (!query.$or) {\n\t\t\treturn plan;\n\t\t}\n\n\t\tconst conditions = query.$or;\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have at least one indexable condition, use index union\n\t\tif (indexableConditions.length > 0) {\n\t\t\tplan.type = 'index_union';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost as the sum of all sets\n\t\t\tplan.estimatedCost = indexableConditions.reduce((sum, scan) => sum + scan.docIds.length, 0);\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for simple single-field queries\n\t * @private\n\t */\n\t_planSimpleQuery(query) {\n\t\tconst plan = new QueryPlan();\n\t\tconst queryKeys = Object.keys(query);\n\n\t\tif (queryKeys.length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Try each index\n\t\tfor (const indexName in this.indexes) {\n\t\t\tconst index = this.indexes[indexName];\n\n\t\t\t// Skip special index types (they have their own planning)\n\t\t\tif (index instanceof TextCollectionIndex || index instanceof GeospatialCollectionIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Try to use this index\n\t\t\tconst docIds = index.query(query);\n\t\t\tif (docIds !== null && docIds.length >= 0) {\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\tplan.indexScans = [{ indexName, docIds }];\n\t\t\t\tplan.estimatedCost = docIds.length;\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Execute a query plan and return document IDs\n\t * @param {QueryPlan} plan - The execution plan\n\t * @returns {Array|null} Array of document IDs or null for full scan\n\t */\n\texecute(plan) {\n\t\tif (plan.type === 'full_scan') {\n\t\t\treturn null; // Signals cursor to do full scan\n\t\t}\n\n\t\tif (plan.type === 'index_scan') {\n\t\t\treturn plan.indexScans[0].docIds;\n\t\t}\n\n\t\tif (plan.type === 'index_intersection') {\n\t\t\t// Intersection: docs must be in ALL index results\n\t\t\tif (plan.indexScans.length === 0) return null;\n\t\t\t\n\t\t\t// Start with the smallest set for efficiency\n\t\t\tconst sorted = plan.indexScans.slice().sort((a, b) => a.docIds.length - b.docIds.length);\n\t\t\tlet result = new Set(sorted[0].docIds);\n\t\t\t\n\t\t\t// Intersect with each subsequent set\n\t\t\tfor (let i = 1; i < sorted.length; i++) {\n\t\t\t\tconst currentSet = new Set(sorted[i].docIds);\n\t\t\t\tresult = new Set([...result].filter(id => currentSet.has(id)));\n\t\t\t\t\n\t\t\t\t// Early exit if intersection becomes empty\n\t\t\t\tif (result.size === 0) break;\n\t\t\t}\n\t\t\t\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\tif (plan.type === 'index_union') {\n\t\t\t// Union: docs in ANY index result\n\t\t\tconst result = new Set();\n\t\t\tfor (const scan of plan.indexScans) {\n\t\t\t\tscan.docIds.forEach(id => result.add(id));\n\t\t\t}\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","import { Cursor } from './Cursor.js';\nimport { SortedCursor } from './SortedCursor.js';\nimport { isArray, getProp, applyProjection, copy } from './utils.js';\nimport { matches } from './queryMatcher.js';\nimport { applyUpdates, createDocFromUpdate } from './updates.js';\nimport { RegularCollectionIndex } from './RegularCollectionIndex.js';\nimport { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\nimport { QueryPlanner } from './QueryPlanner.js';\n\n/**\n * Collection class\n */\nexport class Collection {\n\tconstructor(db, storage, idGenerator) {\n\t\tthis.db = db;\n\t\tthis.storage = storage;\n\t\tthis.idGenerator = idGenerator;\n\t\tthis.indexes = {}; // Index storage - map of index name to index structure\n\t\tthis.queryPlanner = new QueryPlanner(this.indexes); // Query planner\n\t\tthis.isCollection = true; // TODO used by dropDatabase, ugly\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Determine if keys specify a text index\n\t */\n\tisTextIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine if keys specify a geospatial index\n\t */\n\tisGeospatialIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build/rebuild an index\n\t */\n\tbuildIndex(indexName, keys, options = {}) {\n\t\tlet index;\n\t\t\n\t\t// Create appropriate index type\n\t\tif (this.isTextIndex(keys)) {\n\t\t\tindex = new TextCollectionIndex(keys, { ...options, name: indexName });\n\t\t} else if (this.isGeospatialIndex(keys)) {\n\t\t\tindex = new GeospatialCollectionIndex(keys, { ...options, name: indexName });\n\t\t} else {\n\t\t\tindex = new RegularCollectionIndex(keys, { ...options, name: indexName });\n\t\t}\n\n\t\t// Build index by scanning all documents\n\t\tfor (let i = 0; i < this.storage.size(); i++) {\n\t\t\tconst doc = this.storage.get(i);\n\t\t\tif (doc) {\n\t\t\t\tindex.add(doc);\n\t\t\t}\n\t\t}\n\n\t\tthis.indexes[indexName] = index;\n\t\treturn index;\n\t}\n\n\t/**\n\t * Update indexes when a document is inserted\n\t */\n\tupdateIndexesOnInsert(doc) {\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tindex.add(doc);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Update indexes when a document is deleted\n\t */\n\tupdateIndexesOnDelete(doc) {\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tindex.remove(doc);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query planner - analyze query and determine optimal execution plan\n\t */\n\tplanQuery(query) {\n\t\tconst plan = this.queryPlanner.plan(query);\n\t\tconst docIds = this.queryPlanner.execute(plan);\n\t\t\n\t\treturn {\n\t\t\tuseIndex: plan.type !== 'full_scan',\n\t\t\tplanType: plan.type,\n\t\t\tindexNames: plan.indexes,\n\t\t\tdocIds: docIds,\n\t\t\testimatedCost: plan.estimatedCost\n\t\t};\n\t}\n\n\t/**\n\t * Get a text index for the given field\n\t * @param {string} field - The field name\n\t * @returns {TextCollectionIndex|null} The text index or null if not found\n\t */\n\tgetTextIndex(field) {\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t\t// Check if this field is indexed\n\t\t\t\t\tif (index.indexedFields.includes(field)) {\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Collection methods\n\taggregate(pipeline) {\n\t\tif (!pipeline || !isArray(pipeline)) {\n\t\t\tthrow { $err: \"Pipeline must be an array\", code: 17287 };\n\t\t}\n\n\t\t// Start with all documents\n\t\tlet results = [];\n\t\tconst cursor = this.find({});\n\t\twhile (cursor.hasNext()) {\n\t\t\tresults.push(cursor.next());\n\t\t}\n\n\t\t// Process each stage in the pipeline\n\t\tfor (let i = 0; i < pipeline.length; i++) {\n\t\t\tconst stage = pipeline[i];\n\t\t\tconst stageKeys = Object.keys(stage);\n\t\t\tif (stageKeys.length !== 1) {\n\t\t\t\tthrow { $err: \"Each pipeline stage must have exactly one key\", code: 17287 };\n\t\t\t}\n\t\t\tconst stageType = stageKeys[0];\n\t\t\tconst stageSpec = stage[stageType];\n\n\t\t\tif (stageType === \"$match\") {\n\t\t\t\t// Filter documents based on query\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tif (matches(results[j], stageSpec)) {\n\t\t\t\t\t\tmatched.push(results[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults = matched;\n\t\t\t} else if (stageType === \"$project\") {\n\t\t\t\t// Reshape documents\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tprojected.push(applyProjection(stageSpec, results[j]));\n\t\t\t\t}\n\t\t\t\tresults = projected;\n\t\t\t} else if (stageType === \"$sort\") {\n\t\t\t\t// Sort documents\n\t\t\t\tconst sortKeys = Object.keys(stageSpec);\n\t\t\t\tresults.sort(function (a, b) {\n\t\t\t\t\tfor (let k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\tconst key = sortKeys[k];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * stageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (stageType === \"$limit\") {\n\t\t\t\t// Limit number of documents\n\t\t\t\tresults = results.slice(0, stageSpec);\n\t\t\t} else if (stageType === \"$skip\") {\n\t\t\t\t// Skip documents\n\t\t\t\tresults = results.slice(stageSpec);\n\t\t\t} else if (stageType === \"$group\") {\n\t\t\t\t// Group documents\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = stageSpec._id;\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\t// Compute group key\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else if (typeof groupId === 'string' && groupId.charAt(0) === '$') {\n\t\t\t\t\t\t// Field reference\n\t\t\t\t\t\tkey = getProp(doc, groupId.substring(1));\n\t\t\t\t\t} else if (typeof groupId === 'object') {\n\t\t\t\t\t\t// Computed key\n\t\t\t\t\t\tkey = JSON.stringify(groupId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = groupId;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\t// Initialize group\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\t// Process each accumulator field\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = stageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'number') {\n\t\t\t\t\t\t\t\t\tsum += accExpr;\n\t\t\t\t\t\t\t\t} else if (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tsum += val || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$min') {\n\t\t\t\t\t\t\tlet min = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tif (val !== undefined && (min === undefined || val < min)) {\n\t\t\t\t\t\t\t\t\t\tmin = val;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = min;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\t\t\t\tconst set = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (const valKey in set) {\n\t\t\t\t\t\t\t\tarr.push(set[valKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$first') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tresult[field] = getProp(group.docs[0], accExpr.substring(1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$last') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tresult[field] = getProp(group.docs[group.docs.length - 1], accExpr.substring(1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tresults = grouped;\n\t\t\t} else if (stageType === \"$count\") {\n\t\t\t\t// Count documents and return single document with count\n\t\t\t\tresults = [{ [stageSpec]: results.length }];\n\t\t\t} else if (stageType === \"$unwind\") {\n\t\t\t\t// Unwind array field\n\t\t\t\tconst unwound = [];\n\t\t\t\tlet fieldPath = stageSpec;\n\t\t\t\tif (typeof fieldPath === 'string' && fieldPath.charAt(0) === '$') {\n\t\t\t\t\tfieldPath = fieldPath.substring(1);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tconst arr = getProp(doc, fieldPath);\n\n\t\t\t\t\tif (arr && isArray(arr) && arr.length > 0) {\n\t\t\t\t\t\tfor (let k = 0; k < arr.length; k++) {\n\t\t\t\t\t\t\tconst unwoundDoc = copy(doc);\n\t\t\t\t\t\t\t// Set the unwound value\n\t\t\t\t\t\t\tconst parts = fieldPath.split('.');\n\t\t\t\t\t\t\tlet target = unwoundDoc;\n\t\t\t\t\t\t\tfor (let l = 0; l < parts.length - 1; l++) {\n\t\t\t\t\t\t\t\tif (!target[parts[l]]) {\n\t\t\t\t\t\t\t\t\ttarget[parts[l]] = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget = target[parts[l]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[parts[parts.length - 1]] = arr[k];\n\t\t\t\t\t\t\tunwound.push(unwoundDoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// MongoDB's default behavior: skip documents where field is missing, null, empty array, or not an array\n\t\t\t\t}\n\t\t\t\tresults = unwound;\n\t\t\t} else {\n\t\t\t\tthrow { $err: \"Unsupported aggregation stage: \" + stageType, code: 17287 };\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tbulkWrite() { throw \"Not Implemented\"; }\n\n\tasync count() {\n\t\treturn this.storage.size();\n\t}\n\n\tasync copyTo(destCollectionName) {\n\t\tif (!this.db[destCollectionName]) {\n\t\t\tthis.db.createCollection(destCollectionName);\n\t\t}\n\t\tconst destCol = this.db[destCollectionName];\n\t\tlet numCopied = 0;\n\t\tconst c = this.find({});\n\t\twhile (c.hasNext()) {\n\t\t\tawait destCol.insertOne(c.next());\n\t\t\tnumCopied++;\n\t\t}\n\t\treturn numCopied;\n\t}\n\n\tasync createIndex(keys, options) {\n\t\t// MongoDB-compliant createIndex\n\t\t// keys: { fieldName: 1 } for ascending, { fieldName: -1 } for descending, { fieldName: 'text' } for text\n\t\t// options: { name: \"indexName\", unique: true, ... }\n\n\t\tif (!keys || typeof keys !== 'object' || Array.isArray(keys)) {\n\t\t\tthrow { $err: \"createIndex requires a key specification object\", code: 2 };\n\t\t}\n\n\t\tconst indexName = (options && options.name) ? options.name : this.generateIndexName(keys);\n\n\t\t// Check if index already exists\n\t\tif (this.indexes[indexName]) {\n\t\t\t// MongoDB checks for key specification conflicts\n\t\t\tconst existingIndex = this.indexes[indexName];\n\t\t\tconst existingKeys = JSON.stringify(existingIndex.keys);\n\t\t\tconst newKeys = JSON.stringify(keys);\n\t\t\tif (existingKeys !== newKeys) {\n\t\t\t\tthrow { $err: \"Index with name '\" + indexName + \"' already exists with a different key specification\", code: 85 };\n\t\t\t}\n\t\t\t// Same index, return without error\n\t\t\treturn indexName;\n\t\t}\n\n\t\t// Build the index\n\t\tthis.buildIndex(indexName, keys, options);\n\n\t\treturn indexName;\n\t}\n\n\tdataSize() { throw \"Not Implemented\"; }\n\n\tasync deleteOne(query) {\n\t\tconst doc = await this.findOne(query);\n\t\tif (doc) {\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id);\n\t\t\treturn { deletedCount: 1 };\n\t\t} else {\n\t\t\treturn { deletedCount: 0 };\n\t\t}\n\t}\n\n\tasync deleteMany(query) {\n\t\tconst c = this.find(query);\n\t\tconst ids = [];\n\t\tconst docs = [];\n\t\twhile (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tids.push(doc._id);\n\t\t\tdocs.push(doc);\n\t\t}\n\t\tconst deletedCount = ids.length;\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tthis.updateIndexesOnDelete(docs[i]);\n\t\t\tthis.storage.remove(ids[i]);\n\t\t}\n\t\treturn { deletedCount: deletedCount };\n\t}\n\n\tasync distinct(field, query) {\n\t\tconst vals = {};\n\t\tconst c = this.find(query);\n\t\twhile (c.hasNext()) {\n\t\t\tconst d = c.next();\n\t\t\tif (d[field]) {\n\t\t\t\tvals[d[field]] = true;\n\t\t\t}\n\t\t}\n\t\treturn Object.keys(vals);\n\t}\n\n\tdrop() {\n\t\tthis.storage.clear();\n\t\t// Clear all indexes\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tthis.indexes[indexName].clear();\n\t\t\t}\n\t\t}\n\t}\n\n\tdropIndex(indexName) {\n\t\tif (!this.indexes[indexName]) {\n\t\t\tthrow { $err: \"Index not found with name: \" + indexName, code: 27 };\n\t\t}\n\t\tthis.indexes[indexName].clear();\n\t\tdelete this.indexes[indexName];\n\t\treturn { nIndexesWas: Object.keys(this.indexes).length + 1, ok: 1 };\n\t}\n\n\tdropIndexes() {\n\t\tconst count = Object.keys(this.indexes).length;\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tthis.indexes[indexName].clear();\n\t\t\t}\n\t\t}\n\t\tthis.indexes = {};\n\t\treturn { nIndexesWas: count, msg: \"non-_id indexes dropped\", ok: 1 };\n\t}\n\tensureIndex() { throw \"Not Implemented\"; }\n\texplain() { throw \"Not Implemented\"; }\n\n\tfind(query, projection) {\n\t\treturn new Cursor(\n\t\t\tthis,\n\t\t\t(query == undefined ? {} : query),\n\t\t\tprojection,\n\t\t\tmatches,\n\t\t\tthis.storage,\n\t\t\tthis.indexes,\n\t\t\tthis.planQuery.bind(this),\n\t\t\tSortedCursor\n\t\t);\n\t}\n\n\tfindAndModify() { throw \"Not Implemented\"; }\n\n\tasync findOne(query, projection) {\n\t\tconst cursor = this.find(query, projection);\n\t\tif (cursor.hasNext()) {\n\t\t\treturn cursor.next();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync findOneAndDelete(filter, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tthis.storage.remove(doc._id);\n\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\telse return doc;\n\t}\n\n\tasync findOneAndReplace(filter, replacement, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\treplacement._id = doc._id;\n\t\tthis.storage.set(doc._id, replacement);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, replacement);\n\t\t\telse return replacement;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tasync findOneAndUpdate(filter, update, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tconst clone = Object.assign({}, doc);\n\t\tapplyUpdates(update, clone);\n\t\tthis.storage.set(doc._id, clone);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, clone);\n\t\t\telse return clone;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tgetIndexes() {\n\t\t// Return array of index specifications\n\t\tconst result = [];\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tresult.push(this.indexes[indexName].getSpec());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetShardDistribution() { throw \"Not Implemented\"; }\n\tgetShardVersion() { throw \"Not Implemented\"; }\n\n\t// non-mongo\n\tgetStore() {\n\t\treturn this.storage.getStore();\n\t}\n\n\tgroup() { throw \"Not Implemented\"; }\n\n\tasync insert(doc) {\n\t\tif (Array == doc.constructor) {\n\t\t\treturn await this.insertMany(doc);\n\t\t} else {\n\t\t\treturn await this.insertOne(doc);\n\t\t}\n\t}\n\n\tasync insertOne(doc) {\n\t\tif (doc._id == undefined) doc._id = this.idGenerator();\n\t\tthis.storage.set(doc._id, doc);\n\t\tthis.updateIndexesOnInsert(doc);\n\t\treturn { insertedId: doc._id };\n\t}\n\n\tasync insertMany(docs) {\n\t\tconst insertedIds = [];\n\t\tfor (let i = 0; i < docs.length; i++) {\n\t\t\tconst result = await this.insertOne(docs[i]);\n\t\t\tinsertedIds.push(result.insertedId);\n\t\t}\n\t\treturn { insertedIds: insertedIds };\n\t}\n\n\tisCapped() { throw \"Not Implemented\"; }\n\tmapReduce() { throw \"Not Implemented\"; }\n\treIndex() { throw \"Not Implemented\"; }\n\n\tasync replaceOne(query, replacement, options) { // only replace\n\t\t// first\n\t\tconst result = {};\n\t\tconst c = this.find(query);\n\t\tresult.matchedCount = c.count();\n\t\tif (result.matchedCount == 0) {\n\t\t\tresult.modifiedCount = 0;\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = replacement;\n\t\t\t\tnewDoc._id = this.idGenerator();\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tresult.upsertedId = newDoc._id;\n\t\t\t}\n\t\t} else {\n\t\t\tresult.modifiedCount = 1;\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\treplacement._id = doc._id;\n\t\t\tthis.storage.set(doc._id, replacement);\n\t\t\tthis.updateIndexesOnInsert(replacement);\n\t\t}\n\t\treturn result;\n\t}\n\n\tremove(query, options) {\n\t\tconst c = this.find(query);\n\t\tif (!c.hasNext()) return;\n\t\tif (options === true || (options && options.justOne)) {\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id);\n\t\t} else {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tthis.storage.remove(doc._id);\n\t\t\t}\n\t\t}\n\t}\n\n\trenameCollection() { throw \"Not Implemented\"; }\n\tsave() { throw \"Not Implemented\"; }\n\tstats() { throw \"Not Implemented\"; }\n\tstorageSize() { throw \"Not Implemented\"; }\n\ttotalSize() { throw \"Not Implemented\"; }\n\ttotalIndexSize() { throw \"Not Implemented\"; }\n\n\tupdate(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tif (options && options.multi) {\n\t\t\t\twhile (c.hasNext()) {\n\t\t\t\t\tconst doc = c.next();\n\t\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\t\tapplyUpdates(updates, doc);\n\t\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc);\n\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateOne(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tapplyUpdates(updates, doc);\n\t\t\tthis.storage.set(doc._id, doc);\n\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateMany(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc);\n\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidate() { throw \"Not Implemented\"; }\n\n\t/**\n\t * Export collection state for storage\n\t * @returns {Object} Collection state including documents and indexes\n\t */\n\texportState() {\n\t\t// Export all documents\n\t\tconst documents = [];\n\t\tfor (let i = 0; i < this.storage.size(); i++) {\n\t\t\tconst doc = this.storage.get(i);\n\t\t\tif (doc) {\n\t\t\t\tdocuments.push(doc);\n\t\t\t}\n\t\t}\n\n\t\t// Export all indexes\n\t\tconst indexes = [];\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tindexes.push(index.serialize());\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdocuments: documents,\n\t\t\tindexes: indexes\n\t\t};\n\t}\n\n\t/**\n\t * Import collection state from storage\n\t * @param {Object} state - Collection state including documents and indexes\n\t */\n\tasync importState(state) {\n\t\t// Clear existing data\n\t\tthis.storage.clear();\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tthis.indexes[indexName].clear();\n\t\t\t}\n\t\t}\n\t\tthis.indexes = {};\n\n\t\t// Import documents\n\t\tif (state.documents && Array.isArray(state.documents)) {\n\t\t\tfor (const doc of state.documents) {\n\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t}\n\t\t}\n\n\t\t// Import indexes\n\t\tif (state.indexes && Array.isArray(state.indexes)) {\n\t\t\tfor (const indexState of state.indexes) {\n\t\t\t\t// Recreate the index based on its type\n\t\t\t\tlet index;\n\t\t\t\tif (indexState.type === 'text') {\n\t\t\t\t\tindex = new TextCollectionIndex(indexState.keys, indexState.options);\n\t\t\t\t\tindex.deserialize(indexState);\n\t\t\t\t} else if (indexState.type === 'geospatial') {\n\t\t\t\t\tindex = new GeospatialCollectionIndex(indexState.keys, indexState.options);\n\t\t\t\t\tindex.deserialize(indexState);\n\t\t\t\t} else {\n\t\t\t\t\t// Default to regular index\n\t\t\t\t\tindex = new RegularCollectionIndex(indexState.keys, indexState.options);\n\t\t\t\t\tindex.deserialize(indexState);\n\t\t\t\t}\n\t\t\t\tthis.indexes[index.name] = index;\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Abstract base class for storage engines\n * Defines the interface for storing and retrieving database state\n */\nexport class StorageEngine {\n\tconstructor() {\n\t\tif (new.target === StorageEngine) {\n\t\t\tthrow new TypeError(\"Cannot construct StorageEngine instances directly\");\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\tthrow new Error('initialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @param {string} dbState.name - The database name\n\t * @param {Object} dbState.collections - Map of collection names to collection data\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tthrow new Error('saveDatabase() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tthrow new Error('loadDatabase() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @param {Array} collectionState.documents - The documents in the collection\n\t * @param {Array} collectionState.indexes - The indexes in the collection\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tthrow new Error('saveCollection() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tthrow new Error('loadCollection() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tthrow new Error('deleteCollection() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tthrow new Error('deleteDatabase() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tthrow new Error('close() must be implemented by subclass');\n\t}\n}\n","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * In-memory storage engine (default)\n * Does not persist data between sessions\n */\nexport class ObjectStorageEngine extends StorageEngine {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.databases = {};\n\t}\n\n\t/**\n\t * Initialize the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\t// No initialization needed for in-memory storage\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tthis.databases[dbState.name] = JSON.parse(JSON.stringify(dbState));\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (this.databases[dbName]) {\n\t\t\treturn JSON.parse(JSON.stringify(this.databases[dbName]));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.databases[dbName]) {\n\t\t\tthis.databases[dbName] = {\n\t\t\t\tname: dbName,\n\t\t\t\tcollections: {}\n\t\t\t};\n\t\t}\n\t\tthis.databases[dbName].collections[collectionName] = JSON.parse(JSON.stringify(collectionState));\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (this.databases[dbName] && this.databases[dbName].collections[collectionName]) {\n\t\t\treturn JSON.parse(JSON.stringify(this.databases[dbName].collections[collectionName]));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (this.databases[dbName] && this.databases[dbName].collections) {\n\t\t\tdelete this.databases[dbName].collections[collectionName];\n\t\t}\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tdelete this.databases[dbName];\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\t// No cleanup needed for in-memory storage\n\t}\n}\n","import { Collection } from './Collection.js';\nimport { LocalStorageStore, ObjectStore } from '../main.js';\nimport { ObjectId } from './ObjectId.js';\nimport { ObjectStorageEngine } from './ObjectStorageEngine.js';\n\n/**\n * DB class\n */\nexport class DB {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t\tthis.dbName = this.options.dbName || 'default';\n\t\t\n\t\t// Initialize storage engine if provided\n\t\tthis.storageEngine = this.options.storageEngine || null;\n\t\t\n\t\t// Initialize localStorage collection if available\n\t\tif (typeof localStorage !== \"undefined\") {\n\t\t\tthis.localStorage = new Collection(\n\t\t\t\tthis,\n\t\t\t\t(this.options.localStorage ? this.options.localStorage : LocalStorageStore),\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t} else {\n\t\t\tthis.localStorage = null;\n\t\t}\n\n\t\t// Return a Proxy to enable dynamic collection creation\n\t\treturn new Proxy(this, {\n\t\t\tget(target, property, receiver) {\n\t\t\t\t// If property exists on target (including undefined values), return it\n\t\t\t\tif (property in target) {\n\t\t\t\t\treturn Reflect.get(target, property, receiver);\n\t\t\t\t}\n\n\t\t\t\t// If property is a symbol or special property, return undefined\n\t\t\t\tif (typeof property === 'symbol' || property.startsWith('_')) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// For collection names, create the collection if it doesn't exist\n\t\t\t\t// Only auto-create if it's a valid collection name and doesn't already exist\n\t\t\t\tif (typeof property === 'string' && property !== 'localStorage') {\n\t\t\t\t\t// Don't auto-create if property was explicitly deleted\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(target, property)) {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t\t// Auto-create the collection\n\t\t\t\t\ttarget.createCollection(property);\n\t\t\t\t\treturn target[property];\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Log function\n\t */\n\t_log(msg) {\n\t\tif (this.options && this.options.print) this.options.print(msg);\n\t\telse console.log(msg);\n\t}\n\n\t/**\n\t * ID generator function\n\t */\n\t_id() {\n\t\tif (this.options && this.options.id) return this.options.id();\n\t\telse return new ObjectId();\n\t}\n\n\t// DB Methods\n\tcloneCollection() { throw \"Not Implemented\"; }\n\tcloneDatabase() { throw \"Not Implemented\"; }\n\tcommandHelp() { throw \"Not Implemented\"; }\n\tcopyDatabase() { throw \"Not Implemented\"; }\n\n\tcreateCollection(name) {\n\t\tif (!name) return;\n\t\tif (name == \"localStorage\") {\n\t\t\tthis.localStorage = new Collection(\n\t\t\t\tthis,\n\t\t\t\t(this.options.localStorage ? this.options.localStorage : LocalStorageStore),\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t} else {\n\t\t\tthis[name] = new Collection(\n\t\t\t\tthis,\n\t\t\t\t(this.options && this.options.storage ? new this.options.storage() : new ObjectStore()),\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\tcurrentOp() { throw \"Not Implemented\"; }\n\n\tdropDatabase() {\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tthis[key].drop(); // drop the contents\n\t\t\t\tdelete this[key];\n\t\t\t}\n\t\t}\n\t}\n\n\teval() { throw \"Not Implemented\"; }\n\tfsyncLock() { throw \"Not Implemented\"; }\n\tfsyncUnlock() { throw \"Not Implemented\"; }\n\tgetCollection() { throw \"Not Implemented\"; }\n\tgetCollectionInfos() { throw \"Not Implemented\"; }\n\n\tgetCollectionNames() {\n\t\tconst names = [];\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tnames.push(key);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tgetLastError() { throw \"Not Implemented\"; }\n\tgetLastErrorObj() { throw \"Not Implemented\"; }\n\tgetLogComponents() { throw \"Not Implemented\"; }\n\tgetMongo() { throw \"Not Implemented\"; }\n\tgetName() { throw \"Not Implemented\"; }\n\tgetPrevError() { throw \"Not Implemented\"; }\n\tgetProfilingLevel() { throw \"Not Implemented\"; }\n\tgetProfilingStatus() { throw \"Not Implemented\"; }\n\tgetReplicationInfo() { throw \"Not Implemented\"; }\n\tgetSiblingDB() { throw \"Not Implemented\"; }\n\n\thelp() {\n\t\tthis._log(\"        help mr                      mapreduce\");\n\t\tthis._log(\"        db.foo.find()                list objects in collection foo\");\n\t\tthis._log(\"        db.foo.find( { a : 1 } )     list objects in foo where a == 1\");\n\t\tthis._log(\"        it                           result of the last line evaluated; use to further iterate\");\n\t}\n\n\thostInfo() { throw \"Not Implemented\"; }\n\tisMaster() { throw \"Not Implemented\"; }\n\tkillOp() { throw \"Not Implemented\"; }\n\tlistCommands() { throw \"Not Implemented\"; }\n\tloadServerScripts() { throw \"Not Implemented\"; }\n\tlogout() { throw \"Not Implemented\"; }\n\tprintCollectionStats() { throw \"Not Implemented\"; }\n\tprintReplicationInfo() { throw \"Not Implemented\"; }\n\tprintShardingStatus() { throw \"Not Implemented\"; }\n\tprintSlaveReplicationInfo() { throw \"Not Implemented\"; }\n\trepairDatabase() { throw \"Not Implemented\"; }\n\tresetError() { throw \"Not Implemented\"; }\n\trunCommand() { throw \"Not Implemented\"; }\n\tserverBuildInfo() { throw \"Not Implemented\"; }\n\tserverCmdLineOpts() { throw \"Not Implemented\"; }\n\tserverStatus() { throw \"Not Implemented\"; }\n\tsetLogLevel() { throw \"Not Implemented\"; }\n\tsetProfilingLevel() { throw \"Not Implemented\"; }\n\tshutdownServer() { throw \"Not Implemented\"; }\n\tstats() { throw \"Not Implemented\"; }\n\tversion() { throw \"Not Implemented\"; }\n\tupgradeCheck() { throw \"Not Implemented\"; }\n\tupgradeCheckAllDBs() { throw \"Not Implemented\"; }\n\n\t/**\n\t * Save database state to storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync saveToStorage() {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\t// Collect all collections and their states\n\t\tconst collections = {};\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tcollections[key] = this[key].exportState();\n\t\t\t}\n\t\t}\n\n\t\t// Save to storage engine\n\t\tawait this.storageEngine.saveDatabase({\n\t\t\tname: this.dbName,\n\t\t\tcollections: collections\n\t\t});\n\t}\n\n\t/**\n\t * Load database state from storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync loadFromStorage() {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\t// Load from storage engine\n\t\tconst dbState = await this.storageEngine.loadDatabase(this.dbName);\n\t\t\n\t\tif (!dbState || !dbState.collections) {\n\t\t\treturn; // No saved state\n\t\t}\n\n\t\t// Drop existing collections\n\t\tthis.dropDatabase();\n\n\t\t// Restore collections\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tthis.createCollection(collectionName);\n\t\t\t\tawait this[collectionName].importState(dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Save a specific collection to storage engine\n\t * @param {string} collectionName - Name of the collection to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(collectionName) {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\tif (!this[collectionName] || !this[collectionName].isCollection) {\n\t\t\tthrow new Error(`Collection '${collectionName}' does not exist`);\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\tconst collectionState = this[collectionName].exportState();\n\t\tawait this.storageEngine.saveCollection(this.dbName, collectionName, collectionState);\n\t}\n\n\t/**\n\t * Load a specific collection from storage engine\n\t * @param {string} collectionName - Name of the collection to load\n\t * @returns {Promise<void>}\n\t */\n\tasync loadCollection(collectionName) {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\tconst collectionState = await this.storageEngine.loadCollection(this.dbName, collectionName);\n\t\t\n\t\tif (!collectionState) {\n\t\t\treturn; // No saved state for this collection\n\t\t}\n\n\t\t// Create or recreate the collection\n\t\tif (!this[collectionName]) {\n\t\t\tthis.createCollection(collectionName);\n\t\t}\n\n\t\tawait this[collectionName].importState(collectionState);\n\t}\n}\n","\r\nimport { DB } from './DB.js'\r\n// https://mongodb.github.io/node-mongodb-native/6.20/classes/MongoClient.html\r\nexport class MongoClient {\r\n\r\n  constructor(uri, options = {}) {\r\n    this.uri = uri;\r\n    this.options = options;\r\n  }\r\n\r\n  static async connect(uri, options = {}) {\r\n    return new MongoClient(uri, options);\r\n  }\r\n\r\n  db(name, opts = {}) {\r\n    // Merge client options with db-specific options\r\n    const dbOptions = { ...this.options, ...opts, dbName: name };\r\n    return new DB(dbOptions);\r\n  }\r\n\r\n  async close() {\r\n    /* no-op for in-memory */ \r\n  }\r\n}","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * IndexedDB-based storage engine for persistent storage\n * Stores each collection separately in IndexedDB\n */\nexport class IndexedDbStorageEngine extends StorageEngine {\n\tconstructor(dbName = 'micro-mongo') {\n\t\tsuper();\n\t\tthis.dbName = dbName;\n\t\tthis.db = null;\n\t\tthis.indexedDBName = `micro-mongo-${dbName}`;\n\t}\n\n\t/**\n\t * Initialize the IndexedDB connection\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open(this.indexedDBName, 1);\n\n\t\t\trequest.onerror = () => {\n\t\t\t\treject(new Error('Failed to open IndexedDB: ' + request.error));\n\t\t\t};\n\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tthis.db = request.result;\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = event.target.result;\n\t\t\t\t\n\t\t\t\t// Create object stores for collections and metadata\n\t\t\t\tif (!db.objectStoreNames.contains('collections')) {\n\t\t\t\t\tdb.createObjectStore('collections', { keyPath: 'name' });\n\t\t\t\t}\n\t\t\t\tif (!db.objectStoreNames.contains('metadata')) {\n\t\t\t\t\tdb.createObjectStore('metadata', { keyPath: 'key' });\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\t// Save metadata\n\t\tconst transaction = this.db.transaction(['metadata'], 'readwrite');\n\t\tconst metadataStore = transaction.objectStore('metadata');\n\t\t\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst request = metadataStore.put({\n\t\t\t\tkey: 'dbName',\n\t\t\t\tvalue: dbState.name\n\t\t\t});\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\n\t\t// Save each collection\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tawait this.saveCollection(dbState.name, collectionName, dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.getAll();\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst collections = {};\n\t\t\t\tfor (const collectionData of request.result) {\n\t\t\t\t\tcollections[collectionData.name] = {\n\t\t\t\t\t\tdocuments: collectionData.documents || [],\n\t\t\t\t\t\tindexes: collectionData.indexes || []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolve({\n\t\t\t\t\tname: dbName,\n\t\t\t\t\tcollections: collections\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.put({\n\t\t\t\tname: collectionName,\n\t\t\t\tdocuments: collectionState.documents || [],\n\t\t\t\tindexes: collectionState.indexes || []\n\t\t\t});\n\t\t\t\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.get(collectionName);\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tif (request.result) {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tdocuments: request.result.documents || [],\n\t\t\t\t\t\tindexes: request.result.indexes || []\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.delete(collectionName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.deleteDatabase(this.indexedDBName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\t}\n}\n","/**\n * MicroMongoDB - Lightweight MongoDB-compatible database\n * Refactored into separate class files\n */\n\n/**\n * MicroMongoDB.LocalStorageStore\n * \n * Singleton\n */\nexport const LocalStorageStore = (function() {\n\n\treturn {\n\t\tclear : function() {\n\t\t\tlocalStorage.clear();\n\t\t},\n\t\tget : function(i) {\n\t\t\treturn JSON.parse(localStorage.getItem(localStorage.key(i)));\n\t\t},\n\t\tgetStore : function() {\n\t\t\treturn localStorage;\n\t\t},\n\t\tremove : function(key) {\n\t\t\tlocalStorage.removeItem(key);\n\t\t},\n\t\tset : async function(key,val) {\n\t\t\tlocalStorage.setItem(key,JSON.stringify(val));\n\t\t},\n\t\tsize : function() {\n\t\t\treturn localStorage.length;\n\t\t}\n\t};\n\n})(); // MicroMongoDB.LocalStorageStore\n\n/**\n * MicroMongoDB.ObjectStore\n * \n * Public Constructor Function\n */\nexport const ObjectStore = function() {\n\n\tvar objs = {};\n\n\treturn {\n\t\tclear : function() {\n\t\t\tobjs = {};\n\t\t},\n\t\tget : function(i) {\n\t\t\treturn objs[Object.keys(objs)[i]];\n\t\t},\n\t\tgetStore : function() {\n\t\t\treturn objs;\n\t\t},\n\t\tremove : function(key) {\n\t\t\tdelete objs[key];\n\t\t},\n\t\tset : function(key,val) {\n\t\t\tobjs[key] = val;\n\t\t},\n\t\tsize : function() {\n\t\t\treturn Object.keys(objs).length;\n\t\t}\n\t}; // MicroMongoDB.ObjectStore return\n}; // MicroMongoDB.ObjectStore\n\n// Export refactored classes\nexport { MongoClient } from './src/MongoClient.js';\nexport { ObjectId } from './src/ObjectId.js';\nexport { StorageEngine } from './src/StorageEngine.js';\nexport { IndexedDbStorageEngine } from './src/IndexedDbStorageEngine.js';\nexport { ObjectStorageEngine } from './src/ObjectStorageEngine.js';\n"],"names":["ObjectId","constructor","id","this","generate","isValid","Error","toLowerCase","toString","toHexString","getTimestamp","timestamp","parseInt","substring","Date","equals","other","toJSON","inspect","length","test","createFromTime","tsHex","Math","floor","slice","ts","now","rand","crypto","getRandomValues","Uint8Array","tail","i","random","padEnd","valuesEqual","a","b","copy","o","out","v","key","Array","isArray","getProp","obj","name","path","split","result","isIn","val","values","arrayMatches","x","y","objectMatches","p","hasOwnProperty","applyProjection","projection","doc","keys","Object","hasInclusion","hasExclusion","$err","code","_id","Cursor","collection","query","matches","storage","indexes","planQuery","SortedCursor","pos","max","_next","queryPlan","useIndex","planType","indexDocIds","indexPos","fullScanDocIds","docIds","_findNext","docId","getStore","size","cur","get","batchSize","close","comment","count","num","c","hasNext","next","explain","forEach","fn","hint","itcount","limit","_max","map","results","push","maxScan","maxTimeMS","min","noCursorTimeout","objsLeftInBatch","pretty","readConcern","readPref","returnKey","showRecordId","skip","snapshot","sort","s","tailable","toArray","Symbol","asyncIterator","cursor","sortSpec","items","sortKeys","step2list","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3list","icate","ative","alize","iciti","ical","ful","ness","vowel","consonants","vowels","gt0","RegExp","eq1","gt1","vowelInStem","consonantLike","sfxLl","sfxE","sfxY","sfxIon","sfxEdOrIng","sfxAtOrBlOrIz","sfxEED","sfxS","sfxSsesOrIes","sfxMultiConsonantLike","step2","step3","step4","stemmer","value","String","match","firstCharacterWasLowerCaseY","codePointAt","exec","STOPWORDS","Set","TextIndex","options","index","Map","documentTerms","documentLengths","useStopWords","stopWords","_tokenize","text","words","filter","word","has","add","termFrequency","stem","set","frequency","remove","term","delete","queryText","scored","requireAll","stemmedTerms","uniqueTerms","docSets","termDocs","intersection","from","totalDocs","idf","docsWithTerm","log","docScores","termFreq","tfIdf","score","docTerms","coverage","entries","r","getTermCount","getDocumentCount","clear","addStopWords","removeStopWords","setStopWordFiltering","enabled","serialize","indexObj","docs","docsObj","freq","documentTermsObj","terms","termsObj","documentLengthsObj","deserialize","state","compareValues","operator","aVal","bVal","prop","textIndex","geoWithin","minLon","maxLat","maxLon","isGeometryWithinBBox","e","geoJson","minLat","type","features","feature","geometry","coordinates","lng","lat","ring","coord","tlMatches","charAt","and","els","or","not","nor","call","Function","where","opMatches","operand","fieldValue","j","found","element","matchesPrimitive","opKeys","k","op","opValue","arr","el","applyUpdates","updates","setOnInsert","fields","amount","field","pop","shift","src","toRemove","notRemoved","removed","l","operation","createDocFromUpdate","idGenerator","newDoc","onlyFields","updateKeys","queryKeys","CollectionIndex","generateIndexName","parts","join","update","oldDoc","getSpec","data","RegularCollectionIndex","super","extractIndexKey","keyFields","JSON","stringify","t","keyParts","indexKey","idx","indexOf","splice","indexFields","queryValue","_queryWithOperators","operators","ops","some","includes","parsed","parse","excludeValue","excludeKey","TextCollectionIndex","indexedFields","_extractText","textParts","search","searchText","textIndexVersion","weights","_getWeights","textIndexState","haversineDistance","lat1","lng1","lat2","lng2","dLat","PI","dLng","sin","cos","atan2","sqrt","intersects","bbox1","bbox2","maxLng","minLng","area","bbox","union","enlargement","RTreeNode","isLeaf","children","updateBBox","Infinity","child","RTree","maxEntries","minEntries","ceil","root","_size","insert","entry","_insert","node","level","_split","target","_chooseSubtree","splitNode","minEnlargement","minArea","targetNode","enl","ar","maxDist","seed1Idx","seed2Idx","waste","node1","node2","enl1","enl2","newRoot","searchBBox","_searchBBox","searchRadius","radiusKm","latDelta","lngDelta","radiusToBoundingBox","candidates","_remove","parent","indexInParent","getAll","_getAll","_serializeNode","serialized","_deserializeNode","GeospatialCollectionIndex","rtree","geoField","_extractCoordinates","sumLat","sumLng","geoValue","coords","geoQuery","$geoWithin","rtreeState","QueryPlan","indexScans","estimatedCost","QueryPlanner","plan","analysis","_analyzeQuery","hasTextSearch","textPlan","_planTextSearch","hasGeoQuery","geoPlan","_planGeoQuery","andPlan","_planAndQuery","orPlan","_planOrQuery","simplePlan","_planSimpleQuery","conditions","$and","condition","subAnalysis","$or","startsWith","indexName","textQuery","_extractTextQuery","$text","$search","indexableConditions","conditionPlan","scan","reduce","sum","execute","sorted","currentSet","Collection","db","queryPlanner","isCollection","isTextIndex","isGeospatialIndex","buildIndex","updateIndexesOnInsert","updateIndexesOnDelete","indexNames","getTextIndex","aggregate","pipeline","find","stage","stageKeys","stageType","stageSpec","matched","projected","groups","groupId","keyStr","accumulators","grouped","groupKey","group","accumulator","accKeys","accType","accExpr","valKey","unwound","fieldPath","unwoundDoc","bulkWrite","copyTo","destCollectionName","createCollection","destCol","numCopied","insertOne","createIndex","existingIndex","dataSize","deleteOne","findOne","deletedCount","deleteMany","ids","distinct","vals","d","drop","dropIndex","nIndexesWas","ok","dropIndexes","msg","ensureIndex","bind","findAndModify","findOneAndDelete","findOneAndReplace","replacement","returnNewDocument","findOneAndUpdate","clone","assign","getIndexes","getShardDistribution","getShardVersion","insertMany","insertedId","insertedIds","isCapped","mapReduce","reIndex","replaceOne","matchedCount","modifiedCount","upsert","upsertedId","justOne","renameCollection","save","stats","storageSize","totalSize","totalIndexSize","multi","updateOne","updateMany","validate","exportState","documents","importState","indexState","StorageEngine","TypeError","initialize","saveDatabase","dbState","loadDatabase","dbName","saveCollection","collectionName","collectionState","loadCollection","deleteCollection","deleteDatabase","ObjectStorageEngine","databases","collections","DB","storageEngine","localStorage","LocalStorageStore","Proxy","property","receiver","Reflect","prototype","_log","print","console","cloneCollection","cloneDatabase","commandHelp","copyDatabase","ObjectStore","currentOp","dropDatabase","eval","fsyncLock","fsyncUnlock","getCollection","getCollectionInfos","getCollectionNames","names","getLastError","getLastErrorObj","getLogComponents","getMongo","getName","getPrevError","getProfilingLevel","getProfilingStatus","getReplicationInfo","getSiblingDB","help","hostInfo","isMaster","killOp","listCommands","loadServerScripts","logout","printCollectionStats","printReplicationInfo","printShardingStatus","printSlaveReplicationInfo","repairDatabase","resetError","runCommand","serverBuildInfo","serverCmdLineOpts","serverStatus","setLogLevel","setProfilingLevel","shutdownServer","version","upgradeCheck","upgradeCheckAllDBs","saveToStorage","loadFromStorage","MongoClient","uri","connect","opts","dbOptions","IndexedDbStorageEngine","indexedDBName","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","onupgradeneeded","event","objectStoreNames","contains","createObjectStore","keyPath","metadataStore","transaction","objectStore","put","collectionsStore","collectionData","getItem","removeItem","async","setItem","objs"],"mappings":"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","x_google_ignoreList":[4]}