{"version":3,"file":"micro-mongo-2.0.0.umd.js","sources":["../node_modules/events/events.js","../node_modules/bjson/src/bjson.js","../src/utils.js","../src/errors.js","../src/Cursor.js","../src/SortedCursor.js","../node_modules/stemmer/index.js","../node_modules/bjson/src/bplustree.js","../node_modules/bjson/src/textindex.js","../src/aggregationExpressions.js","../src/queryMatcher.js","../src/Timestamp.js","../src/updates.js","../src/Index.js","../src/RegularCollectionIndex.js","../src/TextCollectionIndex.js","../node_modules/bjson/src/rtree.js","../src/GeospatialCollectionIndex.js","../src/QueryPlanner.js","../src/ChangeStream.js","../src/Collection.js","../src/DocumentStore.js","../src/IndexStore.js","../src/CollectionStore.js","../src/StorageEngine.js","../src/DB.js","../src/MongoClient.js","../src/IndexedDbStorageEngine.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Binary JSON Encoder/Decoder\n * \n * Encodes JavaScript values to a compact binary format compatible with\n * Origin Private File System (OPFS).\n */\n\nconst TYPE = {\n  NULL: 0x00,\n  FALSE: 0x01,\n  TRUE: 0x02,\n  INT: 0x03,\n  FLOAT: 0x04,\n  STRING: 0x05,\n  OID: 0x06,\n  DATE: 0x07,\n  POINTER: 0x08,\n  ARRAY: 0x10,\n  OBJECT: 0x11\n};\n\n\n/**\n * ObjectId class - MongoDB-compatible 24-character hex string identifier\n * Format: 8-char timestamp + 16-char random data\n */\nclass ObjectId {\n  constructor(id) {\n    if (id === undefined || id === null) {\n      // Generate new ObjectId\n      this.id = ObjectId.generate();\n    } else if (typeof id === 'string') {\n      // Create from hex string\n      if (!ObjectId.isValid(id)) {\n        throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${id}`);\n      }\n      this.id = id.toLowerCase();\n    } else if (id instanceof Uint8Array && id.length === 12) {\n      this.id = Array.from(id).map(b => b.toString(16).padStart(2, '0')).join('');\n    } else if (id instanceof ObjectId) {\n      // Copy constructor\n      this.id = id.id;\n    } else {\n      throw new Error(`Argument passed in must be a string of 24 hex characters or an ObjectId`);\n    }\n  }\n\n  /**\n   * Returns the ObjectId as a 24-character hex string\n   */\n  toString() {\n    return this.id;\n  }\n\n  /**\n   * Returns the ObjectId as a 24-character hex string (alias for toString)\n   */\n  toHexString() {\n    return this.id;\n  }\n\n  /**\n   * Returns the timestamp portion of the ObjectId as a Date\n   */\n  getTimestamp() {\n    const timestamp = parseInt(this.id.substring(0, 8), 16);\n    return new Date(timestamp * 1000);\n  }\n\n  equals(other) {\n    if (!(other instanceof ObjectId)) {\n      throw new Error('Can only compare with another ObjectId');\n    }\n    return this.id === other.id;\n  }\n\n  /**\n   * Compares this ObjectId with another for equality\n   */\n  compare(other) {\n    if (!(other instanceof ObjectId)) {\n      throw new Error('Can only compare with another ObjectId');\n    }\n\n    return this.id.localeCompare(other.id);\n  }\n\n  /**\n   * Returns the ObjectId in JSON format (as hex string)\n   */\n  toJSON() {\n    return this.id;\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return `ObjectId(\"${this.id}\")`;\n  }\n\n  toBytes() {\n    const bytes = new Uint8Array(12);\n    for (let i = 0; i < 12; i++) {\n      bytes[i] = parseInt(this.id.substring(i * 2, i * 2 + 2), 16);\n    }\n    return bytes;\n  }\n\n  /**\n   * Validates if a string is a valid ObjectId hex string\n   */\n  static isValid(id) {\n    if (!id) return false;\n    if (typeof id !== 'string') return false;\n    if (id.length !== 24) return false;\n    return /^[0-9a-fA-F]{24}$/.test(id);\n  }\n\n  /**\n   * Creates an ObjectId from a timestamp\n   */\n  static createFromTime(timestamp) {\n    const ts = Math.floor(timestamp / 1000);\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\n    const tail = '0000000000000000'; // Zero out the random portion\n    return new ObjectId(tsHex + tail);\n  }\n\n  /**\n   * Generates a new ObjectId hex string\n   * Format: 8-char timestamp (4 bytes) + 16-char random data (8 bytes)\n   */\n  static generate() {\n    const ts = Math.floor(Date.now() / 1000);\n    \n    // Generate 8 random bytes\n    const rand = typeof crypto !== 'undefined' && crypto.getRandomValues ? new Uint8Array(8) : null;\n    let tail = '';\n    \n    if (rand) {\n      crypto.getRandomValues(rand);\n      for (let i = 0; i < rand.length; i++) {\n        tail += ('0' + rand[i].toString(16)).slice(-2);\n      }\n    } else {\n      // Fallback for environments without crypto\n      // Generate two 8-character hex strings\n      tail = Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8) +\n             Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8);\n    }\n    \n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\n    return (tsHex + tail).slice(0, 24);\n  }\n}\n\n/**\n * Pointer class - represents a 64-bit file offset pointer\n * Used to store file offsets for referenced data structures\n */\nclass Pointer {\n  constructor(offset) {\n    if (offset === undefined || offset === null) {\n      throw new Error('Pointer offset must be a number');\n    }\n    if (typeof offset !== 'number') {\n      throw new Error('Pointer offset must be a number');\n    }\n    if (!Number.isInteger(offset)) {\n      throw new Error('Pointer offset must be an integer');\n    }\n    if (offset < 0) {\n      throw new Error('Pointer offset must be non-negative');\n    }\n    if (offset > Number.MAX_SAFE_INTEGER) {\n      throw new Error('Pointer offset exceeds maximum safe integer');\n    }\n    this.offset = offset;\n  }\n\n  /**\n   * Returns the pointer offset as a number\n   */\n  valueOf() {\n    return this.offset;\n  }\n\n  /**\n   * Returns the pointer offset as a string\n   */\n  toString() {\n    return this.offset.toString();\n  }\n\n  /**\n   * Returns the pointer in JSON format (as number)\n   */\n  toJSON() {\n    return this.offset;\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return `Pointer(${this.offset})`;\n  }\n\n  /**\n   * Compares this Pointer with another for equality\n   */\n  equals(other) {\n    if (!(other instanceof Pointer)) {\n      return false;\n    }\n    return this.offset === other.offset;\n  }\n}\n\n/**\n * Encode a JavaScript value to binary format\n */\nfunction encode(value) {\n  const buffers = [];\n\n  function encodeValue(val) {\n    if (val === null) {\n      buffers.push(new Uint8Array([TYPE.NULL]));\n    } else if (val === false) {\n      buffers.push(new Uint8Array([TYPE.FALSE]));\n    } else if (val === true) {\n      buffers.push(new Uint8Array([TYPE.TRUE]));\n    } else if (val instanceof ObjectId) {\n      buffers.push(new Uint8Array([TYPE.OID]));\n      buffers.push(val.toBytes());\n    } else if (val instanceof Date) {\n      buffers.push(new Uint8Array([TYPE.DATE]));\n      const buffer = new ArrayBuffer(8);\n      const view = new DataView(buffer);\n      view.setBigInt64(0, BigInt(val.getTime()), true); // little-endian\n      buffers.push(new Uint8Array(buffer));\n    } else if (val instanceof Pointer) {\n      buffers.push(new Uint8Array([TYPE.POINTER]));\n      const buffer = new ArrayBuffer(8);\n      const view = new DataView(buffer);\n      view.setBigUint64(0, BigInt(val.offset), true); // little-endian\n      buffers.push(new Uint8Array(buffer));\n    } else if (typeof val === 'number') {\n      if (Number.isInteger(val) && Number.isSafeInteger(val)) {\n        // 64-bit signed integer (stored as BigInt64)\n        buffers.push(new Uint8Array([TYPE.INT]));\n        const buffer = new ArrayBuffer(8);\n        const view = new DataView(buffer);\n        view.setBigInt64(0, BigInt(val), true); // little-endian\n        buffers.push(new Uint8Array(buffer));\n      } else {\n        // 64-bit float\n        buffers.push(new Uint8Array([TYPE.FLOAT]));\n        const buffer = new ArrayBuffer(8);\n        const view = new DataView(buffer);\n        view.setFloat64(0, val, true); // little-endian\n        buffers.push(new Uint8Array(buffer));\n      }\n    } else if (typeof val === 'string') {\n      buffers.push(new Uint8Array([TYPE.STRING]));\n      const encoded = new TextEncoder().encode(val);\n      // Store length as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, encoded.length, true);\n      buffers.push(new Uint8Array(lengthBuffer));\n      buffers.push(encoded);\n    } else if (Array.isArray(val)) {\n      // Encode array to temporary buffer to determine size\n      const tempBuffers = [];\n      \n      // Store array length as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, val.length, true);\n      tempBuffers.push(new Uint8Array(lengthBuffer));\n      \n      // Encode each element into temp buffer\n      const startLength = buffers.length;\n      for (const item of val) {\n        encodeValue(item);\n      }\n      // Collect encoded elements\n      const elementBuffers = buffers.splice(startLength);\n      tempBuffers.push(...elementBuffers);\n      \n      // Calculate total size of array content\n      const contentSize = tempBuffers.reduce((sum, buf) => sum + buf.length, 0);\n      \n      // Now write: TYPE + SIZE + CONTENT\n      buffers.push(new Uint8Array([TYPE.ARRAY]));\n      const sizeBuffer = new ArrayBuffer(4);\n      const sizeView = new DataView(sizeBuffer);\n      sizeView.setUint32(0, contentSize, true);\n      buffers.push(new Uint8Array(sizeBuffer));\n      buffers.push(...tempBuffers);\n    } else if (typeof val === 'object') {\n      // Encode object to temporary buffer to determine size\n      const tempBuffers = [];\n      \n      const keys = Object.keys(val);\n      // Store number of keys as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, keys.length, true);\n      tempBuffers.push(new Uint8Array(lengthBuffer));\n      \n      // Encode each key-value pair into temp buffer\n      const startLength = buffers.length;\n      for (const key of keys) {\n        // Encode key as string (without type byte)\n        const encoded = new TextEncoder().encode(key);\n        const keyLengthBuffer = new ArrayBuffer(4);\n        const keyLengthView = new DataView(keyLengthBuffer);\n        keyLengthView.setUint32(0, encoded.length, true);\n        buffers.push(new Uint8Array(keyLengthBuffer));\n        buffers.push(encoded);\n        // Encode value\n        encodeValue(val[key]);\n      }\n      // Collect encoded key-value pairs\n      const kvBuffers = buffers.splice(startLength);\n      tempBuffers.push(...kvBuffers);\n      \n      // Calculate total size of object content\n      const contentSize = tempBuffers.reduce((sum, buf) => sum + buf.length, 0);\n      \n      // Now write: TYPE + SIZE + CONTENT\n      buffers.push(new Uint8Array([TYPE.OBJECT]));\n      const sizeBuffer = new ArrayBuffer(4);\n      const sizeView = new DataView(sizeBuffer);\n      sizeView.setUint32(0, contentSize, true);\n      buffers.push(new Uint8Array(sizeBuffer));\n      buffers.push(...tempBuffers);\n    } else {\n      throw new Error(`Unsupported type: ${typeof val}`);\n    }\n  }\n\n  encodeValue(value);\n\n  // Combine all buffers\n  const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buf of buffers) {\n    result.set(buf, offset);\n    offset += buf.length;\n  }\n\n  return result;\n}\n\n/**\n * Decode binary data to JavaScript value\n */\nfunction decode(data) {\n  let offset = 0;\n\n  function decodeValue() {\n    if (offset >= data.length) {\n      throw new Error('Unexpected end of data');\n    }\n\n    const type = data[offset++];\n\n    switch (type) {\n      case TYPE.NULL:\n        return null;\n      \n      case TYPE.FALSE:\n        return false;\n      \n      case TYPE.TRUE:\n        return true;\n      \n      case TYPE.INT: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for INT');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const value = view.getBigInt64(0, true);\n        offset += 8;\n        if (value < BigInt(Number.MIN_SAFE_INTEGER) || value > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('Decoded integer exceeds safe range');\n        }\n        return Number(value);\n      }\n      \n      case TYPE.FLOAT: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for FLOAT');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const value = view.getFloat64(0, true);\n        offset += 8;\n        return value;\n      }\n      \n      case TYPE.STRING: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for STRING length');\n        }\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + length > data.length) {\n          throw new Error('Unexpected end of data for STRING content');\n        }\n        const stringData = data.slice(offset, offset + length);\n        offset += length;\n        return new TextDecoder().decode(stringData);\n      }\n      \n      case TYPE.OID: {\n        if (offset + 12 > data.length) {\n          throw new Error('Unexpected end of data for OID');\n        }\n        const oidBytes = data.slice(offset, offset + 12);\n        offset += 12;\n        return new ObjectId(oidBytes);\n      }\n      \n      case TYPE.DATE: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for DATE');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const timestamp = view.getBigInt64(0, true);\n        offset += 8;\n        return new Date(Number(timestamp));\n      }\n      \n      case TYPE.POINTER: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for POINTER');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const pointerOffset = view.getBigUint64(0, true);\n        offset += 8;\n        // Validate offset is within safe integer range\n        if (pointerOffset > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('Pointer offset out of valid range');\n        }\n        return new Pointer(Number(pointerOffset));\n      }\n      \n      case TYPE.ARRAY: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for ARRAY size');\n        }\n        // Read size in bytes\n        const sizeView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const size = sizeView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + size > data.length) {\n          throw new Error('Unexpected end of data for ARRAY content');\n        }\n        \n        // Read array length\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        const arr = [];\n        for (let i = 0; i < length; i++) {\n          arr.push(decodeValue());\n        }\n        return arr;\n      }\n      \n      case TYPE.OBJECT: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for OBJECT size');\n        }\n        // Read size in bytes\n        const sizeView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const size = sizeView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + size > data.length) {\n          throw new Error('Unexpected end of data for OBJECT content');\n        }\n        \n        // Read number of keys\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        const obj = {};\n        for (let i = 0; i < length; i++) {\n          // Decode key\n          if (offset + 4 > data.length) {\n            throw new Error('Unexpected end of data for OBJECT key length');\n          }\n          const keyLengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n          const keyLength = keyLengthView.getUint32(0, true);\n          offset += 4;\n          \n          if (offset + keyLength > data.length) {\n            throw new Error('Unexpected end of data for OBJECT key');\n          }\n          const keyData = data.slice(offset, offset + keyLength);\n          offset += keyLength;\n          const key = new TextDecoder().decode(keyData);\n          \n          // Decode value\n          obj[key] = decodeValue();\n        }\n        return obj;\n      }\n      \n      default:\n        throw new Error(`Unknown type byte: 0x${type.toString(16)}`);\n    }\n  }\n\n  return decodeValue();\n}\n\n/**\n * OPFS File Operations\n */\nclass BJsonFile {\n  constructor(filename) {\n    this.filename = filename;\n    this.root = null;\n    this.fileHandle = null;\n    this.file = null;\n    this.mode = null; // 'r' for read-only, 'rw' for read-write\n    this.isOpen = false;\n  }\n\n  /**\n   * Open the file with specified mode\n   * @param {string} mode - 'r' for read-only, 'rw' for read-write\n   */\n  async open(mode = 'r') {\n    if (this.isOpen) {\n      throw new Error(`File is already open in ${this.mode} mode`);\n    }\n\n    if (mode !== 'r' && mode !== 'rw') {\n      throw new Error(`Invalid mode: ${mode}. Use 'r' for read-only or 'rw' for read-write`);\n    }\n\n    if (!navigator.storage || !navigator.storage.getDirectory) {\n      throw new Error('Origin Private File System (OPFS) is not supported in this browser');\n    }\n\n    this.root = await navigator.storage.getDirectory();\n    this.mode = mode;\n\n    try {\n      // For read mode, file must exist\n      if (mode === 'r') {\n        this.fileHandle = await this.root.getFileHandle(this.filename);\n      } else {\n        // For read-write mode, create if doesn't exist\n        this.fileHandle = await this.root.getFileHandle(this.filename, { create: true });\n      }\n      this.file = await this.fileHandle.getFile();\n      this.isOpen = true;\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        throw new Error(`File not found: ${this.filename}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Close the file\n   */\n  async close() {\n    this.isOpen = false;\n    this.mode = null;\n    this.fileHandle = null;\n    this.file = null;\n  }\n\n  /**\n   * Ensure file is open, throw if not\n   */\n  ensureOpen() {\n    if (!this.isOpen) {\n      throw new Error(`File is not open. Call open('r') or open('rw') first`);\n    }\n  }\n\n  /**\n   * Ensure file is writable, throw if read-only\n   */\n  ensureWritable() {\n    this.ensureOpen();\n    if (this.mode === 'r') {\n      throw new Error(`File is opened in read-only mode. Cannot write or append`);\n    }\n  }\n\n  /**\n   * Refresh the file reference (needed after writes to get updated size)\n   */\n  async refreshFile() {\n    this.ensureOpen();\n    this.file = await this.fileHandle.getFile();\n  }\n\n  async #readRange(start, length) {\n    this.ensureOpen();\n    const slice = this.file.slice(start, start + length);\n    const arrayBuffer = await slice.arrayBuffer();\n    return new Uint8Array(arrayBuffer);\n  }\n\n  async getFileSize() {\n    this.ensureOpen();\n    return this.file.size;\n  }\n\n  async write(data) {\n    this.ensureWritable();\n    \n    // Encode data to binary\n    const binaryData = encode(data);\n    \n    // Create writable stream (truncates existing content)\n    const writable = await this.fileHandle.createWritable();\n    \n    // Write data\n    await writable.write(binaryData);\n    await writable.close();\n    \n    // Refresh file reference to get updated size\n    await this.refreshFile();\n  }\n\n  async read(pointer = new Pointer(0)) {\n    this.ensureOpen();\n    \n    const fileSize = await this.getFileSize();\n    \n    if (fileSize === 0) {\n      throw new Error(`File is empty: ${this.filename}`);\n    }\n\n    const pointerValue = pointer.valueOf();\n    \n    // Validate pointer offset\n    if (pointerValue < 0 || pointerValue >= fileSize) {\n      throw new Error(`Pointer offset ${pointer} out of file bounds [0, ${fileSize})`);\n    }\n    \n    // Read from pointer offset to end of file\n    const binaryData = await this.#readRange(pointerValue, fileSize - pointerValue);\n    \n    // Decode and return the first value\n    return decode(binaryData);\n  }\n\n  async append(data) {\n    this.ensureWritable();\n    \n    // Encode new data to binary\n    const binaryData = encode(data);\n    \n    // Get current file size\n    const existingSize = this.file.size;\n    \n    // Create writable stream with keepExistingData\n    const writable = await this.fileHandle.createWritable({ keepExistingData: true });\n    \n    // Seek to end\n    await writable.seek(existingSize);\n    \n    // Write new data\n    await writable.write(binaryData);\n    await writable.close();\n    \n    // Refresh file reference to get updated size\n    await this.refreshFile();\n  }\n\n  async *scan() {\n    this.ensureOpen();\n    \n    const fileSize = await this.getFileSize();\n      \n      if (fileSize === 0) {\n        return;\n      }\n      \n      let offset = 0;\n      \n      // Scan through and yield each top-level value\n      while (offset < fileSize) {\n        // Helper function to determine how many bytes a value occupies\n        const getValueSize = async (readPosition) => {\n          // Read 1 byte for type\n          let tempData = await this.#readRange(readPosition, 1);\n          let pos = 1;\n          const type = tempData[0];\n          \n          switch (type) {\n            case TYPE.NULL:\n            case TYPE.FALSE:\n            case TYPE.TRUE:\n              return 1;\n            \n            case TYPE.INT:\n            case TYPE.FLOAT:\n            case TYPE.DATE:\n            case TYPE.POINTER:\n              return 1 + 8;\n\n            case TYPE.OID:\n              return 1 + 12;\n            \n            case TYPE.STRING: {\n              // Read length (4 bytes)\n              tempData = await this.#readRange(readPosition + 1, 4);\n              const view = new DataView(tempData.buffer, tempData.byteOffset, 4);\n              const length = view.getUint32(0, true);\n              return 1 + 4 + length;\n            }\n            \n            case TYPE.ARRAY: {\n              // Read size in bytes (4 bytes)\n              tempData = await this.#readRange(readPosition + 1, 4);\n              const view = new DataView(tempData.buffer, tempData.byteOffset, 4);\n              const size = view.getUint32(0, true);\n              return 1 + 4 + size; // type + size + content\n            }\n            \n            case TYPE.OBJECT: {\n              // Read size in bytes (4 bytes)\n              tempData = await this.#readRange(readPosition + 1, 4);\n              const view = new DataView(tempData.buffer, tempData.byteOffset, 4);\n              const size = view.getUint32(0, true);\n              return 1 + 4 + size; // type + size + content\n            }\n            \n            default:\n              throw new Error(`Unknown type byte: 0x${type.toString(16)}`);\n          }\n        };\n        \n        // Determine size of the current value\n        const valueSize = await getValueSize(offset);\n        \n        // Read only the bytes needed for this value\n        const valueData = await this.#readRange(offset, valueSize);\n        offset += valueSize;\n        \n        // Decode and yield this value\n        yield decode(valueData);\n      }\n  }\n\n  async delete() {\n    this.ensureWritable();\n    \n    try {\n      await this.root.removeEntry(this.filename);\n      // File is deleted, mark as closed\n      await this.close();\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        // File doesn't exist, nothing to delete\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async exists() {\n    if (!navigator.storage || !navigator.storage.getDirectory) {\n      throw new Error('Origin Private File System (OPFS) is not supported in this browser');\n    }\n    \n    const root = await navigator.storage.getDirectory();\n    try {\n      await root.getFileHandle(this.filename);\n      return true;\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        return false;\n      }\n      throw error;\n    }\n  }\n}\n\nexport {\n  TYPE,\n  ObjectId,\n  Pointer,\n  encode,\n  decode,\n  BJsonFile\n};\n","/**\n * Utility functions for MicroMongoDB\n */\n\nimport { ObjectId } from 'bjson';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Deep copy an object or array\n */\nexport function copy(o) {\n\t// Handle ObjectId\n\tif (o instanceof ObjectId) {\n\t\treturn new ObjectId(o.id);\n\t}\n\t\n\tvar out, v, key;\n\tout = Array.isArray(o) ? [] : {};\n\tfor (key in o) {\n\t\tv = o[key];\n\t\tout[key] = (typeof v === \"object\" && v !== null) ? copy(v) : v;\n\t}\n\treturn out;\n}\n\n/**\n * Get a property from an object using dot notation\n * Supports array element access via numeric indices (e.g., \"items.0.name\")\n */\nexport function getProp(obj, name) {\n\tvar path = name.split(\".\");\n\tvar result = obj[path[0]];\n\tfor (var i = 1; i < path.length; i++) {\n\t\tif (result == undefined || result == null) return result;\n\t\t\n\t\t// Check if this path segment is a numeric index\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\t// If it's a valid array index, use it\n\t\tif (isArray(result) && !isNaN(numericIndex) && numericIndex >= 0 && numericIndex < result.length) {\n\t\t\tresult = result[numericIndex];\n\t\t} else {\n\t\t\tresult = result[pathSegment];\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Get field values for query matching, handling MongoDB-style array traversal\n * When a path traverses an array, this returns all matching values from array elements\n * Returns an array of values if array traversal occurred, otherwise the single value\n * \n * Example:\n *   doc = { items: [{ price: 10 }, { price: 20 }] }\n *   getFieldValues(doc, 'items.price') -> [10, 20]\n */\nexport function getFieldValues(obj, name) {\n\tvar path = name.split(\".\");\n\tvar results = [obj];\n\t\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\tvar newResults = [];\n\t\t\n\t\tfor (var j = 0; j < results.length; j++) {\n\t\t\tvar current = results[j];\n\t\t\tif (current == undefined || current == null) continue;\n\t\t\t\n\t\t\t// If this is a numeric index and current is an array, access that element\n\t\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\t\tif (numericIndex < current.length) {\n\t\t\t\t\tnewResults.push(current[numericIndex]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If current is an array but path segment is not numeric, traverse all elements\n\t\t\telse if (isArray(current)) {\n\t\t\t\tfor (var k = 0; k < current.length; k++) {\n\t\t\t\t\tif (current[k] != undefined && current[k] != null && typeof current[k] === 'object') {\n\t\t\t\t\t\tnewResults.push(current[k][pathSegment]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, normal property access\n\t\t\telse if (typeof current === 'object') {\n\t\t\t\tnewResults.push(current[pathSegment]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresults = newResults;\n\t}\n\t\n\t// Filter out undefined values\n\tresults = results.filter(function(v) { return v !== undefined; });\n\t\n\t// If we have multiple values, return the array\n\t// If we have exactly one, return it directly\n\t// If we have none, return undefined\n\tif (results.length === 0) return undefined;\n\tif (results.length === 1) return results[0];\n\treturn results;\n}\n\n/**\n * Set a property on an object using dot notation\n * Creates intermediate objects as needed\n * Supports array element access via numeric indices\n * Supports $[] operator to update all array elements\n */\nexport function setProp(obj, name, value) {\n\t// Check if path contains $[] operator\n\tif (name.indexOf('$[]') !== -1) {\n\t\treturn setPropWithAllPositional(obj, name, value);\n\t}\n\t\n\tvar path = name.split(\".\");\n\tvar current = obj;\n\t\n\tfor (var i = 0; i < path.length - 1; i++) {\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\t// If this is a numeric index and current is an array\n\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\t// Ensure the array is large enough\n\t\t\twhile (current.length <= numericIndex) {\n\t\t\t\tcurrent.push(undefined);\n\t\t\t}\n\t\t\t// If the element doesn't exist, create an object\n\t\t\tif (current[numericIndex] == undefined || current[numericIndex] == null) {\n\t\t\t\t// Look ahead to see if next segment is numeric (array) or not (object)\n\t\t\t\tvar nextSegment = path[i + 1];\n\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\tcurrent[numericIndex] = [];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[numericIndex] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[numericIndex];\n\t\t}\n\t\t// Regular property access\n\t\telse {\n\t\t\tif (current[pathSegment] == undefined || current[pathSegment] == null) {\n\t\t\t\t// Look ahead to see if next segment is numeric (array) or not (object)\n\t\t\t\tvar nextSegment = path[i + 1];\n\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[pathSegment] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[pathSegment];\n\t\t}\n\t}\n\t\n\t// Set the final value\n\tvar lastSegment = path[path.length - 1];\n\tvar lastNumericIndex = parseInt(lastSegment, 10);\n\t\n\tif (isArray(current) && !isNaN(lastNumericIndex) && lastNumericIndex >= 0) {\n\t\twhile (current.length <= lastNumericIndex) {\n\t\t\tcurrent.push(undefined);\n\t\t}\n\t\tcurrent[lastNumericIndex] = value;\n\t} else {\n\t\tcurrent[lastSegment] = value;\n\t}\n}\n\n/**\n * Set a property using the $[] all positional operator\n * Updates all elements in an array\n */\nfunction setPropWithAllPositional(obj, name, value) {\n\tvar path = name.split(\".\");\n\tvar current = obj;\n\t\n\t// Navigate to the $[] operator\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\t\n\t\tif (pathSegment === '$[]') {\n\t\t\t// Current should be an array - update all elements\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\tthrow new Error(\"The positional operator did not find the match needed from the query.\");\n\t\t\t}\n\t\t\t\n\t\t\t// Build the remaining path after $[]\n\t\t\tvar remainingPath = path.slice(i + 1).join('.');\n\t\t\t\n\t\t\t// Update all array elements\n\t\t\tfor (var j = 0; j < current.length; j++) {\n\t\t\t\tif (remainingPath) {\n\t\t\t\t\t// There's more path after $[], recursively set on each element\n\t\t\t\t\tsetProp(current[j], remainingPath, value);\n\t\t\t\t} else {\n\t\t\t\t\t// $[] is the last segment, replace each element with value\n\t\t\t\t\tcurrent[j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Navigate to the next level\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\tcurrent = current[numericIndex];\n\t\t} else {\n\t\t\tif (current[pathSegment] == undefined || current[pathSegment] == null) {\n\t\t\t\t// Create intermediate object or array\n\t\t\t\tvar nextSegment = i + 1 < path.length ? path[i + 1] : null;\n\t\t\t\tif (nextSegment === '$[]') {\n\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t} else {\n\t\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathSegment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[pathSegment];\n\t\t}\n\t}\n}\n\n/**\n * Check if value is an array\n */\nexport function isArray(o) {\n\treturn Array == o.constructor;\n}\n\n/**\n * Convert object to array of key-value pairs\n */\nexport function toArray(obj) {\n\tvar arr = [];\n\tfor (var key in obj) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar el = {};\n\t\t\tel[key] = obj[key];\n\t\t\tarr.push(el);\n\t\t}\n\t}\n\treturn arr;\n}\n\n/**\n * Check if a value is in an array\n */\nexport function isIn(val, values) {\n\tfor (var i = 0; i < values.length; i++) {\n\t\tif (valuesEqual(values[i], val)) return true;\n\t}\n\treturn false;\n}\n\n/**\n * Check if two arrays match\n */\nexport function arrayMatches(x, y) {\n\tif (x.length != y.length) return false;\n\tfor (var i = 0; i < x.length; i++) {\n\t\tif (valuesEqual(x[i], y[i])) continue;\n\t\tif (typeof (x[i]) != typeof (y[i])) return false;\n\t\tif (typeof (x[i]) == \"object\" && x[i] !== null) {\n\t\t\tif (isArray(x[i])) {\n\t\t\t\tif (!arrayMatches(x[i], y[i])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[i], y[i])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[i], y[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Check if two objects match\n */\nexport function objectMatches(x, y) {\n\tfor (var p in x) {\n\t\tif (!x.hasOwnProperty(p)) continue;\n\t\tif (!y.hasOwnProperty(p)) return false;\n\t\tif (valuesEqual(x[p], y[p])) continue;\n\t\tif (typeof (x[p]) != typeof (y[p])) return false;\n\t\tif (typeof (x[p]) == \"object\" && x[p] !== null) {\n\t\t\tif (isArray(x[p])) {\n\t\t\t\tif (!arrayMatches(x[p], y[p])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[p], y[p])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[p], y[p])) return false;\n\t\t}\n\t}\n\tfor (var p in y) {\n\t\tif (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Apply projection to a document\n */\nexport function applyProjection(projection, doc) {\n\tvar result = {};\n\tvar keys = Object.keys(projection);\n\tif (keys.length == 0) return doc;\n\t\n\t// Check for mixed inclusion/exclusion (except _id which can be excluded in inclusion projection)\n\tvar hasInclusion = false;\n\tvar hasExclusion = false;\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (keys[i] === '_id') continue; // _id is special\n\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\telse hasExclusion = true;\n\t}\n\t\n\tif (hasInclusion && hasExclusion) {\n\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t}\n\t\n\tif (projection[keys[0]] || hasInclusion) {\n\t\t// Inclusion projection\n\t\t// Include _id unless explicitly excluded\n\t\tif (projection._id !== 0) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i] === '_id') continue;\n\t\t\tif (!projection[keys[i]]) continue;\n\t\t\t\n\t\t\tvar fieldPath = keys[i];\n\t\t\tvar value = getProp(doc, fieldPath);\n\t\t\t\n\t\t\tif (value !== undefined) {\n\t\t\t\t// Use setProp to create nested structure\n\t\t\t\tsetProp(result, fieldPath, value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Exclusion projection - start with a copy of the document\n\t\tfor (var key in doc) {\n\t\t\tif (doc.hasOwnProperty(key)) {\n\t\t\t\t// Deep copy the value\n\t\t\t\tvar val = doc[key];\n\t\t\t\tif (typeof val === 'object' && val !== null && !isArray(val)) {\n\t\t\t\t\tresult[key] = copy(val);\n\t\t\t\t} else if (isArray(val)) {\n\t\t\t\t\tresult[key] = val.slice(); // shallow copy array\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Remove excluded fields\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (projection[keys[i]]) continue; // Skip if value is truthy\n\t\t\t\n\t\t\tvar fieldPath = keys[i];\n\t\t\tvar pathParts = fieldPath.split('.');\n\t\t\t\n\t\t\t// Navigate to the parent object and delete the final property\n\t\t\tif (pathParts.length === 1) {\n\t\t\t\tdelete result[fieldPath];\n\t\t\t} else {\n\t\t\t\tvar parent = result;\n\t\t\t\tfor (var j = 0; j < pathParts.length - 1; j++) {\n\t\t\t\t\tif (parent == undefined || parent == null) break;\n\t\t\t\t\tparent = parent[pathParts[j]];\n\t\t\t\t}\n\t\t\t\tif (parent != undefined && parent != null) {\n\t\t\t\t\tdelete parent[pathParts[pathParts.length - 1]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Convert bbox to GeoJSON\n */\nexport function bboxToGeojson(bbox) {\n\tconst minLon = bbox[0][0];\n\tconst maxLat = bbox[0][1];\n\tconst maxLon = bbox[1][0];\n\tconst minLat = bbox[1][1];\n\treturn {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: [{\n\t\t\ttype: 'Feature',\n\t\t\tproperties: {},\n\t\t\tgeometry: {\n\t\t\t\ttype: 'Polygon',\n\t\t\t\tcoordinates: [[\n\t\t\t\t\t[minLon, maxLat],\n\t\t\t\t\t[minLon, minLat],\n\t\t\t\t\t[maxLon, minLat],\n\t\t\t\t\t[maxLon, maxLat],\n\t\t\t\t\t[minLon, maxLat]\n\t\t\t\t]]\n\t\t\t}\n\t\t}]\n\t};\n}\n","/**\n * MongoDB Error Classes\n * \n * Structured error hierarchy compatible with MongoDB driver\n */\n\n/**\n * Error codes matching MongoDB error codes\n */\nexport const ErrorCodes = {\n\t// General errors\n\tOK: 0,\n\tINTERNAL_ERROR: 1,\n\tBAD_VALUE: 2,\n\tNO_SUCH_KEY: 4,\n\tGRAPH_CONTAINS_CYCLE: 5,\n\tHOST_UNREACHABLE: 6,\n\tHOST_NOT_FOUND: 7,\n\tUNKNOWN_ERROR: 8,\n\tFAILED_TO_PARSE: 17287, // Using test-compatible error code\n\tCANNOT_MUTATE_OBJECT: 10,\n\tUSER_NOT_FOUND: 11,\n\tUNSUPPORTED_FORMAT: 12,\n\tUNAUTHORIZED: 13,\n\tTYPE_MISMATCH: 14,\n\tOVERFLOW: 15,\n\tINVALID_LENGTH: 16,\n\tPROTOCOL_ERROR: 17,\n\tAUTHENTICATION_FAILED: 18,\n\tILLEGAL_OPERATION: 20,\n\tNAMESPACE_NOT_FOUND: 26,\n\tINDEX_NOT_FOUND: 27,\n\tPATH_NOT_VIABLE: 28,\n\tCANNOT_CREATE_INDEX: 67,\n\tINDEX_ALREADY_EXISTS: 68,\n\tINDEX_EXISTS: 68,\n\tCOMMAND_NOT_FOUND: 59,\n\tNAMESPACE_EXISTS: 48,\n\tINVALID_NAMESPACE: 73,\n\tINDEX_OPTIONS_CONFLICT: 85,\n\tINVALID_INDEX_SPECIFICATION_OPTION: 197,\n\t\n\t// Write errors\n\tWRITE_CONFLICT: 112,\n\tDUPLICATE_KEY: 11000,\n\tDUPLICATE_KEY_UPDATE: 11001,\n\t\n\t// Validation errors\n\tDOCUMENT_VALIDATION_FAILURE: 121,\n\t\n\t// Query errors\n\tBAD_QUERY: 2,\n\tCANNOT_INDEX_PARALLEL_ARRAYS: 171,\n\t\n\t// Cursor errors\n\tCURSOR_NOT_FOUND: 43,\n\t\n\t// Collection errors\n\tCOLLECTION_IS_EMPTY: 26,\n\t\n\t// Not implemented (custom code)\n\tNOT_IMPLEMENTED: 999,\n\tOPERATION_NOT_SUPPORTED: 998\n};\n\n/**\n * Base class for all MongoDB errors\n */\nexport class MongoError extends Error {\n\tconstructor(message, options = {}) {\n\t\tsuper(message);\n\t\tthis.name = 'MongoError';\n\t\tthis.code = options.code || ErrorCodes.UNKNOWN_ERROR;\n\t\tthis.codeName = this._getCodeName(this.code);\n\t\t\n\t\t// Backward compatibility: add $err property matching old error format\n\t\tthis.$err = message;\n\t\t\n\t\t// Additional context\n\t\tif (options.collection) this.collection = options.collection;\n\t\tif (options.database) this.database = options.database;\n\t\tif (options.operation) this.operation = options.operation;\n\t\tif (options.query) this.query = options.query;\n\t\tif (options.document) this.document = options.document;\n\t\tif (options.field) this.field = options.field;\n\t\tif (options.index) this.index = options.index;\n\t\t\n\t\t// Capture stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t}\n\t\n\t_getCodeName(code) {\n\t\tconst codeToName = {\n\t\t\t0: 'OK',\n\t\t\t1: 'InternalError',\n\t\t\t2: 'BadValue',\n\t\t\t4: 'NoSuchKey',\n\t\t\t5: 'GraphContainsCycle',\n\t\t\t6: 'HostUnreachable',\n\t\t\t7: 'HostNotFound',\n\t\t\t8: 'UnknownError',\n\t\t\t10: 'CannotMutateObject',\n\t\t\t11: 'UserNotFound',\n\t\t\t12: 'UnsupportedFormat',\n\t\t\t13: 'Unauthorized',\n\t\t\t14: 'TypeMismatch',\n\t\t\t15: 'Overflow',\n\t\t\t16: 'InvalidLength',\n\t\t\t17: 'ProtocolError',\n\t\t\t18: 'AuthenticationFailed',\n\t\t\t20: 'IllegalOperation',\n\t\t\t26: 'NamespaceNotFound',\n\t\t\t27: 'IndexNotFound',\n\t\t\t28: 'PathNotViable',\n\t\t\t43: 'CursorNotFound',\n\t\t\t48: 'NamespaceExists',\n\t\t\t59: 'CommandNotFound',\n\t\t\t67: 'CannotCreateIndex',\n\t\t\t68: 'IndexExists',\n\t\t\t73: 'InvalidNamespace',\n\t\t\t85: 'IndexOptionsConflict',\n\t\t\t112: 'WriteConflict',\n\t\t\t121: 'DocumentValidationFailure',\n\t\t\t171: 'CannotIndexParallelArrays',\n\t\t\t197: 'InvalidIndexSpecificationOption',\n\t\t\t998: 'OperationNotSupported',\n\t\t\t999: 'NotImplemented',\n\t\t\t11000: 'DuplicateKey',\n\t\t\t11001: 'DuplicateKeyUpdate',\n\t\t\t17287: 'FailedToParse'\n\t\t};\n\t\treturn codeToName[code] || 'UnknownError';\n\t}\n\t\n\ttoJSON() {\n\t\tconst json = {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tcode: this.code,\n\t\t\tcodeName: this.codeName\n\t\t};\n\t\t\n\t\t// Include all enumerable properties\n\t\tif (this.collection) json.collection = this.collection;\n\t\tif (this.database) json.database = this.database;\n\t\tif (this.operation) json.operation = this.operation;\n\t\tif (this.index) json.index = this.index;\n\t\tif (this.indexName) json.indexName = this.indexName;\n\t\tif (this.field) json.field = this.field;\n\t\tif (this.query) json.query = this.query;\n\t\tif (this.document) json.document = this.document;\n\t\tif (this.namespace) json.namespace = this.namespace;\n\t\tif (this.cursorId) json.cursorId = this.cursorId;\n\t\tif (this.feature) json.feature = this.feature;\n\t\tif (this.keyPattern) json.keyPattern = this.keyPattern;\n\t\tif (this.keyValue) json.keyValue = this.keyValue;\n\t\tif (this.writeErrors) json.writeErrors = this.writeErrors;\n\t\t\n\t\treturn json;\n\t}\n}\n\n/**\n * Server-side errors\n */\nexport class MongoServerError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoServerError';\n\t}\n}\n\n/**\n * Driver-side errors (client errors)\n */\nexport class MongoDriverError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoDriverError';\n\t\tthis.code = options.code || ErrorCodes.INTERNAL_ERROR;\n\t}\n}\n\n/**\n * Write operation errors\n */\nexport class WriteError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'WriteError';\n\t\tthis.code = options.code || ErrorCodes.WRITE_CONFLICT;\n\t}\n}\n\n/**\n * Duplicate key error\n */\nexport class DuplicateKeyError extends WriteError {\n\tconstructor(key, options = {}) {\n\t\tconst keyStr = JSON.stringify(key);\n\t\tconst message = `E11000 duplicate key error${options.collection ? ` collection: ${options.collection}` : ''} index: ${keyStr} dup key: ${keyStr}`;\n\t\tsuper(message, { ...options, code: ErrorCodes.DUPLICATE_KEY });\n\t\tthis.name = 'DuplicateKeyError';\n\t\tthis.keyPattern = key;\n\t\tthis.keyValue = options.keyValue || key;\n\t}\n}\n\n/**\n * Document validation errors\n */\nexport class ValidationError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'ValidationError';\n\t\tthis.code = options.code || ErrorCodes.DOCUMENT_VALIDATION_FAILURE;\n\t\tthis.validationErrors = options.validationErrors || [];\n\t}\n}\n\n/**\n * Index-related errors\n */\nexport class IndexError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'IndexError';\n\t}\n}\n\n/**\n * Index already exists error\n */\nexport class IndexExistsError extends IndexError {\n\tconstructor(indexName, options = {}) {\n\t\tsuper(`Index with name '${indexName}' already exists`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INDEX_EXISTS\n\t\t});\n\t\tthis.name = 'IndexExistsError';\n\t\tthis.indexName = indexName;\n\t}\n}\n\n/**\n * Index not found error\n */\nexport class IndexNotFoundError extends IndexError {\n\tconstructor(indexName, options = {}) {\n\t\tsuper(`Index '${indexName}' not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INDEX_NOT_FOUND,\n\t\t\tindex: indexName\n\t\t});\n\t\tthis.name = 'IndexNotFoundError';\n\t\tthis.indexName = indexName;\n\t}\n}\n\n/**\n * Cannot create index error\n */\nexport class CannotCreateIndexError extends IndexError {\n\tconstructor(reason, options = {}) {\n\t\tsuper(`Cannot create index: ${reason}`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.CANNOT_CREATE_INDEX\n\t\t});\n\t\tthis.name = 'CannotCreateIndexError';\n\t}\n}\n\n/**\n * Query errors\n */\nexport class QueryError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'QueryError';\n\t\tthis.code = options.code || ErrorCodes.BAD_QUERY;\n\t}\n}\n\n/**\n * Type mismatch error\n */\nexport class TypeMismatchError extends MongoError {\n\tconstructor(field, expectedType, actualType, options = {}) {\n\t\tsuper(\n\t\t\t`Type mismatch for field '${field}': expected ${expectedType}, got ${actualType}`,\n\t\t\t{ ...options, code: ErrorCodes.TYPE_MISMATCH, field }\n\t\t);\n\t\tthis.name = 'TypeMismatchError';\n\t\tthis.expectedType = expectedType;\n\t\tthis.actualType = actualType;\n\t}\n}\n\n/**\n * Namespace errors\n */\nexport class NamespaceError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'NamespaceError';\n\t}\n}\n\n/**\n * Namespace not found\n */\nexport class NamespaceNotFoundError extends NamespaceError {\n\tconstructor(namespace, options = {}) {\n\t\tsuper(`Namespace '${namespace}' not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t\tthis.name = 'NamespaceNotFoundError';\n\t\tthis.namespace = namespace;\n\t}\n}\n\n/**\n * Invalid namespace\n */\nexport class InvalidNamespaceError extends NamespaceError {\n\tconstructor(namespace, reason, options = {}) {\n\t\t// Handle case where reason is actually options\n\t\tif (typeof reason === 'object' && !options) {\n\t\t\toptions = reason;\n\t\t\treason = undefined;\n\t\t}\n\t\tconst msg = reason ? `Invalid namespace '${namespace}': ${reason}` : `Invalid namespace '${namespace}'`;\n\t\tsuper(msg, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INVALID_NAMESPACE\n\t\t});\n\t\tthis.name = 'InvalidNamespaceError';\n\t\tthis.namespace = namespace;\n\t}\n}\n\n/**\n * Cursor errors\n */\nexport class CursorError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'CursorError';\n\t}\n}\n\n/**\n * Cursor not found\n */\nexport class CursorNotFoundError extends CursorError {\n\tconstructor(cursorId, options = {}) {\n\t\tsuper(`Cursor ${cursorId} not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.CURSOR_NOT_FOUND\n\t\t});\n\t\tthis.name = 'CursorNotFoundError';\n\t\tthis.cursorId = cursorId;\n\t}\n}\n\n/**\n * Not implemented error\n */\nexport class NotImplementedError extends MongoError {\n\tconstructor(feature, options = {}) {\n\t\tsuper(`${feature} is not implemented in micro-mongo`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.NOT_IMPLEMENTED\n\t\t});\n\t\tthis.name = 'NotImplementedError';\n\t\tthis.feature = feature;\n\t}\n}\n\n/**\n * Operation not supported\n */\nexport class OperationNotSupportedError extends MongoError {\n\tconstructor(operation, reason, options = {}) {\n\t\t// Handle case where reason is actually options\n\t\tif (typeof reason === 'object' && !options) {\n\t\t\toptions = reason;\n\t\t\treason = undefined;\n\t\t}\n\t\tconst msg = reason ? `Operation '${operation}' is not supported: ${reason}` : `Operation '${operation}' is not supported`;\n\t\tsuper(msg, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.OPERATION_NOT_SUPPORTED,\n\t\t\toperation\n\t\t});\n\t\tthis.name = 'OperationNotSupportedError';\n\t}\n}\n\n/**\n * Bad value error\n */\nexport class BadValueError extends MongoError {\n\tconstructor(field, value, reason, options = {}) {\n\t\tsuper(`Bad value for field '${field}': ${reason}`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.BAD_VALUE,\n\t\t\tfield\n\t\t});\n\t\tthis.name = 'BadValueError';\n\t\tthis.value = value;\n\t}\n}\n\n/**\n * Bulk write error\n */\nexport class BulkWriteError extends MongoError {\n\tconstructor(writeErrors = [], options = {}) {\n\t\tconst message = `Bulk write operation error: ${writeErrors.length} error(s)`;\n\t\tsuper(message, options);\n\t\tthis.name = 'BulkWriteError';\n\t\tthis.writeErrors = writeErrors;\n\t\tthis.code = options.code || ErrorCodes.WRITE_CONFLICT;\n\t}\n}\n\n/**\n * Network error (for API compatibility, not functional in micro-mongo)\n */\nexport class MongoNetworkError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoNetworkError';\n\t\tthis.code = options.code || ErrorCodes.HOST_UNREACHABLE;\n\t}\n}\n\n/**\n * Helper function to create appropriate error\n */\nexport function createError(type, ...args) {\n\tswitch (type) {\n\t\tcase 'duplicate_key':\n\t\t\treturn new DuplicateKeyError(...args);\n\t\tcase 'validation':\n\t\t\treturn new ValidationError(...args);\n\t\tcase 'index_exists':\n\t\t\treturn new IndexExistsError(...args);\n\t\tcase 'index_not_found':\n\t\t\treturn new IndexNotFoundError(...args);\n\t\tcase 'cannot_create_index':\n\t\t\treturn new CannotCreateIndexError(...args);\n\t\tcase 'query':\n\t\t\treturn new QueryError(...args);\n\t\tcase 'type_mismatch':\n\t\t\treturn new TypeMismatchError(...args);\n\t\tcase 'namespace_not_found':\n\t\t\treturn new NamespaceNotFoundError(...args);\n\t\tcase 'invalid_namespace':\n\t\t\treturn new InvalidNamespaceError(...args);\n\t\tcase 'cursor_not_found':\n\t\t\treturn new CursorNotFoundError(...args);\n\t\tcase 'not_implemented':\n\t\t\treturn new NotImplementedError(...args);\n\t\tcase 'operation_not_supported':\n\t\t\treturn new OperationNotSupportedError(...args);\n\t\tcase 'bad_value':\n\t\t\treturn new BadValueError(...args);\n\t\tcase 'write':\n\t\t\treturn new WriteError(...args);\n\t\tdefault:\n\t\t\treturn new MongoError(...args);\n\t}\n}\n","import { applyProjection } from './utils.js';\nimport { NotImplementedError, QueryError, ErrorCodes } from './errors.js';\n\n/**\n * Cursor class for iterating over query results\n * Now a simple iterator over pre-filtered documents\n */\nexport class Cursor {\n\tconstructor(collection, query, projection, documents, SortedCursor) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.projection = projection;\n\t\tthis.documents = documents; // Pre-filtered array of documents\n\t\tthis.SortedCursor = SortedCursor;\n\n\t\t// Validate projection if provided\n\t\tif (projection && Object.keys(projection).length > 0) {\n\t\t\tconst keys = Object.keys(projection);\n\t\t\tlet hasInclusion = false;\n\t\t\tlet hasExclusion = false;\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tif (keys[i] === '_id') continue; // _id is special\n\t\t\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\t\t\telse hasExclusion = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (hasInclusion && hasExclusion) {\n\t\t\t\tthrow new QueryError(\"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", { \n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE,\n\t\t\t\t\tcollection: collection.name \n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.pos = 0;\n\t\tthis._limit = 0;\n\t\tthis._skip = 0;\n\t\tthis._closed = false;\n\t}\n\n\tbatchSize(size) { \n\t\t// No-op for in-memory database, but return this for chaining\n\t\tthis._batchSize = size;\n\t\treturn this;\n\t}\n\tclose() {\n\t\tthis._closed = true;\n\t\tthis.pos = this.documents.length; // Move to end\n\t\treturn undefined;\n\t}\n\tcomment(commentString) {\n\t\tthis._comment = commentString;\n\t\treturn this;\n\t}\n\t\n\tcount() {\n\t\t// Return total count without considering skip/limit applied to this cursor\n\t\treturn this.documents.length;\n\t}\n\t\n\texplain(verbosity = 'queryPlanner') {\n\t\t// Return basic query execution info\n\t\treturn {\n\t\t\tqueryPlanner: {\n\t\t\t\tplannerVersion: 1,\n\t\t\t\tnamespace: `${this.collection.db?.name || 'db'}.${this.collection.name}`,\n\t\t\t\tindexFilterSet: false,\n\t\t\t\tparsedQuery: this.query,\n\t\t\t\twinningPlan: {\n\t\t\t\t\tstage: 'COLLSCAN',\n\t\t\t\t\tfilter: this.query,\n\t\t\t\t\tdirection: 'forward'\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutionStats: verbosity === 'executionStats' || verbosity === 'allPlansExecution' ? {\n\t\t\t\texecutionSuccess: true,\n\t\t\t\tnReturned: this.documents.length,\n\t\t\t\texecutionTimeMillis: 0,\n\t\t\t\ttotalKeysExamined: 0,\n\t\t\t\ttotalDocsExamined: this.documents.length\n\t\t\t} : undefined,\n\t\t\tok: 1\n\t\t};\n\t}\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\tif (this._closed) return false;\n\t\t// Calculate effective max position: skip + limit or total docs\n\t\tlet effectiveMax;\n\t\tif (this._limit > 0) {\n\t\t\teffectiveMax = Math.min(this._skip + this._limit, this.documents.length);\n\t\t} else {\n\t\t\teffectiveMax = this.documents.length;\n\t\t}\n\t\treturn this.pos < effectiveMax;\n\t}\n\t\n\thint(index) {\n\t\t// Store hint for query planner (informational in micro-mongo)\n\t\tthis._hint = index;\n\t\treturn this;\n\t}\n\titcount() {\n\t\tlet count = 0;\n\t\twhile (this.hasNext()) {\n\t\t\tthis.next();\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tlimit(_max) {\n\t\tthis._limit = _max;\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan(maxScan) {\n\t\t// Set maximum number of documents to scan (deprecated in MongoDB 4.0)\n\t\tthis._maxScan = maxScan;\n\t\treturn this;\n\t}\n\tmaxTimeMS(ms) {\n\t\t// Set maximum execution time (informational in micro-mongo)\n\t\tthis._maxTimeMS = ms;\n\t\treturn this;\n\t}\n\tmax(indexBounds) {\n\t\t// Set maximum index bound (informational in micro-mongo)\n\t\tthis._maxIndexBounds = indexBounds;\n\t\treturn this;\n\t}\n\tmin(indexBounds) {\n\t\t// Set minimum index bound (informational in micro-mongo)\n\t\tthis._minIndexBounds = indexBounds;\n\t\treturn this;\n\t}\n\t\n\tnext() {\n\t\tif (!this.hasNext()) {\n\t\t\tthrow new QueryError(\"Error: error hasNext: false\", { \n\t\t\t\tcollection: this.collection.name \n\t\t\t});\n\t\t}\n\t\tconst result = this.documents[this.pos++];\n\t\tif (this.projection) {\n\t\t\treturn applyProjection(this.projection, result);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tnoCursorTimeout() {\n\t\t// Prevent cursor timeout (no-op for in-memory)\n\t\tthis._noCursorTimeout = true;\n\t\treturn this;\n\t}\n\tobjsLeftInBatch() {\n\t\t// Return number of objects left in current batch\n\t\t// For in-memory, this is same as remaining documents\n\t\treturn this.size();\n\t}\n\tpretty() {\n\t\t// Enable pretty printing (no-op but return this for chaining)\n\t\tthis._pretty = true;\n\t\treturn this;\n\t}\n\treadConcern(level) {\n\t\t// Set read concern (no-op for in-memory database)\n\t\tthis._readConcern = level;\n\t\treturn this;\n\t}\n\treadPref(mode, tagSet) {\n\t\t// Set read preference (no-op for in-memory database)\n\t\tthis._readPref = { mode, tagSet };\n\t\treturn this;\n\t}\n\treturnKey(enabled = true) {\n\t\t// Return only the index key (informational in micro-mongo)\n\t\tthis._returnKey = enabled;\n\t\treturn this;\n\t}\n\tshowRecordId(enabled = true) {\n\t\t// Show record ID in results\n\t\tthis._showRecordId = enabled;\n\t\treturn this;\n\t}\n\tsize() {\n\t\t// Return count considering skip and limit\n\t\tconst remaining = this.documents.length - this.pos;\n\t\tif (this._limit > 0) {\n\t\t\t// Calculate how many docs left based on skip+limit boundary\n\t\t\tconst maxPos = this._skip + this._limit;\n\t\t\treturn Math.min(maxPos - this.pos, remaining);\n\t\t}\n\t\treturn remaining;\n\t}\n\t\n\tskip(num) {\n\t\tthis._skip = num;\n\t\t// Move initial position to skip point\n\t\tif (this.pos === 0) {\n\t\t\tthis.pos = Math.min(num, this.documents.length);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tisClosed() {\n\t\treturn this._closed === true;\n\t}\n\t\n\tsnapshot() { throw new NotImplementedError('snapshot'); }\n\t\n\tsort(s) {\n\t\treturn new this.SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\tallowDiskUse(enabled = true) {\n\t\t// Allow disk use for sorts (no-op for in-memory)\n\t\tthis._allowDiskUse = enabled;\n\t\treturn this;\n\t}\n\t\n\tcollation(collationDocument) {\n\t\t// Set collation (no-op for micro-mongo)\n\t\tthis._collation = collationDocument;\n\t\treturn this;\n\t}\n\t\n\ttailable() { throw new NotImplementedError('tailable'); }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","/**\n * SortedCursor class for iterating over sorted query results\n */\nexport class SortedCursor {\n\tconstructor(collection, query, cursor, sort) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.sortSpec = sort;\n\t\tthis.pos = 0;\n\t\tthis.items = [];\n\t\t\n\t\t// Collect all items from the cursor\n\t\twhile (cursor.hasNext()) {\n\t\t\tthis.items.push(cursor.next());\n\t\t}\n\t\t\n\t\t// Sort the items\n\t\tconst sortKeys = Object.keys(sort);\n\t\tthis.items.sort(function(a, b) {\n\t\t\tfor (let i = 0; i < sortKeys.length; i++) {\n\t\t\t\tif (a[sortKeys[i]] == undefined && b[sortKeys[i]] != undefined) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] != undefined && b[sortKeys[i]] == undefined) return 1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] < b[sortKeys[i]]) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] > b[sortKeys[i]]) return 1 * sort[sortKeys[i]];\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\treturn this.items.length;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\treturn this.pos < this.items.length;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(max) {\n\t\tthis.items = this.items.slice(0, max);\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\treturn this.items[this.pos++];\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","// Standard suffix manipulations.\n/** @type {Record<string, string>} */\nconst step2list = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant-vowel sequences.\nconst consonant = '[^aeiou]'\nconst vowel = '[aeiouy]'\nconst consonants = '(' + consonant + '[^aeiouy]*)'\nconst vowels = '(' + vowel + '[aeiou]*)'\n\nconst gt0 = new RegExp('^' + consonants + '?' + vowels + consonants)\nconst eq1 = new RegExp(\n  '^' + consonants + '?' + vowels + consonants + vowels + '?$'\n)\nconst gt1 = new RegExp('^' + consonants + '?(' + vowels + consonants + '){2,}')\nconst vowelInStem = new RegExp('^' + consonants + '?' + vowel)\nconst consonantLike = new RegExp('^' + consonants + vowel + '[^aeiouwxy]$')\n\n// Exception expressions.\nconst sfxLl = /ll$/\nconst sfxE = /^(.+?)e$/\nconst sfxY = /^(.+?)y$/\nconst sfxIon = /^(.+?(s|t))(ion)$/\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/\nconst sfxEED = /^(.+?)eed$/\nconst sfxS = /^.+?[^s]s$/\nconst sfxSsesOrIes = /^.+?(ss|i)es$/\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nexport function stemmer(value) {\n  let result = String(value).toLowerCase()\n\n  // Exit early.\n  if (result.length < 3) {\n    return result\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true\n    result = 'Y' + result.slice(1)\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2)\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1)\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1]\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += 'e'\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += 'e'\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + 'i'\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]]\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]]\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1]\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1]\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1]\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1)\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = 'y' + result.slice(1)\n  }\n\n  return result\n}\n","/**\n * BPlusTree - Persistent immutable B+ tree with BJsonFile storage\n * \n * Usage pattern:\n *   const tree = new BPlusTree('tree.bjson');\n *   await tree.open();\n *   await tree.add(key, value);\n *   await tree.close();\n */\n\nimport { BJsonFile, Pointer } from './bjson.js';\n\n/**\n * Node for persistent storage\n * @private\n */\nclass NodeData {\n    /**\n     * Creates a node data object for serialization\n     * @param {number} id - Unique node ID\n     * @param {boolean} isLeaf - Leaf flag\n     * @param {Array} keys - Key array\n     * @param {Array} values - Value array (leaf nodes)\n     * @param {Array} children - Child pointers (internal nodes)\n     * @param {Pointer} next - Pointer to next leaf\n     */\n    constructor(id, isLeaf, keys, values, children, next) {\n        this.id = id;\n        this.isLeaf = isLeaf;\n        this.keys = keys;\n        this.values = values;\n        this.children = children;\n        for (let v of children) {\n            if (!(v instanceof Pointer)) {\n                throw new Error('Children must be Pointer objects');\n            }\n        }\n        this.next = next;\n    }\n}\n\n/**\n * Persistent immutable B+ tree with append-only file storage\n */\nexport class BPlusTree {\n    /**\n     * Creates a new persistent B+ tree\n     * @param {string} filename - Path to storage file\n     * @param {number} order - Tree order (default: 3)\n     */\n    constructor(filename, order = 3) {\n        if (order < 3) {\n            throw new Error('B+ tree order must be at least 3');\n        }\n        this.filename = filename;\n        this.order = order;\n        this.minKeys = Math.ceil(order / 2) - 1;\n        \n        this.file = new BJsonFile(filename);\n        this.isOpen = false;\n        \n        // Metadata\n        this.rootPointer = null;\n        this.nextNodeId = 0;\n        this._size = 0;\n    }\n\n    /**\n     * Open the tree file (create if doesn't exist)\n     */\n    async open() {\n        if (this.isOpen) {\n            throw new Error('Tree file is already open');\n        }\n\n        const exists = await this.file.exists();\n\n        if (exists) {\n            await this.file.open('rw');\n            await this._loadMetadata();\n        } else {\n            await this.file.open('rw');\n            await this._initializeNewTree();\n        }\n\n        this.isOpen = true;\n    }\n\n    /**\n     * Close the tree file and save metadata\n     */\n    async close() {\n        if (this.isOpen) {\n            await this._saveMetadata();\n            await this.file.close();\n            this.isOpen = false;\n        }\n    }\n\n    /**\n     * Initialize a new empty tree\n     */\n    async _initializeNewTree() {\n        const rootNode = new NodeData(0, true, [], [], [], null);\n        this.nextNodeId = 1;\n        this._size = 0;\n\n        const rootPointer = await this._saveNode(rootNode);\n        this.rootPointer = rootPointer;\n\n        await this._saveMetadata();\n    }\n\n    /**\n     * Save metadata to file\n     */\n    async _saveMetadata() {\n        const metadata = {\n            version: 1,\n            maxEntries: this.order,  // Renamed to match RTree size\n            minEntries: this.minKeys,  // Renamed to match RTree size\n            size: this._size,\n            rootPointer: this.rootPointer,\n            nextId: this.nextNodeId  // Renamed to match RTree size\n        };\n\n        await this.file.append(metadata);\n    }\n\n    /**\n     * Load metadata from file\n     */\n    async _loadMetadata() {\n        const fileSize = await this.file.getFileSize();\n        // Metadata object has 6 INT fields (now encoded as 8-byte ints) plus keys\n        const METADATA_SIZE = 135;\n        \n        if (fileSize < METADATA_SIZE) {\n            throw new Error('Invalid tree file');\n        }\n\n        const metadataOffset = fileSize - METADATA_SIZE;\n        const metadata = await this.file.read(metadataOffset);\n\n        if (!metadata || typeof metadata.maxEntries === 'undefined') {\n            throw new Error(`Failed to read metadata: missing required fields`);\n        }\n\n        this.order = metadata.maxEntries;\n        this.minKeys = metadata.minEntries;\n        this._size = metadata.size;\n        this.nextNodeId = metadata.nextId;\n        this.rootPointer = metadata.rootPointer;\n    }\n\n    /**\n     * Save a node to disk\n     */\n    async _saveNode(node) {\n        const offset = await this.file.getFileSize();\n        await this.file.append(node);\n        return new Pointer(offset);\n    }\n\n    /**\n     * Load a node from disk\n     */\n    async _loadNode(pointer) {\n        if (!(pointer instanceof Pointer)) {\n            throw new Error('Expected Pointer object');\n        }\n\n        const data = await this.file.read(pointer);\n        return new NodeData(\n            data.id,\n            data.isLeaf,\n            data.keys,\n            data.values,\n            data.children,\n            data.next\n        );\n    }\n\n    /**\n     * Load root node\n     */\n    async _loadRoot() {\n        return await this._loadNode(this.rootPointer);\n    }\n\n    /**\n     * Search for a key\n     */\n    async search(key) {\n        const root = await this._loadRoot();\n        return this._searchNode(root, key);\n    }\n\n    /**\n     * Internal search\n     */\n    async _searchNode(node, key) {\n        if (node.isLeaf) {\n            for (let i = 0; i < node.keys.length; i++) {\n                if (key === node.keys[i]) {\n                    return node.values[i];\n                }\n            }\n            return undefined;\n        } else {\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n            const child = await this._loadNode(node.children[i]);\n            return this._searchNode(child, key);\n        }\n    }\n\n    /**\n     * Insert a key-value pair\n     */\n    async add(key, value) {\n        const root = await this._loadRoot();\n        const result = await this._addToNode(root, key, value);\n\n        let newRoot;\n        if (result.newNode) {\n            newRoot = result.newNode;\n        } else {\n            // Split occurred - save the split nodes and create new root with pointers\n            const leftPointer = await this._saveNode(result.left);\n            const rightPointer = await this._saveNode(result.right);\n            newRoot = new NodeData(\n                this.nextNodeId++,\n                false,\n                [result.splitKey],\n                [],\n                [leftPointer, rightPointer],\n                null\n            );\n        }\n\n        const rootPointer = await this._saveNode(newRoot);\n        this.rootPointer = rootPointer;\n\n        this._size++;\n    }\n\n    /**\n     * Internal add\n     */\n    async _addToNode(node, key, value) {\n        if (node.isLeaf) {\n            const keys = [...node.keys];\n            const values = [...node.values];\n\n            const existingIdx = keys.indexOf(key);\n            if (existingIdx !== -1) {\n                values[existingIdx] = value;\n                return {\n                    newNode: new NodeData(node.id, true, keys, values, [], null)\n                };\n            }\n\n            let insertIdx = 0;\n            while (insertIdx < keys.length && key > keys[insertIdx]) {\n                insertIdx++;\n            }\n            keys.splice(insertIdx, 0, key);\n            values.splice(insertIdx, 0, value);\n\n            if (keys.length < this.order) {\n                return {\n                    newNode: new NodeData(node.id, true, keys, values, [], null)\n                };\n            } else {\n                const mid = Math.ceil(keys.length / 2);\n                const leftKeys = keys.slice(0, mid);\n                const leftValues = values.slice(0, mid);\n                const rightKeys = keys.slice(mid);\n                const rightValues = values.slice(mid);\n\n                const rightNode = new NodeData(this.nextNodeId++, true, rightKeys, rightValues, [], null);\n                const leftNode = new NodeData(node.id, true, leftKeys, leftValues, [], null);\n\n                return {\n                    left: leftNode,\n                    right: rightNode,\n                    splitKey: rightKeys[0]\n                };\n            }\n        } else {\n            const keys = [...node.keys];\n            const children = [...node.children];\n\n            let childIdx = 0;\n            while (childIdx < keys.length && key >= keys[childIdx]) {\n                childIdx++;\n            }\n\n            const childNode = await this._loadNode(children[childIdx]);\n            const result = await this._addToNode(childNode, key, value);\n\n            if (result.newNode) {\n                const newChildPointer = await this._saveNode(result.newNode);\n                children[childIdx] = newChildPointer;\n                return {\n                    newNode: new NodeData(node.id, false, keys, [], children, null)\n                };\n            } else {\n                const leftPointer = await this._saveNode(result.left);\n                const rightPointer = await this._saveNode(result.right);\n\n                keys.splice(childIdx, 0, result.splitKey);\n                children.splice(childIdx, 1, leftPointer, rightPointer);\n\n                if (keys.length < this.order) {\n                    return {\n                        newNode: new NodeData(node.id, false, keys, [], children, null)\n                    };\n                } else {\n                    const mid = Math.ceil(keys.length / 2) - 1;\n                    const splitKey = keys[mid];\n                    const leftKeys = keys.slice(0, mid);\n                    const rightKeys = keys.slice(mid + 1);\n                    const leftChildren = children.slice(0, mid + 1);\n                    const rightChildren = children.slice(mid + 1);\n\n                    const leftNode = new NodeData(node.id, false, leftKeys, [], leftChildren, null);\n                    const rightNode = new NodeData(this.nextNodeId++, false, rightKeys, [], rightChildren, null);\n\n                    return {\n                        left: leftNode,\n                        right: rightNode,\n                        splitKey: splitKey\n                    };\n                }\n            }\n        }\n    }\n\n    /**\n     * Delete a key\n     */\n    async delete(key) {\n        const root = await this._loadRoot();\n        const newRoot = await this._deleteFromNode(root, key);\n\n        if (!newRoot) {\n            return; // Key not found\n        }\n\n        let finalRoot = newRoot;\n        if (finalRoot.keys.length === 0 && !finalRoot.isLeaf && finalRoot.children.length > 0) {\n            finalRoot = await this._loadNode(finalRoot.children[0]);\n        }\n\n        const rootPointer = await this._saveNode(finalRoot);\n        this.rootPointer = rootPointer;\n\n        this._size--;\n    }\n\n    /**\n     * Internal delete\n     */\n    async _deleteFromNode(node, key) {\n        if (node.isLeaf) {\n            const keyIndex = node.keys.indexOf(key);\n\n            if (keyIndex === -1) {\n                return null;\n            }\n\n            const newKeys = [...node.keys];\n            const newValues = [...node.values];\n            newKeys.splice(keyIndex, 1);\n            newValues.splice(keyIndex, 1);\n\n            return new NodeData(node.id, true, newKeys, newValues, [], node.next);\n        } else {\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n\n            const childNode = await this._loadNode(node.children[i]);\n            const newChild = await this._deleteFromNode(childNode, key);\n\n            if (!newChild) {\n                return null;\n            }\n\n            const newChildren = [...node.children];\n            const newChildPointer = await this._saveNode(newChild);\n            newChildren[i] = newChildPointer;\n\n            return new NodeData(node.id, false, [...node.keys], [], newChildren, null);\n        }\n    }\n\n    /**\n     * Get all entries as array\n     */\n    async toArray() {\n        const result = [];\n        await this._collectAllEntries(await this._loadRoot(), result);\n        return result;\n    }\n\n    /**\n     * Collect all entries in sorted order by traversing tree\n     * @private\n     */\n    async _collectAllEntries(node, result) {\n        if (node.isLeaf) {\n            for (let i = 0; i < node.keys.length; i++) {\n                result.push({\n                    key: node.keys[i],\n                    value: node.values[i]\n                });\n            }\n        } else {\n            for (const childPointer of node.children) {\n                const child = await this._loadNode(childPointer);\n                await this._collectAllEntries(child, result);\n            }\n        }\n    }\n\n    /**\n     * Get tree size\n     */\n    size() {\n        return this._size;\n    }\n\n    /**\n     * Check if empty\n     */\n    isEmpty() {\n        return this._size === 0;\n    }\n\n    /**\n     * Range search\n     */\n    async rangeSearch(minKey, maxKey) {\n        const result = [];\n        await this._rangeSearchNode(await this._loadRoot(), minKey, maxKey, result);\n        return result;\n    }\n\n    /**\n     * Range search helper that traverses tree\n     * @private\n     */\n    async _rangeSearchNode(node, minKey, maxKey, result) {\n        if (node.isLeaf) {\n            for (let i = 0; i < node.keys.length; i++) {\n                if (node.keys[i] >= minKey && node.keys[i] <= maxKey) {\n                    result.push({\n                        key: node.keys[i],\n                        value: node.values[i]\n                    });\n                }\n            }\n        } else {\n            for (const childPointer of node.children) {\n                const child = await this._loadNode(childPointer);\n                await this._rangeSearchNode(child, minKey, maxKey, result);\n            }\n        }\n    }\n\n    /**\n     * Get tree height\n     */\n    async getHeight() {\n        let height = 0;\n        let current = await this._loadRoot();\n\n        while (!current.isLeaf) {\n            height++;\n            current = await this._loadNode(current.children[0]);\n        }\n\n        return height;\n    }\n\n    /**\n     * Compact the tree into a new file by copying only the current live nodes.\n     * Returns size metrics so callers can see how much space was reclaimed.\n     * @param {string} destinationFilename - New file to write the compacted tree into\n     * @returns {Promise<{oldSize:number,newSize:number,bytesSaved:number,newFilename:string}>}\n     */\n    async compact(destinationFilename) {\n        if (!this.isOpen) {\n            throw new Error('Tree file is not open');\n        }\n        if (!destinationFilename) {\n            throw new Error('Destination filename is required for compaction');\n        }\n\n        // Make sure the current file has up-to-date metadata before measuring size\n        await this._saveMetadata();\n        const oldSize = await this.file.getFileSize();\n\n        // Rebuild a fresh tree with only the live entries\n        const entries = await this.toArray();\n        const newTree = new BPlusTree(destinationFilename, this.order);\n        await newTree.open();\n        for (const entry of entries) {\n            await newTree.add(entry.key, entry.value);\n        }\n        await newTree.close();\n\n        // Measure new file size after metadata has been written on close\n        const tempFile = new BJsonFile(destinationFilename);\n        await tempFile.open('r');\n        const newSize = await tempFile.getFileSize();\n        await tempFile.close();\n\n        return {\n            oldSize,\n            newSize,\n            bytesSaved: Math.max(0, oldSize - newSize),\n            newFilename: destinationFilename\n        };\n    }\n}\n","import { stemmer } from 'stemmer';\nimport { BPlusTree } from './bplustree.js';\n\n// Common English stop words that don't add semantic value to searches\nconst STOPWORDS = new Set([\n  'a', 'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', \n  'around', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'between', 'both', \n  'but', 'by', 'came', 'can', 'come', 'could', 'did', 'do', 'each', 'for', 'from', \n  'get', 'got', 'has', 'had', 'he', 'have', 'her', 'here', 'him', 'himself', 'his', \n  'how', 'i', 'if', 'in', 'into', 'is', 'it', 'like', 'make', 'many', 'me', 'might', \n  'more', 'most', 'much', 'must', 'my', 'never', 'now', 'of', 'on', 'only', 'or', \n  'other', 'our', 'out', 'over', 'said', 'same', 'see', 'should', 'since', 'some', \n  'still', 'such', 'take', 'than', 'that', 'the', 'their', 'them', 'then', 'there', \n  'these', 'they', 'this', 'those', 'through', 'to', 'too', 'under', 'up', 'very', \n  'was', 'way', 'we', 'well', 'were', 'what', 'where', 'which', 'while', 'who', \n  'with', 'would', 'you', 'your'\n]);\n\n/**\n * Tokenize text into individual words\n * @param {string} text - The text to tokenize\n * @returns {string[]} Array of words\n */\nexport function tokenize(text) {\n  if (typeof text !== 'string') {\n    return [];\n  }\n  // Split on non-word characters and filter out empty strings\n  const words = text.toLowerCase()\n    .split(/\\W+/)\n    .filter(word => word.length > 0);\n  \n  // Filter stop words\n  return words.filter(word => !STOPWORDS.has(word));\n}\n\n/**\n * TextIndex - A text index implementation using Porter stemmer algorithm\n * \n * This class provides full-text search capabilities by indexing terms\n * and associating them with document IDs. It uses the Porter stemmer\n * algorithm to normalize words to their root forms.\n */\nexport class TextIndex {\n  constructor(options = {}) {\n    const {\n      baseFilename = `text-index-${Date.now()}-${Math.random().toString(16).slice(2)}`,\n      order = 16,\n      trees\n    } = options;\n\n    this.baseFilename = baseFilename;\n    this.index = trees?.index || new BPlusTree(`${baseFilename}-terms.bjson`, order);\n    this.documentTerms = trees?.documentTerms || new BPlusTree(`${baseFilename}-documents.bjson`, order);\n    this.documentLengths = trees?.documentLengths || new BPlusTree(`${baseFilename}-lengths.bjson`, order);\n    this.isOpen = false;\n  }\n\n  async open() {\n    if (this.isOpen) {\n      throw new Error('TextIndex is already open');\n    }\n\n    await Promise.all([\n      this.index.open(),\n      this.documentTerms.open(),\n      this.documentLengths.open()\n    ]);\n\n    this.isOpen = true;\n  }\n\n  async close() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    await Promise.all([\n      this.index.close(),\n      this.documentTerms.close(),\n      this.documentLengths.close()\n    ]);\n\n    this.isOpen = false;\n  }\n\n  _ensureOpen() {\n    if (!this.isOpen) {\n      throw new Error('TextIndex is not open');\n    }\n  }\n\n  /**\n   * Add terms from text to the index for a given document ID\n   * @param {string} docId - The document identifier\n   * @param {string} text - The text content to index\n   */\n  async add(docId, text) {\n    this._ensureOpen();\n\n    if (!docId) {\n      throw new Error('Document ID is required');\n    }\n\n    const words = tokenize(text);\n    const termFrequency = new Map();\n\n    words.forEach(word => {\n      const stem = stemmer(word);\n      termFrequency.set(stem, (termFrequency.get(stem) || 0) + 1);\n    });\n\n    for (const [stem, frequency] of termFrequency.entries()) {\n      const postings = (await this.index.search(stem)) || {};\n      postings[docId] = frequency;\n      await this.index.add(stem, postings);\n    }\n\n    const existingTerms = (await this.documentTerms.search(docId)) || {};\n    const mergedTerms = { ...existingTerms };\n    termFrequency.forEach((frequency, stem) => {\n      mergedTerms[stem] = frequency;\n    });\n\n    const docLength = Object.values(mergedTerms).reduce((sum, count) => sum + count, 0);\n\n    await this.documentTerms.add(docId, mergedTerms);\n    await this.documentLengths.add(docId, docLength);\n  }\n\n  /**\n   * Remove all indexed terms for a given document ID\n   * @param {string} docId - The document identifier to remove\n   * @returns {boolean} True if document was found and removed, false otherwise\n   */\n  async remove(docId) {\n    this._ensureOpen();\n\n    const terms = await this.documentTerms.search(docId);\n    if (!terms) {\n      return false;\n    }\n\n    for (const [term] of Object.entries(terms)) {\n      const postings = (await this.index.search(term)) || {};\n      delete postings[docId];\n\n      if (Object.keys(postings).length === 0) {\n        await this.index.delete(term);\n      } else {\n        await this.index.add(term, postings);\n      }\n    }\n\n    await this.documentTerms.delete(docId);\n    await this.documentLengths.delete(docId);\n    return true;\n  }\n\n  /**\n   * Query the index for documents containing the given terms with relevance scoring\n   * @param {string} queryText - The search query text\n   * @param {Object} options - Query options\n   * @param {boolean} options.scored - If true, return scored results; if false, return just IDs (default: true)\n   * @param {boolean} options.requireAll - If true, require ALL terms; if false, rank by relevance (default: false)\n   * @returns {Array} Array of document IDs (if scored=false) or objects with {id, score} (if scored=true)\n   */\n  async query(queryText, options = { scored: true, requireAll: false }) {\n    this._ensureOpen();\n\n    const words = tokenize(queryText);\n    if (words.length === 0) {\n      return [];\n    }\n\n    const stemmedTerms = words.map(word => stemmer(word));\n    const uniqueTerms = [...new Set(stemmedTerms)];\n\n    if (options.requireAll) {\n      const docSets = [];\n      for (const term of uniqueTerms) {\n        const termDocs = await this.index.search(term);\n        docSets.push(new Set(Object.keys(termDocs || {})));\n      }\n\n      if (docSets.length === 0) {\n        return [];\n      }\n\n      const intersection = new Set(docSets[0]);\n      for (let i = 1; i < docSets.length; i++) {\n        for (const docId of [...intersection]) {\n          if (!docSets[i].has(docId)) {\n            intersection.delete(docId);\n          }\n        }\n      }\n\n      return Array.from(intersection);\n    }\n\n    const docLengthEntries = await this.documentLengths.toArray();\n    const docLengthMap = new Map(docLengthEntries.map(({ key, value }) => [String(key), value || 1]));\n    const totalDocs = docLengthEntries.length;\n\n    const idf = new Map();\n    for (const term of uniqueTerms) {\n      const termDocs = await this.index.search(term);\n      const docsWithTerm = termDocs ? Object.keys(termDocs).length : 0;\n      if (docsWithTerm > 0) {\n        idf.set(term, Math.log(totalDocs / docsWithTerm));\n      }\n    }\n\n    const docScores = new Map();\n    for (const term of uniqueTerms) {\n      const termDocs = await this.index.search(term);\n      if (!termDocs) {\n        continue;\n      }\n\n      for (const [docId, termFreq] of Object.entries(termDocs)) {\n        const docLength = docLengthMap.get(docId) || 1;\n        const tf = termFreq / docLength;\n        const termIdf = idf.get(term) || 0;\n        const prev = docScores.get(docId) || 0;\n        docScores.set(docId, prev + tf * termIdf);\n      }\n    }\n\n    for (const [docId, score] of docScores.entries()) {\n      const docTerms = (await this.documentTerms.search(docId)) || {};\n      const matchingTerms = uniqueTerms.filter(term => !!docTerms[term]).length;\n      const coverage = matchingTerms / uniqueTerms.length;\n      docScores.set(docId, score * (1 + coverage));\n    }\n\n    const results = Array.from(docScores.entries())\n      .map(([id, score]) => ({ id, score }))\n      .sort((a, b) => b.score - a.score);\n\n    if (options.scored === false) {\n      return results.map(r => r.id);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Get the number of unique terms in the index\n   * @returns {number} Number of unique terms\n   */\n  async getTermCount() {\n    this._ensureOpen();\n    const terms = await this.index.toArray();\n    return terms.length;\n  }\n\n  /**\n   * Get the number of documents in the index\n   * @returns {number} Number of indexed documents\n   */\n  async getDocumentCount() {\n    this._ensureOpen();\n    const docs = await this.documentTerms.toArray();\n    return docs.length;\n  }\n\n  /**\n   * Clear all data from the index\n   */\n  async clear() {\n    this._ensureOpen();\n\n    const [terms, docs, lengths] = await Promise.all([\n      this.index.toArray(),\n      this.documentTerms.toArray(),\n      this.documentLengths.toArray()\n    ]);\n\n    // Run deletes sequentially to avoid overlapping writes on the same underlying file\n    for (const entry of terms) {\n      await this.index.delete(entry.key);\n    }\n\n    for (const entry of docs) {\n      await this.documentTerms.delete(entry.key);\n    }\n\n    for (const entry of lengths) {\n      await this.documentLengths.delete(entry.key);\n    }\n  }\n\n  /**\n   * Compact all internal B+ trees into new files and switch the index to use them.\n   * @param {string} destinationBase - Base filename (without suffixes) for the compacted files\n   * @returns {Promise<{terms: object, documents: object, lengths: object}>}\n   */\n  async compact(destinationBase = `${this.baseFilename}-compact-${Date.now()}`) {\n    this._ensureOpen();\n\n    if (!destinationBase) {\n      throw new Error('Destination base filename is required for compaction');\n    }\n\n    const termsDest = `${destinationBase}-terms.bjson`;\n    const documentsDest = `${destinationBase}-documents.bjson`;\n    const lengthsDest = `${destinationBase}-lengths.bjson`;\n\n    const results = await Promise.all([\n      this.index.compact(termsDest),\n      this.documentTerms.compact(documentsDest),\n      this.documentLengths.compact(lengthsDest)\n    ]);\n\n    const indexOrder = this.index.order;\n    const documentsOrder = this.documentTerms.order;\n    const lengthsOrder = this.documentLengths.order;\n\n    await this.close();\n\n    this.baseFilename = destinationBase;\n    this.index = new BPlusTree(termsDest, indexOrder);\n    this.documentTerms = new BPlusTree(documentsDest, documentsOrder);\n    this.documentLengths = new BPlusTree(lengthsDest, lengthsOrder);\n\n    await this.open();\n\n    return {\n      terms: results[0],\n      documents: results[1],\n      lengths: results[2]\n    };\n  }\n\n}\n\n// Re-export the stemmer so consumers can share the exact same implementation\nexport { stemmer };\n","/**\n * Aggregation Expression Evaluator\n * \n * Implements MongoDB aggregation expression operators for use in\n * $project, $addFields, $set, $group, and other pipeline stages.\n */\n\nimport { getProp } from './utils.js';\n\n/**\n * Evaluate an aggregation expression against a document\n * @param {*} expr - The expression to evaluate (can be literal, field reference, or expression object)\n * @param {Object} doc - The document to evaluate against\n * @returns {*} The evaluated result\n */\nexport function evaluateExpression(expr, doc) {\n\t// Literal values (strings not starting with $, numbers, booleans, null)\n\tif (expr === null || expr === undefined) {\n\t\treturn expr;\n\t}\n\t\n\tif (typeof expr === 'boolean' || typeof expr === 'number') {\n\t\treturn expr;\n\t}\n\t\n\t// Field reference ($fieldName) or variable reference ($$variableName)\n\tif (typeof expr === 'string') {\n\t\tif (expr.startsWith('$$')) {\n\t\t\t// Special system variables for $redact\n\t\t\tif (expr === '$$KEEP' || expr === '$$PRUNE' || expr === '$$DESCEND') {\n\t\t\t\treturn expr;\n\t\t\t}\n\t\t\t// Variable reference ($$var)\n\t\t\treturn getProp(doc, expr.substring(2));\n\t\t} else if (expr.charAt(0) === '$') {\n\t\t\t// Field reference ($field)\n\t\t\treturn getProp(doc, expr.substring(1));\n\t\t}\n\t\treturn expr; // Literal string\n\t}\n\t\n\t// Expression object\n\tif (typeof expr === 'object') {\n\t\t// Check if it's an array literal\n\t\tif (Array.isArray(expr)) {\n\t\t\treturn expr.map(item => evaluateExpression(item, doc));\n\t\t}\n\t\t\n\t\t// Expression operator\n\t\tconst keys = Object.keys(expr);\n\t\tif (keys.length === 0) {\n\t\t\treturn expr; // Empty object literal\n\t\t}\n\t\t\n\t\tconst operator = keys[0];\n\t\t\n\t\t// Check if this is an operator (starts with $) or an object literal\n\t\tif (operator.charAt(0) === '$') {\n\t\t\t// This is an expression operator\n\t\t\tconst operand = expr[operator];\n\t\t\treturn evaluateOperator(operator, operand, doc);\n\t\t} else {\n\t\t\t// This is an object literal - evaluate each field\n\t\t\tconst result = {};\n\t\t\tfor (const key of keys) {\n\t\t\t\tresult[key] = evaluateExpression(expr[key], doc);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\treturn expr;\n}\n\n/**\n * Evaluate a specific operator\n */\nfunction evaluateOperator(operator, operand, doc) {\n\tswitch (operator) {\n\t\t// Arithmetic operators\n\t\tcase '$add': return evalAdd(operand, doc);\n\t\tcase '$subtract': return evalSubtract(operand, doc);\n\t\tcase '$multiply': return evalMultiply(operand, doc);\n\t\tcase '$divide': return evalDivide(operand, doc);\n\t\tcase '$mod': return evalMod(operand, doc);\n\t\tcase '$pow': return evalPow(operand, doc);\n\t\tcase '$sqrt': return evalSqrt(operand, doc);\n\t\tcase '$abs': return evalAbs(operand, doc);\n\t\tcase '$ceil': return evalCeil(operand, doc);\n\t\tcase '$floor': return evalFloor(operand, doc);\n\t\tcase '$trunc': return evalTrunc(operand, doc);\n\t\tcase '$round': return evalRound(operand, doc);\n\t\t\n\t\t// String operators\n\t\tcase '$concat': return evalConcat(operand, doc);\n\t\tcase '$substr': return evalSubstr(operand, doc);\n\t\tcase '$toLower': return evalToLower(operand, doc);\n\t\tcase '$toUpper': return evalToUpper(operand, doc);\n\t\tcase '$trim': return evalTrim(operand, doc);\n\t\tcase '$ltrim': return evalLtrim(operand, doc);\n\t\tcase '$rtrim': return evalRtrim(operand, doc);\n\t\tcase '$split': return evalSplit(operand, doc);\n\t\tcase '$strLenCP': return evalStrLenCP(operand, doc);\n\t\tcase '$strcasecmp': return evalStrcasecmp(operand, doc);\n\t\tcase '$indexOfCP': return evalIndexOfCP(operand, doc);\n\t\tcase '$replaceOne': return evalReplaceOne(operand, doc);\n\t\tcase '$replaceAll': return evalReplaceAll(operand, doc);\n\t\t\n\t\t// Comparison operators\n\t\tcase '$cmp': return evalCmp(operand, doc);\n\t\tcase '$eq': return evalEq(operand, doc);\n\t\tcase '$ne': return evalNe(operand, doc);\n\t\tcase '$gt': return evalGt(operand, doc);\n\t\tcase '$gte': return evalGte(operand, doc);\n\t\tcase '$lt': return evalLt(operand, doc);\n\t\tcase '$lte': return evalLte(operand, doc);\n\t\t\n\t\t// Logical operators\n\t\tcase '$and': return evalAnd(operand, doc);\n\t\tcase '$or': return evalOr(operand, doc);\n\t\tcase '$not': return evalNot(operand, doc);\n\t\t\n\t\t// Conditional operators\n\t\tcase '$cond': return evalCond(operand, doc);\n\t\tcase '$ifNull': return evalIfNull(operand, doc);\n\t\tcase '$switch': return evalSwitch(operand, doc);\n\t\t\n\t\t// Date operators\n\t\tcase '$year': return evalYear(operand, doc);\n\t\tcase '$month': return evalMonth(operand, doc);\n\t\tcase '$dayOfMonth': return evalDayOfMonth(operand, doc);\n\t\tcase '$dayOfWeek': return evalDayOfWeek(operand, doc);\n\t\tcase '$dayOfYear': return evalDayOfYear(operand, doc);\n\t\tcase '$hour': return evalHour(operand, doc);\n\t\tcase '$minute': return evalMinute(operand, doc);\n\t\tcase '$second': return evalSecond(operand, doc);\n\t\tcase '$millisecond': return evalMillisecond(operand, doc);\n\t\tcase '$week': return evalWeek(operand, doc);\n\t\tcase '$isoWeek': return evalIsoWeek(operand, doc);\n\t\tcase '$isoWeekYear': return evalIsoWeekYear(operand, doc);\n\t\tcase '$dateToString': return evalDateToString(operand, doc);\n\t\tcase '$toDate': return evalToDate(operand, doc);\n\t\t\n\t\t// Array operators\n\t\tcase '$arrayElemAt': return evalArrayElemAt(operand, doc);\n\t\tcase '$concatArrays': return evalConcatArrays(operand, doc);\n\t\tcase '$filter': return evalFilter(operand, doc);\n\t\tcase '$in': return evalIn(operand, doc);\n\t\tcase '$indexOfArray': return evalIndexOfArray(operand, doc);\n\t\tcase '$isArray': return evalIsArray(operand, doc);\n\t\tcase '$map': return evalMap(operand, doc);\n\t\tcase '$reduce': return evalReduce(operand, doc);\n\t\tcase '$size': return evalSize(operand, doc);\n\t\tcase '$slice': return evalSlice(operand, doc);\n\t\tcase '$reverseArray': return evalReverseArray(operand, doc);\n\t\tcase '$zip': return evalZip(operand, doc);\n\t\t\n\t\t// Type operators\n\t\tcase '$type': return evalType(operand, doc);\n\t\tcase '$convert': return evalConvert(operand, doc);\n\t\tcase '$toBool': return evalToBool(operand, doc);\n\t\tcase '$toDecimal': return evalToDecimal(operand, doc);\n\t\tcase '$toDouble': return evalToDouble(operand, doc);\n\t\tcase '$toInt': return evalToInt(operand, doc);\n\t\tcase '$toLong': return evalToLong(operand, doc);\n\t\tcase '$toString': return evalToString(operand, doc);\n\t\t\n\t\t// Object operators\n\t\tcase '$objectToArray': return evalObjectToArray(operand, doc);\n\t\tcase '$arrayToObject': return evalArrayToObject(operand, doc);\n\t\tcase '$mergeObjects': return evalMergeObjects(operand, doc);\n\t\t\n\t\t// Literal operator\n\t\tcase '$literal': return operand;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported aggregation operator: ${operator}`);\n\t}\n}\n\n// ============================================================================\n// ARITHMETIC OPERATORS\n// ============================================================================\n\nfunction evalAdd(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet sum = 0;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val instanceof Date) {\n\t\t\tsum += val.getTime();\n\t\t} else if (typeof val === 'number') {\n\t\t\tsum += val;\n\t\t}\n\t}\n\treturn sum;\n}\n\nfunction evalSubtract(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\t\n\tif (val1 instanceof Date && val2 instanceof Date) {\n\t\treturn val1.getTime() - val2.getTime();\n\t} else if (val1 instanceof Date && typeof val2 === 'number') {\n\t\treturn new Date(val1.getTime() - val2);\n\t} else if (typeof val1 === 'number' && typeof val2 === 'number') {\n\t\treturn val1 - val2;\n\t}\n\treturn null;\n}\n\nfunction evalMultiply(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet product = 1;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (typeof val === 'number') {\n\t\t\tproduct *= val;\n\t\t}\n\t}\n\treturn product;\n}\n\nfunction evalDivide(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\tif (typeof val1 === 'number' && typeof val2 === 'number' && val2 !== 0) {\n\t\treturn val1 / val2;\n\t}\n\treturn null;\n}\n\nfunction evalMod(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\tif (typeof val1 === 'number' && typeof val2 === 'number' && val2 !== 0) {\n\t\treturn val1 % val2;\n\t}\n\treturn null;\n}\n\nfunction evalPow(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst base = evaluateExpression(operands[0], doc);\n\tconst exponent = evaluateExpression(operands[1], doc);\n\tif (typeof base === 'number' && typeof exponent === 'number') {\n\t\treturn Math.pow(base, exponent);\n\t}\n\treturn null;\n}\n\nfunction evalSqrt(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number' && val >= 0) {\n\t\treturn Math.sqrt(val);\n\t}\n\treturn null;\n}\n\nfunction evalAbs(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.abs(val);\n\t}\n\treturn null;\n}\n\nfunction evalCeil(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.ceil(val);\n\t}\n\treturn null;\n}\n\nfunction evalFloor(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.floor(val);\n\t}\n\treturn null;\n}\n\nfunction evalTrunc(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.trunc(val);\n\t}\n\treturn null;\n}\n\nfunction evalRound(operands, doc) {\n\tconst val = evaluateExpression(Array.isArray(operands) ? operands[0] : operands, doc);\n\tconst place = Array.isArray(operands) && operands[1] !== undefined \n\t\t? evaluateExpression(operands[1], doc) \n\t\t: 0;\n\t\n\tif (typeof val === 'number' && typeof place === 'number') {\n\t\tconst multiplier = Math.pow(10, place);\n\t\treturn Math.round(val * multiplier) / multiplier;\n\t}\n\treturn null;\n}\n\n// ============================================================================\n// STRING OPERATORS\n// ============================================================================\n\nfunction evalConcat(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet result = '';\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val !== null && val !== undefined) {\n\t\t\tresult += String(val);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalSubstr(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 3) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst start = evaluateExpression(operands[1], doc);\n\tconst length = evaluateExpression(operands[2], doc);\n\tif (typeof start === 'number' && typeof length === 'number') {\n\t\treturn str.substr(start, length);\n\t}\n\treturn null;\n}\n\nfunction evalToLower(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).toLowerCase() : '';\n}\n\nfunction evalToUpper(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).toUpperCase() : '';\n}\n\nfunction evalTrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`^[${escapeRegex(chars)}]+|[${escapeRegex(chars)}]+$`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.trim();\n}\n\nfunction evalLtrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`^[${escapeRegex(chars)}]+`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.replace(/^\\s+/, '');\n}\n\nfunction evalRtrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`[${escapeRegex(chars)}]+$`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.replace(/\\s+$/, '');\n}\n\nfunction evalSplit(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst delimiter = String(evaluateExpression(operands[1], doc) || '');\n\treturn str.split(delimiter);\n}\n\nfunction evalStrLenCP(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).length : 0;\n}\n\nfunction evalStrcasecmp(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst str1 = String(evaluateExpression(operands[0], doc) || '').toLowerCase();\n\tconst str2 = String(evaluateExpression(operands[1], doc) || '').toLowerCase();\n\t\n\tif (str1 < str2) return -1;\n\tif (str1 > str2) return 1;\n\treturn 0;\n}\n\nfunction evalIndexOfCP(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst substr = String(evaluateExpression(operands[1], doc) || '');\n\tconst start = operands[2] !== undefined ? evaluateExpression(operands[2], doc) : 0;\n\tconst end = operands[3] !== undefined ? evaluateExpression(operands[3], doc) : str.length;\n\t\n\tconst searchStr = str.substring(start, end);\n\tconst index = searchStr.indexOf(substr);\n\treturn index === -1 ? -1 : index + start;\n}\n\nfunction evalReplaceOne(operand, doc) {\n\tconst input = String(evaluateExpression(operand.input, doc) || '');\n\tconst find = String(evaluateExpression(operand.find, doc) || '');\n\tconst replacement = String(evaluateExpression(operand.replacement, doc) || '');\n\t\n\treturn input.replace(find, replacement);\n}\n\nfunction evalReplaceAll(operand, doc) {\n\tconst input = String(evaluateExpression(operand.input, doc) || '');\n\tconst find = String(evaluateExpression(operand.find, doc) || '');\n\tconst replacement = String(evaluateExpression(operand.replacement, doc) || '');\n\t\n\treturn input.split(find).join(replacement);\n}\n\nfunction escapeRegex(str) {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// ============================================================================\n// COMPARISON OPERATORS\n// ============================================================================\n\nfunction evalCmp(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\t\n\tif (val1 < val2) return -1;\n\tif (val1 > val2) return 1;\n\treturn 0;\n}\n\nfunction evalEq(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 === val2;\n}\n\nfunction evalNe(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 !== val2;\n}\n\nfunction evalGt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 > val2;\n}\n\nfunction evalGte(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 >= val2;\n}\n\nfunction evalLt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 < val2;\n}\n\nfunction evalLte(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 <= val2;\n}\n\n// ============================================================================\n// LOGICAL OPERATORS\n// ============================================================================\n\nfunction evalAnd(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (!val) return false;\n\t}\n\treturn true;\n}\n\nfunction evalOr(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val) return true;\n\t}\n\treturn false;\n}\n\nfunction evalNot(operand, doc) {\n\tconst val = evaluateExpression(Array.isArray(operand) ? operand[0] : operand, doc);\n\treturn !val;\n}\n\n// ============================================================================\n// CONDITIONAL OPERATORS\n// ============================================================================\n\nfunction evalCond(operand, doc) {\n\t// Supports both array form [if, then, else] and object form {if, then, else}\n\tlet ifExpr, thenExpr, elseExpr;\n\t\n\tif (Array.isArray(operand)) {\n\t\tif (operand.length !== 3) return null;\n\t\t[ifExpr, thenExpr, elseExpr] = operand;\n\t} else if (typeof operand === 'object') {\n\t\tifExpr = operand.if;\n\t\tthenExpr = operand.then;\n\t\telseExpr = operand.else;\n\t} else {\n\t\treturn null;\n\t}\n\t\n\tconst condition = evaluateExpression(ifExpr, doc);\n\treturn condition ? evaluateExpression(thenExpr, doc) : evaluateExpression(elseExpr, doc);\n}\n\nfunction evalIfNull(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\t\n\tfor (let i = 0; i < operands.length; i++) {\n\t\tconst val = evaluateExpression(operands[i], doc);\n\t\tif (val !== null && val !== undefined) {\n\t\t\treturn val;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction evalSwitch(operand, doc) {\n\tif (typeof operand !== 'object' || !Array.isArray(operand.branches)) {\n\t\treturn null;\n\t}\n\t\n\tfor (const branch of operand.branches) {\n\t\tconst caseResult = evaluateExpression(branch.case, doc);\n\t\tif (caseResult) {\n\t\t\treturn evaluateExpression(branch.then, doc);\n\t\t}\n\t}\n\t\n\treturn operand.default !== undefined ? evaluateExpression(operand.default, doc) : null;\n}\n\n// ============================================================================\n// DATE OPERATORS\n// ============================================================================\n\nfunction evalYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCFullYear();\n\t}\n\treturn null;\n}\n\nfunction evalMonth(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMonth() + 1; // MongoDB returns 1-12\n\t}\n\treturn null;\n}\n\nfunction evalDayOfMonth(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCDate();\n\t}\n\treturn null;\n}\n\nfunction evalDayOfWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCDay() + 1; // MongoDB returns 1-7 (Sunday is 1)\n\t}\n\treturn null;\n}\n\nfunction evalDayOfYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst start = new Date(Date.UTC(date.getUTCFullYear(), 0, 0));\n\t\tconst diff = date - start;\n\t\tconst oneDay = 1000 * 60 * 60 * 24;\n\t\treturn Math.floor(diff / oneDay);\n\t}\n\treturn null;\n}\n\nfunction evalHour(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCHours();\n\t}\n\treturn null;\n}\n\nfunction evalMinute(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMinutes();\n\t}\n\treturn null;\n}\n\nfunction evalSecond(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCSeconds();\n\t}\n\treturn null;\n}\n\nfunction evalMillisecond(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMilliseconds();\n\t}\n\treturn null;\n}\n\nfunction evalWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst onejan = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));\n\t\tconst week = Math.ceil((((date - onejan) / 86400000) + onejan.getUTCDay() + 1) / 7);\n\t\treturn week - 1; // MongoDB weeks are 0-indexed\n\t}\n\treturn null;\n}\n\nfunction evalIsoWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst target = new Date(date.valueOf());\n\t\tconst dayNr = (date.getUTCDay() + 6) % 7;\n\t\ttarget.setUTCDate(target.getUTCDate() - dayNr + 3);\n\t\tconst firstThursday = target.valueOf();\n\t\ttarget.setUTCMonth(0, 1);\n\t\tif (target.getUTCDay() !== 4) {\n\t\t\ttarget.setUTCMonth(0, 1 + ((4 - target.getUTCDay()) + 7) % 7);\n\t\t}\n\t\treturn 1 + Math.ceil((firstThursday - target) / 604800000);\n\t}\n\treturn null;\n}\n\nfunction evalIsoWeekYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst target = new Date(date.valueOf());\n\t\ttarget.setUTCDate(target.getUTCDate() - ((date.getUTCDay() + 6) % 7) + 3);\n\t\treturn target.getUTCFullYear();\n\t}\n\treturn null;\n}\n\nfunction evalDateToString(operand, doc) {\n\tconst format = operand.format ? evaluateExpression(operand.format, doc) : '%Y-%m-%dT%H:%M:%S.%LZ';\n\tconst date = evaluateExpression(operand.date, doc);\n\t\n\tif (!(date instanceof Date)) return null;\n\t\n\t// Simple format string implementation using UTC methods\n\treturn format\n\t\t.replace('%Y', date.getUTCFullYear())\n\t\t.replace('%m', String(date.getUTCMonth() + 1).padStart(2, '0'))\n\t\t.replace('%d', String(date.getUTCDate()).padStart(2, '0'))\n\t\t.replace('%H', String(date.getUTCHours()).padStart(2, '0'))\n\t\t.replace('%M', String(date.getUTCMinutes()).padStart(2, '0'))\n\t\t.replace('%S', String(date.getUTCSeconds()).padStart(2, '0'))\n\t\t.replace('%L', String(date.getUTCMilliseconds()).padStart(3, '0'));\n}\n\nfunction evalToDate(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (val instanceof Date) return val;\n\tif (typeof val === 'string' || typeof val === 'number') {\n\t\tconst date = new Date(val);\n\t\treturn isNaN(date.getTime()) ? null : date;\n\t}\n\treturn null;\n}\n\n// ============================================================================\n// ARRAY OPERATORS\n// ============================================================================\n\nfunction evalArrayElemAt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\tconst idx = evaluateExpression(operands[1], doc);\n\t\n\tif (!Array.isArray(arr) || typeof idx !== 'number') return null;\n\t\n\tconst index = idx < 0 ? arr.length + idx : idx;\n\treturn arr[index];\n}\n\nfunction evalConcatArrays(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tconst result = [];\n\tfor (const operand of operands) {\n\t\tconst arr = evaluateExpression(operand, doc);\n\t\tif (Array.isArray(arr)) {\n\t\t\tresult.push(...arr);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalFilter(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst asVar = operand.as || 'this';\n\tconst cond = operand.cond;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\treturn input.filter(item => {\n\t\tconst itemDoc = { ...doc, [asVar]: item };\n\t\treturn evaluateExpression(cond, itemDoc);\n\t});\n}\n\nfunction evalIn(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst value = evaluateExpression(operands[0], doc);\n\tconst arr = evaluateExpression(operands[1], doc);\n\t\n\tif (!Array.isArray(arr)) return false;\n\treturn arr.includes(value);\n}\n\nfunction evalIndexOfArray(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\tconst search = evaluateExpression(operands[1], doc);\n\tconst start = operands[2] !== undefined ? evaluateExpression(operands[2], doc) : 0;\n\tconst end = operands[3] !== undefined ? evaluateExpression(operands[3], doc) : arr.length;\n\t\n\tif (!Array.isArray(arr)) return null;\n\t\n\tfor (let i = start; i < end && i < arr.length; i++) {\n\t\tif (arr[i] === search) return i;\n\t}\n\treturn -1;\n}\n\nfunction evalIsArray(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn Array.isArray(val);\n}\n\nfunction evalMap(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst asVar = operand.as || 'this';\n\tconst inExpr = operand.in;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\treturn input.map(item => {\n\t\tconst itemDoc = { ...doc, [asVar]: item };\n\t\treturn evaluateExpression(inExpr, itemDoc);\n\t});\n}\n\nfunction evalReduce(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst initialValue = evaluateExpression(operand.initialValue, doc);\n\tconst inExpr = operand.in;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\tlet value = initialValue;\n\tfor (const item of input) {\n\t\tconst itemDoc = { ...doc, value, this: item };\n\t\tvalue = evaluateExpression(inExpr, itemDoc);\n\t}\n\treturn value;\n}\n\nfunction evalSize(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\treturn Array.isArray(arr) ? arr.length : null;\n}\n\nfunction evalSlice(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\t\n\tif (!Array.isArray(arr)) return null;\n\t\n\tif (operands.length === 2) {\n\t\tconst n = evaluateExpression(operands[1], doc);\n\t\treturn n >= 0 ? arr.slice(0, n) : arr.slice(n);\n\t} else {\n\t\tconst position = evaluateExpression(operands[1], doc);\n\t\tconst n = evaluateExpression(operands[2], doc);\n\t\treturn arr.slice(position, position + n);\n\t}\n}\n\nfunction evalReverseArray(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\treturn Array.isArray(arr) ? arr.slice().reverse() : null;\n}\n\nfunction evalZip(operand, doc) {\n\tconst inputs = operand.inputs ? evaluateExpression(operand.inputs, doc) : null;\n\tconst useLongestLength = operand.useLongestLength || false;\n\tconst defaults = operand.defaults;\n\t\n\tif (!Array.isArray(inputs)) return null;\n\t\n\tconst arrays = inputs.map(input => evaluateExpression(input, doc));\n\tif (!arrays.every(arr => Array.isArray(arr))) return null;\n\t\n\tconst maxLength = Math.max(...arrays.map(arr => arr.length));\n\tconst length = useLongestLength ? maxLength : Math.min(...arrays.map(arr => arr.length));\n\t\n\tconst result = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tconst tuple = [];\n\t\tfor (let j = 0; j < arrays.length; j++) {\n\t\t\tif (i < arrays[j].length) {\n\t\t\t\ttuple.push(arrays[j][i]);\n\t\t\t} else if (defaults && j < defaults.length) {\n\t\t\t\ttuple.push(defaults[j]);\n\t\t\t} else {\n\t\t\t\ttuple.push(null);\n\t\t\t}\n\t\t}\n\t\tresult.push(tuple);\n\t}\n\treturn result;\n}\n\n// ============================================================================\n// TYPE OPERATORS\n// ============================================================================\n\nfunction evalType(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\t\n\tif (val === null) return 'null';\n\tif (val === undefined) return 'missing';\n\tif (typeof val === 'boolean') return 'bool';\n\tif (typeof val === 'number') return Number.isInteger(val) ? 'int' : 'double';\n\tif (typeof val === 'string') return 'string';\n\tif (val instanceof Date) return 'date';\n\tif (Array.isArray(val)) return 'array';\n\tif (typeof val === 'object') return 'object';\n\t\n\treturn 'unknown';\n}\n\nfunction evalConvert(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst to = operand.to;\n\tconst onError = operand.onError;\n\tconst onNull = operand.onNull;\n\t\n\tif (input === null) {\n\t\treturn onNull !== undefined ? evaluateExpression(onNull, doc) : null;\n\t}\n\t\n\ttry {\n\t\tswitch (to) {\n\t\t\tcase 'double':\n\t\t\tcase 'decimal':\n\t\t\t\treturn parseFloat(input);\n\t\t\tcase 'int':\n\t\t\tcase 'long':\n\t\t\t\treturn parseInt(input);\n\t\t\tcase 'bool':\n\t\t\t\treturn Boolean(input);\n\t\t\tcase 'string':\n\t\t\t\treturn String(input);\n\t\t\tcase 'date':\n\t\t\t\treturn new Date(input);\n\t\t\tdefault:\n\t\t\t\treturn input;\n\t\t}\n\t} catch (e) {\n\t\treturn onError !== undefined ? evaluateExpression(onError, doc) : null;\n\t}\n}\n\nfunction evalToBool(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn Boolean(val);\n}\n\nfunction evalToDecimal(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseFloat(val);\n}\n\nfunction evalToDouble(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseFloat(val);\n}\n\nfunction evalToInt(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseInt(val);\n}\n\nfunction evalToLong(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseInt(val);\n}\n\nfunction evalToString(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (val === null || val === undefined) return null;\n\treturn String(val);\n}\n\n// ============================================================================\n// OBJECT OPERATORS\n// ============================================================================\n\nfunction evalObjectToArray(operand, doc) {\n\tconst obj = evaluateExpression(operand, doc);\n\tif (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n\t\treturn null;\n\t}\n\t\n\treturn Object.keys(obj).map(key => ({ k: key, v: obj[key] }));\n}\n\nfunction evalArrayToObject(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\tif (!Array.isArray(arr)) return null;\n\t\n\tconst result = {};\n\tfor (const item of arr) {\n\t\tif (Array.isArray(item) && item.length === 2) {\n\t\t\tresult[item[0]] = item[1];\n\t\t} else if (typeof item === 'object' && item.k !== undefined && item.v !== undefined) {\n\t\t\tresult[item.k] = item.v;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalMergeObjects(operands, doc) {\n\tif (!Array.isArray(operands)) {\n\t\t// Single object\n\t\treturn evaluateExpression(operands, doc);\n\t}\n\t\n\tconst result = {};\n\tfor (const operand of operands) {\n\t\tconst obj = evaluateExpression(operand, doc);\n\t\tif (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {\n\t\t\tObject.assign(result, obj);\n\t\t}\n\t}\n\treturn result;\n}\n","import { getProp, getFieldValues, isArray, arrayMatches, objectMatches, toArray, isIn, bboxToGeojson } from './utils.js';\nimport { stemmer, tokenize } from 'bjson/textindex';\nimport { ObjectId } from 'bjson';\nimport { evaluateExpression } from './aggregationExpressions.js';\n\n/**\n * BSON type mappings for $type operator\n */\nconst BSON_TYPES = {\n\t1: 'double',\n\t2: 'string',\n\t3: 'object',\n\t4: 'array',\n\t5: 'binData',\n\t6: 'undefined',\n\t7: 'objectId',\n\t8: 'bool',\n\t9: 'date',\n\t10: 'null',\n\t11: 'regex',\n\t13: 'javascript',\n\t15: 'javascriptWithScope',\n\t16: 'int',\n\t17: 'timestamp',\n\t18: 'long',\n\t19: 'decimal',\n\t127: 'maxKey',\n\t'-1': 'minKey'\n};\n\n// Reverse mapping from alias to code\nconst TYPE_ALIASES = Object.entries(BSON_TYPES).reduce((acc, [code, name]) => {\n\tacc[name] = parseInt(code);\n\treturn acc;\n}, {});\n\n/**\n * Check if a value matches a BSON type or type code\n */\nfunction matchesType(value, typeSpec) {\n\t// Handle array of types\n\tif (isArray(typeSpec)) {\n\t\tfor (let i = 0; i < typeSpec.length; i++) {\n\t\t\tif (matchesType(value, typeSpec[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Get type code from spec (can be number or string alias)\n\tconst typeCode = typeof typeSpec === 'number' ? typeSpec : TYPE_ALIASES[typeSpec];\n\tconst typeName = BSON_TYPES[typeCode] || typeSpec;\n\t\n\t// Check value type\n\tif (value === null) return typeName === 'null' || typeCode === 10;\n\tif (value === undefined) return typeName === 'undefined' || typeCode === 6;\n\tif (typeof value === 'number') {\n\t\tif (Number.isInteger(value)) return typeName === 'int' || typeCode === 16;\n\t\treturn typeName === 'double' || typeCode === 1;\n\t}\n\tif (typeof value === 'string') return typeName === 'string' || typeCode === 2;\n\tif (typeof value === 'boolean') return typeName === 'bool' || typeCode === 8;\n\tif (value instanceof Date) return typeName === 'date' || typeCode === 9;\n\tif (value instanceof ObjectId) return typeName === 'objectId' || typeCode === 7;\n\tif (value instanceof RegExp) return typeName === 'regex' || typeCode === 11;\n\tif (isArray(value)) return typeName === 'array' || typeCode === 4;\n\tif (typeof value === 'object') return typeName === 'object' || typeCode === 3;\n\t\n\t// Fallback to simple type check\n\treturn typeof value === typeSpec;\n}\n\n/**\n * Bit query operator helpers\n */\nfunction toBitMask(positions) {\n\tif (isArray(positions)) {\n\t\t// Array of bit positions\n\t\tlet mask = 0;\n\t\tfor (let i = 0; i < positions.length; i++) {\n\t\t\tmask |= (1 << positions[i]);\n\t\t}\n\t\treturn mask;\n\t} else if (typeof positions === 'number') {\n\t\t// Bitmask directly\n\t\treturn positions;\n\t}\n\treturn 0;\n}\n\nfunction matchesBitsAllSet(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) === mask;\n}\n\nfunction matchesBitsAllClear(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) === 0;\n}\n\nfunction matchesBitsAnySet(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) !== 0;\n}\n\nfunction matchesBitsAnyClear(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) !== mask;\n}\n\n/**\n * JSON Schema validator (simplified)\n */\nfunction validateJsonSchema(doc, schema) {\n\t// Basic JSON Schema validation\n\tif (schema.type) {\n\t\tconst docType = isArray(doc) ? 'array' : (doc === null ? 'null' : typeof doc);\n\t\tif (schema.type !== docType) return false;\n\t}\n\t\n\tif (schema.required && isArray(schema.required)) {\n\t\tfor (let i = 0; i < schema.required.length; i++) {\n\t\t\tif (!(schema.required[i] in doc)) return false;\n\t\t}\n\t}\n\t\n\tif (schema.properties) {\n\t\tfor (const key in schema.properties) {\n\t\t\t// When using $jsonSchema as a query operator, properties must exist to match\n\t\t\t// (This is different from standard JSON Schema validation where properties are optional)\n\t\t\tif (!(key in doc)) return false;\n\t\t\t\n\t\t\tconst propSchema = schema.properties[key];\n\t\t\tif (!validateJsonSchema(doc[key], propSchema)) return false;\n\t\t}\n\t}\n\t\n\tif (schema.minimum !== undefined && typeof doc === 'number') {\n\t\tif (doc < schema.minimum) return false;\n\t}\n\t\n\tif (schema.maximum !== undefined && typeof doc === 'number') {\n\t\tif (doc > schema.maximum) return false;\n\t}\n\t\n\tif (schema.minLength !== undefined && typeof doc === 'string') {\n\t\tif (doc.length < schema.minLength) return false;\n\t}\n\t\n\tif (schema.maxLength !== undefined && typeof doc === 'string') {\n\t\tif (doc.length > schema.maxLength) return false;\n\t}\n\t\n\tif (schema.pattern && typeof doc === 'string') {\n\t\tconst regex = new RegExp(schema.pattern);\n\t\tif (!regex.test(doc)) return false;\n\t}\n\t\n\tif (schema.enum && isArray(schema.enum)) {\n\t\tif (!schema.enum.includes(doc)) return false;\n\t}\n\t\n\treturn true;\n}\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId && b instanceof ObjectId) {\n    return a.equals(b);\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Compare two values with a comparison operator, handling ObjectId instances\n */\nfunction compareValues(a, b, operator) {\n\t// Convert ObjectIds to comparable values (use timestamp for ordering)\n\tlet aVal = a;\n\tlet bVal = b;\n\t\n\tif (a instanceof ObjectId) {\n\t\taVal = a.toString();\n\t}\n\tif (b instanceof ObjectId) {\n\t\tbVal = b.toString();\n\t}\n\t\n\tswitch(operator) {\n\t\tcase '>': return aVal > bVal;\n\t\tcase '>=': return aVal >= bVal;\n\t\tcase '<': return aVal < bVal;\n\t\tcase '<=': return aVal <= bVal;\n\t\tdefault: return false;\n\t}\n}\n\n/**\n * Check if a field value (possibly from array traversal) matches a condition\n * Handles both single values and arrays of values (from array traversal)\n */\nfunction fieldValueMatches(fieldValue, checkFn) {\n\t// Use strict equality to allow null values through\n\tif (fieldValue === undefined) return false;\n\t\n\t// Check for null before isArray to avoid crash\n\tif (fieldValue === null) return checkFn(fieldValue);\n\t\n\t// If fieldValue is an array (from array traversal), check if ANY element matches\n\tif (isArray(fieldValue)) {\n\t\tfor (var i = 0; i < fieldValue.length; i++) {\n\t\t\tif (checkFn(fieldValue[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Otherwise check the single value\n\treturn checkFn(fieldValue);\n}\n\n/**\n * Tokenize text for search\n */\nfunction tokenizeText(text) {\n\tif (typeof text !== 'string') return [];\n\n  const words = tokenize(text);\n\treturn words.map(w => stemmer(w));\n}\n\n/**\n * Text search helper\n * Matches if the property contains tokens from the query\n */\nexport function text(prop, queryText) {\n\tif (typeof prop !== 'string') return false;\n\t\n\tconst propTokens = new Set(tokenizeText(prop));\n\tconst queryTokens = tokenizeText(queryText);\n\t\n\t// Match if any query term is in the document\n\treturn queryTokens.some(term => propTokens.has(term));\n}\n\n/**\n * Geo within helper - using bounding box logic instead of de9im\n * This is a simpler implementation that doesn't require de9im dependency\n */\nexport function geoWithin(prop, query) {\n\ttry {\n\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\tif (!Array.isArray(query) || query.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst minLon = query[0][0];\n\t\tconst maxLat = query[0][1];\n\t\tconst maxLon = query[1][0];\n\t\tconst minLat = query[1][1];\n\n\t\t// Check if geometry is within bounding box\n\t\treturn isGeometryWithinBBox(prop, minLon, maxLon, minLat, maxLat);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if a GeoJSON geometry is within a bounding box\n * For Points: checks if the point is within the bbox\n * For Polygons: checks if ALL vertices are within the bbox\n */\nfunction isGeometryWithinBBox(geoJson, minLon, maxLon, minLat, maxLat) {\n\tif (!geoJson) return false;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t// All features must be within the bbox\n\t\tfor (const feature of geoJson.features) {\n\t\t\tif (feature.geometry) {\n\t\t\t\tif (!isGeometryWithinBBox(feature.geometry, minLon, maxLon, minLat, maxLat)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn isGeometryWithinBBox(geoJson.geometry, minLon, maxLon, minLat, maxLat);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn lng >= minLon && lng <= maxLon && lat >= minLat && lat <= maxLat;\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - ALL vertices must be within the bbox\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tfor (const ring of geoJson.coordinates) {\n\t\t\tfor (const coord of ring) {\n\t\t\t\tconst lng = coord[0];\n\t\t\t\tconst lat = coord[1];\n\t\t\t\tif (lng < minLon || lng > maxLon || lat < minLat || lat > maxLat) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Extract coordinates from a GeoJSON object for indexing purposes\n * This uses centroid for polygons to get a single point to index\n * @param {Object} geoJson - The GeoJSON object\n * @returns {Object|null} Object with lat and lng, or null if invalid\n */\nfunction extractCoordinatesFromGeoJSON(geoJson) {\n\tif (!geoJson) return null;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\tconst feature = geoJson.features[0];\n\t\tif (feature.geometry) {\n\t\t\treturn extractCoordinatesFromGeoJSON(feature.geometry);\n\t\t}\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn extractCoordinatesFromGeoJSON(geoJson.geometry);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn { lat, lng };\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - use centroid of first coordinate ring\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tconst ring = geoJson.coordinates[0];\n\t\tif (ring.length > 0) {\n\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\tfor (const coord of ring) {\n\t\t\t\tsumLng += coord[0];\n\t\t\t\tsumLat += coord[1];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\tlng: sumLng / ring.length\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Calculate haversine distance between two points in kilometers\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = \n\t\tMath.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Check if a point is within a certain distance (in meters) of a reference point\n */\nfunction isNear(geoJson, refLng, refLat, maxDistanceMeters) {\n\tconst coords = extractCoordinatesFromGeoJSON(geoJson);\n\tif (!coords) return false;\n\tconst distanceKm = haversineDistance(coords.lat, coords.lng, refLat, refLng);\n\tconst distanceM = distanceKm * 1000;\n\treturn distanceM <= maxDistanceMeters;\n}\n\n/**\n * Check if geometries intersect (simple implementation)\n */\nfunction geoIntersects(geoJson, queryGeo) {\n\tif (!geoJson || !queryGeo) return false;\n\t\n\t// Get coordinates from query geometry\n\tconst queryCoords = extractCoordinatesFromGeoJSON(queryGeo);\n\tif (!queryCoords) return false;\n\t\n\t// Get coordinates from document geometry\n\tconst docCoords = extractCoordinatesFromGeoJSON(geoJson);\n\tif (!docCoords) return false;\n\t\n\t// For now, simple point-in-polygon check for polygons\n\t// If query is a polygon, check if document point is inside\n\tif (queryGeo.type === 'Polygon' && geoJson.type === 'Point') {\n\t\treturn pointInPolygon(docCoords.lng, docCoords.lat, queryGeo.coordinates[0]);\n\t}\n\t\n\t// If document is a polygon and query is a point, check if point is inside\n\tif (geoJson.type === 'Polygon' && queryGeo.type === 'Point') {\n\t\tconst queryPt = queryGeo.coordinates;\n\t\treturn pointInPolygon(queryPt[0], queryPt[1], geoJson.coordinates[0]);\n\t}\n\t\n\t// For points, check if they're the same or very close\n\tif (geoJson.type === 'Point' && queryGeo.type === 'Point') {\n\t\tconst dist = haversineDistance(docCoords.lat, docCoords.lng, queryCoords.lat, queryCoords.lng);\n\t\treturn dist < 0.001; // Within about 1 meter\n\t}\n\t\n\treturn false;\n}\n\n/**\n * Point-in-polygon test using ray casting algorithm\n */\nfunction pointInPolygon(lng, lat, ring) {\n\tlet inside = false;\n\tfor (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n\t\tconst xi = ring[i][0], yi = ring[i][1];\n\t\tconst xj = ring[j][0], yj = ring[j][1];\n\t\tconst intersect = ((yi > lat) !== (yj > lat)) && (lng < (xj - xi) * (lat - yi) / (yj - yi) + xi);\n\t\tif (intersect) inside = !inside;\n\t}\n\treturn inside;\n}\n\n/**\n * $where operator implementation\n * SECURITY NOTE: This uses Function constructor which can execute arbitrary code.\n * This is acceptable for a local/in-memory database but should NOT be used\n * in environments where untrusted user input is processed.\n */\nexport function where(doc, value) {\n\tif (typeof value === 'function') {\n\t\ttry {\n\t\t\treturn value.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t} else if (typeof value === 'string') {\n\t\t// Evaluate the string as a function\n\t\ttry {\n\t\t\tvar fn = new Function('return ' + value);\n\t\t\treturn fn.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Top-level match function\n */\nexport function tlMatches(doc, query) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return and(doc, value);\n\t\telse if (key == \"$or\") return or(doc, value);\n\t\telse if (key == \"$not\") return not(doc, value);\n\t\telse if (key == \"$nor\") return nor(doc, value);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse if (key == \"$comment\") return true; // $comment is metadata, doesn't filter\n\t\telse if (key == \"$jsonSchema\") return validateJsonSchema(doc, value); // Top-level schema validation\n\t\telse if (key == \"$expr\") {\n\t\t\t// Handle $expr at top level\n\t\t\ttry {\n\t\t\t\treturn evaluateExpression(value, doc);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatches(doc, key, value);\n\t}\n}\n\n/**\n * Operator match function\n */\nexport function opMatches(doc, key, value) {\n\t// Get field value using array-aware traversal\n\tvar fieldValue = getFieldValues(doc, key);\n\t\n\tif (typeof (value) == \"string\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"number\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"boolean\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (value instanceof ObjectId) return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return fieldValue != undefined && fieldValueMatches(fieldValue, function(v) { return v && v.match(value); });\n\t\telse if (isArray(value)) return fieldValue != undefined && fieldValueMatches(fieldValue, function(v) { return v && arrayMatches(v, value); });\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = Object.keys(value)[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '>'); })) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '>='); })) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '<'); })) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '<='); })) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return !valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (fieldValueMatches(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$exists\") {\n\t\t\t\t\t\t// For $exists, we need to use getProp which returns undefined if field doesn't exist\n\t\t\t\t\t\t// getFieldValues might return an array which would be truthy\n\t\t\t\t\tvar rawValue = getProp(doc, key);\n\t\t\t\t\tif (operand ? rawValue == undefined : rawValue != undefined) return false;\n\t\t\t\t} else if (operator == \"$type\") {\n\t\t\t\t\t// Support both BSON type codes and aliases\n\t\t\t\t\t// Note: $type checks the field value itself, not array elements\n\t\t\t\t\t// If field doesn't exist (undefined), it can only match type 'undefined' (6)\n\t\t\t\t\tif (fieldValue === undefined) {\n\t\t\t\t\t\tconst expectedTypeCode = typeof operand === 'number' ? operand : TYPE_ALIASES[operand];\n\t\t\t\t\t\tif (expectedTypeCode !== 6) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!matchesType(fieldValue, operand)) return false;\n\t\t\t\t\t}\n\t\t\t\t} else if (operator == \"$mod\") {\n\t\t\t\t\tif (operand.length != 2) throw { $err: \"Can't canonicalize query: BadValue malformed mod, not enough elements\", code: 17287 };\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && (v % operand[0] == operand[1]); })) return false;\n\t\t\t\t} else if (operator == \"$regex\") {\n\t\t\t\t\t// Support string pattern with optional $options\n\t\t\t\t\tvar pattern = operand;\n\t\t\t\t\tvar flags = value.$options || '';\n\t\t\t\t\tvar regex = (typeof pattern === 'string') ? new RegExp(pattern, flags) : pattern;\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && regex.test(v); })) return false;\n\t\t\t\t} else if (operator == \"$options\") {\n\t\t\t\t\t// $options is handled with $regex, skip here\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (operator == \"$text\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && text(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$expr\") {\n\t\t\t\t\t// Evaluate aggregation expression against the document\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = evaluateExpression(operand, doc);\n\t\t\t\t\t\tif (!result) return false;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// If expression evaluation fails, don't match\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (operator == \"$geoWithin\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && geoWithin(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$near\" || operator == \"$nearSphere\") {\n\t\t\t\t\t\t// Handle $near and $nearSphere with distance calculation\n\t\t\t\t\t\tlet coordinates;\n\t\t\t\t\t\tif (operand.$geometry) {\n\t\t\t\t\t\t\tcoordinates = operand.$geometry.coordinates;\n\t\t\t\t\t\t} else if (operand.coordinates) {\n\t\t\t\t\t\t\tcoordinates = operand.coordinates;\n\t\t\t\t\t\t} else if (Array.isArray(operand)) {\n\t\t\t\t\t\t\tcoordinates = operand;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (coordinates && coordinates.length >= 2) {\n\t\t\t\t\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\t\t\t\tconst maxDistanceMeters = operand.$maxDistance || 1000000; // Default to 1000km\n\t\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && isNear(v, lng, lat, maxDistanceMeters); })) return false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$geoIntersects\") {\n\t\t\t\t\t\t// Handle $geoIntersects\n\t\t\t\t\t\tconst geometry = operand.$geometry || operand;\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && geoIntersects(v, geometry); })) return false;\n\t\t\t\t\t} else if (operator == \"$not\") {\n\t\t\t\t\t\tif (opMatches(doc, key, operand)) return false;\n\t\t\t\t\t} else if (operator == \"$all\") {\n\t\t\t\t\t\t// $all requires the field to be an array, use getProp not getFieldValues\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < operand.length; j++) {\n\t\t\t\t\t\t\tif (!isIn(operand[j], arrayFieldValue)) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\t// $elemMatch requires the field to be an array, use getProp not getFieldValues\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor (var j = 0; j < arrayFieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = arrayFieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && !(element == opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && !(element != opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$in\" && !isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$nin\" && isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found) return false;\n\t\t\t\t} else if (operator == \"$size\") {\n\t\t\t\t\tvar sizeFieldValue = getProp(doc, key);\n\t\t\t\t\tif (sizeFieldValue == undefined || !isArray(sizeFieldValue)) return false;\n\t\t\t\t\tif (sizeFieldValue.length != operand) return false;\n\t\t\t\t} else if (operator == \"$bitsAllSet\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAllSet(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAllClear\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAllClear(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAnySet\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAnySet(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAnyClear\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAnyClear(v, operand); })) return false;\n\t\t\t\t} else {\n\t\t\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue unknown operator: \" + operator, code: 17287 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn getProp(doc, key) && objectMatches(getProp(doc, key), value);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * $not operator\n */\nexport function not(doc, value) {\n\treturn !tlMatches(doc, value);\n}\n\n/**\n * $and operator\n */\nexport function and(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatches(doc, els[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * $or operator\n */\nexport function or(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return true;\n\t}\n\treturn false;\n}\n\n/**\n * $nor operator\n */\nexport function nor(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Main matches function - query structure: (top level operators ( \"age\" : (operators) ))\n * top, top level query, implicit $and\n */\nexport function matches(doc, query) {\n\treturn and(doc, toArray(query));\n}\n\n/**\n * Enhanced matching function that also tracks which array index matched for positional operator ($)\n * Returns an object with:\n *   - matched: boolean indicating if the query matched\n *   - arrayFilters: object mapping field paths to the first matched array index\n * \n * Example: if query is { \"grades\": { $gte: 85 } } and doc is { grades: [80, 90, 85] }\n * Returns: { matched: true, arrayFilters: { \"grades\": 1 } } (index 1 is 90, first to match)\n */\nexport function matchWithArrayIndices(doc, query) {\n\tconst arrayFilters = {};\n\tconst matched = andWithTracking(doc, toArray(query), arrayFilters);\n\treturn { matched, arrayFilters };\n}\n\n/**\n * Helper to track array indices during AND matching\n */\nfunction andWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Top level match with tracking\n */\nfunction tlMatchesWithTracking(doc, query, arrayFilters) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return andWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$or\") return orWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$not\") {\n\t\t\t// For $not, we don't track positions as it's a negation\n\t\t\treturn !tlMatches(doc, value);\n\t\t}\n\t\telse if (key == \"$nor\") return norWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse if (key == \"$comment\") return true;\n\t\telse if (key == \"$jsonSchema\") return validateJsonSchema(doc, value);\n\t\telse if (key == \"$expr\") {\n\t\t\ttry {\n\t\t\t\treturn evaluateExpression(value, doc);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatchesWithTracking(doc, key, value, arrayFilters);\n\t}\n}\n\n/**\n * OR operator with tracking - track positions from the first matching clause\n */\nfunction orWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * NOR operator with tracking\n */\nfunction norWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Operator match with array index tracking\n */\nfunction opMatchesWithTracking(doc, key, value, arrayFilters) {\n\t// Get the base field (before any dots)\n\tconst baseField = key.split('.')[0];\n\tconst fieldValue = getFieldValues(doc, key);\n\t\n\t// Helper to track which index matched\n\tconst trackMatchingIndex = (fieldValue, checkFn) => {\n\t\tif (fieldValue === undefined) return false;\n\t\tif (fieldValue === null) return checkFn(fieldValue);\n\t\t\n\t\t// If fieldValue is an array from array traversal\n\t\tif (isArray(fieldValue)) {\n\t\t\t// Check if the base field itself is an array in the document\n\t\t\tconst baseValue = getProp(doc, baseField);\n\t\t\tif (isArray(baseValue)) {\n\t\t\t\t// Find first matching index\n\t\t\t\tfor (var i = 0; i < fieldValue.length; i++) {\n\t\t\t\t\tif (checkFn(fieldValue[i])) {\n\t\t\t\t\t\t// Track this as the matched index for this field\n\t\t\t\t\t\tarrayFilters[key] = i;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Otherwise use regular matching\n\t\treturn fieldValueMatches(fieldValue, checkFn);\n\t};\n\t\n\t// Now perform the actual matching with tracking\n\tif (typeof (value) == \"string\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"number\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"boolean\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (value instanceof ObjectId) return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return v && v.match(value); });\n\t\telse if (isArray(value)) return fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return v && arrayMatches(v, value); });\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\t// Handle operators\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = keys[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '>'); })) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '>='); })) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '<'); })) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '<='); })) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return !valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (trackMatchingIndex(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\t// Special handling for $elemMatch\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < arrayFieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = arrayFieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tarrayFilters[key] = j;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && element != opValue) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && element == opValue) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tarrayFilters[key] = j;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For other operators, use standard matching\n\t\t\t\t\t\tif (!opMatches(doc, key, value)) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// Object equality\n\t\t\t\treturn fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return objectMatches(v, value); });\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n","/**\n * Timestamp class - MongoDB-compatible BSON Timestamp\n * A 64-bit value where the high 32 bits represent seconds since Unix epoch\n * and the low 32 bits represent an incrementing ordinal\n */\nexport class Timestamp {\n  constructor(low, high) {\n    if (arguments.length === 0) {\n      // Generate new timestamp with current time\n      this.low = 0;\n      this.high = Math.floor(Date.now() / 1000);\n    } else if (arguments.length === 1) {\n      // Handle object with low/high properties\n      if (typeof low === 'object' && low !== null) {\n        this.low = low.low || 0;\n        this.high = low.high || 0;\n      } else {\n        // Single argument - use as high (seconds)\n        this.low = 0;\n        this.high = low;\n      }\n    } else {\n      // Two arguments: low (increment) and high (seconds)\n      this.low = low >>> 0; // Ensure unsigned 32-bit integer\n      this.high = high >>> 0; // Ensure unsigned 32-bit integer\n    }\n  }\n\n  /**\n   * Returns the timestamp in a comparable form\n   */\n  valueOf() {\n    return this.high * 0x100000000 + this.low;\n  }\n\n  /**\n   * Returns the timestamp as a string\n   */\n  toString() {\n    return `Timestamp(${this.high}, ${this.low})`;\n  }\n\n  /**\n   * Returns the timestamp as a JSON object\n   */\n  toJSON() {\n    return {\n      $timestamp: {\n        t: this.high,\n        i: this.low\n      }\n    };\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return this.toString();\n  }\n\n  /**\n   * Compares this Timestamp with another for equality\n   */\n  equals(other) {\n    if (!other) return false;\n    \n    if (other instanceof Timestamp) {\n      return this.low === other.low && this.high === other.high;\n    }\n    \n    if (typeof other === 'object' && other.low !== undefined && other.high !== undefined) {\n      return this.low === other.low && this.high === other.high;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get the seconds part of the timestamp\n   */\n  getHighBits() {\n    return this.high;\n  }\n\n  /**\n   * Get the increment part of the timestamp\n   */\n  getLowBits() {\n    return this.low;\n  }\n\n  /**\n   * Returns a Date object representing the timestamp\n   */\n  toDate() {\n    return new Date(this.high * 1000);\n  }\n\n  /**\n   * Creates a Timestamp from a Date object\n   */\n  static fromDate(date) {\n    const seconds = Math.floor(date.getTime() / 1000);\n    return new Timestamp(0, seconds);\n  }\n\n  /**\n   * Creates a Timestamp for the current time\n   */\n  static now() {\n    return new Timestamp();\n  }\n}\n","/**\n * Update operations module\n */\n\nimport { setProp, getProp, isArray } from './utils.js';\nimport { opMatches, matches } from './queryMatcher.js';\nimport { Timestamp } from './Timestamp.js';\n\n/**\n * Extract identifier from a filtered positional operator pattern like $[identifier]\n * Returns null if not a filtered positional operator\n */\nfunction extractFilteredPositionalIdentifier(pathSegment) {\n\tconst match = pathSegment.match(/^\\$\\[([^\\]]+)\\]$/);\n\treturn match ? match[1] : null;\n}\n\n/**\n * Parse a field path and extract filtered positional identifiers\n * Returns an array of path segments with metadata about which are filtered positional operators\n */\nfunction parseFieldPath(fieldPath) {\n\tconst segments = fieldPath.split('.');\n\treturn segments.map(segment => {\n\t\tconst identifier = extractFilteredPositionalIdentifier(segment);\n\t\treturn {\n\t\t\tsegment: segment,\n\t\t\tisFilteredPositional: identifier !== null,\n\t\t\tidentifier: identifier\n\t\t};\n\t});\n}\n\n/**\n * Apply an update operation to array elements matching arrayFilters\n */\nfunction applyToFilteredArrayElements(doc, parsedPath, value, operation, arrayFilters) {\n\t// Navigate through the path and apply updates to matching array elements\n\tfunction traverse(current, pathIndex, filterContext) {\n\t\tif (pathIndex >= parsedPath.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pathInfo = parsedPath[pathIndex];\n\t\tconst isLastSegment = pathIndex === parsedPath.length - 1;\n\n\t\tif (pathInfo.isFilteredPositional) {\n\t\t\t// This is a filtered positional operator like $[elem]\n\t\t\tconst identifier = pathInfo.identifier;\n\t\t\tconst filter = arrayFilters ? arrayFilters.find(f => {\n\t\t\t\t// Find the filter that uses this identifier\n\t\t\t\tconst filterKeys = Object.keys(f);\n\t\t\t\treturn filterKeys.some(key => key.startsWith(identifier + '.') || key === identifier);\n\t\t\t}) : null;\n\n\t\t\t// If arrayFilters is not provided, treat $[identifier] as a literal field name\n\t\t\tif (!arrayFilters) {\n\t\t\t\tif (!current[pathInfo.segment]) {\n\t\t\t\t\t// Create intermediate object/array as needed\n\t\t\t\t\tconst nextPath = parsedPath[pathIndex + 1];\n\t\t\t\t\tif (nextPath && nextPath.isFilteredPositional) {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t\t} else {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isArray(current)) {\n\t\t\t\t// If current is not an array, create it as an object property\n\t\t\t\tif (!current[pathInfo.segment]) {\n\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t}\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t\t} else {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Iterate through array elements and apply to matching ones\n\t\t\tfor (let i = 0; i < current.length; i++) {\n\t\t\t\tconst element = current[i];\n\t\t\t\t\n\t\t\t\t// Check if this element matches the filter\n\t\t\t\tlet shouldUpdate = true;\n\t\t\t\tif (filter) {\n\t\t\t\t\t// Transform filter to check against the element\n\t\t\t\t\t// If filter has identifier.field, check element.field\n\t\t\t\t\t// If filter has just identifier, check element directly\n\t\t\t\t\tlet transformedFilter = {};\n\t\t\t\t\tlet hasDirectMatch = false;\n\t\t\t\t\t\n\t\t\t\t\tObject.keys(filter).forEach(key => {\n\t\t\t\t\t\tif (key.startsWith(identifier + '.')) {\n\t\t\t\t\t\t\t// Replace \"identifier.field\" with just \"field\" for matching against element\n\t\t\t\t\t\t\tconst fieldPath = key.substring(identifier.length + 1);\n\t\t\t\t\t\t\ttransformedFilter[fieldPath] = filter[key];\n\t\t\t\t\t\t} else if (key === identifier) {\n\t\t\t\t\t\t\t// Direct identifier match - the filter condition applies to the element value itself\n\t\t\t\t\t\t\ttransformedFilter = filter[key];\n\t\t\t\t\t\t\thasDirectMatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Check if element matches the filter\n\t\t\t\t\tif (hasDirectMatch) {\n\t\t\t\t\t\t// For primitive values, we need to check against the condition directly\n\t\t\t\t\t\t// Create a wrapper to use the matches function\n\t\t\t\t\t\tconst testDoc = { value: element };\n\t\t\t\t\t\tconst testFilter = { value: transformedFilter };\n\t\t\t\t\t\tshouldUpdate = matches(testDoc, testFilter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For object properties, match against the element as a document\n\t\t\t\t\t\tshouldUpdate = matches(element, transformedFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldUpdate) {\n\t\t\t\t\tif (isLastSegment) {\n\t\t\t\t\t\t// Apply the operation to this array element\n\t\t\t\t\t\tapplyOperationToValue(current, i, value, operation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Continue traversing deeper\n\t\t\t\t\t\tif (element !== null && element !== undefined) {\n\t\t\t\t\t\t\ttraverse(current[i], pathIndex + 1, filterContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Regular path segment\n\t\t\tif (current[pathInfo.segment] === undefined || current[pathInfo.segment] === null) {\n\t\t\t\tif (!isLastSegment) {\n\t\t\t\t\t// Create intermediate object/array\n\t\t\t\t\tconst nextPath = parsedPath[pathIndex + 1];\n\t\t\t\t\tif (nextPath && nextPath.isFilteredPositional) {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isLastSegment) {\n\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t} else {\n\t\t\t\tif (current[pathInfo.segment] !== undefined && current[pathInfo.segment] !== null) {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(doc, 0, {});\n}\n\n/**\n * Apply a specific operation to a value (for use with filtered positional operators)\n */\nfunction applyOperationToValue(container, key, value, operation) {\n\tswitch (operation) {\n\t\tcase '$set':\n\t\t\tcontainer[key] = value;\n\t\t\tbreak;\n\t\tcase '$inc':\n\t\t\tif (container[key] === undefined) container[key] = 0;\n\t\t\tcontainer[key] += value;\n\t\t\tbreak;\n\t\tcase '$mul':\n\t\t\tcontainer[key] = container[key] * value;\n\t\t\tbreak;\n\t\tcase '$min':\n\t\t\tcontainer[key] = Math.min(container[key], value);\n\t\t\tbreak;\n\t\tcase '$max':\n\t\t\tcontainer[key] = Math.max(container[key], value);\n\t\t\tbreak;\n\t\tcase '$unset':\n\t\t\tdelete container[key];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontainer[key] = value;\n\t}\n}\n\n/**\n * Check if a field path contains a filtered positional operator\n */\nfunction hasFilteredPositionalOperator(fieldPath) {\n\treturn /\\$\\[[^\\]]+\\]/.test(fieldPath);\n}\n\n/**\n * Deep equality check for objects\n */\nfunction objectEquals(a, b) {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\t\n\t// Handle arrays\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\tfor (var i = 0; i < a.length; i++) {\n\t\t\tif (!objectEquals(a[i], b[i])) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t// Handle dates\n\tif (a instanceof Date && b instanceof Date) {\n\t\treturn a.getTime() === b.getTime();\n\t}\n\t\n\t// One is array, the other is not\n\tif (Array.isArray(a) !== Array.isArray(b)) return false;\n\t\n\tvar keysA = Object.keys(a);\n\tvar keysB = Object.keys(b);\n\t\n\tif (keysA.length !== keysB.length) return false;\n\t\n\tfor (var i = 0; i < keysA.length; i++) {\n\t\tvar key = keysA[i];\n\t\tif (!keysB.includes(key)) return false;\n\t\tif (!objectEquals(a[key], b[key])) return false;\n\t}\n\t\n\treturn true;\n}\n\n/**\n * Check if a field path contains the $[] positional operator\n */\nfunction hasAllPositional(field) {\n\treturn field.indexOf('$[]') !== -1;\n}\n\n/**\n * Apply an update function to all elements matching $[] operator\n * This is used for operators like $inc, $mul that need to read-modify-write\n */\nfunction applyToAllPositional(doc, field, updateFn) {\n\tvar path = field.split(\".\");\n\tvar current = doc;\n\t\n\t// Navigate to the first $[] operator\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\t\n\t\tif (pathSegment === '$[]') {\n\t\t\t// Current should be an array\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\treturn; // Skip if not an array\n\t\t\t}\n\t\t\t\n\t\t\t// Build the remaining path after this $[]\n\t\t\tvar remainingPath = path.slice(i + 1).join('.');\n\t\t\t\n\t\t\t// Process each array element\n\t\t\tfor (var j = 0; j < current.length; j++) {\n\t\t\t\tif (remainingPath) {\n\t\t\t\t\t// There's more path after $[], recursively apply\n\t\t\t\t\tif (remainingPath.indexOf('$[]') !== -1) {\n\t\t\t\t\t\t// Nested $[] operator\n\t\t\t\t\t\tapplyToAllPositional(current[j], remainingPath, updateFn);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No more $[], apply the update function\n\t\t\t\t\t\tvar currentValue = getProp(current[j], remainingPath);\n\t\t\t\t\t\tvar newValue = updateFn(currentValue);\n\t\t\t\t\t\tsetProp(current[j], remainingPath, newValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// $[] is the last segment, apply to each element directly\n\t\t\t\t\tcurrent[j] = updateFn(current[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Navigate to next level\n\t\tif (current == null || current == undefined) return;\n\t\tcurrent = current[pathSegment];\n\t}\n}\n\n/**\n * Replace $ positional operator in a field path with the matched array index\n * \n * @param {string} fieldPath - The field path potentially containing $\n * @param {object} arrayFilters - Map of field paths to matched array indices\n * @returns {string} The field path with $ replaced by the matched index\n */\nfunction replacePositionalOperator(fieldPath, arrayFilters) {\n\tif (!arrayFilters || !fieldPath.includes('$')) {\n\t\treturn fieldPath;\n\t}\n\t\n\t// Split the path to find the $ placeholder\n\tconst parts = fieldPath.split('.');\n\tconst dollarIndex = parts.indexOf('$');\n\t\n\tif (dollarIndex === -1) {\n\t\treturn fieldPath;\n\t}\n\t\n\t// Build the field path up to the $\n\tconst pathBeforeDollar = parts.slice(0, dollarIndex).join('.');\n\t\n\t// Find the matched index for this field path\n\t// We need to check if we have a match for the field before $\n\tlet matchedIndex = null;\n\t\n\t// Try to find a matching filter by checking various possible field paths\n\t// The query could be on the array itself or a nested field\n\tfor (const filterPath in arrayFilters) {\n\t\t// Check if the filter path matches the beginning of our field path\n\t\tif (filterPath === pathBeforeDollar || filterPath.startsWith(pathBeforeDollar + '.')) {\n\t\t\tmatchedIndex = arrayFilters[filterPath];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// If we found a matched index, replace $ with it\n\tif (matchedIndex !== null && matchedIndex !== undefined) {\n\t\tparts[dollarIndex] = matchedIndex.toString();\n\t\treturn parts.join('.');\n\t}\n\t\n\t// If no matched index found, return original path (update will likely be a no-op)\n\treturn fieldPath;\n}\n\n/**\n * Apply update operators to a document\n * \n * @param {object} updates - The update operators to apply\n * @param {object} doc - The document to update\n * @param {boolean} setOnInsert - Whether to apply $setOnInsert\n * @param {object} arrayFilters - Optional map of field paths to matched array indices for $ operator\n */\nexport function applyUpdates(updates, doc, setOnInsert, positionalMatchInfo, userArrayFilters) {\n\tvar keys = Object.keys(updates);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar value = updates[key];\n\t\tif (key == \"$inc\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$inc', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn (val === undefined ? 0 : val) + amount;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tif (currentValue == undefined) currentValue = 0;\n\t\t\t\t\tsetProp(doc, field, currentValue + amount);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$mul\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$mul', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn val * amount;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tif (currentValue == undefined) currentValue = 0;\n\t\t\t\t\tsetProp(doc, field, currentValue * amount);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$rename\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar newName = replacePositionalOperator(value[fields[j]], positionalMatchInfo);\n\t\t\t\tdoc[newName] = doc[field];\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$setOnInsert\" && setOnInsert) {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tdoc[field] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$set\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, value[fields[j]], '$set', userArrayFilters);\n\t\t\t\t} else {\n\t\t\t\t\tsetProp(doc, field, value[fields[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$unset\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$min\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$min', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn Math.min(val, amount);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tsetProp(doc, field, Math.min(currentValue, amount));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$max\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$max', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn Math.max(val, amount);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tsetProp(doc, field, Math.max(currentValue, amount));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$currentDate\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar typeSpec = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Handle boolean true or { $type: \"date\" }\n\t\t\t\tif (typeSpec === true || (typeof typeSpec === 'object' && typeSpec.$type === 'date')) {\n\t\t\t\t\tsetProp(doc, field, new Date());\n\t\t\t\t}\n\t\t\t\t// Handle { $type: \"timestamp\" }\n\t\t\t\telse if (typeof typeSpec === 'object' && typeSpec.$type === 'timestamp') {\n\t\t\t\t\tsetProp(doc, field, new Timestamp());\n\t\t\t\t}\n\t\t\t\t// Default to Date for backwards compatibility\n\t\t\t\telse {\n\t\t\t\t\tsetProp(doc, field, new Date());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$addToSet\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar addValue = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tcurrentArray.push(addValue);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pop\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar popValue = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tif (popValue == 1) {\n\t\t\t\t\t\tcurrentArray.pop();\n\t\t\t\t\t} else if (popValue == -1) {\n\t\t\t\t\t\tcurrentArray.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pull\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar condition = value[fields[j]];\n\t\t\t\tvar src = getProp(doc, field);\n\t\t\t\t\n\t\t\t\t// Skip if field doesn't exist or is not an array\n\t\t\t\tif (src == undefined || !Array.isArray(src)) continue;\n\t\t\t\t\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar element = src[k];\n\t\t\t\t\tvar shouldRemove = false;\n\t\t\t\t\t\n\t\t\t\t\t// Determine how to match the condition against the element\n\t\t\t\t\tif (typeof condition === 'object' && condition !== null && !Array.isArray(condition)) {\n\t\t\t\t\t\t// Condition is an object (could be a query or a value to match)\n\t\t\t\t\t\tif (typeof element === 'object' && element !== null && !Array.isArray(element)) {\n\t\t\t\t\t\t\t// Element is also an object - use query matching\n\t\t\t\t\t\t\t// This handles both {price: null}, {name: \"test\"}, and {price: {$gte: 10}}\n\t\t\t\t\t\t\tshouldRemove = matches(element, condition);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Element is a primitive but condition is an object with operators like {$gte: 5}\n\t\t\t\t\t\t\tvar tempDoc = { __temp: element };\n\t\t\t\t\t\t\tshouldRemove = opMatches(tempDoc, \"__temp\", condition);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Condition is a simple value (string, number, boolean, null, etc.)\n\t\t\t\t\t\t// Do direct comparison\n\t\t\t\t\t\tshouldRemove = element == condition;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!shouldRemove) notRemoved.push(element);\n\t\t\t\t}\n\t\t\t\tsetProp(doc, field, notRemoved);\n\t\t\t}\n\t\t} else if (key == \"$pullAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar src = getProp(doc, field);\n\t\t\t\tvar toRemove = value[fields[j]];\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar removed = false;\n\t\t\t\t\tfor (var l = 0; l < toRemove.length; l++) {\n\t\t\t\t\t\tif (src[k] == toRemove[l]) {\n\t\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!removed) notRemoved.push(src[k]);\n\t\t\t\t}\n\t\t\t\tsetProp(doc, field, notRemoved);\n\t\t\t}\n\t\t} else if (key == \"$pushAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar values = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tfor (var k = 0; k < values.length; k++) {\n\t\t\t\t\t\tcurrentArray.push(values[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$push\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar pushValue = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this is a modifier-based push\n\t\t\t\tvar isModifierPush = pushValue !== null && typeof pushValue === 'object' && \n\t\t\t\t\t(pushValue.$each !== undefined || pushValue.$position !== undefined || \n\t\t\t\t\t pushValue.$slice !== undefined || pushValue.$sort !== undefined);\n\t\t\t\t\n\t\t\t\tif (isModifierPush) {\n\t\t\t\t\t// Initialize array if it doesn't exist\n\t\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\t\tif (!currentArray) {\n\t\t\t\t\t\tcurrentArray = [];\n\t\t\t\t\t\tsetProp(doc, field, currentArray);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Get the values to push (either from $each or wrap single value)\n\t\t\t\t\tvar valuesToPush = pushValue.$each !== undefined ? pushValue.$each : [pushValue];\n\t\t\t\t\t\n\t\t\t\t\t// Get position (default to end of array)\n\t\t\t\t\tvar position = pushValue.$position !== undefined ? pushValue.$position : currentArray.length;\n\t\t\t\t\t\n\t\t\t\t\t// Handle negative position (from end)\n\t\t\t\t\tif (position < 0) {\n\t\t\t\t\t\tposition = Math.max(0, currentArray.length + position);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Insert values at specified position\n\t\t\t\t\tcurrentArray.splice(position, 0, ...valuesToPush);\n\t\t\t\t\t\n\t\t\t\t\t// Apply $sort if specified\n\t\t\t\t\tif (pushValue.$sort !== undefined) {\n\t\t\t\t\t\tvar sortSpec = pushValue.$sort;\n\t\t\t\t\t\tif (typeof sortSpec === 'number') {\n\t\t\t\t\t\t\t// Simple numeric sort\n\t\t\t\t\t\t\tcurrentArray.sort(function(a, b) {\n\t\t\t\t\t\t\t\tif (a < b) return sortSpec > 0 ? -1 : 1;\n\t\t\t\t\t\t\t\tif (a > b) return sortSpec > 0 ? 1 : -1;\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (typeof sortSpec === 'object') {\n\t\t\t\t\t\t\t// Sort by subdocument fields\n\t\t\t\t\t\t\tcurrentArray.sort(function(a, b) {\n\t\t\t\t\t\t\t\tvar sortKeys = Object.keys(sortSpec);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar sortKey = sortKeys[k];\n\t\t\t\t\t\t\t\t\tvar sortDir = sortSpec[sortKey];\n\t\t\t\t\t\t\t\t\tvar aVal = getProp(a, sortKey);\n\t\t\t\t\t\t\t\t\tvar bVal = getProp(b, sortKey);\n\t\t\t\t\t\t\t\t\tif (aVal < bVal) return sortDir > 0 ? -1 : 1;\n\t\t\t\t\t\t\t\t\tif (aVal > bVal) return sortDir > 0 ? 1 : -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Apply $slice if specified\n\t\t\t\t\tif (pushValue.$slice !== undefined) {\n\t\t\t\t\t\tvar sliceValue = pushValue.$slice;\n\t\t\t\t\t\tif (sliceValue < 0) {\n\t\t\t\t\t\t\t// Keep last N elements\n\t\t\t\t\t\t\tvar sliced = currentArray.slice(sliceValue);\n\t\t\t\t\t\t\tsetProp(doc, field, sliced);\n\t\t\t\t\t\t} else if (sliceValue === 0) {\n\t\t\t\t\t\t\t// Empty the array\n\t\t\t\t\t\t\tsetProp(doc, field, []);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Keep first N elements\n\t\t\t\t\t\t\tvar sliced = currentArray.slice(0, sliceValue);\n\t\t\t\t\t\t\tsetProp(doc, field, sliced);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Simple push (original behavior)\n\t\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\t\tcurrentArray.push(pushValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$bit\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tvar field = replacePositionalOperator(fields[0], positionalMatchInfo);\n\t\t\tvar operation = value[fields[0]];\n\t\t\tvar operator = Object.keys(operation)[0];\n\t\t\tvar operand = operation[operator];\n\t\t\tvar currentValue = getProp(doc, field);\n\t\t\tif (operator == \"and\") {\n\t\t\t\tsetProp(doc, field, currentValue & operand);\n\t\t\t} else if (operator == \"or\") {\n\t\t\t\tsetProp(doc, field, currentValue | operand);\n\t\t\t} else if (operator == \"xor\") {\n\t\t\t\tsetProp(doc, field, currentValue ^ operand);\n\t\t\t} else {\n\t\t\t\tthrow \"unknown $bit operator: \" + operator;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow \"unknown update operator: \" + key;\n\t\t}\n\t}\n}\n\n/**\n * Create a new document from query and update operators for upsert\n */\nexport function createDocFromUpdate(query, updates, idGenerator) {\n\tvar newDoc = { _id: idGenerator() };\n\tvar onlyFields = true;\n\tvar updateKeys = Object.keys(updates);\n\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\tif (updateKeys[i].charAt(0) == \"$\") {\n\t\t\tonlyFields = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (onlyFields) {\n\t\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\t\tnewDoc[updateKeys[i]] = updates[updateKeys[i]];\n\t\t}\n\t} else {\n\t\tvar queryKeys = Object.keys(query);\n\t\tfor (var i = 0; i < queryKeys.length; i++) {\n\t\t\tnewDoc[queryKeys[i]] = query[queryKeys[i]];\n\t\t}\n\t\tapplyUpdates(updates, newDoc, true);\n\t}\n\treturn newDoc;\n}\n","/**\n * Base class for collection indexes\n * Provides a common interface for different types of indexes (e.g., regular, text, geo)\n */\nexport class Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tthis.name = name;\n\t\tthis.keys = keys;\n\t\tthis.storage = storage;\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tthrow new Error('add() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tthrow new Error('remove() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Update a document in the index (remove old, add new)\n\t * @param {Object} oldDoc - The old document\n\t * @param {Object} newDoc - The new document\n\t */\n\tupdate(oldDoc, newDoc) {\n\t\tthis.remove(oldDoc);\n\t\tthis.add(newDoc);\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query to execute\n\t * @returns {Array} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tthrow new Error('query() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthrow new Error('clear() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Get index specification (for getIndexes())\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\tthrow new Error('serialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} data - Serialized index state\n\t */\n\tdeserialize(data) {\n\t\tthrow new Error('deserialize() must be implemented by subclass');\n\t}\n}\n","import { Index } from './Index.js';\nimport { getProp } from './utils.js';\nimport { BPlusTree } from 'bjson/bplustree';\n\n/**\n * Regular index using bjson's persistent BPlusTree with OPFS backing\n * All operations are async\n */\nexport class RegularCollectionIndex extends Index {\n\tconstructor(name, keys, storageFilePath, options = {}) {\n\t\tsuper(name, keys, storageFilePath, options);\n\t\t// Use OPFS-backed B+ tree for persistent index storage\n\t\tthis.data = new BPlusTree(storageFilePath, 50);\n\t\tthis.isOpen = false;\n\t}\n\n\t/**\n\t * Open the index file\n\t * Must be called before using the index\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tawait this.data.open();\n\t\t\tthis.isOpen = true;\n\t\t} catch (error) {\n\t\t\t// If file is corrupted, delete and recreate\n\t\t\tif (error.message && (error.message.includes('Unknown type byte') || \n\t\t\t\t\terror.message.includes('Failed to read metadata') ||\n\t\t\t\t\terror.message.includes('Invalid tree file'))) {\n\t\t\t\t// Try to delete the corrupted file\n\t\t\t\tif (typeof navigator !== 'undefined' && navigator.storage) {\n\t\t\t\t\tconst opfsRoot = await navigator.storage.getDirectory();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait opfsRoot.removeEntry(this.storage);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// File might not exist, ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create fresh BPlusTree\n\t\t\t\tthis.data = new BPlusTree(this.storage, 50);\n\t\t\t\tawait this.data.open();\n\t\t\t\tthis.isOpen = true;\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the index file\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\ttry {\n\t\t\t\tawait this.data.close();\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors from already-closed files\n\t\t\t\tif (!error.message || !error.message.includes('File is not open')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Extract index key value from a document\n\t */\n\textractIndexKey(doc) {\n\t\tconst keyFields = Object.keys(this.keys);\n\t\tif (keyFields.length === 0) return null;\n\n\t\t// For simple single-field index\n\t\tif (keyFields.length === 1) {\n\t\t\tconst field = keyFields[0];\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value === undefined) return null;\n\t\t\t// Preserve type information in the key\n\t\t\treturn value; //JSON.stringify({ t: typeof value, v: value });\n\t\t}\n\n\t\t// For compound index, concatenate values with type preservation\n\t\tconst keyParts = [];\n\t\tfor (let i = 0; i < keyFields.length; i++) {\n\t\t\tconst value = getProp(doc, keyFields[i]);\n\t\t\tif (value === undefined) return null;\n\t\t\tkeyParts.push(value /*JSON.stringify(value) */);\n\t\t}\n\t\t// Use a separator that won't appear in JSON\n\t\treturn keyParts.join('\\x00');\n\t}\n\n\t/**\n\t * Add a document to the index\n   * \n\t * @param {Object} doc - The document to index\n\t */\n\tasync add(doc) {\n\t\tif (!this.isOpen) {\n\t\t\tawait this.open();\n\t\t}\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tconst docId = doc._id.toString();\n\t\t\t// Get existing doc IDs for this key (if any)\n\t\t\tconst existing = await this.data.search(indexKey);\n\t\t\tlet docIds;\n\t\t\tif (Array.isArray(existing)) {\n\t\t\t\t// Avoid duplicates\n\t\t\t\tif (!existing.includes(docId)) {\n\t\t\t\t\tdocIds = [...existing, docId];\n\t\t\t\t} else {\n\t\t\t\t\treturn; // Already indexed\n\t\t\t\t}\n\t\t\t} else if (existing) {\n\t\t\t\t// Single value, convert to array\n\t\t\t\tdocIds = existing === docId ? [existing] : [existing, docId];\n\t\t\t} else {\n\t\t\t\t// No existing value\n\t\t\t\tdocIds = [docId];\n\t\t\t}\n\t\t\tawait this.data.add(indexKey, docIds);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the index\n   * \n\t * @param {Object} doc - The document to remove\n\t */\n\tasync remove(doc) {\n\t\tif (!this.isOpen) {\n\t\t\tawait this.open();\n\t\t}\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tconst docId = doc._id.toString();\n\t\t\tconst existing = await this.data.search(indexKey);\n\t\t\tif (Array.isArray(existing)) {\n\t\t\t\tconst filtered = existing.filter(id => id !== docId);\n\t\t\t\tif (filtered.length > 0) {\n\t\t\t\t\tawait this.data.add(indexKey, filtered);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.data.delete(indexKey);\n\t\t\t\t}\n\t\t\t} else if (existing === docId) {\n\t\t\t\tawait this.data.delete(indexKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the index\n   * \n\t * @param {*} query - The query object\n\t * @returns {Promise<Array|null>} Array of document IDs or null if index cannot satisfy query\n\t */\n\tasync query(query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(this.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst queryValue = query[field];\n\n\t\t// Case 1: Simple equality\n\t\tif (typeof queryValue !== 'object' || queryValue === null) {\n\t\t\tconst indexKey = queryValue;\n\t\t\tconst result = await this.data.search(indexKey);\n\t\t\t// Result might be an array of doc IDs or undefined\n\t\t\treturn result || [];\n\t\t}\n\n\t\t// Case 2: Query with operators\n\t\tif (typeof queryValue === 'object' && !Array.isArray(queryValue)) {\n\t\t\treturn await this._queryWithOperators(field, queryValue);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Query index with comparison operators\n   * \n\t * @private\n\t */\n\tasync _queryWithOperators(field, operators) {\n\t\tconst ops = Object.keys(operators);\n\t\tconst results = new Set();\n\n\t\t// Handle range queries: $gt, $gte, $lt, $lte\n\t\tconst hasRangeOp = ops.some(op => ['$gt', '$gte', '$lt', '$lte'].includes(op));\n\t\t\n\t\tif (hasRangeOp) {\n\t\t\t// Use B+ tree's efficient range search if we have both bounds\n\t\t\tconst hasGt = ops.includes('$gt') || ops.includes('$gte');\n\t\t\tconst hasLt = ops.includes('$lt') || ops.includes('$lte');\n\t\t\t\n\t\t\tif (hasGt && hasLt) {\n\t\t\t\t// Determine min and max bounds\n\t\t\t\tconst minValue = ops.includes('$gte') ? operators['$gte'] : \n\t\t\t\t                ops.includes('$gt') ? operators['$gt'] : -Infinity;\n\t\t\t\tconst maxValue = ops.includes('$lte') ? operators['$lte'] : \n\t\t\t\t                ops.includes('$lt') ? operators['$lt'] : Infinity;\n\t\t\t\t\n\t\t\t\tconst rangeResults = await this.data.rangeSearch(minValue, maxValue);\n\t\t\t\t\n\t\t\t\tfor (const entry of rangeResults) {\n\t\t\t\t\tconst keyValue = entry.key;\n\t\t\t\t\tconst value = entry.value;\n\t\t\t\t\t\n\t\t\t\t\t// Apply exact operator semantics\n\t\t\t\t\tlet matches = true;\n\t\t\t\t\tif (ops.includes('$gt') && !(keyValue > operators['$gt'])) matches = false;\n\t\t\t\t\tif (ops.includes('$gte') && !(keyValue >= operators['$gte'])) matches = false;\n\t\t\t\t\tif (ops.includes('$lt') && !(keyValue < operators['$lt'])) matches = false;\n\t\t\t\t\tif (ops.includes('$lte') && !(keyValue <= operators['$lte'])) matches = false;\n\t\t\t\t\t\n\t\t\t\t\tif (matches && value) {\n\t\t\t\t\t\t// value is an array of document IDs\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tvalue.forEach(id => results.add(id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresults.add(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t} else {\n\t\t\t\t// Scan all entries if we don't have both bounds\n\t\t\t\tconst allEntries = await this.data.toArray();\n\t\t\t\t\n\t\t\t\tfor (const entry of allEntries) {\n\t\t\t\t\tconst keyValue = entry.key;\n\t\t\t\t\tconst value = entry.value;\n\t\t\t\t\t\n\t\t\t\t\t// Check if value matches all operators\n\t\t\t\t\tlet matches = true;\n\t\t\t\t\tfor (const op of ops) {\n\t\t\t\t\t\tconst operand = operators[op];\n\t\t\t\t\t\tif (op === '$gt' && !(keyValue > operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$gte' && !(keyValue >= operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$lt' && !(keyValue < operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$lte' && !(keyValue <= operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$eq' && !(keyValue === operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$ne' && !(keyValue !== operand)) matches = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (matches && value) {\n\t\t\t\t\t\t// value is an array of document IDs\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tvalue.forEach(id => results.add(id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresults.add(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $in operator\n\t\tif (ops.includes('$in')) {\n\t\t\tconst values = operators['$in'];\n\t\t\tif (Array.isArray(values)) {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tconst result = await this.data.search(value);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tif (Array.isArray(result)) {\n\t\t\t\t\t\t\tresult.forEach(id => results.add(id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresults.add(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $eq operator\n\t\tif (ops.includes('$eq')) {\n\t\t\tconst value = operators['$eq'];\n\t\t\tconst result = await this.data.search(value);\n\t\t\tif (result) {\n\t\t\t\treturn Array.isArray(result) ? result : [result];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\t// Handle $ne operator (requires full scan, not optimal)\n\t\tif (ops.includes('$ne')) {\n\t\t\tconst excludeValue = operators['$ne'];\n\t\t\tconst allEntries = await this.data.toArray();\n\t\t\t\n\t\t\tfor (const entry of allEntries) {\n\t\t\t\tif (entry.key !== excludeValue && entry.value) {\n\t\t\t\t\t// value is an array of document IDs\n\t\t\t\t\tif (Array.isArray(entry.value)) {\n\t\t\t\t\t\tentry.value.forEach(id => results.add(id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresults.add(entry.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Array.from(results);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all entries from the index\n\t */\n\tasync clear() {\n\t\t// For persistent storage, close and recreate the tree\n\t\tif (this.isOpen) {\n\t\t\tawait this.close();\n\t\t}\n\t\t// BPlusTree will be recreated when we open again\n\t\tthis.data = new BPlusTree(this.data.filename, 50);\n\t\tawait this.open();\n\t}\n}\n","import { Index } from './Index.js';\nimport { TextIndex } from 'bjson/textindex';\nimport { getProp } from './utils.js';\n\n/**\n * Text index implementation\n * OPFS-backed async implementation using bjson TextIndex\n */\nexport class TextCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage);\n\t\t// Use OPFS-backed TextIndex for persistent full-text search\n\t\tthis.textIndex = new TextIndex({ baseFilename: storage });\n\t\tthis.isOpen = false;\n\t\t// Track which fields are indexed\n\t\tthis.indexedFields = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\tthis.indexedFields.push(field);\n\t\t\t}\n\t\t}\n\t\tif (this.indexedFields.length === 0) {\n\t\t\tthrow new Error('Text index must have at least one field with type \"text\"');\n\t\t}\n\t}\n\n\t/**\n\t * Open the index files\n\t * Must be called before using the index\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.textIndex.open();\n\t\tthis.isOpen = true;\n\t}\n\n\t/**\n\t * Close the index files\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\ttry {\n\t\t\t\tawait this.textIndex.close();\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors from already-closed files\n\t\t\t\tif (!error.message || !error.message.includes('File is not open')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Extract text content from a document for the indexed fields\n\t * @param {Object} doc - The document\n\t * @returns {string} Combined text from all indexed fields\n\t */\n\t_extractText(doc) {\n\t\tconst textParts = [];\n\t\tfor (const field of this.indexedFields) {\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\ttextParts.push(String(value));\n\t\t\t}\n\t\t}\n\t\treturn textParts.join(' ');\n\t}\n\n\t/**\n\t * Add a document to the text index\n\t * @param {Object} doc - The document to index\n\t */\n\tasync add(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst text = this._extractText(doc);\n\t\tif (text) {\n\t\t\tawait this.textIndex.add(String(doc._id), text);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the text index\n\t * @param {Object} doc - The document to remove\n\t */\n\tasync remove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.textIndex.remove(String(doc._id));\n\t}\n\n\t/**\n\t * Query the text index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a text search\n\t */\n\tquery(query) {\n\t\t// This method is used for query planning\n\t\t// Text queries are handled separately in queryMatcher\n\t\treturn null;\n\t}\n\n\t/**\n\t * Search the text index\n\t * @param {string} searchText - The text to search for\n\t * @param {Object} options - Search options\n\t * @returns {Promise<Array>} Array of document IDs\n\t */\n\tasync search(searchText, options = {}) {\n\t\tconst results = await this.textIndex.query(searchText, { scored: false, ...options });\n\t\treturn results;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tasync clear() {\n\t\t// Recreate the index by closing and reopening\n\t\tif (this.isOpen) {\n\t\t\tawait this.close();\n\t\t}\n\t\tthis.textIndex = new TextIndex({ baseFilename: this.storage });\n\t\tawait this.open();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\ttextIndexVersion: 3,\n\t\t\tweights: this._getWeights()\n\t\t};\n\t}\n\n\t/**\n\t * Get field weights (all default to 1 for now)\n\t */\n\t_getWeights() {\n\t\tconst weights = {};\n\t\tfor (const field of this.indexedFields) {\n\t\t\tweights[field] = 1;\n\t\t}\n\t\treturn weights;\n\t}\n\n}\n","/**\n * On-Disk R-tree implementation using BJsonFile\n * \n * This implementation stores all data in an append-only bjson file:\n * - Nodes are stored as bjson records\n * - Node references use Pointer objects for file offsets\n * - Updates append new versions rather than modifying in place\n * - An in-memory index tracks the latest offset for each node ID\n * \n * File format:\n * - Record 0: Metadata (version, maxEntries, size, rootPointer, nextId)\n * - Records 1+: Node data (id, isLeaf, children, bbox)\n *   - For internal nodes: children are Pointer objects to child nodes\n *   - For leaf nodes: children are data entries with {bbox, lat, lng, data}\n */\n\nimport { BJsonFile, Pointer, encode, decode } from './bjson.js';\n\n/**\n * Calculate distance between two points using Haversine formula\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Convert radius query to bounding box\n */\nfunction radiusToBoundingBox(lat, lng, radiusKm) {\n\tconst latDelta = radiusKm / 111;\n\tconst lngDelta = radiusKm / (111 * Math.cos(lat * Math.PI / 180));\n\t\n\treturn {\n\t\tminLat: lat - latDelta,\n\t\tmaxLat: lat + latDelta,\n\t\tminLng: lng - lngDelta,\n\t\tmaxLng: lng + lngDelta\n\t};\n}\n\n/**\n * Check if two bounding boxes intersect\n */\nfunction intersects(bbox1, bbox2) {\n\treturn !(bbox1.maxLat < bbox2.minLat ||\n\t\tbbox1.minLat > bbox2.maxLat ||\n\t\tbbox1.maxLng < bbox2.minLng ||\n\t\tbbox1.minLng > bbox2.maxLng);\n}\n\n/**\n * Calculate the area of a bounding box\n */\nfunction area(bbox) {\n\treturn (bbox.maxLat - bbox.minLat) * (bbox.maxLng - bbox.minLng);\n}\n\n/**\n * Calculate the bounding box that contains both input boxes\n */\nfunction union(bbox1, bbox2) {\n\treturn {\n\t\tminLat: Math.min(bbox1.minLat, bbox2.minLat),\n\t\tmaxLat: Math.max(bbox1.maxLat, bbox2.maxLat),\n\t\tminLng: Math.min(bbox1.minLng, bbox2.minLng),\n\t\tmaxLng: Math.max(bbox1.maxLng, bbox2.maxLng)\n\t};\n}\n\n/**\n * Calculate the enlargement needed to include bbox2 in bbox1\n */\nfunction enlargement(bbox1, bbox2) {\n\tconst unionBox = union(bbox1, bbox2);\n\treturn area(unionBox) - area(bbox1);\n}\n\n/**\n * R-tree node stored on disk\n */\nclass RTreeNode {\n\tconstructor(rtree, nodeData) {\n\t\tthis.rtree = rtree;\n\t\tthis.id = nodeData.id;\n\t\tthis.isLeaf = nodeData.isLeaf;\n\t\tthis.children = nodeData.children || [];\n\t\tthis.bbox = nodeData.bbox;\n\t}\n\n\t/**\n\t * Update the bounding box to contain all children\n\t */\n\tasync updateBBox() {\n\t\tif (this.children.length === 0) {\n\t\t\tthis.bbox = null;\n\t\t\treturn;\n\t\t}\n\n\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\tlet minLng = Infinity, maxLng = -Infinity;\n\n\t\tfor (const child of this.children) {\n\t\t\tlet bbox;\n\t\t\tif (this.isLeaf) {\n\t\t\t\t// Leaf node: children are data entries\n\t\t\t\tbbox = child.bbox;\n\t\t\t} else {\n\t\t\t\t// Internal node: children are Pointers - need to load child nodes\n\t\t\t\tconst childNode = await this.rtree._loadNode(child);\n\t\t\t\tbbox = childNode.bbox;\n\t\t\t}\n\n\t\t\tif (bbox) {\n\t\t\t\tminLat = Math.min(minLat, bbox.minLat);\n\t\t\t\tmaxLat = Math.max(maxLat, bbox.maxLat);\n\t\t\t\tminLng = Math.min(minLng, bbox.minLng);\n\t\t\t\tmaxLng = Math.max(maxLng, bbox.maxLng);\n\t\t\t}\n\t\t}\n\n\t\tthis.bbox = { minLat, maxLat, minLng, maxLng };\n\t\t\n\t\t// Save updated node to disk\n\t\tawait this.rtree._saveNode(this);\n\t}\n\n\t/**\n\t * Convert node to plain object for serialization\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tisLeaf: this.isLeaf,\n\t\t\tchildren: this.children,\n\t\t\tbbox: this.bbox\n\t\t};\n\t}\n}\n\n/**\n * On-disk R-tree implementation\n */\nexport class RTree {\n\tconstructor(filename, maxEntries = 9) {\n\t\tthis.filename = filename;\n\t\tthis.maxEntries = maxEntries;\n\t\tthis.minEntries = Math.max(2, Math.ceil(maxEntries / 2));\n\t\t\n\t\t// Metadata\n\t\tthis.rootPointer = null;\n\t\tthis.nextId = 1;\n\t\tthis._size = 0;\n\t\t\n\t\t// BJsonFile handle\n\t\tthis.file = new BJsonFile(filename);\n\t\tthis.isOpen = false;\n\t}\n\n\t/**\n\t * Open the R-tree file (create if doesn't exist)\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\tthrow new Error('R-tree file is already open');\n\t\t}\n\n\t\tconst exists = await this.file.exists();\n\t\t\n\t\tif (exists) {\n\t\t\t// Load existing tree\n\t\t\tawait this.file.open('rw');\n\t\t\tawait this._loadFromFile();\n\t\t} else {\n\t\t\t// Create new tree\n\t\t\tawait this.file.open('rw');\n\t\t\tawait this._initializeNewTree();\n\t\t}\n\t\t\n\t\tthis.isOpen = true;\n\t}\n\n\t/**\n\t * Close the R-tree file\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\tawait this._writeMetadata();\n\t\t\tawait this.file.close();\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Initialize a new empty tree\n\t */\n\tasync _initializeNewTree() {\n\t\t// Create root node\n\t\tconst rootNode = new RTreeNode(this, {\n\t\t\tid: 0,\n\t\t\tisLeaf: true,\n\t\t\tchildren: [],\n\t\t\tbbox: null\n\t\t});\n\t\t\n\t\tthis.nextId = 1;\n\t\tthis._size = 0;\n\t\t\n\t\t// Save root node\n\t\tthis.rootPointer = await this._saveNode(rootNode);\n\t\t\n\t\t// Write metadata as first record\n\t\tawait this._writeMetadata();\n\t}\n\n\t/**\n\t * Write metadata record to file\n\t */\n\tasync _writeMetadata() {\n\t\tconst metadata = {\n\t\t\tversion: 1,\n\t\t\tmaxEntries: this.maxEntries,\n\t\t\tminEntries: this.minEntries,\n\t\t\tsize: this._size,\n\t\t\trootPointer: this.rootPointer,\n\t\t\tnextId: this.nextId\n\t\t};\n\t\t\n\t\t// Append metadata to file (don't use write which truncates)\n\t\tawait this.file.append(metadata);\n\t}\n\n\t/**\n\t * Load tree from existing file\n\t */\n\tasync _loadFromFile() {\n\t\t// Calculate fixed metadata size:\n\t\t// Metadata object has 6 fields: version, maxEntries, minEntries, size, rootPointer, nextId\n\t\t// All are INT type encoded as 8-byte ints (1 type byte + 8 bytes payload)\n\t\t// Object encoding: TYPE (1) + SIZE (4) + COUNT (4) + key-value pairs\n\t\t// Total size with 8-byte ints: 135 bytes\n\t\tconst METADATA_SIZE = 135;\n\t\t\n\t\tconst fileSize = await this.file.getFileSize();\n\t\tif (fileSize < METADATA_SIZE) {\n\t\t\tthrow new Error('Invalid R-tree file format: file too small for metadata');\n\t\t}\n\t\t\n\t\t// Read metadata from the end of the file\n\t\tconst metadataOffset = fileSize - METADATA_SIZE;\n\t\tconst metadata = await this.file.read(metadataOffset);\n\t\t\n\t\tthis.maxEntries = metadata.maxEntries;\n\t\tthis.minEntries = metadata.minEntries;\n\t\tthis._size = metadata.size;\n\t\tthis.rootPointer = metadata.rootPointer;\n\t\tthis.nextId = metadata.nextId;\n\t}\n\n\t/**\n\t * Save a node to disk and return its Pointer\n\t */\n\tasync _saveNode(node) {\n\t\tconst nodeData = node.toJSON();\n\t\t\n\t\t// Get current file size (this is where the node will be stored)\n\t\tconst offset = await this.file.getFileSize();\n\t\t\n\t\t// Append node to file\n\t\tawait this.file.append(nodeData);\n\t\t\n\t\t// Return pointer to the saved node\n\t\treturn new Pointer(offset);\n\t}\n\n\t/**\n\t * Load a node from disk by Pointer\n\t */\n\tasync _loadNode(pointer) {\n\t\tif (!(pointer instanceof Pointer)) {\n\t\t\tthrow new Error('Expected Pointer object');\n\t\t}\n\t\t\n\t\tconst offset = pointer.valueOf();\n\t\t\n\t\t// Read the node from file at this offset\n\t\tconst nodeData = await this.file.read(offset);\n\t\t\n\t\treturn new RTreeNode(this, nodeData);\n\t}\n\n\t/**\n\t * Load the root node\n\t */\n\tasync _loadRoot() {\n\t\treturn await this._loadNode(this.rootPointer);\n\t}\n\n\t/**\n\t * Insert a point into the R-tree with an ObjectId\n\t */\n\tasync insert(lat, lng, objectId) {\n\t\tif (!this.isOpen) {\n\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t}\n\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst entry = { bbox, lat, lng, objectId };\n\t\t\n\t\tconst root = await this._loadRoot();\n\t\tconst result = await this._insert(entry, root, 1);\n\t\t\n\t\tif (result.split) {\n\t\t\t// Root was split, create new root\n\t\t\tconst newRoot = new RTreeNode(this, {\n\t\t\t\tid: this.nextId++,\n\t\t\t\tisLeaf: false,\n\t\t\t\tchildren: result.pointers,\n\t\t\t\tbbox: null\n\t\t\t});\n\t\t\t\n\t\t\tawait newRoot.updateBBox();\n\t\t\tthis.rootPointer = await this._saveNode(newRoot);\n\t\t} else {\n\t\t\t// Root was updated but not split, update the pointer\n\t\t\tthis.rootPointer = result.pointer;\n\t\t}\n\t\t\n\t\tthis._size++;\n\t\tawait this._writeMetadata();\n\t}\n\n\t/**\n\t * Internal insert method - returns splitPointers if split occurred, else returns updated node pointer\n\t */\n\tasync _insert(entry, node, level) {\n\t\tif (node.isLeaf) {\n\t\t\tnode.children.push(entry);\n\t\t\tawait node.updateBBox();\n\n\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\tconst [pointer1, pointer2] = await this._split(node);\n\t\t\t\treturn { split: true, pointers: [pointer1, pointer2] };\n\t\t\t}\n\t\t\t\n\t\t\t// Save updated leaf node\n\t\t\tconst pointer = await this._saveNode(node);\n\t\t\treturn { split: false, pointer };\n\t\t} else {\n\t\t\t// Choose subtree\n\t\t\tconst targetPointer = await this._chooseSubtree(entry.bbox, node);\n\t\t\tconst targetNode = await this._loadNode(targetPointer);\n\t\t\tconst result = await this._insert(entry, targetNode, level + 1);\n\n\t\t\tif (result.split) {\n\t\t\t\t// Child was split, find and replace it\n\t\t\t\tlet childIndex = -1;\n\t\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tif (node.children[i].valueOf() === targetPointer.valueOf()) {\n\t\t\t\t\t\tchildIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (childIndex !== -1) {\n\t\t\t\t\t// Replace the old child with both new children\n\t\t\t\t\tnode.children[childIndex] = result.pointers[0];\n\t\t\t\t\tnode.children.push(result.pointers[1]);\n\t\t\t\t} else {\n\t\t\t\t\t// Shouldn't happen, but add both if we can't find\n\t\t\t\t\tnode.children.push(result.pointers[0]);\n\t\t\t\t\tnode.children.push(result.pointers[1]);\n\t\t\t\t}\n\t\t\t\tawait node.updateBBox();\n\n\t\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\t\tconst [pointer1, pointer2] = await this._split(node);\n\t\t\t\t\treturn { split: true, pointers: [pointer1, pointer2] };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Child was not split, but may have been updated with new pointer\n\t\t\t\t// Update the child pointer in this node's children\n\t\t\t\tlet childIndex = -1;\n\t\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tif (node.children[i].valueOf() === targetPointer.valueOf()) {\n\t\t\t\t\t\tchildIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (childIndex !== -1) {\n\t\t\t\t\t// Update child pointer to point to the new version\n\t\t\t\t\tnode.children[childIndex] = result.pointer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update this node's bbox (use the current children pointers)\n\t\t\t\tawait node.updateBBox();\n\t\t\t}\n\t\t\t\n\t\t// Save updated internal node\n\t\tconst pointer = await this._saveNode(node);\n\t\treturn { split: false, pointer };\n    }\n\t}\n\n\t/**\n\t * Choose the best subtree to insert an entry\n\t */\n\tasync _chooseSubtree(bbox, node) {\n\t\tlet minEnlargement = Infinity;\n\t\tlet minArea = Infinity;\n\t\tlet targetPointer = null;\n\n    for (const childPointer of node.children) {\n\t\t\t// Debug: check if we have a Pointer\n\t\t\tif (!(childPointer instanceof Pointer)) {\n\t\t\t\tthrow new Error(`Expected Pointer in _chooseSubtree, got: ${typeof childPointer}`);\n\t\t\t}\n\t\t\t\n\t\t\tconst childNode = await this._loadNode(childPointer);\n\t\t\tconst enl = enlargement(childNode.bbox, bbox);\n\t\t\tconst ar = area(childNode.bbox);\n\n\t\t\tif (enl < minEnlargement || (enl === minEnlargement && ar < minArea)) {\n\t\t\t\tminEnlargement = enl;\n\t\t\t\tminArea = ar;\n\t\t\t\ttargetPointer = childPointer;\n\t\t\t}\n\t\t}\n\n\t\treturn targetPointer;\n\t}\n\n\t/**\n\t * Split an overflowing node\n\t */\n\tasync _split(node) {\n\t\tconst children = node.children;\n\t\tconst isLeaf = node.isLeaf;\n\n\t\t// Find two seeds (most distant entries)\n\t\tlet maxDist = -Infinity;\n\t\tlet seed1Idx = 0, seed2Idx = 1;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tfor (let j = i + 1; j < children.length; j++) {\n\t\t\t\tlet bbox1, bbox2;\n\t\t\t\t\n\t\t\t\tif (isLeaf) {\n\t\t\t\t\tbbox1 = children[i].bbox;\n\t\t\t\t\tbbox2 = children[j].bbox;\n\t\t\t\t} else {\n\t\t\t\t\tconst node1 = await this._loadNode(children[i]);\n\t\t\t\t\tconst node2 = await this._loadNode(children[j]);\n\t\t\t\t\tbbox1 = node1.bbox;\n\t\t\t\t\tbbox2 = node2.bbox;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst dist = area(union(bbox1, bbox2));\n\t\t\t\tif (dist > maxDist) {\n\t\t\t\t\tmaxDist = dist;\n\t\t\t\t\tseed1Idx = i;\n\t\t\t\t\tseed2Idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create two new nodes\n\t\tconst node1 = new RTreeNode(this, {\n\t\t\tid: this.nextId++,\n\t\t\tisLeaf: isLeaf,\n\t\t\tchildren: [children[seed1Idx]],\n\t\t\tbbox: null\n\t\t});\n\n\t\tconst node2 = new RTreeNode(this, {\n\t\t\tid: this.nextId++,\n\t\t\tisLeaf: isLeaf,\n\t\t\tchildren: [children[seed2Idx]],\n\t\t\tbbox: null\n\t\t});\n\n\t\t// Distribute remaining entries\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tif (i === seed1Idx || i === seed2Idx) continue;\n\n\t\t\tconst child = children[i];\n\t\t\t\n\t\t\tlet bbox;\n\t\t\tif (isLeaf) {\n\t\t\t\tbbox = child.bbox;\n\t\t\t} else {\n\t\t\t\tconst childNode = await this._loadNode(child);\n\t\t\t\tbbox = childNode.bbox;\n\t\t\t}\n\t\t\t\n\t\t\tawait node1.updateBBox();\n\t\t\tawait node2.updateBBox();\n\t\t\t\n\t\t\tconst enl1 = node1.bbox ? enlargement(node1.bbox, bbox) : 0;\n\t\t\tconst enl2 = node2.bbox ? enlargement(node2.bbox, bbox) : 0;\n\n\t\t\tif (enl1 < enl2) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (enl2 < enl1) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else {\n\t\t\t\t// Equal enlargement, choose one with fewer children\n\t\t\t\tif (node1.children.length <= node2.children.length) {\n\t\t\t\t\tnode1.children.push(child);\n\t\t\t\t} else {\n\t\t\t\t\tnode2.children.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait node1.updateBBox();\n\t\tawait node2.updateBBox();\n\n\t\t// Save both nodes (don't reuse the original node)\n\t\tconst pointer1 = await this._saveNode(node1);\n\t\tconst pointer2 = await this._saveNode(node2);\n\n\t\t// Return both pointers\n\t\treturn [pointer1, pointer2];\n\t}\n\n\t/**\n\t * Search for points within a bounding box, returning entries with coords\n\t */\n\tasync searchBBox(bbox) {\n\t\tif (!this.isOpen) {\n\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t}\n\n\t\tconst results = [];\n\t\tconst root = await this._loadRoot();\n\t\tawait this._searchBBox(bbox, root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search\n\t */\n\tasync _searchBBox(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\tobjectId: entry.objectId,\n\t\t\t\t\t\tlat: entry.lat,\n\t\t\t\t\t\tlng: entry.lng\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const childPointer of node.children) {\n\t\t\t\tconst childNode = await this._loadNode(childPointer);\n\t\t\t\tawait this._searchBBox(bbox, childNode, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search for points within a radius of a location, returning ObjectIds with distances\n\t */\n\tasync searchRadius(lat, lng, radiusKm) {\n\t\tconst bbox = radiusToBoundingBox(lat, lng, radiusKm);\n\t\tconst root = await this._loadRoot();\n\t\tconst entries = [];\n\t\tawait this._searchBBoxEntries(bbox, root, entries);\n\n\t\tconst results = [];\n\t\tfor (const entry of entries) {\n\t\t\tconst dist = haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\tif (dist <= radiusKm) {\n\t\t\t\tresults.push({\n\t\t\t\t\tobjectId: entry.objectId,\n\t\t\t\t\tlat: entry.lat,\n\t\t\t\t\tlng: entry.lng,\n\t\t\t\t\tdistance: dist\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search that returns full entries (used by radius search)\n\t */\n\tasync _searchBBoxEntries(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const childPointer of node.children) {\n\t\t\t\tconst childNode = await this._loadNode(childPointer);\n\t\t\t\tawait this._searchBBoxEntries(bbox, childNode, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove an entry from the R-tree by ObjectId\n\t */\n\tasync remove(objectId) {\n\t\tif (!this.isOpen) {\n\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t}\n\n\t\tconst root = await this._loadRoot();\n\t\tconst result = await this._remove(objectId, root);\n\n\t\tif (!result.found) {\n\t\t\treturn false; // Entry not found\n\t\t}\n\n\t\tif (result.underflow && result.children) {\n\t\t\t// Root underflowed and has children\n\t\t\tif (result.children.length === 0) {\n\t\t\t\t// Tree is now empty, create new empty root\n\t\t\t\tconst newRoot = new RTreeNode(this, {\n\t\t\t\t\tid: this.nextId++,\n\t\t\t\t\tisLeaf: true,\n\t\t\t\t\tchildren: [],\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tthis.rootPointer = await this._saveNode(newRoot);\n\t\t\t} else if (result.children.length === 1 && !result.isLeaf) {\n\t\t\t\t// Root has only one child and is internal node - make child the new root\n\t\t\t\tthis.rootPointer = result.children[0];\n\t\t\t} else {\n\t\t\t\t// Root underflowed but still has multiple children, save it\n\t\t\t\tconst newRoot = new RTreeNode(this, {\n\t\t\t\t\tid: root.id,\n\t\t\t\t\tisLeaf: result.isLeaf,\n\t\t\t\t\tchildren: result.children,\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tawait newRoot.updateBBox();\n\t\t\t\tthis.rootPointer = await this._saveNode(newRoot);\n\t\t\t}\n\t\t} else if (result.pointer) {\n\t\t\t// Root was updated\n\t\t\tthis.rootPointer = result.pointer;\n\t\t}\n\n\t\tthis._size--;\n\t\tawait this._writeMetadata();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Internal remove method\n\t * Returns: { found: boolean, underflow: boolean, pointer: Pointer, children: Array, isLeaf: boolean }\n\t */\n\tasync _remove(objectId, node) {\n\t\tif (node.isLeaf) {\n\t\t\t// Find and remove the entry\n\t\t\tconst initialLength = node.children.length;\n\t\t\tnode.children = node.children.filter(entry => \n\t\t\t\t!entry.objectId.equals(objectId)\n\t\t\t);\n\n\t\t\tif (node.children.length === initialLength) {\n\t\t\t\t// Entry not found\n\t\t\t\treturn { found: false };\n\t\t\t}\n\n\t\t\tawait node.updateBBox();\n\t\t\tconst pointer = await this._saveNode(node);\n\n\t\t\t// Check for underflow\n\t\t\tconst underflow = node.children.length < this.minEntries && node.children.length > 0;\n\t\t\t\n\t\t\treturn {\n\t\t\t\tfound: true,\n\t\t\t\tunderflow,\n\t\t\t\tpointer,\n\t\t\t\tchildren: node.children,\n\t\t\t\tisLeaf: true\n\t\t\t};\n\t\t} else {\n\t\t\t// Internal node - search children\n\t\t\tlet found = false;\n\t\t\tlet updatedChildren = [...node.children];\n\n\t\t\tfor (let i = 0; i < updatedChildren.length; i++) {\n\t\t\t\tconst childPointer = updatedChildren[i];\n\t\t\t\tconst childNode = await this._loadNode(childPointer);\n\n\t\t\t\t// Check if the child's bbox could contain the entry\n\t\t\t\t// For internal nodes, we need to check all children since we don't store exact coordinates\n\t\t\t\tconst result = await this._remove(objectId, childNode);\n\n\t\t\t\tif (result.found) {\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\tif (result.underflow) {\n\t\t\t\t\t\t// Child underflowed, try to handle it\n\t\t\t\t\t\tconst handled = await this._handleUnderflow(node, i, childNode, result);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (handled.merged) {\n\t\t\t\t\t\t\t// Node was merged or redistributed, update children array\n\t\t\t\t\t\t\tupdatedChildren = handled.children;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Just update the pointer\n\t\t\t\t\t\t\tupdatedChildren[i] = result.pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Update child pointer\n\t\t\t\t\t\tupdatedChildren[i] = result.pointer;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update this node\n\t\t\t\t\tconst updatedNode = new RTreeNode(this, {\n\t\t\t\t\t\tid: node.id,\n\t\t\t\t\t\tisLeaf: false,\n\t\t\t\t\t\tchildren: updatedChildren,\n\t\t\t\t\t\tbbox: null\n\t\t\t\t\t});\n\t\t\t\t\tawait updatedNode.updateBBox();\n\t\t\t\t\tconst pointer = await this._saveNode(updatedNode);\n\n\t\t\t\t\t// Check if this node now underflows\n\t\t\t\t\tconst underflow = updatedChildren.length < this.minEntries && updatedChildren.length > 0;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfound: true,\n\t\t\t\t\t\tunderflow,\n\t\t\t\t\t\tpointer,\n\t\t\t\t\t\tchildren: updatedChildren,\n\t\t\t\t\t\tisLeaf: false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Entry not found in any child\n\t\t\treturn { found: false };\n\t\t}\n\t}\n\n\t/**\n\t * Handle underflow in a child node by merging or redistributing\n\t */\n\tasync _handleUnderflow(parentNode, childIndex, childNode, childResult) {\n\t\tconst siblings = [];\n\n\t\t// Find siblings (nodes before and after)\n\t\tif (childIndex > 0) {\n\t\t\tconst prevPointer = parentNode.children[childIndex - 1];\n\t\t\tconst prevNode = await this._loadNode(prevPointer);\n\t\t\tsiblings.push({ index: childIndex - 1, node: prevNode, pointer: prevPointer });\n\t\t}\n\t\tif (childIndex < parentNode.children.length - 1) {\n\t\t\tconst nextPointer = parentNode.children[childIndex + 1];\n\t\t\tconst nextNode = await this._loadNode(nextPointer);\n\t\t\tsiblings.push({ index: childIndex + 1, node: nextNode, pointer: nextPointer });\n\t\t}\n\n\t\t// Try to borrow from a sibling\n\t\tfor (const sibling of siblings) {\n\t\t\tif (sibling.node.children.length > this.minEntries) {\n\t\t\t\t// Sibling has extra entries, redistribute\n\t\t\t\tconst allChildren = [\n\t\t\t\t\t...childResult.children,\n\t\t\t\t\t...sibling.node.children\n\t\t\t\t];\n\n\t\t\t\tconst mid = Math.ceil(allChildren.length / 2);\n\t\t\t\tconst newChild1Children = allChildren.slice(0, mid);\n\t\t\t\tconst newChild2Children = allChildren.slice(mid);\n\n\t\t\t\tconst newChild1 = new RTreeNode(this, {\n\t\t\t\t\tid: childNode.id,\n\t\t\t\t\tisLeaf: childResult.isLeaf,\n\t\t\t\t\tchildren: newChild1Children,\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tawait newChild1.updateBBox();\n\n\t\t\t\tconst newChild2 = new RTreeNode(this, {\n\t\t\t\t\tid: sibling.node.id,\n\t\t\t\t\tisLeaf: sibling.node.isLeaf,\n\t\t\t\t\tchildren: newChild2Children,\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tawait newChild2.updateBBox();\n\n\t\t\t\tconst pointer1 = await this._saveNode(newChild1);\n\t\t\t\tconst pointer2 = await this._saveNode(newChild2);\n\n\t\t\t\t// Update parent's children\n\t\t\t\tconst newChildren = [...parentNode.children];\n\t\t\t\tconst minIndex = Math.min(childIndex, sibling.index);\n\t\t\t\tconst maxIndex = Math.max(childIndex, sibling.index);\n\t\t\t\t\n\t\t\t\tnewChildren[minIndex] = pointer1;\n\t\t\t\tnewChildren[maxIndex] = pointer2;\n\n\t\t\t\treturn { merged: true, children: newChildren };\n\t\t\t}\n\t\t}\n\n\t\t// Can't borrow, merge with a sibling\n\t\tif (siblings.length > 0) {\n\t\t\tconst sibling = siblings[0];\n\t\t\tconst mergedChildren = [\n\t\t\t\t...childResult.children,\n\t\t\t\t...sibling.node.children\n\t\t\t];\n\n\t\t\tconst mergedNode = new RTreeNode(this, {\n\t\t\t\tid: this.nextId++,\n\t\t\t\tisLeaf: childResult.isLeaf,\n\t\t\t\tchildren: mergedChildren,\n\t\t\t\tbbox: null\n\t\t\t});\n\t\t\tawait mergedNode.updateBBox();\n\t\t\tconst mergedPointer = await this._saveNode(mergedNode);\n\n\t\t\t// Update parent's children - remove both old nodes, add merged\n\t\t\tconst newChildren = parentNode.children.filter((_, i) => \n\t\t\t\ti !== childIndex && i !== sibling.index\n\t\t\t);\n\t\t\tnewChildren.push(mergedPointer);\n\n\t\t\treturn { merged: true, children: newChildren };\n\t\t}\n\n\t\t// No siblings (shouldn't happen except for root)\n\t\treturn { merged: false };\n\t}\n\n\t/**\n\t * Get the number of entries in the tree\n\t */\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Clear all entries from the tree\n\t */\n\tasync clear() {\n\t\tawait this.close();\n\t\t\n\t\t// Delete and recreate file\n\t\tconst tempFile = new BJsonFile(this.filename);\n\t\tawait tempFile.open('rw');\n\t\tawait tempFile.delete();\n\t\t\n\t\t// Reinitialize\n\t\tthis.file = new BJsonFile(this.filename);\n\t\tawait this.open();\n\t}\n\n\t\t/**\n\t\t * Compact the R-tree by copying the current root and all reachable nodes into a new file.\n\t\t * Returns size metrics to show reclaimed space.\n\t\t * @param {string} destinationFilename\n\t\t */\n\t\tasync compact(destinationFilename) {\n\t\t\tif (!this.isOpen) {\n\t\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t\t}\n\t\t\tif (!destinationFilename) {\n\t\t\t\tthrow new Error('Destination filename is required for compaction');\n\t\t\t}\n\n\t\t\t// Flush current metadata so size reflects latest state\n\t\t\tawait this._writeMetadata();\n\t\t\tconst oldSize = await this.file.getFileSize();\n\n\t\t\tconst dest = new RTree(destinationFilename, this.maxEntries);\n\t\t\tdest.minEntries = this.minEntries;\n\t\t\tdest.nextId = this.nextId;\n\t\t\tdest._size = this._size;\n\n\t\t\tawait dest.file.open('rw');\n\t\t\tdest.isOpen = true;\n\n\t\t\tconst pointerMap = new Map();\n\n\t\t\tconst cloneNode = async (pointer) => {\n\t\t\t\tconst offset = pointer.valueOf();\n\t\t\t\tif (pointerMap.has(offset)) {\n\t\t\t\t\treturn pointerMap.get(offset);\n\t\t\t\t}\n\n\t\t\t\tconst sourceNode = await this._loadNode(pointer);\n\t\t\t\tconst clonedChildren = [];\n\n\t\t\t\tif (sourceNode.isLeaf) {\n\t\t\t\t\t// Leaf children are plain entries\n\t\t\t\t\tfor (const child of sourceNode.children) {\n\t\t\t\t\t\tclonedChildren.push(child);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (const childPointer of sourceNode.children) {\n\t\t\t\t\t\tconst newChildPtr = await cloneNode(childPointer);\n\t\t\t\t\t\tclonedChildren.push(newChildPtr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst clonedNode = new RTreeNode(dest, {\n\t\t\t\t\tid: sourceNode.id,\n\t\t\t\t\tisLeaf: sourceNode.isLeaf,\n\t\t\t\t\tchildren: clonedChildren,\n\t\t\t\t\tbbox: sourceNode.bbox\n\t\t\t\t});\n\n\t\t\t\tconst newPointer = await dest._saveNode(clonedNode);\n\t\t\t\tpointerMap.set(offset, newPointer);\n\t\t\t\treturn newPointer;\n\t\t\t};\n\n\t\t\tconst newRootPointer = await cloneNode(this.rootPointer);\n\t\t\tdest.rootPointer = newRootPointer;\n\n\t\t\tawait dest._writeMetadata();\n\t\t\tawait dest.file.close();\n\t\t\tdest.isOpen = false;\n\n\t\t\tconst tempFile = new BJsonFile(destinationFilename);\n\t\t\tawait tempFile.open('r');\n\t\t\tconst newSize = await tempFile.getFileSize();\n\t\t\tawait tempFile.close();\n\n\t\t\treturn {\n\t\t\t\toldSize,\n\t\t\t\tnewSize,\n\t\t\t\tbytesSaved: Math.max(0, oldSize - newSize),\n\t\t\t\tnewFilename: destinationFilename\n\t\t\t};\n\t\t}\n}\n\nexport default RTree;\n","import { Index } from './Index.js';\nimport { RTree } from 'bjson/rtree';\nimport { getProp } from './utils.js';\nimport { ObjectId } from 'bjson';\n\n/**\n * Geospatial index implementation\n * OPFS-backed async implementation using bjson RTree\n */\nexport class GeospatialCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage, options);\n\t\t// Use OPFS-backed RTree for geospatial indexing\n\t\tthis.rtree = new RTree(storage, 9);\n\t\tthis.isOpen = false;\n\t\tthis._idMap = new Map(); // docId string -> ObjectId\n\t\tthis._objectIdMap = new Map(); // ObjectId string -> original docId\n\t\t// Track which field is the geospatial field\n\t\tthis.geoField = null;\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\tthis.geoField = field;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!this.geoField) {\n\t\t\tthrow new Error('Geospatial index must have at least one field with type \"2dsphere\" or \"2d\"');\n\t\t}\n\t}\n\n\n\t/**\n\t * Normalize a value so it can be stored in the RTree and compared via equals()\n\t * @param {*} id - Document identifier\n\t * @returns {*} ObjectId-compatible value with equals()/toString()\n\t */\n\t_normalizeObjectId(id) {\n\t\tif (id instanceof ObjectId) {\n\t\t\tthis._objectIdMap.set(id.toString(), id.toString());\n\t\t\treturn id;\n\t\t}\n\n\t\tconst key = String(id);\n\n\t\tif (this._idMap.has(key)) {\n\t\t\treturn this._idMap.get(key);\n\t\t}\n\n\t\tlet objectId;\n\t\ttry {\n\t\t\tif (typeof id === 'string' && ObjectId.isValid(id)) {\n\t\t\t\tobjectId = new ObjectId(id);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Fall through to deterministic generation\n\t\t}\n\n\t\tif (!objectId) {\n\t\t\tobjectId = this._createDeterministicObjectId(key);\n\t\t}\n\n\t\tthis._idMap.set(key, objectId);\n\t\tthis._objectIdMap.set(objectId.toString(), key);\n\t\treturn objectId;\n\t}\n\n\t_toDocId(id) {\n\t\tif (id instanceof ObjectId) {\n\t\t\tconst mapped = this._objectIdMap.get(id.toString());\n\t\t\treturn mapped !== undefined ? mapped : id.toString();\n\t\t}\n\t\tif (id && typeof id === 'object' && 'objectId' in id) {\n\t\t\treturn this._toDocId(id.objectId);\n\t\t}\n\t\treturn String(id);\n\t}\n\n\t_createDeterministicObjectId(key) {\n\t\tlet hash = 0x811c9dc5;\n\t\tfor (let i = 0; i < key.length; i++) {\n\t\t\thash ^= key.charCodeAt(i);\n\t\t\thash = Math.imul(hash, 0x01000193);\n\t\t}\n\t\tconst hex = (hash >>> 0).toString(16).padStart(8, '0');\n\t\tconst idHex = (hex + hex + hex).slice(0, 24);\n\t\treturn new ObjectId(idHex);\n\t}\n\n\t/**\n\t * Open the index file\n\t * Must be called before using the index\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.rtree.open();\n\t\tthis.isOpen = true;\n\t}\n\n\t/**\n\t * Close the index file\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\ttry {\n\t\t\t\tawait this.rtree.close();\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors from already-closed files\n\t\t\t\tif (!error.message || !error.message.includes('File is not open')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Extract coordinates from a GeoJSON object\n\t * @param {Object} geoJson - The GeoJSON object\n\t * @returns {Object|null} Object with lat and lng, or null if invalid\n\t */\n\t_extractCoordinates(geoJson) {\n\t\tif (!geoJson) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t\tconst feature = geoJson.features[0];\n\t\t\tif (feature.geometry) {\n\t\t\t\treturn this._extractCoordinates(feature.geometry);\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\t\treturn this._extractCoordinates(geoJson.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\t\tconst [lng, lat] = geoJson.coordinates;\n\t\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Polygon - use centroid of first coordinate\n\t\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\t\tconst ring = geoJson.coordinates[0];\n\t\t\tif (ring.length > 0) {\n\t\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tsumLng += coord[0];\n\t\t\t\t\tsumLat += coord[1];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\t\tlng: sumLng / ring.length\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add a document to the geospatial index\n\t * @param {Object} doc - The document to index\n\t */\n\tasync add(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\t// RTree.insert expects (lat, lng, objectId)\n\t\t\tconst objectId = this._normalizeObjectId(doc._id);\n\t\t\tawait this.rtree.insert(coords.lat, coords.lng, objectId);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the geospatial index\n\t * @param {Object} doc - The document to remove\n\t */\n\tasync remove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\t// RTree.remove expects just the ObjectId (or compatible value)\n\t\tconst objectId = this._normalizeObjectId(doc._id);\n\t\tawait this.rtree.remove(objectId);\n\t}\n\n\t/**\n\t * Query the geospatial index\n\t * @param {*} query - The query object\n\t * @returns {Promise<Array|null>} Array of document IDs or null if query is not a geospatial query\n\t */\n\tasync query(query) {\n\t\t// Check if this is a geospatial query on our indexed field\n\t\tif (!query[this.geoField]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geoQuery = query[this.geoField];\n\n\t\t// Handle $geoWithin with bounding box\n\t\tif (geoQuery.$geoWithin) {\n\t\t\tconst bbox = geoQuery.$geoWithin;\n\t\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\t\tif (Array.isArray(bbox) && bbox.length === 2) {\n\t\t\t\tconst minLon = bbox[0][0];\n\t\t\t\tconst maxLat = bbox[0][1];\n\t\t\t\tconst maxLon = bbox[1][0];\n\t\t\t\tconst minLat = bbox[1][1];\n\n\t\t\t\tconst results = await this.rtree.searchBBox({\n\t\t\t\t\tminLat: minLat,\n\t\t\t\t\tmaxLat: maxLat,\n\t\t\t\t\tminLng: minLon,\n\t\t\t\t\tmaxLng: maxLon\n\t\t\t\t});\n\n\t\t\t\t// searchBBox returns entries with coords\n\t\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t\t}\n\t\t}\n\n\t\t// Handle $near with radius\n\t\tif (geoQuery.$near) {\n\t\t\tconst nearQuery = geoQuery.$near;\n\t\t\t\n\t\t\t// Extract geometry from $geometry or use direct coordinates\n\t\t\tlet coordinates;\n\t\t\tif (nearQuery.$geometry) {\n\t\t\t\tcoordinates = nearQuery.$geometry.coordinates;\n\t\t\t} else if (nearQuery.coordinates) {\n\t\t\t\tcoordinates = nearQuery.coordinates;\n\t\t\t} else if (Array.isArray(nearQuery)) {\n\t\t\t\tcoordinates = nearQuery;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\n\t\t\t// $maxDistance in meters (default to 1000km if not specified)\n\t\t\tconst maxDistanceMeters = nearQuery.$maxDistance || 1000000;\n\t\t\tconst maxDistanceKm = maxDistanceMeters / 1000;\n\n\t\t\t// Use rtree.searchRadius to find points within distance\n\t\t\t// Returns array of { objectId, lat, lng, distance }\n\t\t\tconst results = await this.rtree.searchRadius(lat, lng, maxDistanceKm);\n\n\t\t\t// Sort by distance (ascending)\n\t\t\tresults.sort((a, b) => a.distance - b.distance);\n\n\t\t\t// Return just the document IDs\n\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t}\n\n\t\t// Handle $nearSphere with radius (uses spherical distance, same as $near)\n\t\tif (geoQuery.$nearSphere) {\n\t\t\tconst nearQuery = geoQuery.$nearSphere;\n\t\t\t\n\t\t\t// Extract geometry from $geometry or use direct coordinates\n\t\t\tlet coordinates;\n\t\t\tif (nearQuery.$geometry) {\n\t\t\t\tcoordinates = nearQuery.$geometry.coordinates;\n\t\t\t} else if (nearQuery.coordinates) {\n\t\t\t\tcoordinates = nearQuery.coordinates;\n\t\t\t} else if (Array.isArray(nearQuery)) {\n\t\t\t\tcoordinates = nearQuery;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\n\t\t\t// $maxDistance in meters (default to 1000km if not specified)\n\t\t\tconst maxDistanceMeters = nearQuery.$maxDistance || 1000000;\n\t\t\tconst maxDistanceKm = maxDistanceMeters / 1000;\n\n\t\t\t// Use rtree.searchRadius to find points within distance (already uses Haversine)\n\t\t\t// Returns array of { objectId, lat, lng, distance }\n\t\t\tconst results = await this.rtree.searchRadius(lat, lng, maxDistanceKm);\n\n\t\t\t// Sort by distance (ascending)\n\t\t\tresults.sort((a, b) => a.distance - b.distance);\n\n\t\t\t// Return just the document IDs\n\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t}\n\n\t\t// Handle $geoIntersects\n\t\tif (geoQuery.$geoIntersects) {\n\t\t\tconst intersectsQuery = geoQuery.$geoIntersects;\n\t\t\t\n\t\t\t// Extract geometry\n\t\t\tlet geometry;\n\t\t\tif (intersectsQuery.$geometry) {\n\t\t\t\tgeometry = intersectsQuery.$geometry;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!geometry || !geometry.type) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// For now, support Point and Polygon geometries\n\t\t\tif (geometry.type === 'Point') {\n\t\t\t\tconst [lng, lat] = geometry.coordinates;\n\t\t\t\t\n\t\t\t\t// Search for points at this exact location\n\t\t\t\t// Use a very small bounding box\n\t\t\t\tconst epsilon = 0.0001; // ~11 meters\n\t\t\t\tconst results = await this.rtree.searchBBox({\n\t\t\t\t\tminLat: lat - epsilon,\n\t\t\t\t\tmaxLat: lat + epsilon,\n\t\t\t\t\tminLng: lng - epsilon,\n\t\t\t\t\tmaxLng: lng + epsilon\n\t\t\t\t});\n\n\t\t\t\t// searchBBox returns entries with coords\n\t\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t\t} else if (geometry.type === 'Polygon') {\n\t\t\t\tconst coordinates = geometry.coordinates;\n\t\t\t\tif (!coordinates || coordinates.length === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Get the exterior ring\n\t\t\t\tconst ring = coordinates[0];\n\t\t\t\tif (!ring || ring.length < 3) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Calculate bounding box of the polygon\n\t\t\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\t\t\tlet minLng = Infinity, maxLng = -Infinity;\n\t\t\t\t\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tconst [lng, lat] = coord;\n\t\t\t\t\tminLat = Math.min(minLat, lat);\n\t\t\t\t\tmaxLat = Math.max(maxLat, lat);\n\t\t\t\t\tminLng = Math.min(minLng, lng);\n\t\t\t\t\tmaxLng = Math.max(maxLng, lng);\n\t\t\t\t}\n\n\t\t\t\t// Search for points within the bounding box\n\t\t\t\tconst candidates = await this.rtree.searchBBox({\n\t\t\t\t\tminLat,\n\t\t\t\t\tmaxLat,\n\t\t\t\t\tminLng,\n\t\t\t\t\tmaxLng\n\t\t\t\t});\n\n\t\t\t\t// Filter by actual point-in-polygon test using returned coordinates\n\t\t\t\tconst results = candidates.filter(entry => this._pointInPolygon(entry.lat, entry.lng, ring));\n\n\t\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Calculate distance between two points using Haversine formula\n\t * @param {number} lat1 - Latitude of first point\n\t * @param {number} lng1 - Longitude of first point\n\t * @param {number} lat2 - Latitude of second point\n\t * @param {number} lng2 - Longitude of second point\n\t * @returns {number} Distance in kilometers\n\t */\n\t_haversineDistance(lat1, lng1, lat2, lng2) {\n\t\tconst R = 6371; // Earth's radius in kilometers\n\t\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\t\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\t\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\treturn R * c;\n\t}\n\n\t/**\n\t * Test if a point is inside a polygon using ray casting algorithm\n\t * @param {number} lat - Point latitude\n\t * @param {number} lng - Point longitude\n\t * @param {Array} ring - Polygon ring as array of [lng, lat] coordinates\n\t * @returns {boolean} True if point is inside polygon\n\t */\n\t_pointInPolygon(lat, lng, ring) {\n\t\tlet inside = false;\n\t\t\n\t\tfor (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n\t\t\tconst [xi, yi] = ring[i];\n\t\t\tconst [xj, yj] = ring[j];\n\t\t\t\n\t\t\tconst intersect = ((yi > lat) !== (yj > lat)) &&\n\t\t\t\t(lng < (xj - xi) * (lat - yi) / (yj - yi) + xi);\n\t\t\t\n\t\t\tif (intersect) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inside;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tasync clear() {\n\t\tif (!this.isOpen) {\n\t\t\tawait this.rtree.open();\n\t\t\tthis.isOpen = true;\n\t\t}\n\t\t// Delete existing on-disk tree to avoid stale entries\n\t\ttry {\n\t\t\tawait this.rtree.file.delete();\n\t\t} catch (err) {\n\t\t\t// Ignore if file doesn't exist; rethrow other errors\n\t\t\tif (!err || err.name !== 'NotFoundError') {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\tthis.isOpen = false;\n\t\t// Recreate the RTree\n\t\tthis.rtree = new RTree(this.rtree.filename, 9);\n\t\tawait this.open();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\t'2dsphereIndexVersion': 3\n\t\t};\n\t}\n\n}\n","import { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\n\n/**\n * Query execution plan\n */\nclass QueryPlan {\n\tconstructor() {\n\t\tthis.type = 'full_scan'; // 'full_scan', 'index_scan', 'index_intersection', 'index_union'\n\t\tthis.indexes = []; // Indexes to use\n\t\tthis.indexScans = []; // Array of { indexName, docIds }\n\t\tthis.estimatedCost = Infinity;\n\t\tthis.indexOnly = false; // If true, only use index results (no full scan fallback)\n\t}\n}\n\n/**\n * Query planner - analyzes queries and generates optimal execution plans\n */\nexport class QueryPlanner {\n\tconstructor(indexes) {\n\t\tthis.indexes = indexes; // Map<string, CollectionIndex>\n\t}\n\n\t/**\n\t * Generate an execution plan for a query\n\t * @param {Object} query - MongoDB query object\n\t * @returns {QueryPlan} Execution plan\n\t */\n\tplan(query) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Empty query - full scan\n\t\tif (!query || Object.keys(query).length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Analyze query structure\n\t\tconst analysis = this._analyzeQuery(query);\n\n\t\t// Check for text search\n\t\tif (analysis.hasTextSearch) {\n\t\t\tconst textPlan = this._planTextSearch(query, analysis);\n\t\t\tif (textPlan) {\n\t\t\t\treturn textPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for geospatial query\n\t\tif (analysis.hasGeoQuery) {\n\t\t\tconst geoPlan = this._planGeoQuery(query, analysis);\n\t\t\tif (geoPlan) {\n\t\t\t\treturn geoPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $and queries - can use index intersection\n\t\tif (analysis.type === 'and') {\n\t\t\tconst andPlan = this._planAndQuery(query, analysis);\n\t\t\tif (andPlan.type !== 'full_scan') {\n\t\t\t\treturn andPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $or queries - can use index union\n\t\tif (analysis.type === 'or') {\n\t\t\tconst orPlan = this._planOrQuery(query, analysis);\n\t\t\tif (orPlan.type !== 'full_scan') {\n\t\t\t\treturn orPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Try to find a single index for simple queries\n\t\tconst simplePlan = this._planSimpleQuery(query);\n\t\tif (simplePlan.type !== 'full_scan') {\n\t\t\treturn simplePlan;\n\t\t}\n\n\t\t// Fall back to full scan\n\t\treturn plan;\n\t}\n\n\t/**\n\t * Analyze query structure\n\t * @private\n\t */\n\t_analyzeQuery(query) {\n\t\tconst analysis = {\n\t\t\ttype: 'simple', // 'simple', 'and', 'or', 'complex'\n\t\t\tfields: [],\n\t\t\toperators: {},\n\t\t\thasTextSearch: false,\n\t\t\thasGeoQuery: false,\n\t\t\tconditions: []\n\t\t};\n\n\t\tconst keys = Object.keys(query);\n\n\t\t// Check for top-level logical operators\n\t\tif (keys.length === 1) {\n\t\t\tconst key = keys[0];\n\t\t\tif (key === '$and') {\n\t\t\t\tanalysis.type = 'and';\n\t\t\t\tanalysis.conditions = query.$and;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t} else if (key === '$or') {\n\t\t\t\tanalysis.type = 'or';\n\t\t\t\tanalysis.conditions = query.$or;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t}\n\t\t}\n\n\t\t// Analyze simple field conditions\n\t\tfor (const field of keys) {\n\t\t\tif (field.startsWith('$')) {\n\t\t\t\tcontinue; // Skip top-level operators we don't handle yet\n\t\t\t}\n\n\t\t\tanalysis.fields.push(field);\n\t\t\tconst value = query[field];\n\n\t\t\t// Check for operators\n\t\t\tif (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n\t\t\t\tconst ops = Object.keys(value);\n\t\t\t\tanalysis.operators[field] = ops;\n\n\t\t\t\t// Check for text search\n\t\t\t\tif (ops.includes('$text')) {\n\t\t\t\t\tanalysis.hasTextSearch = true;\n\t\t\t\t}\n\n\t\t\t\t// Check for geospatial operators\n\t\t\t\tif (ops.some(op => ['$geoWithin', '$geoIntersects', '$near', '$nearSphere'].includes(op))) {\n\t\t\t\t\tanalysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If multiple fields, it's an implicit $and\n\t\tif (keys.length > 1) {\n\t\t\tanalysis.type = 'and';\n\t\t}\n\n\t\treturn analysis;\n\t}\n\n\t/**\n\t * Plan for text search queries\n\t * @private\n\t */\n\t_planTextSearch(query, analysis) {\n\t\t// Find text index\n\t\tfor (const [indexName,index] of this.indexes) {\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Look for $text operator in query\n\t\t\t\tconst textQuery = this._extractTextQuery(query);\n\t\t\t\tif (textQuery) {\n\t\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\t\tplan.type = 'index_scan';\n\t\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\t\tplan.indexScans = [{ indexName, index, textQuery }];\n\t\t\t\t\tplan.estimatedCost = 100; // Rough estimate without executing\n\t\t\t\t\tplan.indexOnly = true; // Text search must use index\n\t\t\t\t\treturn plan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extract $text query from query object\n\t * @private\n\t */\n\t_extractTextQuery(query) {\n\t\tfor (const field in query) {\n\t\t\tconst value = query[field];\n\t\t\tif (typeof value === 'object' && value !== null && value.$text) {\n\t\t\t\treturn typeof value.$text === 'string' ? value.$text : value.$text.$search;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for geospatial queries\n\t * @private\n\t */\n\t_planGeoQuery(query, analysis) {\n\t\t// Find geospatial index\n\t\tfor (const [indexName,index] of this.indexes) {\n\t\t\tif (index instanceof GeospatialCollectionIndex) {\n\t\t\t\t// Check if this index can handle the query (don't execute yet)\n\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\tplan.indexScans = [{ indexName, index, query }];\n\t\t\t\tplan.estimatedCost = 100; // Rough estimate without executing\n\t\t\t\tplan.indexOnly = true; // Geospatial queries must use index\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for $and queries (index intersection)\n\t * @private\n\t */\n\t_planAndQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Extract conditions\n\t\tlet conditions;\n\t\tif (query.$and) {\n\t\t\tconditions = query.$and;\n\t\t} else {\n\t\t\t// Implicit AND - convert to array of conditions\n\t\t\tconditions = Object.keys(query).map(field => ({ [field]: query[field] }));\n\t\t}\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have multiple indexable conditions, use index intersection\n\t\tif (indexableConditions.length > 1) {\n\t\t\tplan.type = 'index_intersection';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost (rough estimate without executing)\n\t\t\tplan.estimatedCost = 50; // Intersection typically reduces result set\n\t\t\treturn plan;\n\t\t}\n\n\t\t// If we have one indexable condition, use it\n\t\tif (indexableConditions.length === 1) {\n\t\t\tplan.type = 'index_scan';\n\t\t\tplan.indexScans = [indexableConditions[0]];\n\t\t\tplan.indexes = [indexableConditions[0].indexName];\n\t\t\tplan.estimatedCost = 50; // Rough estimate without executing\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for $or queries (index union)\n\t * @private\n\t */\n\t_planOrQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\tif (!query.$or) {\n\t\t\treturn plan;\n\t\t}\n\n\t\tconst conditions = query.$or;\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have at least one indexable condition, use index union\n\t\tif (indexableConditions.length > 0) {\n\t\t\tplan.type = 'index_union';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost (rough estimate without executing)\n\t\t\tplan.estimatedCost = 100 * indexableConditions.length; // Union typically increases result set\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for simple single-field queries\n\t * @private\n\t */\n\t_planSimpleQuery(query) {\n\t\tconst plan = new QueryPlan();\n\t\tconst queryKeys = Object.keys(query);\n\n\t\tif (queryKeys.length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Try each index\n\t\tfor (const [indexName,index] of this.indexes) {\n\n\t\t\t// Skip special index types (they have their own planning)\n\t\t\tif (index instanceof TextCollectionIndex || index instanceof GeospatialCollectionIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if this index CAN handle the query (don't execute yet)\n\t\t\tif (this._canIndexHandleQuery(index, query)) {\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\tplan.indexScans = [{ indexName, index, query }];\n\t\t\t\tplan.estimatedCost = 50; // Rough estimate without executing\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Execute a single index scan that was deferred from planning\n\t * @private\n\t */\n\tasync _executeIndexScan(scan) {\n\t\tconst { index, query, textQuery } = scan;\n\t\t\n\t\t// Handle text search\n\t\tif (textQuery !== undefined) {\n\t\t\treturn await index.search(textQuery);\n\t\t}\n\t\t\n\t\t// Handle regular index query\n\t\tif (query !== undefined) {\n\t\t\tconst docIds = await index.query(query);\n\t\t\treturn docIds !== null ? docIds : [];\n\t\t}\n\t\t\n\t\t// Fallback: if docIds were already computed (backward compatibility)\n\t\tif (scan.docIds !== undefined) {\n\t\t\treturn scan.docIds;\n\t\t}\n\t\t\n\t\treturn [];\n\t}\n\n\t/**\n\t * Check if an index can handle a query (without executing it)\n\t * @private\n\t */\n\t_canIndexHandleQuery(index, query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(index.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Execute a query plan and return document IDs\n\t * @param {QueryPlan} plan - The execution plan\n\t * @returns {Promise<Array|null>} Array of document IDs or null for full scan\n\t */\n\tasync execute(plan) {\n\t\tif (plan.type === 'full_scan') {\n\t\t\treturn null; // Signals cursor to do full scan\n\t\t}\n\n\t\tif (plan.type === 'index_scan') {\n\t\t\t// Execute the query now\n\t\t\tconst scan = plan.indexScans[0];\n\t\t\treturn await this._executeIndexScan(scan);\n\t\t}\n\n\t\tif (plan.type === 'index_intersection') {\n\t\t\t// Intersection: docs must be in ALL index results\n\t\t\tif (plan.indexScans.length === 0) return null;\n\t\t\t\n\t\t\t// Execute all scans\n\t\t\tconst results = [];\n\t\t\tfor (const scan of plan.indexScans) {\n\t\t\t\tresults.push({\n\t\t\t\t\tdocIds: await this._executeIndexScan(scan),\n\t\t\t\t\tindexName: scan.indexName\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// Start with the smallest set for efficiency\n\t\t\tconst sorted = results.slice().sort((a, b) => a.docIds.length - b.docIds.length);\n\t\t\tlet result = new Set(sorted[0].docIds);\n\t\t\t\n\t\t\t// Intersect with each subsequent set\n\t\t\tfor (let i = 1; i < sorted.length; i++) {\n\t\t\t\tconst currentSet = new Set(sorted[i].docIds);\n\t\t\t\tresult = new Set([...result].filter(id => currentSet.has(id)));\n\t\t\t\t\n\t\t\t\t// Early exit if intersection becomes empty\n\t\t\t\tif (result.size === 0) break;\n\t\t\t}\n\t\t\t\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\tif (plan.type === 'index_union') {\n\t\t\t// Union: docs in ANY index result\n\t\t\tconst result = new Set();\n\t\t\tfor (const scan of plan.indexScans) {\n\t\t\t\tconst docIds = await this._executeIndexScan(scan);\n\t\t\t\tdocIds.forEach(id => result.add(id));\n\t\t\t}\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","import { EventEmitter } from 'events';\nimport { matches } from './queryMatcher.js';\n\n/**\n * ChangeStream watches for changes in collections and emits change events\n * Compatible with MongoDB Change Streams API\n */\nexport class ChangeStream extends EventEmitter {\n\tconstructor(target, pipeline = [], options = {}) {\n\t\tsuper();\n\t\t\n\t\tthis.target = target; // MongoClient, DB, or Collection\n\t\tthis.pipeline = pipeline;\n\t\tthis.options = options;\n\t\tthis.closed = false;\n\t\tthis._listeners = new Map();\n\t\tthis._changeCounter = 0;\n\t\t\n\t\t// Start watching immediately (synchronously)\n\t\tthis._startWatching();\n\t}\n\n\t/**\n\t * Start watching for changes\n\t * @private\n\t */\n\t_startWatching() {\n\t\tif (this.closed) return;\n\t\t\n\t\tconst collections = this._getCollectionsToWatch();\n\t\t\n\t\tfor (const collection of collections) {\n\t\t\tthis._watchCollection(collection);\n\t\t}\n\t\t\n\t\t// For DB watching, we also need to intercept new collection creation\n\t\tif (this.target.constructor.name === 'DB') {\n\t\t\tthis._interceptDBCollectionCreation();\n\t\t}\n\t\t\n\t\t// For MongoClient watching, intercept db() calls\n\t\tif (this.target.constructor.name === 'MongoClient') {\n\t\t\tthis._interceptClientDBCreation();\n\t\t}\n\t}\n\n\t/**\n\t * Get collections to watch based on target type\n\t * @private\n\t */\n\t_getCollectionsToWatch() {\n\t\tconst collections = [];\n\t\t\n\t\t// MongoClient - watch all collections in all databases\n\t\tif (this.target.constructor.name === 'MongoClient') {\n\t\t\t// Store reference to monitor for new databases/collections\n\t\t\tthis._monitorClient();\n\t\t\treturn collections;\n\t\t}\n\t\t\n\t\t// DB - watch all collections in the database\n\t\tif (this.target.constructor.name === 'DB') {\n\t\t\tconst collectionNames = this.target.getCollectionNames();\n\t\t\tfor (const name of collectionNames) {\n\t\t\t\tconst collection = this.target[name];\n\t\t\t\tif (collection && collection.isCollection) {\n\t\t\t\t\tcollections.push(collection);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Also monitor for new collections\n\t\t\tthis._monitorDB();\n\t\t}\n\t\t\n\t\t// Collection - watch specific collection\n\t\tif (this.target.isCollection) {\n\t\t\tcollections.push(this.target);\n\t\t}\n\t\t\n\t\treturn collections;\n\t}\n\n\t/**\n\t * Watch a specific collection for changes\n\t * @private\n\t */\n\t_watchCollection(collection) {\n\t\tif (this.closed) return;\n\t\tif (!collection) return; // Skip null/undefined\n\t\tif (typeof collection.on !== 'function') return; // Skip non-EventEmitters\n\t\tif (!collection.isCollection) return; // Skip non-collections\n\t\tif (this._listeners.has(collection)) return; // Already watching\n\t\t\n\t\tconst handlers = {\n\t\t\tinsert: (doc) => this._emitChange('insert', collection, doc),\n\t\t\tupdate: (doc, updateDescription) => this._emitChange('update', collection, doc, updateDescription),\n\t\t\treplace: (doc) => this._emitChange('replace', collection, doc),\n\t\t\tdelete: (doc) => this._emitChange('delete', collection, doc)\n\t\t};\n\t\t\n\t\t// Store handlers for cleanup\n\t\tthis._listeners.set(collection, handlers);\n\t\t\n\t\t// Listen to collection change events\n\t\tcollection.on('insert', handlers.insert);\n\t\tcollection.on('update', handlers.update);\n\t\tcollection.on('replace', handlers.replace);\n\t\tcollection.on('delete', handlers.delete);\n\t}\n\n\t/**\n\t * Emit a change event\n\t * @private\n\t */\n\t_emitChange(operationType, collection, doc, updateDescription = null) {\n\t\tif (this.closed) return;\n\t\t\n\t\tconst changeEvent = this._createChangeEvent(\n\t\t\toperationType,\n\t\t\tcollection,\n\t\t\tdoc,\n\t\t\tupdateDescription\n\t\t);\n\t\t\n\t\t// Apply pipeline filters if any\n\t\tif (!this._matchesPipeline(changeEvent)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.emit('change', changeEvent);\n\t}\n\n\t/**\n\t * Create a MongoDB-compatible change event document\n\t * @private\n\t */\n\t_createChangeEvent(operationType, collection, doc, updateDescription) {\n\t\tconst event = {\n\t\t\t_id: {\n\t\t\t\t_data: Buffer.from(String(++this._changeCounter)).toString('base64')\n\t\t\t},\n\t\t\toperationType,\n\t\t\tclusterTime: new Date(),\n\t\t\tns: {\n\t\t\t\tdb: collection.db.dbName,\n\t\t\t\tcoll: collection.name\n\t\t\t},\n\t\t\tdocumentKey: {\n\t\t\t\t_id: doc._id\n\t\t\t}\n\t\t};\n\t\t\n\t\tswitch (operationType) {\n\t\t\tcase 'insert':\n\t\t\t\tevent.fullDocument = doc;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'update':\n\t\t\t\tevent.updateDescription = updateDescription || {\n\t\t\t\t\tupdatedFields: {},\n\t\t\t\t\tremovedFields: [],\n\t\t\t\t\ttruncatedArrays: []\n\t\t\t\t};\n\t\t\t\t// Include full document if requested\n\t\t\t\tif (this.options.fullDocument === 'updateLookup') {\n\t\t\t\t\tevent.fullDocument = doc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'replace':\n\t\t\t\tevent.fullDocument = doc;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'delete':\n\t\t\t\t// For delete, doc contains the deleted document's _id\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn event;\n\t}\n\n\t/**\n\t * Check if change event matches pipeline filters\n\t * @private\n\t */\n\t_matchesPipeline(changeEvent) {\n\t\tif (!this.pipeline || this.pipeline.length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// Process pipeline stages\n\t\tfor (const stage of this.pipeline) {\n\t\t\tif (stage.$match) {\n\t\t\t\t// Use the same query matcher as find()\n\t\t\t\t// Note: matches(document, query) - document first, query second\n\t\t\t\tif (!matches(changeEvent, stage.$match)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get nested value from object using dot notation\n\t * @private\n\t */\n\t_getNestedValue(obj, path) {\n\t\treturn path.split('.').reduce((current, part) => current?.[part], obj);\n\t}\n\n\t/**\n\t * Monitor client for new databases/collections (simplified)\n\t * @private\n\t */\n\t_monitorClient() {\n\t\t// Handled by _interceptClientDBCreation\n\t}\n\n\t/**\n\t * Intercept DB creation on a MongoClient\n\t * @private\n\t */\n\t_interceptClientDBCreation() {\n\t\tconst client = this.target;\n\t\tconst originalDb = client.db.bind(client);\n\t\tconst self = this;\n\t\t\n\t\t// Track databases we're watching\n\t\tthis._watchedDBs = new Map();\n\t\t\n\t\t// Override db() method to watch new databases\n\t\tclient.db = function(name, opts) {\n\t\t\tconst database = originalDb(name, opts);\n\t\t\tconst dbName = database.dbName;\n\t\t\t\n\t\t\t// Only set up watch once per database\n\t\t\tif (!self._watchedDBs.has(dbName)) {\n\t\t\t\tself._watchedDBs.set(dbName, database);\n\t\t\t\t\n\t\t\t\t// Watch existing collections in this database\n\t\t\t\tconst collectionNames = database.getCollectionNames();\n\t\t\t\tfor (const colName of collectionNames) {\n\t\t\t\t\tconst col = database[colName];\n\t\t\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\t\t\tself._watchCollection(col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Intercept new collection creation on this database\n\t\t\t\tself._interceptDBCollectionCreationForClient(database);\n\t\t\t}\n\t\t\t\n\t\t\treturn database;\n\t\t};\n\t\t\n\t\t// Store original for cleanup\n\t\tthis._originalClientMethods = { db: originalDb };\n\t}\n\n\t/**\n\t * Intercept collection creation for a database in client watch mode\n\t * @private\n\t */\n\t_interceptDBCollectionCreationForClient(db) {\n\t\tconst originalCollection = db.collection.bind(db);\n\t\tconst originalCreateCollection = db.createCollection.bind(db);\n\t\tconst self = this;\n\t\t\n\t\tdb.collection = function(name) {\n\t\t\tconst col = originalCollection(name);\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t\treturn col;\n\t\t};\n\t\t\n\t\tdb.createCollection = function(name) {\n\t\t\toriginalCreateCollection(name);\n\t\t\tconst col = db[name];\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Monitor database for new collections\n\t * @private\n\t */\n\t_monitorDB() {\n\t\t// Handled by _interceptDBCollectionCreation\n\t}\n\n\t/**\n\t * Intercept new collection creation on a DB\n\t * @private\n\t */\n\t_interceptDBCollectionCreation() {\n\t\tconst db = this.target;\n\t\tconst originalCollection = db.collection.bind(db);\n\t\tconst originalCreateCollection = db.createCollection.bind(db);\n\t\tconst self = this;\n\t\t\n\t\t// Override collection() method to watch new collections\n\t\tdb.collection = function(name) {\n\t\t\tconst col = originalCollection(name);\n\t\t\t// Watch this collection if we haven't already\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t\treturn col;\n\t\t};\n\t\t\n\t\t// Override createCollection() method\n\t\tdb.createCollection = function(name) {\n\t\t\toriginalCreateCollection(name);\n\t\t\tconst col = db[name];\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Store originals for cleanup\n\t\tthis._originalDBMethods = { collection: originalCollection, createCollection: originalCreateCollection };\n\t}\n\n\t/**\n\t * Close the change stream\n\t */\n\tclose() {\n\t\tif (this.closed) return;\n\t\t\n\t\tthis.closed = true;\n\t\t\n\t\t// Remove all collection listeners\n\t\tfor (const [collection, handlers] of this._listeners) {\n\t\t\tcollection.off('insert', handlers.insert);\n\t\t\tcollection.off('update', handlers.update);\n\t\t\tcollection.off('replace', handlers.replace);\n\t\t\tcollection.off('delete', handlers.delete);\n\t\t}\n\t\t\n\t\tthis._listeners.clear();\n\t\t\n\t\t// Restore original DB methods if we intercepted them\n\t\tif (this._originalDBMethods && this.target.constructor.name === 'DB') {\n\t\t\tthis.target.collection = this._originalDBMethods.collection;\n\t\t\tthis.target.createCollection = this._originalDBMethods.createCollection;\n\t\t}\n\t\t\n\t\t// Restore original MongoClient methods if we intercepted them\n\t\tif (this._originalClientMethods && this.target.constructor.name === 'MongoClient') {\n\t\t\tthis.target.db = this._originalClientMethods.db;\n\t\t}\n\t\t\n\t\t// Emit close before removing all listeners\n\t\tthis.emit('close');\n\t\tthis.removeAllListeners();\n\t}\n\n\t/**\n\t * Check if the stream is closed\n\t */\n\tget isClosed() {\n\t\treturn this.closed;\n\t}\n\n\t/**\n\t * Async iterator support for for-await-of loops\n\t */\n\tasync *[Symbol.asyncIterator]() {\n\t\tconst queue = [];\n\t\tlet resolveNext = null;\n\t\tlet streamClosed = false;\n\t\t\n\t\tconst onChange = (change) => {\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext({ value: change, done: false });\n\t\t\t\tresolveNext = null;\n\t\t\t} else {\n\t\t\t\tqueue.push(change);\n\t\t\t}\n\t\t};\n\t\t\n\t\tconst onClose = () => {\n\t\t\tstreamClosed = true;\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext({ done: true });\n\t\t\t\tresolveNext = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tconst onError = (error) => {\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext(Promise.reject(error));\n\t\t\t\tresolveNext = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tthis.on('change', onChange);\n\t\tthis.on('close', onClose);\n\t\tthis.on('error', onError);\n\t\t\n\t\ttry {\n\t\t\twhile (!streamClosed) {\n\t\t\t\tif (queue.length > 0) {\n\t\t\t\t\tyield queue.shift();\n\t\t\t\t} else {\n\t\t\t\t\tconst next = await new Promise((resolve) => {\n\t\t\t\t\t\tresolveNext = resolve;\n\t\t\t\t\t\t// Check if stream was closed while waiting\n\t\t\t\t\t\tif (streamClosed) {\n\t\t\t\t\t\t\tresolve({ done: true });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif (next.done) break;\n\t\t\t\t\tyield next.value;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.off('change', onChange);\n\t\t\tthis.off('close', onClose);\n\t\t\tthis.off('error', onError);\n\t\t}\n\t}\n\n\t/**\n\t * Get next change (for compatibility)\n\t */\n\tasync next() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst onChange = (change) => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(change);\n\t\t\t};\n\t\t\t\n\t\t\tconst onClose = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(null);\n\t\t\t};\n\t\t\t\n\t\t\tconst onError = (error) => {\n\t\t\t\tcleanup();\n\t\t\t\treject(error);\n\t\t\t};\n\t\t\t\n\t\t\tconst cleanup = () => {\n\t\t\t\tthis.off('change', onChange);\n\t\t\t\tthis.off('close', onClose);\n\t\t\t\tthis.off('error', onError);\n\t\t\t};\n\t\t\t\n\t\t\tif (this.closed) {\n\t\t\t\tresolve(null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis.once('change', onChange);\n\t\t\tthis.once('close', onClose);\n\t\t\tthis.once('error', onError);\n\t\t});\n\t}\n}\n","import { EventEmitter } from 'events';\nimport { Cursor } from './Cursor.js';\nimport { SortedCursor } from './SortedCursor.js';\nimport { isArray, getProp, applyProjection, copy } from './utils.js';\nimport { matches, matchWithArrayIndices } from './queryMatcher.js';\nimport { applyUpdates, createDocFromUpdate } from './updates.js';\nimport { RegularCollectionIndex } from './RegularCollectionIndex.js';\nimport { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\nimport { QueryPlanner } from './QueryPlanner.js';\nimport { evaluateExpression } from './aggregationExpressions.js';\nimport { ChangeStream } from './ChangeStream.js';\nimport { \n\tNotImplementedError, \n\tQueryError, \n\tBadValueError, \n\tIndexError, \n\tIndexNotFoundError,\n\tErrorCodes \n} from './errors.js';\n\n/**\n * Collection class\n */\nexport class Collection extends EventEmitter {\n\tconstructor(db, name, storage, idGenerator) {\n\t\tsuper();\n\t\tthis.db = db;\n\t\tthis.name = name;\n\t\tthis.storage = storage;\n\t\tthis.idGenerator = idGenerator;\n\t\tthis.indexes = new Map(); // Index storage - map of index name to index structure\n\t\tthis.queryPlanner = new QueryPlanner(this.indexes); // Query planner\n\t\tthis.isCollection = true; // TODO used by dropDatabase, ugly\n\n\t\t// Indexes are loaded async via createIndex/openIndexes\n\t\t// No synchronous index loading in OPFS-only mode\n\t\tthis._restoreIndexesFromStorage();\n\t}\n\n\t_restoreIndexesFromStorage() {\n\t\tif (!this.storage || !this.storage.indexes || typeof this.storage.indexes[Symbol.iterator] !== 'function') {\n\t\t\treturn;\n\t\t}\n\t\tfor (const [indexName, indexStore] of this.storage.indexes) {\n\t\t\tconst meta = indexStore && typeof indexStore.getAllMeta === 'function' ? indexStore.getAllMeta() : null;\n\t\t\tif (!meta || !meta.type || !meta.baseFilename || !meta.keys) continue;\n\t\t\tconst name = meta.name || indexName;\n\t\t\tlet index;\n\t\t\tif (meta.type === 'text') {\n\t\t\t\tindex = new TextCollectionIndex(name, meta.keys, meta.baseFilename, meta.options || {});\n\t\t\t} else if (meta.type === 'geospatial') {\n\t\t\t\tconst storageFile = meta.storage || `${meta.baseFilename}-geo.bjson`;\n\t\t\t\tindex = new GeospatialCollectionIndex(name, meta.keys, storageFile, meta.options || {});\n\t\t\t} else {\n\t\t\t\tconst storageFile = meta.storage || `${meta.baseFilename}.bjson`;\n\t\t\t\tindex = new RegularCollectionIndex(name, meta.keys, storageFile, meta.options || {});\n\t\t\t}\n\t\t\tthis.indexes.set(name, index);\n\t\t}\n\t}\n\n\tasync _ensureIndexOpen(index) {\n\t\tif (index && typeof index.open === 'function' && !index.isOpen) {\n\t\t\tawait index.open();\n\t\t}\n\t}\n\n\t/**\n\t * Close all indexes\n\t */\n\tasync close() {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index && typeof index.close === 'function') {\n\t\t\t\tawait index.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Determine if keys specify a text index\n\t */\n\tisTextIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine if keys specify a geospatial index\n\t */\n\tisGeospatialIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build a safe base filename for OPFS-backed index files\n\t */\n\t_getIndexBaseFilename(indexName) {\n\t\tconst sanitize = value => String(value).replace(/[^a-zA-Z0-9_-]/g, '_');\n\t\tconst dbName = this.db.dbName || this.db.name || 'db';\n\t\treturn `${sanitize(dbName)}-${sanitize(this.name)}-${sanitize(indexName)}`;\n\t}\n\n\t/**\n\t * Build/rebuild an index\n\t */\n\tasync buildIndex(indexName, keys, options = {}) {\n\t\tlet index;\n\t\tconst baseFilename = this._getIndexBaseFilename(indexName);\n\t\tlet storageFile;\n\t\tlet type;\n\t\t\n\t\t// Create appropriate index type\n\t\tif (this.isTextIndex(keys)) {\n\t\t\ttype = 'text';\n\t\t\tstorageFile = baseFilename; // TextIndex uses base filename for its multiple files\n\t\t\tindex = new TextCollectionIndex(indexName, keys, storageFile, options);\n\t\t} else if (this.isGeospatialIndex(keys)) {\n\t\t\ttype = 'geospatial';\n\t\t\tstorageFile = `${baseFilename}-geo.bjson`;\n\t\t\tindex = new GeospatialCollectionIndex(indexName, keys, storageFile, options);\n\t\t} else {\n\t\t\ttype = 'regular';\n\t\t\tstorageFile = `${baseFilename}.bjson`;\n\t\t\tindex = new RegularCollectionIndex(indexName, keys, storageFile, options);\n\t\t}\n\n\t\t// Persist index metadata in the collection store so we can restore on reloads\n\t\tif (this.storage && typeof this.storage.createIndexStore === 'function') {\n\t\t\tthis.storage.createIndexStore(indexName, {\n\t\t\t\tname: indexName,\n\t\t\t\tkeys,\n\t\t\t\ttype,\n\t\t\t\tbaseFilename,\n\t\t\t\tstorage: storageFile,\n\t\t\t\toptions\n\t\t\t});\n\t\t}\n\n\t\t// Open the index for use\n\t\tawait index.open();\n\n\t\t// Rebuild from a clean slate to avoid stale persisted entries\n\t\tif (typeof index.clear === 'function') {\n\t\t\tawait index.clear();\n\t\t}\n\n\t\t// Build index by scanning all documents\n\t\tconst allDocs = this.storage.getAllDocuments();\n\t\tfor (const doc of allDocs) {\n\t\t\tif (doc) {\n\t\t\t\tawait index.add(doc);\n\t\t\t}\n\t\t}\n\n\t\tthis.indexes.set(indexName, index);\n\t\treturn index;\n\t}\n\n\t/**\n\t * Update indexes when a document is inserted\n\t */\n\tasync updateIndexesOnInsert(doc) {\n\t\tconst promises = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tpromises.push((async () => {\n\t\t\t\tawait this._ensureIndexOpen(index);\n\t\t\t\tawait index.add(doc);\n\t\t\t})());\n\t\t}\n\t\t// Wait for all index operations to complete\n\t\tif (promises.length > 0) {\n\t\t\tawait Promise.all(promises);\n\t\t}\n\t}\n\n\t/**\n\t * Update indexes when a document is deleted\n\t */\n\tasync updateIndexesOnDelete(doc) {\n\t\tconst promises = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tpromises.push((async () => {\n\t\t\t\tawait this._ensureIndexOpen(index);\n\t\t\t\tawait index.remove(doc);\n\t\t\t})());\n\t\t}\n\t\t// Wait for all index operations to complete\n\t\tif (promises.length > 0) {\n\t\t\tawait Promise.all(promises);\n\t\t}\n\t}\n\n\t/**\n\t * Query planner - analyze query and determine optimal execution plan\n\t */\n\tplanQuery(query) {\n\t\tconst plan = this.queryPlanner.plan(query);\n\t\t// Note: With OPFS storage, indexes are async. Callers should use planQueryAsync\n\t\t// For now, we return null docIds to signal full scan\n\t\t// Actual async query execution happens via planQueryAsync\n\t\t\n\t\treturn {\n\t\t\tuseIndex: plan.type !== 'full_scan',\n\t\t\tplanType: plan.type,\n\t\t\tindexNames: plan.indexes,\n\t\t\tdocIds: null, // Force full scan for now - use planQueryAsync for index results\n\t\t\testimatedCost: plan.estimatedCost,\n\t\t\tindexOnly: plan.indexOnly || false\n\t\t};\n\t}\n\n\t/**\n\t * Async version of query planner - for use with async indexes\n\t */\n\tasync planQueryAsync(query) {\n\t\tconst plan = this.queryPlanner.plan(query);\n\t\tconst docIds = await this.queryPlanner.execute(plan);\n\t\t\n\t\treturn {\n\t\t\tuseIndex: plan.type !== 'full_scan',\n\t\t\tplanType: plan.type,\n\t\t\tindexNames: plan.indexes,\n\t\t\tdocIds: docIds,\n\t\t\testimatedCost: plan.estimatedCost,\n\t\t\tindexOnly: plan.indexOnly || false\n\t\t};\n\t}\n\n\t/**\n\t * Get a text index for the given field\n\t * @param {string} field - The field name\n\t * @returns {TextCollectionIndex|null} The text index or null if not found\n\t */\n\tgetTextIndex(field) {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Check if this field is indexed\n\t\t\t\tif (index.indexedFields.includes(field)) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Collection methods\n\taggregate(pipeline) {\n\t\tif (!pipeline || !isArray(pipeline)) {\n\t\t\tthrow new QueryError('Pipeline must be an array', { \n\t\t\t\tcollection: this.name, \n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t\t\t});\n\t\t}\n\n\t\t// Start with all documents\n\t\tlet results = [];\n\t\tconst cursor = this.find({});\n\t\twhile (cursor.hasNext()) {\n\t\t\tresults.push(cursor.next());\n\t\t}\n\n\t\t// Process each stage in the pipeline\n\t\tfor (let i = 0; i < pipeline.length; i++) {\n\t\t\tconst stage = pipeline[i];\n\t\t\tconst stageKeys = Object.keys(stage);\n\t\t\tif (stageKeys.length !== 1) {\n\t\t\t\tthrow new QueryError('Each pipeline stage must have exactly one key', { \n\t\t\t\t\tcollection: this.name, \n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t\t\t\t});\n\t\t\t}\n\t\t\tconst stageType = stageKeys[0];\n\t\t\tconst stageSpec = stage[stageType];\n\n\t\t\tif (stageType === \"$match\") {\n\t\t\t\t// Filter documents based on query\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tif (matches(results[j], stageSpec)) {\n\t\t\t\t\t\tmatched.push(results[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults = matched;\n\t\t\t} else if (stageType === \"$project\") {\n\t\t\t\t// Reshape documents with expression support\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tprojected.push(applyProjectionWithExpressions(stageSpec, results[j]));\n\t\t\t\t}\n\t\t\t\tresults = projected;\n\t\t\t} else if (stageType === \"$addFields\" || stageType === \"$set\") {\n\t\t\t\t// Add/set fields with computed expressions\n\t\t\t\tconst modified = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = copy(results[j]);\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tconst expr = stageSpec[field];\n\t\t\t\t\t\tdoc[field] = evaluateExpression(expr, results[j]);\n\t\t\t\t\t}\n\t\t\t\t\tmodified.push(doc);\n\t\t\t\t}\n\t\t\t\tresults = modified;\n\t\t\t} else if (stageType === \"$unset\") {\n\t\t\t\t// Remove fields from documents\n\t\t\t\tconst modified = [];\n\t\t\t\t// $unset can be a string (single field), array of strings, or object\n\t\t\t\tlet fieldsToRemove = [];\n\t\t\t\tif (typeof stageSpec === 'string') {\n\t\t\t\t\tfieldsToRemove = [stageSpec];\n\t\t\t\t} else if (Array.isArray(stageSpec)) {\n\t\t\t\t\tfieldsToRemove = stageSpec;\n\t\t\t\t} else if (typeof stageSpec === 'object') {\n\t\t\t\t\t// Object form: { field1: \"\", field2: \"\" } or { field1: 1, field2: 1 }\n\t\t\t\t\tfieldsToRemove = Object.keys(stageSpec);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = copy(results[j]);\n\t\t\t\t\tfor (let k = 0; k < fieldsToRemove.length; k++) {\n\t\t\t\t\t\tconst field = fieldsToRemove[k];\n\t\t\t\t\t\t// Support dot notation for nested field removal\n\t\t\t\t\t\tconst pathParts = field.split('.');\n\t\t\t\t\t\tif (pathParts.length === 1) {\n\t\t\t\t\t\t\tdelete doc[field];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Navigate to parent and delete nested field\n\t\t\t\t\t\t\tlet parent = doc;\n\t\t\t\t\t\t\tfor (let m = 0; m < pathParts.length - 1; m++) {\n\t\t\t\t\t\t\t\tif (parent == undefined || parent == null) break;\n\t\t\t\t\t\t\t\tparent = parent[pathParts[m]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (parent != undefined && parent != null) {\n\t\t\t\t\t\t\t\tdelete parent[pathParts[pathParts.length - 1]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmodified.push(doc);\n\t\t\t\t}\n\t\t\t\tresults = modified;\n\t\t\t} else if (stageType === \"$sort\") {\n\t\t\t\t// Sort documents\n\t\t\t\tconst sortKeys = Object.keys(stageSpec);\n\t\t\t\tresults.sort(function (a, b) {\n\t\t\t\t\tfor (let k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\tconst key = sortKeys[k];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * stageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (stageType === \"$limit\") {\n\t\t\t\t// Limit number of documents\n\t\t\t\tresults = results.slice(0, stageSpec);\n\t\t\t} else if (stageType === \"$skip\") {\n\t\t\t\t// Skip documents\n\t\t\t\tresults = results.slice(stageSpec);\n\t\t\t} else if (stageType === \"$group\") {\n\t\t\t\t// Group documents\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = stageSpec._id;\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\t// Compute group key using expression evaluator\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = evaluateExpression(groupId, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\t// Initialize group\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\t// Process each accumulator field\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = stageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$min') {\n\t\t\t\t\t\t\tlet min = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (min === undefined || val < min)) {\n\t\t\t\t\t\t\t\t\tmin = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = min;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\t\t\t\tconst set = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (const valKey in set) {\n\t\t\t\t\t\t\t\tarr.push(set[valKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$first') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tresult[field] = evaluateExpression(accExpr, group.docs[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$last') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tresult[field] = evaluateExpression(accExpr, group.docs[group.docs.length - 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$stdDevPop') {\n\t\t\t\t\t\t\t// Population standard deviation\n\t\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (values.length > 0) {\n\t\t\t\t\t\t\t\tconst mean = values.reduce((a, b) => a + b, 0) / values.length;\n\t\t\t\t\t\t\t\tconst variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n\t\t\t\t\t\t\t\tresult[field] = Math.sqrt(variance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$stdDevSamp') {\n\t\t\t\t\t\t\t// Sample standard deviation\n\t\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (values.length > 1) {\n\t\t\t\t\t\t\t\tconst mean = values.reduce((a, b) => a + b, 0) / values.length;\n\t\t\t\t\t\t\t\tconst variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (values.length - 1);\n\t\t\t\t\t\t\t\tresult[field] = Math.sqrt(variance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$mergeObjects') {\n\t\t\t\t\t\t\t// Merge objects from all documents in group\n\t\t\t\t\t\t\tconst merged = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'object' && val !== null && !Array.isArray(val)) {\n\t\t\t\t\t\t\t\t\tObject.assign(merged, val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = merged;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tresults = grouped;\n\t\t\t} else if (stageType === \"$count\") {\n\t\t\t\t// Count documents and return single document with count\n\t\t\t\tresults = [{ [stageSpec]: results.length }];\n\t\t\t} else if (stageType === \"$unwind\") {\n\t\t\t\t// Unwind array field\n\t\t\t\tconst unwound = [];\n\t\t\t\tlet fieldPath = stageSpec;\n\t\t\t\tif (typeof fieldPath === 'string' && fieldPath.charAt(0) === '$') {\n\t\t\t\t\tfieldPath = fieldPath.substring(1);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tconst arr = getProp(doc, fieldPath);\n\n\t\t\t\t\tif (arr && isArray(arr) && arr.length > 0) {\n\t\t\t\t\t\tfor (let k = 0; k < arr.length; k++) {\n\t\t\t\t\t\t\tconst unwoundDoc = copy(doc);\n\t\t\t\t\t\t\t// Set the unwound value\n\t\t\t\t\t\t\tconst parts = fieldPath.split('.');\n\t\t\t\t\t\t\tlet target = unwoundDoc;\n\t\t\t\t\t\t\tfor (let l = 0; l < parts.length - 1; l++) {\n\t\t\t\t\t\t\t\tif (!target[parts[l]]) {\n\t\t\t\t\t\t\t\t\ttarget[parts[l]] = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget = target[parts[l]];\n\t\t\t}\n\t\t\ttarget[parts[parts.length - 1]] = arr[k];\n\t\t\tunwound.push(unwoundDoc);\n\t\t}\n\t}\n\t// MongoDB's default behavior: skip documents where field is missing, null, empty array, or not an array\n}\nresults = unwound;\n} else if (stageType === \"$sortByCount\") {\n\t// Group by expression value and count occurrences, sorted descending by count\n\tconst groups = {};\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst value = evaluateExpression(stageSpec, doc);\n\t\tconst key = JSON.stringify(value);\n\t\t\n\t\tif (!groups[key]) {\n\t\t\tgroups[key] = {\n\t\t\t\t_id: value,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t}\n\t\tgroups[key].count++;\n\t}\n\t\n\t// Convert to array and sort by count descending\n\tresults = Object.values(groups).sort((a, b) => b.count - a.count);\n} else if (stageType === \"$replaceRoot\" || stageType === \"$replaceWith\") {\n\t// Replace root document with specified document\n\tconst modified = [];\n\tconst newRootSpec = stageType === \"$replaceRoot\" ? stageSpec.newRoot : stageSpec;\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst newRoot = evaluateExpression(newRootSpec, results[j]);\n\t\tif (typeof newRoot === 'object' && newRoot !== null && !Array.isArray(newRoot)) {\n\t\t\tmodified.push(newRoot);\n\t\t} else {\n\t\t\tthrow new QueryError('$replaceRoot expression must evaluate to an object', {\n\t\t\t\tcollection: this.name,\n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t});\n\t\t}\n\t}\n\tresults = modified;\n} else if (stageType === \"$sample\") {\n\t// Random sampling of documents\n\tconst size = stageSpec.size || 1;\n\tif (typeof size !== 'number' || size < 0) {\n\t\tthrow new QueryError('$sample size must be a non-negative number', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Shuffle using Fisher-Yates algorithm and take first 'size' elements\n\tconst shuffled = [...results];\n\tfor (let j = shuffled.length - 1; j > 0; j--) {\n\t\tconst k = Math.floor(Math.random() * (j + 1));\n\t\t[shuffled[j], shuffled[k]] = [shuffled[k], shuffled[j]];\n\t}\n\tresults = shuffled.slice(0, Math.min(size, shuffled.length));\n} else if (stageType === \"$bucket\") {\n\t// Categorize documents into buckets based on boundaries\n\tif (!stageSpec.groupBy || !stageSpec.boundaries) {\n\t\tthrow new QueryError('$bucket requires groupBy and boundaries', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst boundaries = stageSpec.boundaries;\n\tconst defaultBucket = stageSpec.default;\n\tconst output = stageSpec.output || { count: { $sum: 1 } };\n\t\n\t// Initialize buckets\n\tconst buckets = {};\n\tfor (let j = 0; j < boundaries.length - 1; j++) {\n\t\tconst key = JSON.stringify(boundaries[j]);\n\t\tbuckets[key] = {\n\t\t\t_id: boundaries[j],\n\t\t\tdocs: []\n\t\t};\n\t}\n\tif (defaultBucket !== undefined) {\n\t\tbuckets['default'] = {\n\t\t\t_id: defaultBucket,\n\t\t\tdocs: []\n\t\t};\n\t}\n\t\n\t// Categorize documents into buckets\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst value = evaluateExpression(stageSpec.groupBy, doc);\n\t\t\n\t\tlet placed = false;\n\t\tfor (let k = 0; k < boundaries.length - 1; k++) {\n\t\t\tif (value >= boundaries[k] && value < boundaries[k + 1]) {\n\t\t\t\tconst key = JSON.stringify(boundaries[k]);\n\t\t\t\tbuckets[key].docs.push(doc);\n\t\t\t\tplaced = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!placed && defaultBucket !== undefined) {\n\t\t\tbuckets['default'].docs.push(doc);\n\t\t}\n\t}\n\t\n\t// Apply output accumulators\n\tconst bucketed = [];\n\tfor (const bucketKey in buckets) {\n\t\tconst bucket = buckets[bucketKey];\n\t\tif (bucket.docs.length === 0) continue; // Skip empty buckets\n\t\t\n\t\tconst result = { _id: bucket._id };\n\t\t\n\t\tfor (const field in output) {\n\t\t\tconst accumulator = output[field];\n\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\n\t\t\tconst accType = accKeys[0];\n\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\n\t\t\t// Apply accumulator (reuse $group logic)\n\t\t\tif (accType === '$sum') {\n\t\t\t\tlet sum = 0;\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\tsum += val;\n\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[field] = sum;\n\t\t\t} else if (accType === '$avg') {\n\t\t\t\tlet sum = 0;\n\t\t\t\tlet count = 0;\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t} else if (accType === '$push') {\n\t\t\t\tconst arr = [];\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tarr.push(val);\n\t\t\t\t}\n\t\t\t\tresult[field] = arr;\n\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\tconst set = {};\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t}\n\t\t\t\tresult[field] = Object.values(set);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbucketed.push(result);\n\t}\n\t\n\t// Sort by _id (bucket boundary)\n\tresults = bucketed.sort((a, b) => {\n\t\tif (a._id < b._id) return -1;\n\t\tif (a._id > b._id) return 1;\n\t\treturn 0;\n\t});\n} else if (stageType === \"$bucketAuto\") {\n\t// Auto-calculate bucket boundaries and categorize documents\n\tif (!stageSpec.groupBy || !stageSpec.buckets) {\n\t\tthrow new QueryError('$bucketAuto requires groupBy and buckets', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst numBuckets = stageSpec.buckets;\n\tconst output = stageSpec.output || { count: { $sum: 1 } };\n\t\n\tif (results.length === 0) {\n\t\tresults = [];\n\t} else {\n\t\t// Extract and sort values\n\t\tconst values = results.map(doc => ({\n\t\t\tvalue: evaluateExpression(stageSpec.groupBy, doc),\n\t\t\tdoc: doc\n\t\t})).sort((a, b) => {\n\t\t\tif (a.value < b.value) return -1;\n\t\t\tif (a.value > b.value) return 1;\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\t// Calculate bucket size\n\t\tconst bucketSize = Math.ceil(values.length / numBuckets);\n\t\tconst buckets = [];\n\t\t\n\t\tfor (let j = 0; j < numBuckets && j * bucketSize < values.length; j++) {\n\t\t\tconst startIdx = j * bucketSize;\n\t\t\tconst endIdx = Math.min((j + 1) * bucketSize, values.length);\n\t\t\tconst bucketDocs = values.slice(startIdx, endIdx);\n\t\t\t\n\t\t\tif (bucketDocs.length === 0) continue;\n\t\t\t\n\t\t\tconst bucket = {\n\t\t\t\t_id: {\n\t\t\t\t\tmin: bucketDocs[0].value,\n\t\t\t\t\tmax: endIdx < values.length ? bucketDocs[bucketDocs.length - 1].value : bucketDocs[bucketDocs.length - 1].value\n\t\t\t\t},\n\t\t\t\tdocs: bucketDocs.map(v => v.doc)\n\t\t\t};\n\t\t\tbuckets.push(bucket);\n\t\t}\n\t\t\n\t\t// Apply output accumulators\n\t\tconst bucketed = [];\n\t\tfor (let j = 0; j < buckets.length; j++) {\n\t\t\tconst bucket = buckets[j];\n\t\t\tconst result = { _id: bucket._id };\n\t\t\t\n\t\t\tfor (const field in output) {\n\t\t\t\tconst accumulator = output[field];\n\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\t\n\t\t\t\tconst accType = accKeys[0];\n\t\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\t\n\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = sum;\n\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\tconst arr = [];\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = arr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbucketed.push(result);\n\t\t}\n\t\t\n\t\tresults = bucketed;\n\t}\n} else if (stageType === \"$out\") {\n\t// Output results to a collection (replaces existing collection)\n\tconst targetCollectionName = stageSpec;\n\t\n\tif (typeof targetCollectionName !== 'string') {\n\t\tthrow new QueryError('$out requires a string collection name', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Drop and recreate target collection\n\tif (this.db[targetCollectionName]) {\n\t\tthis.db.dropCollection(targetCollectionName);\n\t}\n\tthis.db.createCollection(targetCollectionName);\n\t\n\tconst targetCollection = this.db[targetCollectionName];\n\t\n\t// Insert all results into target collection\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst docId = doc._id;\n\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\ttargetCollection.storage.set(key, doc);\n\t}\n\t\n\t// $out returns empty results (MongoDB behavior)\n\tresults = [];\n} else if (stageType === \"$merge\") {\n\t// Merge results into a collection (MongoDB 4.2+)\n\tlet targetCollectionName;\n\tlet on = '_id';\n\tlet whenMatched = 'merge';\n\tlet whenNotMatched = 'insert';\n\t\n\tif (typeof stageSpec === 'string') {\n\t\ttargetCollectionName = stageSpec;\n\t} else if (typeof stageSpec === 'object') {\n\t\ttargetCollectionName = stageSpec.into;\n\t\ton = stageSpec.on || on;\n\t\twhenMatched = stageSpec.whenMatched || whenMatched;\n\t\twhenNotMatched = stageSpec.whenNotMatched || whenNotMatched;\n\t}\n\t\n\tif (!targetCollectionName) {\n\t\tthrow new QueryError('$merge requires a target collection', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Create target collection if it doesn't exist\n\tif (!this.db[targetCollectionName]) {\n\t\tthis.db.createCollection(targetCollectionName);\n\t}\n\t\n\tconst targetCollection = this.db[targetCollectionName];\n\t\n\t// Merge documents\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst matchField = typeof on === 'string' ? on : on[0];\n\t\tconst matchValue = getProp(doc, matchField);\n\t\t\n\t\t// Find existing document\n\t\tconst existingCursor = targetCollection.find({ [matchField]: matchValue });\n\t\tconst existing = existingCursor.hasNext() ? existingCursor.next() : null;\n\t\t\n\t\tif (existing) {\n\t\t\tif (whenMatched === 'replace') {\n\t\t\t\tconst docId = doc._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, doc);\n\t\t\t} else if (whenMatched === 'merge') {\n\t\t\t\tconst merged = Object.assign({}, existing, doc);\n\t\t\t\tconst docId = merged._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, merged);\n\t\t\t} else if (whenMatched === 'keepExisting') {\n\t\t\t\t// Do nothing\n\t\t\t} else if (whenMatched === 'fail') {\n\t\t\t\tthrow new QueryError('$merge failed: duplicate key', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.DUPLICATE_KEY\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (whenNotMatched === 'insert') {\n\t\t\t\tconst docId = doc._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, doc);\n\t\t\t} else if (whenNotMatched === 'discard') {\n\t\t\t\t// Do nothing\n\t\t\t} else if (whenNotMatched === 'fail') {\n\t\t\t\tthrow new QueryError('$merge failed: document not found', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// $merge returns empty results (MongoDB behavior)\n\tresults = [];\n} else if (stageType === \"$lookup\") {\n\t// Left outer join with another collection\n\tif (!stageSpec.from || !stageSpec.localField || !stageSpec.foreignField || !stageSpec.as) {\n\t\tthrow new QueryError('$lookup requires from, localField, foreignField, and as', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Check if collection exists without triggering auto-creation\n\tconst collectionNames = this.db.getCollectionNames();\n\tif (!collectionNames.includes(stageSpec.from)) {\n\t\tthrow new QueryError('$lookup: collection not found: ' + stageSpec.from, {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t}\n\t\n\tconst fromCollection = this.db[stageSpec.from];\n\t\n\tconst joined = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst localValue = getProp(doc, stageSpec.localField);\n\t\t\n\t\t// Find matching documents in foreign collection\n\t\tconst matches = [];\n\t\tconst foreignCursor = fromCollection.find({ [stageSpec.foreignField]: localValue });\n\t\twhile (foreignCursor.hasNext()) {\n\t\t\tmatches.push(foreignCursor.next());\n\t\t}\n\t\t\n\t\tdoc[stageSpec.as] = matches;\n\t\tjoined.push(doc);\n\t}\n\tresults = joined;\n} else if (stageType === \"$graphLookup\") {\n\t// Recursive graph lookup\n\tif (!stageSpec.from || !stageSpec.startWith || !stageSpec.connectFromField || \n\t    !stageSpec.connectToField || !stageSpec.as) {\n\t\tthrow new QueryError('$graphLookup requires from, startWith, connectFromField, connectToField, and as', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Check if collection exists without triggering auto-creation\n\tconst collectionNames = this.db.getCollectionNames();\n\tif (!collectionNames.includes(stageSpec.from)) {\n\t\tthrow new QueryError('$graphLookup: collection not found: ' + stageSpec.from, {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t}\n\t\n\tconst fromCollection = this.db[stageSpec.from];\n\t\n\tconst maxDepth = stageSpec.maxDepth !== undefined ? stageSpec.maxDepth : Number.MAX_SAFE_INTEGER;\n\tconst depthField = stageSpec.depthField;\n\tconst restrictSearchWithMatch = stageSpec.restrictSearchWithMatch;\n\t\n\tconst graphed = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst startValue = evaluateExpression(stageSpec.startWith, results[j]);\n\t\t\n\t\t// Recursive lookup\n\t\tconst visited = new Set();\n\t\tconst matches = [];\n\t\tconst queue = [{ value: startValue, depth: 0 }];\n\t\t\n\t\twhile (queue.length > 0) {\n\t\t\tconst { value, depth } = queue.shift();\n\t\t\tif (depth > maxDepth) continue;\n\t\t\t\n\t\t\tconst valueKey = JSON.stringify(value);\n\t\t\tif (visited.has(valueKey)) continue;\n\t\t\tvisited.add(valueKey);\n\t\t\t\n\t\t\t// Find matching documents\n\t\t\tlet query = { [stageSpec.connectToField]: value };\n\t\t\tif (restrictSearchWithMatch) {\n\t\t\t\tquery = { $and: [query, restrictSearchWithMatch] };\n\t\t\t}\n\t\t\t\n\t\t\tconst cursor = fromCollection.find(query);\n\t\t\twhile (cursor.hasNext()) {\n\t\t\t\tconst match = cursor.next();\n\t\t\t\tconst matchCopy = copy(match);\n\t\t\t\t\n\t\t\t\tif (depthField) {\n\t\t\t\t\tmatchCopy[depthField] = depth;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmatches.push(matchCopy);\n\t\t\t\t\n\t\t\t\t// Add connected value to queue for next iteration\n\t\t\t\tconst nextValue = getProp(match, stageSpec.connectFromField);\n\t\t\t\tif (nextValue !== undefined && nextValue !== null) {\n\t\t\t\t\tqueue.push({ value: nextValue, depth: depth + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdoc[stageSpec.as] = matches;\n\t\tgraphed.push(doc);\n\t}\n\tresults = graphed;\n} else if (stageType === \"$facet\") {\n\t// Multiple parallel pipelines\n\tif (typeof stageSpec !== 'object' || Array.isArray(stageSpec)) {\n\t\tthrow new QueryError('$facet requires an object with pipeline definitions', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst facetResult = {};\n\t\n\tfor (const facetName in stageSpec) {\n\t\tconst facetPipeline = stageSpec[facetName];\n\t\t\n\t\tif (!Array.isArray(facetPipeline)) {\n\t\t\tthrow new QueryError('$facet pipeline must be an array', {\n\t\t\t\tcollection: this.name,\n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t});\n\t\t}\n\t\t\n\t\t// Execute the sub-pipeline on a copy of current results\n\t\tlet facetResults = results.map(r => copy(r));\n\t\t\n\t\tfor (let k = 0; k < facetPipeline.length; k++) {\n\t\t\tconst facetStage = facetPipeline[k];\n\t\t\tconst facetStageKeys = Object.keys(facetStage);\n\t\t\tif (facetStageKeys.length !== 1) {\n\t\t\t\tthrow new QueryError('Each pipeline stage must have exactly one key', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tconst facetStageType = facetStageKeys[0];\n\t\t\tconst facetStageSpec = facetStage[facetStageType];\n\t\t\t\n\t\t\t// Process facet stage (recursive call to aggregation logic)\n\t\t\t// We need to inline the stage processing here\n\t\t\tif (facetStageType === \"$match\") {\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tif (matches(facetResults[m], facetStageSpec)) {\n\t\t\t\t\t\tmatched.push(facetResults[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfacetResults = matched;\n\t\t\t} else if (facetStageType === \"$project\") {\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tprojected.push(applyProjectionWithExpressions(facetStageSpec, facetResults[m]));\n\t\t\t\t}\n\t\t\t\tfacetResults = projected;\n\t\t\t} else if (facetStageType === \"$limit\") {\n\t\t\t\tfacetResults = facetResults.slice(0, facetStageSpec);\n\t\t\t} else if (facetStageType === \"$skip\") {\n\t\t\t\tfacetResults = facetResults.slice(facetStageSpec);\n\t\t\t} else if (facetStageType === \"$sort\") {\n\t\t\t\tconst sortKeys = Object.keys(facetStageSpec);\n\t\t\t\tfacetResults.sort(function (a, b) {\n\t\t\t\t\tfor (let n = 0; n < sortKeys.length; n++) {\n\t\t\t\t\t\tconst key = sortKeys[n];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * facetStageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (facetStageType === \"$count\") {\n\t\t\t\tfacetResults = [{ [facetStageSpec]: facetResults.length }];\n\t\t\t} else if (facetStageType === \"$group\") {\n\t\t\t\t// Handle $group in facet sub-pipelines\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = facetStageSpec._id;\n\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = evaluateExpression(groupId, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators (simplified version)\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\tfor (const field in facetStageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = facetStageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tfacetResults = grouped;\n\t\t\t} else if (facetStageType === \"$sortByCount\") {\n\t\t\t\t// Handle $sortByCount in facet sub-pipelines\n\t\t\t\tconst groups = {};\n\t\t\t\t\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tconst value = evaluateExpression(facetStageSpec, doc);\n\t\t\t\t\tconst key = JSON.stringify(value);\n\t\t\t\t\t\n\t\t\t\t\tif (!groups[key]) {\n\t\t\t\t\t\tgroups[key] = {\n\t\t\t\t\t\t\t_id: value,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tgroups[key].count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfacetResults = Object.values(groups).sort((a, b) => b.count - a.count);\n\t\t\t} else if (facetStageType === \"$sample\") {\n\t\t\t\t// Handle $sample in facet sub-pipelines\n\t\t\t\tconst size = facetStageSpec.size || 1;\n\t\t\t\tconst shuffled = [...facetResults];\n\t\t\t\tfor (let m = shuffled.length - 1; m > 0; m--) {\n\t\t\t\t\tconst k = Math.floor(Math.random() * (m + 1));\n\t\t\t\t\t[shuffled[m], shuffled[k]] = [shuffled[k], shuffled[m]];\n\t\t\t\t}\n\t\t\t\tfacetResults = shuffled.slice(0, Math.min(size, shuffled.length));\n\t\t\t} else if (facetStageType === \"$bucket\") {\n\t\t\t\t// Handle $bucket in facet sub-pipelines\n\t\t\t\tconst boundaries = facetStageSpec.boundaries;\n\t\t\t\tconst defaultBucket = facetStageSpec.default;\n\t\t\t\tconst output = facetStageSpec.output || { count: { $sum: 1 } };\n\t\t\t\t\n\t\t\t\tconst buckets = {};\n\t\t\t\tfor (let m = 0; m < boundaries.length - 1; m++) {\n\t\t\t\t\tconst key = JSON.stringify(boundaries[m]);\n\t\t\t\t\tbuckets[key] = {\n\t\t\t\t\t\t_id: boundaries[m],\n\t\t\t\t\t\tdocs: []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (defaultBucket !== undefined) {\n\t\t\t\t\tbuckets['default'] = {\n\t\t\t\t\t\t_id: defaultBucket,\n\t\t\t\t\t\tdocs: []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Categorize documents\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tconst value = evaluateExpression(facetStageSpec.groupBy, doc);\n\t\t\t\t\t\n\t\t\t\t\tlet placed = false;\n\t\t\t\t\tfor (let n = 0; n < boundaries.length - 1; n++) {\n\t\t\t\t\t\tif (value >= boundaries[n] && value < boundaries[n + 1]) {\n\t\t\t\t\t\t\tconst key = JSON.stringify(boundaries[n]);\n\t\t\t\t\t\t\tbuckets[key].docs.push(doc);\n\t\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!placed && defaultBucket !== undefined) {\n\t\t\t\t\t\tbuckets['default'].docs.push(doc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst bucketed = [];\n\t\t\t\tfor (const bucketKey in buckets) {\n\t\t\t\t\tconst bucket = buckets[bucketKey];\n\t\t\t\t\tif (bucket.docs.length === 0) continue;\n\t\t\t\t\t\n\t\t\t\t\tconst result = { _id: bucket._id };\n\t\t\t\t\t\n\t\t\t\t\tfor (const field in output) {\n\t\t\t\t\t\tconst accumulator = output[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < bucket.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[n]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbucketed.push(result);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfacetResults = bucketed.sort((a, b) => {\n\t\t\t\t\tif (a._id < b._id) return -1;\n\t\t\t\t\tif (a._id > b._id) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add more stage types as needed for facet sub-pipelines\n\t\t}\n\t\t\n\t\tfacetResult[facetName] = facetResults;\n\t}\n\t\n\tresults = [facetResult];\n} else if (stageType === \"$redact\") {\n\t// Conditionally filter or redact document content\n\tconst redacted = [];\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst decision = evaluateExpression(stageSpec, doc);\n\t\t\n\t\tif (decision === '$$DESCEND') {\n\t\t\t// Include document and recurse into subdocuments (simplified: just include)\n\t\t\tredacted.push(doc);\n\t\t} else if (decision === '$$PRUNE') {\n\t\t\t// Exclude this document\n\t\t\tcontinue;\n\t\t} else if (decision === '$$KEEP') {\n\t\t\t// Include this document\n\t\t\tredacted.push(doc);\n\t\t} else {\n\t\t\t// If result is a conditional expression, evaluate it\n\t\t\tif (decision) {\n\t\t\t\tredacted.push(doc);\n\t\t\t}\n\t\t}\n\t}\n\tresults = redacted;\n} else if (stageType === \"$geoNear\") {\n\t// Geospatial aggregation with distance calculation\n\tif (!stageSpec.near || !stageSpec.distanceField) {\n\t\tthrow new QueryError('$geoNear requires near and distanceField', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst near = stageSpec.near;\n\tconst distanceField = stageSpec.distanceField;\n\tconst maxDistance = stageSpec.maxDistance;\n\tconst minDistance = stageSpec.minDistance || 0;\n\tconst spherical = stageSpec.spherical !== false;\n\tconst key = stageSpec.key || 'location';\n\t\n\t// Calculate distance for each document\n\tconst withDistances = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst location = getProp(doc, key);\n\t\t\n\t\tif (!location || !Array.isArray(location) || location.length < 2) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Calculate distance (using Haversine formula for spherical or Euclidean for planar)\n\t\tlet distance;\n\t\tif (spherical) {\n\t\t\t// Haversine formula for great circle distance\n\t\t\tconst R = 6371000; // Earth radius in meters\n\t\t\tconst lat1 = near[1] * Math.PI / 180;\n\t\t\tconst lat2 = location[1] * Math.PI / 180;\n\t\t\tconst deltaLat = (location[1] - near[1]) * Math.PI / 180;\n\t\t\tconst deltaLon = (location[0] - near[0]) * Math.PI / 180;\n\t\t\t\n\t\t\tconst a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\n\t\t\t          Math.cos(lat1) * Math.cos(lat2) *\n\t\t\t          Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n\t\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\t\tdistance = R * c;\n\t\t} else {\n\t\t\t// Euclidean distance\n\t\t\tconst dx = location[0] - near[0];\n\t\t\tconst dy = location[1] - near[1];\n\t\t\tdistance = Math.sqrt(dx * dx + dy * dy);\n\t\t}\n\t\t\n\t\t// Filter by distance\n\t\tif (distance >= minDistance && (!maxDistance || distance <= maxDistance)) {\n\t\t\tdoc[distanceField] = distance;\n\t\t\twithDistances.push(doc);\n\t\t}\n\t}\n\t\n\t// Sort by distance (nearest first)\n\twithDistances.sort((a, b) => a[distanceField] - b[distanceField]);\n\t\n\t// Apply limit if specified\n\tif (stageSpec.limit) {\n\t\tresults = withDistances.slice(0, stageSpec.limit);\n\t} else {\n\t\tresults = withDistances;\n\t}\n} else {\n\tthrow new QueryError('Unsupported aggregation stage: ' + stageType, { \n\t\tcollection: this.name, \n\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t});\n}\n}\n\nreturn results;\n}\tbulkWrite() { throw new NotImplementedError('bulkWrite', { collection: this.name }); }\n\n\tasync count() {\n\t\treturn this.storage.size();\n\t}\n\n\tasync copyTo(destCollectionName) {\n\t\tif (!this.db[destCollectionName]) {\n\t\t\tthis.db.createCollection(destCollectionName);\n\t\t}\n\t\tconst destCol = this.db[destCollectionName];\n\t\tlet numCopied = 0;\n\t\tconst c = this.find({});\n\t\twhile (c.hasNext()) {\n\t\t\tawait destCol.insertOne(c.next());\n\t\t\tnumCopied++;\n\t\t}\n\t\treturn numCopied;\n\t}\n\n\tasync createIndex(keys, options) {\n\t\t// MongoDB-compliant createIndex\n\t\t// keys: { fieldName: 1 } for ascending, { fieldName: -1 } for descending, { fieldName: 'text' } for text\n\t\t// options: { name: \"indexName\", unique: true, ... }\n\n\t\tif (!keys || typeof keys !== 'object' || Array.isArray(keys)) {\n\t\t\tthrow new BadValueError('keys', keys, 'createIndex requires a key specification object', { \n\t\t\t\tcollection: this.name \n\t\t\t});\n\t\t}\n\n\t\tconst indexName = (options && options.name) ? options.name : this.generateIndexName(keys);\n\n\t\t// Check if index already exists\n\t\tif (this.indexes.has(indexName)) {\n\t\t\t// MongoDB checks for key specification conflicts\n\t\t\tconst existingIndex = this.indexes.get(indexName);\n\t\t\tconst existingKeys = JSON.stringify(existingIndex.keys);\n\t\t\tconst newKeys = JSON.stringify(keys);\n\t\t\tif (existingKeys !== newKeys) {\n\t\t\t\tthrow new IndexError(\n\t\t\t\t\t\"Index with name '\" + indexName + \"' already exists with a different key specification\", \n\t\t\t\t\t{ \n\t\t\t\t\t\tcode: ErrorCodes.INDEX_OPTIONS_CONFLICT,\n\t\t\t\t\t\tindex: indexName, \n\t\t\t\t\t\tcollection: this.name \n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Same index, return without error\n\t\t\treturn indexName;\n\t\t}\n\n\t\t// Build the index\n\t\tawait this.buildIndex(indexName, keys, options);\n\n\t\treturn indexName;\n\t}\n\n\tdataSize() { throw new NotImplementedError('dataSize', { collection: this.name }); }\n\n\tasync deleteOne(query) {\n\t\tconst doc = await this.findOne(query);\n\t\tif (doc) {\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id.toString());\n\t\t\tthis.emit('delete', { _id: doc._id });\n\t\t\treturn { deletedCount: 1 };\n\t\t} else {\n\t\t\treturn { deletedCount: 0 };\n\t\t}\n\t}\n\n\tasync deleteMany(query) {\n\t\tconst c = this.find(query);\n\t\tconst ids = [];\n\t\tconst docs = [];\n\t\twhile (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tids.push(doc._id);\n\t\t\tdocs.push(doc);\n\t\t}\n\t\tconst deletedCount = ids.length;\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tawait this.updateIndexesOnDelete(docs[i]);\n\t\t\tthis.storage.remove(ids[i].toString());\n\t\t\tthis.emit('delete', { _id: ids[i] });\n\t\t}\n\t\treturn { deletedCount: deletedCount };\n\t}\n\n\tasync distinct(field, query) {\n\t\tconst vals = {};\n\t\tconst c = this.find(query);\n\t\twhile (c.hasNext()) {\n\t\t\tconst d = c.next();\n\t\t\tif (d[field]) {\n\t\t\t\tvals[d[field]] = true;\n\t\t\t}\n\t\t}\n\t\treturn Object.keys(vals);\n\t}\n\n\tasync drop() {\n\t\t// Clear all indexes\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index && typeof index.clear === 'function') {\n\t\t\t\tawait index.clear();\n\t\t\t}\n\t\t}\n\t\tthis.storage.clear();\n\t}\n\n\tdropIndex(indexName) {\n\t\tif (!this.indexes.has(indexName)) {\n\t\t\tthrow new IndexNotFoundError(indexName, { collection: this.name });\n\t\t}\n\t\tthis.indexes.get(indexName).clear();\n\t\tthis.indexes.delete(indexName);\n\t\treturn { nIndexesWas: this.indexes.size + 1, ok: 1 };\n\t}\n\n\tdropIndexes() {\n\t\tconst count = this.indexes.size;\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tindex.clear();\n\t\t}\n\t\tthis.indexes.clear();\n\t\treturn { nIndexesWas: count, msg: \"non-_id indexes dropped\", ok: 1 };\n\t}\n\tensureIndex() { throw new NotImplementedError('ensureIndex', { collection: this.name }); }\n\texplain() { throw new NotImplementedError('explain', { collection: this.name }); }\n\n\tfind(query, projection) {\n\t\tconst normalizedQuery = query == undefined ? {} : query;\n\t\tconst nearSpec = this._extractNearSpec(normalizedQuery);\n\t\t\n\t\t// Get query plan (synchronous, returns null for index docIds)\n\t\tconst queryPlan = this.planQuery(normalizedQuery);\n\t\tconst documents = [];\n\t\tconst seen = {}; // Track which docs we've seen to avoid duplicates\n\t\t\n\t\t// For now, always do full scan since index queries are async\n\t\t// In the future, use planQueryAsync for index-based queries\n\t\tconst allDocs = this.storage.getAllDocuments();\n\t\tfor (const doc of allDocs) {\n\t\t\tif (!seen[doc._id] && matches(doc, normalizedQuery)) {\n\t\t\t\tseen[doc._id] = true;\n\t\t\t\tdocuments.push(doc);\n\t\t\t}\n\t\t}\n\n\t\tif (nearSpec) {\n\t\t\tthis._sortByNearDistance(documents, nearSpec);\n\t\t}\n\t\t\n\t\treturn new Cursor(\n\t\t\tthis,\n\t\t\tnormalizedQuery,\n\t\t\tprojection,\n\t\t\tdocuments,\n\t\t\tSortedCursor\n\t\t);\n\t}\n\n\t_extractNearSpec(query) {\n\t\tfor (const field of Object.keys(query || {})) {\n\t\t\tif (field.startsWith('$')) continue;\n\t\t\tconst value = query[field];\n\t\t\tif (!value || typeof value !== 'object') continue;\n\n\t\t\tif (value.$near) {\n\t\t\t\tconst coords = this._parseNearCoordinates(value.$near);\n\t\t\t\tif (coords) return { field, ...coords };\n\t\t\t}\n\n\t\t\tif (value.$nearSphere) {\n\t\t\t\tconst coords = this._parseNearCoordinates(value.$nearSphere);\n\t\t\t\tif (coords) return { field, ...coords };\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t_parseNearCoordinates(spec) {\n\t\tlet coordinates;\n\t\tif (spec && typeof spec === 'object') {\n\t\t\tif (spec.$geometry && spec.$geometry.coordinates) {\n\t\t\t\tcoordinates = spec.$geometry.coordinates;\n\t\t\t} else if (spec.coordinates) {\n\t\t\t\tcoordinates = spec.coordinates;\n\t\t\t} else if (Array.isArray(spec)) {\n\t\t\t\tcoordinates = spec;\n\t\t\t}\n\t\t}\n\n\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst [lng, lat] = coordinates;\n\t\tif (typeof lat !== 'number' || typeof lng !== 'number') {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { lat, lng };\n\t}\n\n\t_extractPointCoordinates(value) {\n\t\tif (!value) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (value.type === 'FeatureCollection' && Array.isArray(value.features) && value.features.length > 0) {\n\t\t\treturn this._extractPointCoordinates(value.features[0].geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (value.type === 'Feature' && value.geometry) {\n\t\t\treturn this._extractPointCoordinates(value.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (value.type === 'Point' && Array.isArray(value.coordinates) && value.coordinates.length >= 2) {\n\t\t\tconst [lng, lat] = value.coordinates;\n\t\t\tif (typeof lat === 'number' && typeof lng === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_sortByNearDistance(documents, nearSpec) {\n\t\tconst { field, lat: targetLat, lng: targetLng } = nearSpec;\n\t\tdocuments.sort((a, b) => {\n\t\t\tconst aPoint = this._extractPointCoordinates(getProp(a, field));\n\t\t\tconst bPoint = this._extractPointCoordinates(getProp(b, field));\n\n\t\t\tconst aDist = aPoint ? this._haversineDistance(aPoint.lat, aPoint.lng, targetLat, targetLng) : Infinity;\n\t\t\tconst bDist = bPoint ? this._haversineDistance(bPoint.lat, bPoint.lng, targetLat, targetLng) : Infinity;\n\n\t\t\treturn aDist - bDist;\n\t\t});\n\t}\n\n\t_haversineDistance(lat1, lng1, lat2, lng2) {\n\t\tconst R = 6371; // Earth's radius in kilometers\n\t\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\t\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\t\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\treturn R * c;\n\t}\n\n\tfindAndModify() { throw new NotImplementedError('findAndModify', { collection: this.name }); }\n\n\tasync findOne(query, projection) {\n\t\tconst cursor = this.find(query, projection);\n\t\tif (cursor.hasNext()) {\n\t\t\treturn cursor.next();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync findOneAndDelete(filter, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tthis.storage.remove(doc._id.toString());\n\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\telse return doc;\n\t}\n\n\tasync findOneAndReplace(filter, replacement, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\treplacement._id = doc._id;\n\t\tthis.storage.set(doc._id.toString(), replacement);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, replacement);\n\t\t\telse return replacement;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tasync findOneAndUpdate(filter, update, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tconst clone = Object.assign({}, doc);\n\t\t\n\t\t// Get array filter information for positional operator support\n\t\tconst matchInfo = matchWithArrayIndices(doc, filter);\n\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\n\t\tapplyUpdates(update, clone, false, positionalMatchInfo, userArrayFilters);\n\t\tthis.storage.set(doc._id.toString(), clone);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, clone);\n\t\t\telse return clone;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tgetIndexes() {\n\t\t// Return array of index specifications\n\t\tconst result = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tresult.push(index.getSpec());\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetShardDistribution() { throw new NotImplementedError('getShardDistribution', { collection: this.name }); }\n\tgetShardVersion() { throw new NotImplementedError('getShardVersion', { collection: this.name }); }\n\n\t// non-mongo\n\tgetStore() {\n\t\treturn this.storage.getStore();\n\t}\n\n\tgroup() { throw new NotImplementedError('group', { collection: this.name }); }\n\n\tasync insert(doc) {\n\t\tif (Array == doc.constructor) {\n\t\t\treturn await this.insertMany(doc);\n\t\t} else {\n\t\t\treturn await this.insertOne(doc);\n\t\t}\n\t}\n\n\tasync insertOne(doc) {\n\t\tif (doc._id == undefined) doc._id = this.idGenerator();\n\t\tthis.storage.set(doc._id.toString(), doc);\n\t\tawait this.updateIndexesOnInsert(doc);\n\t\tthis.emit('insert', doc);\n\t\treturn { insertedId: doc._id };\n\t}\n\n\tasync insertMany(docs) {\n\t\tconst insertedIds = [];\n\t\tfor (let i = 0; i < docs.length; i++) {\n\t\t\tconst result = await this.insertOne(docs[i]);\n\t\t\tinsertedIds.push(result.insertedId);\n\t\t}\n\t\treturn { insertedIds: insertedIds };\n\t}\n\n\tisCapped() { throw new NotImplementedError('isCapped', { collection: this.name }); }\n\tmapReduce() { throw new NotImplementedError('mapReduce', { collection: this.name }); }\n\treIndex() { throw new NotImplementedError('reIndex', { collection: this.name }); }\n\n\tasync replaceOne(query, replacement, options) { // only replace\n\t\t// first\n\t\tconst result = {};\n\t\tconst c = this.find(query);\n\t\tresult.matchedCount = c.count();\n\t\tif (result.matchedCount == 0) {\n\t\t\tresult.modifiedCount = 0;\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = replacement;\n\t\t\t\tnewDoc._id = this.idGenerator();\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t\tresult.upsertedId = newDoc._id;\n\t\t\t}\n\t\t} else {\n\t\t\tresult.modifiedCount = 1;\n\t\t\tconst doc = c.next();\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\treplacement._id = doc._id;\n\t\t\tthis.storage.set(doc._id.toString(), replacement);\n\t\t\tawait this.updateIndexesOnInsert(replacement);\n\t\t\tthis.emit('replace', replacement);\n\t\t}\n\t\treturn result;\n\t}\n\n\tasync remove(query, options) {\n\t\tconst c = this.find(query);\n\t\tif (!c.hasNext()) return;\n\t\tif (options === true || (options && options.justOne)) {\n\t\t\tconst doc = c.next();\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id.toString());\n\t\t} else {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\tthis.storage.remove(doc._id.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\trenameCollection() { throw new NotImplementedError('renameCollection', { collection: this.name }); }\n\tsave() { throw new NotImplementedError('save', { collection: this.name }); }\n\tstats() { throw new NotImplementedError('stats', { collection: this.name }); }\n\tstorageSize() { throw new NotImplementedError('storageSize', { collection: this.name }); }\n\ttotalSize() { throw new NotImplementedError('totalSize', { collection: this.name }); }\n\ttotalIndexSize() { throw new NotImplementedError('totalIndexSize', { collection: this.name }); }\n\n\tasync update(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tif (options && options.multi) {\n\t\t\t\twhile (c.hasNext()) {\n\t\t\t\t\tconst doc = c.next();\n\t\t\t\t\t\n\t\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\t\n\t\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst doc = c.next();\n\t\t\t\t\n\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\n\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateOne(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tconst originalDoc = JSON.parse(JSON.stringify(doc));\n\t\t\t\n\t\t\t// Get array filter information for positional operator support\n\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\tconst updateDescription = this._getUpdateDescription(originalDoc, doc);\n\t\t\tthis.emit('update', doc, updateDescription);\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateMany(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tconst originalDoc = JSON.parse(JSON.stringify(doc));\n\t\t\t\t\n\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\n\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\t\tconst updateDescription = this._getUpdateDescription(originalDoc, doc);\n\t\t\t\tthis.emit('update', doc, updateDescription);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidate() { throw new NotImplementedError('validate', { collection: this.name }); }\n\n\t/**\n\t * Generate updateDescription for change events\n\t * Compares original and updated documents to track changes\n\t */\n\t_getUpdateDescription(originalDoc, updatedDoc) {\n\t\tconst updatedFields = {};\n\t\tconst removedFields = [];\n\n\t\t// Find updated and new fields\n\t\tfor (const key in updatedDoc) {\n\t\t\tif (key === '_id') continue;\n\t\t\tif (JSON.stringify(originalDoc[key]) !== JSON.stringify(updatedDoc[key])) {\n\t\t\t\tupdatedFields[key] = updatedDoc[key];\n\t\t\t}\n\t\t}\n\n\t\t// Find removed fields\n\t\tfor (const key in originalDoc) {\n\t\t\tif (key === '_id') continue;\n\t\t\tif (!(key in updatedDoc)) {\n\t\t\t\tremovedFields.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tupdatedFields,\n\t\t\tremovedFields,\n\t\t\ttruncatedArrays: [] // Not implemented in micro-mongo\n\t\t};\n\t}\n\n\t/**\n\t * Watch for changes to this collection\n\t * @param {Array} pipeline - Aggregation pipeline to filter changes\n\t * @param {Object} options - Watch options (fullDocument, etc.)\n\t * @returns {ChangeStream} A change stream instance\n\t */\n\twatch(pipeline = [], options = {}) {\n\t\treturn new ChangeStream(this, pipeline, options);\n\t}\n\n}\n\n/**\n * Apply projection with expression support\n * Enhanced version of applyProjection that supports computed expressions\n */\nfunction applyProjectionWithExpressions(projection, doc) {\n\tconst result = {};\n\tconst keys = Object.keys(projection);\n\t\n\t// Check if this is an inclusion or exclusion projection\n\tlet isInclusion = false;\n\tlet isExclusion = false;\n\tlet hasComputedFields = false;\n\t\n\tfor (const key of keys) {\n\t\tif (key === '_id') continue;\n\t\tconst value = projection[key];\n\t\t\n\t\tif (value === 1 || value === true) {\n\t\t\tisInclusion = true;\n\t\t} else if (value === 0 || value === false) {\n\t\t\tisExclusion = true;\n\t\t} else {\n\t\t\t// Computed field (expression)\n\t\t\thasComputedFields = true;\n\t\t}\n\t}\n\t\n\t// Handle computed fields - they imply inclusion mode\n\tif (hasComputedFields || isInclusion) {\n\t\t// Inclusion mode: only include specified fields\n\t\t// Always include _id unless explicitly excluded\n\t\tif (projection._id !== 0 && projection._id !== false) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tconst value = projection[key];\n\t\t\t\n\t\t\tif (key === '_id') {\n\t\t\t\tif (value === 0 || value === false) {\n\t\t\t\t\tdelete result._id;\n\t\t\t\t}\n\t\t\t} else if (value === 1 || value === true) {\n\t\t\t\t// Simple field inclusion\n\t\t\t\tresult[key] = getProp(doc, key);\n\t\t\t} else {\n\t\t\t\t// Computed field (expression)\n\t\t\t\tresult[key] = evaluateExpression(value, doc);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Exclusion mode: include all fields except specified ones\n\t\tfor (const key in doc) {\n\t\t\tif (doc.hasOwnProperty(key)) {\n\t\t\t\tresult[key] = doc[key];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tif (projection[key] === 0 || projection[key] === false) {\n\t\t\t\tdelete result[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\n","/**\n * DocumentStore - In-memory document storage for collections\n * Simple key-value store using a plain JavaScript object\n */\nexport class DocumentStore {\n\tconstructor() {\n\t\tthis.data = new Map();\n\t}\n\n\tclear() {\n\t\tthis.data = new Map();\n\t}\n\n  keys() {\n    return this.data.keys();\n  }\n\n\tget(index) {\n\t\treturn this.data.get(index);\n\t}\n\n\tremove(key) {\n\t\tthis.data.delete(key);\n\t}\n\n\tset(key, value) {\n\t\tthis.data.set(key, value);\n\t}\n\n\tsize() {\n\t\treturn this.data.size;\n\t}\n}\n","/**\n * IndexStore - In-memory index storage for collections\n * \n * Simple key-value store using a plain JavaScript object\n */\nexport class IndexStore {\n\tconstructor(meta) {\n    this._meta = new Map();\n\t\tthis._data = new Map();\n    \n    if (meta) {\n      for (const [key, value] of Object.entries(meta)) {\n        this._meta.set(key, value);\n      }\n    }\n\t}\n\n  /**\n   * Return all metadata as a plain object\n   */\n  getAllMeta() {\n    const meta = {};\n    for (const [key, value] of this._meta) {\n      meta[key] = value;\n    }\n    return meta;\n  }\n\n\tsetMeta(key, value) {\n\t\tthis._meta.set(key, value);\n\t}\n\n  hasMeta(key) {\n    return this._meta.has(key);\n  }\n\n  getMeta(key) {\n\t\treturn this._meta.get(key);\n\t}\n\n  hasDataMap(name) {\n    return this._data.has(name);\n  }\n\n  getDataMap(name) {\n    if (!this._data.has(name)) {\n      this._data.set(name, new Map());\n    }\n    return this._data.get(name);\n  }\n\n\t// clear() {\n\t// \tthis._data.clear();\n\t// }\n\n  // keys() {\n  //   return this._data.keys();\n  // }\n\n  // has(index) {\n  //   return this._data.has(index);\n  // }\n\n\t// get(index) {\n\t// \treturn this._data.get(index);\n\t// }\n\n\t// remove(key) {\n\t// \tthis._data.delete(key);\n\t// }\n\n\t// set(key, value) {\n\t// \tthis._data.set(key, value);\n\t// }\n\n\t// size() {\n\t// \treturn this._data.size;\n\t// }\n}\n","import { DocumentStore } from './DocumentStore.js';\nimport { IndexStore } from './IndexStore.js';\n\n/**\n * CollectionStore - Unified storage for collection documents and indexes\n * \n * Provides:\n * - Document storage (via DocumentStore)\n * - Index data storage (plain objects for each index)\n * - Unified interface for Collection to manage all its data\n */\nexport class CollectionStore {\n\tconstructor() {\n\n\t\t// Document storage - uses DocumentStore for document CRUD operations\n\t\tthis.documents = new DocumentStore();\n\t\t\n\t\t// Index storage - plain object to store index data\n\t\t// Structure: { indexName: indexDataObject }\n\t\tthis.indexes = new Map();\n\t}\n\n\t/**\n\t * Clear all documents and indexes\n\t */\n\tclear() {\n\t\tthis.documents.clear();\n    this.indexes.clear();\n\t}\n\n  /**\n   * Get all document keys\n   * @returns {[string]} Array of document keys\n   */\n  documentKeys() {\n    return this.documents.keys();\n  }\n\n\t/**\n\t * Get all documents as an array\n\t * @returns {Array} Array of all documents\n\t */\n\tgetAllDocuments() {\n\t\treturn Array.from(this.documents.data.values());\n\t}\n\n\t/**\n\t * Get document by ID\n\t * @param {string} docId - Document ID\n\t * @returns {Object|undefined} Document or undefined\n\t */\n\tget(key) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n\t\treturn this.documents.get(key);\n\t}\n\n\t/**\n\t * \n\t */\n\tset(key, value) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n    this.documents.set(key, value);\n\t}\n\n\t/**\n\t * \n\t */\n\tremove(key) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n\t\tthis.documents.remove(key);\n\t}\n\n\t/**\n\t *\n\t */\n\tsize() {\n\t\treturn this.documents.size();\n\t}\n\n\t/**\n\t * Get entire document store (for export/save)\n\t * @returns {Object} Document store object\n\t */\n\tgetStore() {\n\t\tconst store = {};\n\t\tfor (const key of this.documents.keys()) {\n\t\t\tstore[key] = this.documents.get(key);\n\t\t}\n\t\treturn store;\n\t}\n\n\t// ==========================================\n\t// Index Storage Interface\n\t// ==========================================\n\n  indexesCount() {\n    return this.indexes.size;\n  }\n\n  indexKeys() {\n    return this.indexes.keys();\n  }\n\n\t/**\n\t * Get index data for a specific index\n\t * @param {string} indexName - Name of the index\n\t * @returns {Object} Index data object (or creates empty one if doesn't exist)\n\t */\n\tcreateIndexStore(name,meta) {\n\t\tif (!this.indexes.has(name)) {\n\t\t\tthis.indexes.set(name, new IndexStore(meta));\n\t\t}\n\t\treturn this.indexes.get(name);\n\t}\n\n}\n","import { CollectionStore } from './CollectionStore.js';\n\n/**\n * In-memory storage engine (default)\n */\nexport class StorageEngine {\n\tconstructor() {\n\t\tthis.collections = new Map();\n\t}\n\n  collectionsCount() {\n    return this.collections.size;\n  }\n  \n  /**\n   * \n   * @returns {[string]} list of collection names\n   */\n  collectionStoreKeys() {\n    return this.collections.keys();\n  }\n\n  /**\n   * \n   * @param {*} collectionName \n   * @returns \n   */\n  getCollectionStore(collectionName) {\n    return this.collections.get(collectionName);\n  }\n\n\t/**\n\t * Create a collection's state\n\t * @param {string} collectionName - The collection name\n\t * @returns {CollectionStore} The collection store\n\t */\n\tcreateCollectionStore(collectionName) {\n    if (this.collections.has(collectionName)) {\n      return this.collections.get(collectionName);\n    }\n    const collectionStore = new CollectionStore();\n    this.collections.set(collectionName, collectionStore);\n    return collectionStore;\n  }\n\n\t/**\n\t * Delete a collection\n\t * @param {string} collectionName - The collection name\n\t */\n\tremoveCollectionStore(collectionName) {\n    this.collections.delete(collectionName);\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @returns {Promise<void>}\n\t */\n\tsave() {\n\t\t// In-memory storage does not persist data\n\t}\n\n}\n","import { Collection } from './Collection.js';\nimport { StorageEngine } from './StorageEngine.js';\nimport { ObjectId } from 'bjson';\nimport { ChangeStream } from './ChangeStream.js';\nimport { NotImplementedError } from './errors.js';\n\n/**\n * DB class\n */\nexport class DB {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t\tthis.dbName = this.options.dbName || 'default';\n\t\t\t\n\t\t// StorageEngine\n\t\tthis.storageEngine = this.options.storageEngine || new StorageEngine();\n\n\t\t// Load existing collections from storage engine\n\t\tthis._loadExistingCollections();\n\n\t\t// Return a Proxy to enable dynamic collection creation\n\t\treturn new Proxy(this, {\n\t\t\tget(target, property, receiver) {\n\t\t\t\t// If property exists on target (including undefined values), return it\n\t\t\t\tif (property in target) {\n\t\t\t\t\treturn Reflect.get(target, property, receiver);\n\t\t\t\t}\n\n\t\t\t\t// If property is a symbol or special property, return undefined\n\t\t\t\tif (typeof property === 'symbol' || property.startsWith('_')) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n        // For collection names, create the collection if it doesn't exist\n        // Only auto-create if it's a valid collection name and doesn't already exist\n        if (typeof property === 'string') {\n          // Don't auto-create if property was explicitly deleted\n          if (Object.prototype.hasOwnProperty.call(target, property)) {\n            return target[property];\n          }\n          // Auto-create the collection\n          target.createCollection(property);\n          return target[property];\n        }\n        return undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Log function\n\t */\n\t_log(msg) {\n\t\tif (this.options && this.options.print) this.options.print(msg);\n\t\telse console.log(msg);\n\t}\n\n\t/**\n\t * ID generator function\n\t */\n\t_id() {\n\t\tif (this.options && this.options.id) return this.options.id();\n\t\telse return new ObjectId();\n\t}\n\n\t/**\n\t * Load existing collections from storage engine\n\t * @private\n\t */\n\t_loadExistingCollections() {\n\t\t// Iterate through all collection stores in the storage engine\n\t\tfor (const collectionName of this.storageEngine.collectionStoreKeys()) {\n\t\t\tconst collectionStore = this.storageEngine.getCollectionStore(collectionName);\n\t\t\t// Create Collection instance for each existing collection\n\t\t\tthis[collectionName] = new Collection(\n\t\t\t\tthis,\n\t\t\t\tcollectionName,\n\t\t\t\tcollectionStore,\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Close all collections\n\t */\n\tasync close() {\n\t\t// Iterate through all collection properties and close them\n\t\tfor (const key of Object.keys(this)) {\n\t\t\tconst collection = this[key];\n\t\t\tif (collection && collection.isCollection && typeof collection.close === 'function') {\n\t\t\t\tawait collection.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t// DB Methods\n\tcloneCollection() { throw new NotImplementedError('cloneCollection', { database: this.dbName }); }\n\tcloneDatabase() { throw new NotImplementedError('cloneDatabase', { database: this.dbName }); }\n\tcommandHelp() { throw new NotImplementedError('commandHelp', { database: this.dbName }); }\n\tcopyDatabase() { throw new NotImplementedError('copyDatabase', { database: this.dbName }); }\n\n\tcreateCollection(name) {\n\t\tif (!name) return;\n\t\tthis[name] = new Collection(\n\t\t\tthis,\n      name,\n\t\t\tthis.storageEngine.createCollectionStore(name),\n\t\t\tthis._id.bind(this)\n\t\t);\n\t}\n\n\t/**\n\t * Get or create a collection by name (MongoDB-compatible method)\n\t * @param {string} name - Collection name\n\t * @returns {Collection} The collection instance\n\t */\n\tcollection(name) {\n\t\tif (!name) throw new Error('Collection name is required');\n\t\t\n\t\t// Return existing collection if it exists\n\t\tif (this[name] && this[name].isCollection) {\n\t\t\treturn this[name];\n\t\t}\n\t\t\n\t\t// Create and return new collection\n\t\tthis.createCollection(name);\n\t\treturn this[name];\n\t}\n\n\tcurrentOp() { throw new NotImplementedError('currentOp', { database: this.dbName }); }\n\n\tasync dropCollection(collectionName) {\n\t\tif (this[collectionName]) {\n\t\t\t// Close/clear collection data\n\t\t\tif (typeof this[collectionName].drop === 'function') {\n\t\t\t\tawait this[collectionName].drop();\n\t\t\t}\n\t\t\t// Remove from storage engine\n\t\t\tthis.storageEngine.removeCollectionStore(collectionName);\n\t\t\t// Delete the collection property from DB\n\t\t\tdelete this[collectionName];\n\t\t}\n\t}\n\n\tasync dropDatabase() {\n\t\t// Get all collection names\n\t\tconst collectionNames = this.getCollectionNames();\n\t\t\n\t\t// Close and drop each collection\n\t\tfor (const name of collectionNames) {\n\t\t\t// Close collection (which closes all indexes)\n\t\t\tif (this[name] && typeof this[name].close === 'function') {\n\t\t\t\tawait this[name].close();\n\t\t\t}\n\t\t\t// Remove from storage engine\n\t\t\tthis.storageEngine.removeCollectionStore(name);\n\t\t\t// Delete the collection property from DB\n\t\t\tdelete this[name];\n\t\t}\n\t}\n\n\teval() { throw new NotImplementedError('eval', { database: this.dbName }); }\n\tfsyncLock() { throw new NotImplementedError('fsyncLock', { database: this.dbName }); }\n\tfsyncUnlock() { throw new NotImplementedError('fsyncUnlock', { database: this.dbName }); }\n\tgetCollection() { throw new NotImplementedError('getCollection', { database: this.dbName }); }\n\tgetCollectionInfos() { throw new NotImplementedError('getCollectionInfos', { database: this.dbName }); }\n\n\tgetCollectionNames() {\n\t\tconst names = [];\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tnames.push(key);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tgetLastError() { throw new NotImplementedError('getLastError', { database: this.dbName }); }\n\tgetLastErrorObj() { throw new NotImplementedError('getLastErrorObj', { database: this.dbName }); }\n\tgetLogComponents() { throw new NotImplementedError('getLogComponents', { database: this.dbName }); }\n\tgetMongo() { throw new NotImplementedError('getMongo', { database: this.dbName }); }\n\tgetName() { throw new NotImplementedError('getName', { database: this.dbName }); }\n\tgetPrevError() { throw new NotImplementedError('getPrevError', { database: this.dbName }); }\n\tgetProfilingLevel() { throw new NotImplementedError('getProfilingLevel', { database: this.dbName }); }\n\tgetProfilingStatus() { throw new NotImplementedError('getProfilingStatus', { database: this.dbName }); }\n\tgetReplicationInfo() { throw new NotImplementedError('getReplicationInfo', { database: this.dbName }); }\n\tgetSiblingDB() { throw new NotImplementedError('getSiblingDB', { database: this.dbName }); }\n\n\thelp() {\n\t\tthis._log(\"        help mr                      mapreduce\");\n\t\tthis._log(\"        db.foo.find()                list objects in collection foo\");\n\t\tthis._log(\"        db.foo.find( { a : 1 } )     list objects in foo where a == 1\");\n\t\tthis._log(\"        it                           result of the last line evaluated; use to further iterate\");\n\t}\n\n\thostInfo() { throw new NotImplementedError('hostInfo', { database: this.dbName }); }\n\tisMaster() { throw new NotImplementedError('isMaster', { database: this.dbName }); }\n\tkillOp() { throw new NotImplementedError('killOp', { database: this.dbName }); }\n\tlistCommands() { throw new NotImplementedError('listCommands', { database: this.dbName }); }\n\tloadServerScripts() { throw new NotImplementedError('loadServerScripts', { database: this.dbName }); }\n\tlogout() { throw new NotImplementedError('logout', { database: this.dbName }); }\n\tprintCollectionStats() { throw new NotImplementedError('printCollectionStats', { database: this.dbName }); }\n\tprintReplicationInfo() { throw new NotImplementedError('printReplicationInfo', { database: this.dbName }); }\n\tprintShardingStatus() { throw new NotImplementedError('printShardingStatus', { database: this.dbName }); }\n\tprintSlaveReplicationInfo() { throw new NotImplementedError('printSlaveReplicationInfo', { database: this.dbName }); }\n\trepairDatabase() { throw new NotImplementedError('repairDatabase', { database: this.dbName }); }\n\tresetError() { throw new NotImplementedError('resetError', { database: this.dbName }); }\n\trunCommand() { throw new NotImplementedError('runCommand', { database: this.dbName }); }\n\tserverBuildInfo() { throw new NotImplementedError('serverBuildInfo', { database: this.dbName }); }\n\tserverCmdLineOpts() { throw new NotImplementedError('serverCmdLineOpts', { database: this.dbName }); }\n\tserverStatus() { throw new NotImplementedError('serverStatus', { database: this.dbName }); }\n\tsetLogLevel() { throw new NotImplementedError('setLogLevel', { database: this.dbName }); }\n\tsetProfilingLevel() { throw new NotImplementedError('setProfilingLevel', { database: this.dbName }); }\n\tshutdownServer() { throw new NotImplementedError('shutdownServer', { database: this.dbName }); }\n\tstats() { throw new NotImplementedError('stats', { database: this.dbName }); }\n\tversion() { throw new NotImplementedError('version', { database: this.dbName }); }\n\tupgradeCheck() { throw new NotImplementedError('upgradeCheck', { database: this.dbName }); }\n\tupgradeCheckAllDBs() { throw new NotImplementedError('upgradeCheckAllDBs', { database: this.dbName }); }\n\n\t/**\n\t * Watch for changes across all collections in this database\n\t * @param {Array} pipeline - Aggregation pipeline to filter changes\n\t * @param {Object} options - Watch options\n\t * @returns {ChangeStream} A change stream instance\n\t */\n\twatch(pipeline = [], options = {}) {\n\t\treturn new ChangeStream(this, pipeline, options);\n\t}\n}\n","import { EventEmitter } from 'events';\r\nimport { DB } from './DB.js';\r\nimport { ChangeStream } from './ChangeStream.js';\r\n\r\nexport class MongoClient extends EventEmitter {\r\n  constructor(uri = 'mongodb://localhost:27017', options = {}) {\r\n    super();\r\n    this.uri = uri;\r\n    this.options = Object.freeze({ ...options }); // Make immutable\r\n    this._isConnected = false;\r\n    this._defaultDb = this._parseDefaultDbName(uri);\r\n    this._databases = new Map(); // Track database instances\r\n  }\r\n\r\n  static async connect(uri, options = {}) {\r\n    const client = new MongoClient(uri, options);\r\n    await client.connect();\r\n    return client;\r\n  }\r\n\r\n  async connect() {\r\n    if (this._isConnected) return this;\r\n    \r\n    this._isConnected = true;\r\n    this.emit('open', this);\r\n    return this;\r\n  }\r\n\r\n  db(name, opts = {}) {\r\n    // Use default from URI if no name provided\r\n    const dbName = name || this._defaultDb;\r\n    if (!dbName) {\r\n      throw new Error('No database name provided and no default in connection string');\r\n    }\r\n    \r\n    // Return cached database instance if it exists\r\n    if (this._databases.has(dbName)) {\r\n      return this._databases.get(dbName);\r\n    }\r\n    \r\n    const dbOptions = { ...this.options, ...opts, dbName };\r\n    const database = new DB(dbOptions);\r\n    this._databases.set(dbName, database);\r\n    return database;\r\n  }\r\n\r\n  async close(force = false) {\r\n    if (!this._isConnected) return;\r\n    \r\n    // Close all database connections (which closes all collections and indexes)\r\n    for (const [dbName, database] of this._databases) {\r\n      if (database && typeof database.close === 'function') {\r\n        await database.close();\r\n      }\r\n    }\r\n    this._databases.clear();\r\n    \r\n    this._isConnected = false;\r\n    this.emit('close');\r\n  }\r\n\r\n  // Session management stubs\r\n  startSession(options = {}) {\r\n    // Return minimal session object for compatibility\r\n    return {\r\n      id: crypto.randomUUID(),\r\n      endSession: () => {},\r\n      withTransaction: async (fn) => await fn(this)\r\n    };\r\n  }\r\n\r\n  async withSession(optionsOrExecutor, executor) {\r\n    const session = this.startSession(\r\n      typeof optionsOrExecutor === 'function' ? {} : optionsOrExecutor\r\n    );\r\n    const fn = typeof optionsOrExecutor === 'function' ? optionsOrExecutor : executor;\r\n    \r\n    try {\r\n      return await fn(session);\r\n    } finally {\r\n      session.endSession();\r\n    }\r\n  }\r\n\r\n  // Configuration getters\r\n  get readConcern() { return this.options.readConcern; }\r\n  get writeConcern() { return this.options.writeConcern; }\r\n  get readPreference() { return this.options.readPreference; }\r\n\r\n  /**\r\n   * Watch for changes across all databases and collections\r\n   * @param {Array} pipeline - Aggregation pipeline to filter changes\r\n   * @param {Object} options - Watch options\r\n   * @returns {ChangeStream} A change stream instance\r\n   */\r\n  watch(pipeline = [], options = {}) {\r\n    return new ChangeStream(this, pipeline, options);\r\n  }\r\n\r\n  _parseDefaultDbName(uri) {\r\n    // Parse mongodb://host:port/dbname format\r\n    const match = uri.match(/\\/([^/?]+)/);\r\n    return match ? match[1] : null;\r\n  }\r\n}","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * IndexedDB-based storage engine for persistent storage\n * Stores each collection separately in IndexedDB\n */\nexport class IndexedDbStorageEngine extends StorageEngine {\n\tconstructor(dbName = 'micro-mongo') {\n\t\tsuper();\n\t\tthis.dbName = dbName;\n\t\tthis.db = null;\n\t\tthis.indexedDBName = `micro-mongo-${dbName}`;\n\t}\n\n\t/**\n\t * Initialize the IndexedDB connection\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open(this.indexedDBName, 1);\n\n\t\t\trequest.onerror = () => {\n\t\t\t\treject(new Error('Failed to open IndexedDB: ' + request.error));\n\t\t\t};\n\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tthis.db = request.result;\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = event.target.result;\n\t\t\t\t\n\t\t\t\t// Create object stores for collections and metadata\n\t\t\t\tif (!db.objectStoreNames.contains('collections')) {\n\t\t\t\t\tdb.createObjectStore('collections', { keyPath: 'name' });\n\t\t\t\t}\n\t\t\t\tif (!db.objectStoreNames.contains('metadata')) {\n\t\t\t\t\tdb.createObjectStore('metadata', { keyPath: 'key' });\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\t// Save metadata\n\t\tconst transaction = this.db.transaction(['metadata'], 'readwrite');\n\t\tconst metadataStore = transaction.objectStore('metadata');\n\t\t\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst request = metadataStore.put({\n\t\t\t\tkey: 'dbName',\n\t\t\t\tvalue: dbState.name\n\t\t\t});\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\n\t\t// Save each collection\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tawait this.saveCollection(dbState.name, collectionName, dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.getAll();\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst collections = {};\n\t\t\t\tfor (const collectionData of request.result) {\n\t\t\t\t\tcollections[collectionData.name] = {\n\t\t\t\t\t\tdocuments: collectionData.documents || [],\n\t\t\t\t\t\tindexes: collectionData.indexes || []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolve({\n\t\t\t\t\tname: dbName,\n\t\t\t\t\tcollections: collections\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.put({\n\t\t\t\tname: collectionName,\n\t\t\t\tdocuments: collectionState.documents || [],\n\t\t\t\tindexes: collectionState.indexes || []\n\t\t\t});\n\t\t\t\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.get(collectionName);\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tif (request.result) {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tdocuments: request.result.documents || [],\n\t\t\t\t\t\tindexes: request.result.indexes || []\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.delete(collectionName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.deleteDatabase(this.indexedDBName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\t}\n}\n"],"names":["ReflectApply","ReflectOwnKeys","NumberIsNaN","eventsModule","events","once","copy","valuesEqual","SortedCursor","text","haversineDistance","fieldValue","i","k","matches","node1","node2","EventEmitter","self","cursor"],"mappings":"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","x_google_ignoreList":[0,1,6,7,8,16]}