{"version":3,"file":"micro-mongo-2.0.0.min.js","sources":["../node_modules/events/events.js","../node_modules/bjson/src/bjson.js","../src/utils.js","../src/errors.js","../src/Cursor.js","../src/SortedCursor.js","../node_modules/stemmer/index.js","../node_modules/bjson/src/bplustree.js","../node_modules/bjson/src/textindex.js","../src/aggregationExpressions.js","../src/queryMatcher.js","../src/Timestamp.js","../src/updates.js","../src/Index.js","../src/RegularCollectionIndex.js","../src/TextCollectionIndex.js","../node_modules/bjson/src/rtree.js","../src/GeospatialCollectionIndex.js","../src/QueryPlanner.js","../src/ChangeStream.js","../src/Collection.js","../src/DocumentStore.js","../src/IndexStore.js","../src/CollectionStore.js","../src/StorageEngine.js","../src/DB.js","../src/MongoClient.js","../src/IndexedDbStorageEngine.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Binary JSON Encoder/Decoder\n * \n * Encodes JavaScript values to a compact binary format compatible with\n * Origin Private File System (OPFS).\n */\n\nconst TYPE = {\n  NULL: 0x00,\n  FALSE: 0x01,\n  TRUE: 0x02,\n  INT: 0x03,\n  FLOAT: 0x04,\n  STRING: 0x05,\n  OID: 0x06,\n  DATE: 0x07,\n  POINTER: 0x08,\n  ARRAY: 0x10,\n  OBJECT: 0x11\n};\n\n\n/**\n * ObjectId class - MongoDB-compatible 24-character hex string identifier\n * Format: 8-char timestamp + 16-char random data\n */\nclass ObjectId {\n  constructor(id) {\n    if (id === undefined || id === null) {\n      // Generate new ObjectId\n      this.id = ObjectId.generate();\n    } else if (typeof id === 'string') {\n      // Create from hex string\n      if (!ObjectId.isValid(id)) {\n        throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${id}`);\n      }\n      this.id = id.toLowerCase();\n    } else if (id instanceof Uint8Array && id.length === 12) {\n      this.id = Array.from(id).map(b => b.toString(16).padStart(2, '0')).join('');\n    } else if (id instanceof ObjectId) {\n      // Copy constructor\n      this.id = id.id;\n    } else {\n      throw new Error(`Argument passed in must be a string of 24 hex characters or an ObjectId`);\n    }\n  }\n\n  /**\n   * Returns the ObjectId as a 24-character hex string\n   */\n  toString() {\n    return this.id;\n  }\n\n  /**\n   * Returns the ObjectId as a 24-character hex string (alias for toString)\n   */\n  toHexString() {\n    return this.id;\n  }\n\n  /**\n   * Returns the timestamp portion of the ObjectId as a Date\n   */\n  getTimestamp() {\n    const timestamp = parseInt(this.id.substring(0, 8), 16);\n    return new Date(timestamp * 1000);\n  }\n\n  equals(other) {\n    if (!(other instanceof ObjectId)) {\n      throw new Error('Can only compare with another ObjectId');\n    }\n    return this.id === other.id;\n  }\n\n  /**\n   * Compares this ObjectId with another for equality\n   */\n  compare(other) {\n    if (!(other instanceof ObjectId)) {\n      throw new Error('Can only compare with another ObjectId');\n    }\n\n    return this.id.localeCompare(other.id);\n  }\n\n  /**\n   * Returns the ObjectId in JSON format (as hex string)\n   */\n  toJSON() {\n    return this.id;\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return `ObjectId(\"${this.id}\")`;\n  }\n\n  toBytes() {\n    const bytes = new Uint8Array(12);\n    for (let i = 0; i < 12; i++) {\n      bytes[i] = parseInt(this.id.substring(i * 2, i * 2 + 2), 16);\n    }\n    return bytes;\n  }\n\n  /**\n   * Validates if a string is a valid ObjectId hex string\n   */\n  static isValid(id) {\n    if (!id) return false;\n    if (typeof id !== 'string') return false;\n    if (id.length !== 24) return false;\n    return /^[0-9a-fA-F]{24}$/.test(id);\n  }\n\n  /**\n   * Creates an ObjectId from a timestamp\n   */\n  static createFromTime(timestamp) {\n    const ts = Math.floor(timestamp / 1000);\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\n    const tail = '0000000000000000'; // Zero out the random portion\n    return new ObjectId(tsHex + tail);\n  }\n\n  /**\n   * Generates a new ObjectId hex string\n   * Format: 8-char timestamp (4 bytes) + 16-char random data (8 bytes)\n   */\n  static generate() {\n    const ts = Math.floor(Date.now() / 1000);\n    \n    // Generate 8 random bytes\n    const rand = typeof crypto !== 'undefined' && crypto.getRandomValues ? new Uint8Array(8) : null;\n    let tail = '';\n    \n    if (rand) {\n      crypto.getRandomValues(rand);\n      for (let i = 0; i < rand.length; i++) {\n        tail += ('0' + rand[i].toString(16)).slice(-2);\n      }\n    } else {\n      // Fallback for environments without crypto\n      // Generate two 8-character hex strings\n      tail = Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8) +\n             Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8);\n    }\n    \n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\n    return (tsHex + tail).slice(0, 24);\n  }\n}\n\n/**\n * Pointer class - represents a 64-bit file offset pointer\n * Used to store file offsets for referenced data structures\n */\nclass Pointer {\n  constructor(offset) {\n    if (offset === undefined || offset === null) {\n      throw new Error('Pointer offset must be a number');\n    }\n    if (typeof offset !== 'number') {\n      throw new Error('Pointer offset must be a number');\n    }\n    if (!Number.isInteger(offset)) {\n      throw new Error('Pointer offset must be an integer');\n    }\n    if (offset < 0) {\n      throw new Error('Pointer offset must be non-negative');\n    }\n    if (offset > Number.MAX_SAFE_INTEGER) {\n      throw new Error('Pointer offset exceeds maximum safe integer');\n    }\n    this.offset = offset;\n  }\n\n  /**\n   * Returns the pointer offset as a number\n   */\n  valueOf() {\n    return this.offset;\n  }\n\n  /**\n   * Returns the pointer offset as a string\n   */\n  toString() {\n    return this.offset.toString();\n  }\n\n  /**\n   * Returns the pointer in JSON format (as number)\n   */\n  toJSON() {\n    return this.offset;\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return `Pointer(${this.offset})`;\n  }\n\n  /**\n   * Compares this Pointer with another for equality\n   */\n  equals(other) {\n    if (!(other instanceof Pointer)) {\n      return false;\n    }\n    return this.offset === other.offset;\n  }\n}\n\n/**\n * Encode a JavaScript value to binary format\n */\nfunction encode(value) {\n  const buffers = [];\n\n  function encodeValue(val) {\n    if (val === null) {\n      buffers.push(new Uint8Array([TYPE.NULL]));\n    } else if (val === false) {\n      buffers.push(new Uint8Array([TYPE.FALSE]));\n    } else if (val === true) {\n      buffers.push(new Uint8Array([TYPE.TRUE]));\n    } else if (val instanceof ObjectId) {\n      buffers.push(new Uint8Array([TYPE.OID]));\n      buffers.push(val.toBytes());\n    } else if (val instanceof Date) {\n      buffers.push(new Uint8Array([TYPE.DATE]));\n      const buffer = new ArrayBuffer(8);\n      const view = new DataView(buffer);\n      view.setBigInt64(0, BigInt(val.getTime()), true); // little-endian\n      buffers.push(new Uint8Array(buffer));\n    } else if (val instanceof Pointer) {\n      buffers.push(new Uint8Array([TYPE.POINTER]));\n      const buffer = new ArrayBuffer(8);\n      const view = new DataView(buffer);\n      view.setBigUint64(0, BigInt(val.offset), true); // little-endian\n      buffers.push(new Uint8Array(buffer));\n    } else if (typeof val === 'number') {\n      if (Number.isInteger(val) && Number.isSafeInteger(val)) {\n        // 64-bit signed integer (stored as BigInt64)\n        buffers.push(new Uint8Array([TYPE.INT]));\n        const buffer = new ArrayBuffer(8);\n        const view = new DataView(buffer);\n        view.setBigInt64(0, BigInt(val), true); // little-endian\n        buffers.push(new Uint8Array(buffer));\n      } else {\n        // 64-bit float\n        buffers.push(new Uint8Array([TYPE.FLOAT]));\n        const buffer = new ArrayBuffer(8);\n        const view = new DataView(buffer);\n        view.setFloat64(0, val, true); // little-endian\n        buffers.push(new Uint8Array(buffer));\n      }\n    } else if (typeof val === 'string') {\n      buffers.push(new Uint8Array([TYPE.STRING]));\n      const encoded = new TextEncoder().encode(val);\n      // Store length as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, encoded.length, true);\n      buffers.push(new Uint8Array(lengthBuffer));\n      buffers.push(encoded);\n    } else if (Array.isArray(val)) {\n      // Encode array to temporary buffer to determine size\n      const tempBuffers = [];\n      \n      // Store array length as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, val.length, true);\n      tempBuffers.push(new Uint8Array(lengthBuffer));\n      \n      // Encode each element into temp buffer\n      const startLength = buffers.length;\n      for (const item of val) {\n        encodeValue(item);\n      }\n      // Collect encoded elements\n      const elementBuffers = buffers.splice(startLength);\n      tempBuffers.push(...elementBuffers);\n      \n      // Calculate total size of array content\n      const contentSize = tempBuffers.reduce((sum, buf) => sum + buf.length, 0);\n      \n      // Now write: TYPE + SIZE + CONTENT\n      buffers.push(new Uint8Array([TYPE.ARRAY]));\n      const sizeBuffer = new ArrayBuffer(4);\n      const sizeView = new DataView(sizeBuffer);\n      sizeView.setUint32(0, contentSize, true);\n      buffers.push(new Uint8Array(sizeBuffer));\n      buffers.push(...tempBuffers);\n    } else if (typeof val === 'object') {\n      // Encode object to temporary buffer to determine size\n      const tempBuffers = [];\n      \n      const keys = Object.keys(val);\n      // Store number of keys as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, keys.length, true);\n      tempBuffers.push(new Uint8Array(lengthBuffer));\n      \n      // Encode each key-value pair into temp buffer\n      const startLength = buffers.length;\n      for (const key of keys) {\n        // Encode key as string (without type byte)\n        const encoded = new TextEncoder().encode(key);\n        const keyLengthBuffer = new ArrayBuffer(4);\n        const keyLengthView = new DataView(keyLengthBuffer);\n        keyLengthView.setUint32(0, encoded.length, true);\n        buffers.push(new Uint8Array(keyLengthBuffer));\n        buffers.push(encoded);\n        // Encode value\n        encodeValue(val[key]);\n      }\n      // Collect encoded key-value pairs\n      const kvBuffers = buffers.splice(startLength);\n      tempBuffers.push(...kvBuffers);\n      \n      // Calculate total size of object content\n      const contentSize = tempBuffers.reduce((sum, buf) => sum + buf.length, 0);\n      \n      // Now write: TYPE + SIZE + CONTENT\n      buffers.push(new Uint8Array([TYPE.OBJECT]));\n      const sizeBuffer = new ArrayBuffer(4);\n      const sizeView = new DataView(sizeBuffer);\n      sizeView.setUint32(0, contentSize, true);\n      buffers.push(new Uint8Array(sizeBuffer));\n      buffers.push(...tempBuffers);\n    } else {\n      throw new Error(`Unsupported type: ${typeof val}`);\n    }\n  }\n\n  encodeValue(value);\n\n  // Combine all buffers\n  const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buf of buffers) {\n    result.set(buf, offset);\n    offset += buf.length;\n  }\n\n  return result;\n}\n\n/**\n * Decode binary data to JavaScript value\n */\nfunction decode(data) {\n  let offset = 0;\n\n  function decodeValue() {\n    if (offset >= data.length) {\n      throw new Error('Unexpected end of data');\n    }\n\n    const type = data[offset++];\n\n    switch (type) {\n      case TYPE.NULL:\n        return null;\n      \n      case TYPE.FALSE:\n        return false;\n      \n      case TYPE.TRUE:\n        return true;\n      \n      case TYPE.INT: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for INT');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const value = view.getBigInt64(0, true);\n        offset += 8;\n        if (value < BigInt(Number.MIN_SAFE_INTEGER) || value > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('Decoded integer exceeds safe range');\n        }\n        return Number(value);\n      }\n      \n      case TYPE.FLOAT: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for FLOAT');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const value = view.getFloat64(0, true);\n        offset += 8;\n        return value;\n      }\n      \n      case TYPE.STRING: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for STRING length');\n        }\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + length > data.length) {\n          throw new Error('Unexpected end of data for STRING content');\n        }\n        const stringData = data.slice(offset, offset + length);\n        offset += length;\n        return new TextDecoder().decode(stringData);\n      }\n      \n      case TYPE.OID: {\n        if (offset + 12 > data.length) {\n          throw new Error('Unexpected end of data for OID');\n        }\n        const oidBytes = data.slice(offset, offset + 12);\n        offset += 12;\n        return new ObjectId(oidBytes);\n      }\n      \n      case TYPE.DATE: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for DATE');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const timestamp = view.getBigInt64(0, true);\n        offset += 8;\n        return new Date(Number(timestamp));\n      }\n      \n      case TYPE.POINTER: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for POINTER');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const pointerOffset = view.getBigUint64(0, true);\n        offset += 8;\n        // Validate offset is within safe integer range\n        if (pointerOffset > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('Pointer offset out of valid range');\n        }\n        return new Pointer(Number(pointerOffset));\n      }\n      \n      case TYPE.ARRAY: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for ARRAY size');\n        }\n        // Read size in bytes\n        const sizeView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const size = sizeView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + size > data.length) {\n          throw new Error('Unexpected end of data for ARRAY content');\n        }\n        \n        // Read array length\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        const arr = [];\n        for (let i = 0; i < length; i++) {\n          arr.push(decodeValue());\n        }\n        return arr;\n      }\n      \n      case TYPE.OBJECT: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for OBJECT size');\n        }\n        // Read size in bytes\n        const sizeView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const size = sizeView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + size > data.length) {\n          throw new Error('Unexpected end of data for OBJECT content');\n        }\n        \n        // Read number of keys\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        const obj = {};\n        for (let i = 0; i < length; i++) {\n          // Decode key\n          if (offset + 4 > data.length) {\n            throw new Error('Unexpected end of data for OBJECT key length');\n          }\n          const keyLengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n          const keyLength = keyLengthView.getUint32(0, true);\n          offset += 4;\n          \n          if (offset + keyLength > data.length) {\n            throw new Error('Unexpected end of data for OBJECT key');\n          }\n          const keyData = data.slice(offset, offset + keyLength);\n          offset += keyLength;\n          const key = new TextDecoder().decode(keyData);\n          \n          // Decode value\n          obj[key] = decodeValue();\n        }\n        return obj;\n      }\n      \n      default:\n        throw new Error(`Unknown type byte: 0x${type.toString(16)}`);\n    }\n  }\n\n  return decodeValue();\n}\n\n/**\n * OPFS File Operations\n */\nclass BJsonFile {\n  constructor(filename) {\n    this.filename = filename;\n    this.root = null;\n    this.fileHandle = null;\n    this.file = null;\n    this.mode = null; // 'r' for read-only, 'rw' for read-write\n    this.isOpen = false;\n  }\n\n  /**\n   * Open the file with specified mode\n   * @param {string} mode - 'r' for read-only, 'rw' for read-write\n   */\n  async open(mode = 'r') {\n    if (this.isOpen) {\n      throw new Error(`File is already open in ${this.mode} mode`);\n    }\n\n    if (mode !== 'r' && mode !== 'rw') {\n      throw new Error(`Invalid mode: ${mode}. Use 'r' for read-only or 'rw' for read-write`);\n    }\n\n    if (!navigator.storage || !navigator.storage.getDirectory) {\n      throw new Error('Origin Private File System (OPFS) is not supported in this browser');\n    }\n\n    this.root = await navigator.storage.getDirectory();\n    this.mode = mode;\n\n    try {\n      // For read mode, file must exist\n      if (mode === 'r') {\n        this.fileHandle = await this.root.getFileHandle(this.filename);\n      } else {\n        // For read-write mode, create if doesn't exist\n        this.fileHandle = await this.root.getFileHandle(this.filename, { create: true });\n      }\n      this.file = await this.fileHandle.getFile();\n      this.isOpen = true;\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        throw new Error(`File not found: ${this.filename}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Close the file\n   */\n  async close() {\n    this.isOpen = false;\n    this.mode = null;\n    this.fileHandle = null;\n    this.file = null;\n  }\n\n  /**\n   * Ensure file is open, throw if not\n   */\n  ensureOpen() {\n    if (!this.isOpen) {\n      throw new Error(`File is not open. Call open('r') or open('rw') first`);\n    }\n  }\n\n  /**\n   * Ensure file is writable, throw if read-only\n   */\n  ensureWritable() {\n    this.ensureOpen();\n    if (this.mode === 'r') {\n      throw new Error(`File is opened in read-only mode. Cannot write or append`);\n    }\n  }\n\n  /**\n   * Refresh the file reference (needed after writes to get updated size)\n   */\n  async refreshFile() {\n    this.ensureOpen();\n    this.file = await this.fileHandle.getFile();\n  }\n\n  async #readRange(start, length) {\n    this.ensureOpen();\n    const slice = this.file.slice(start, start + length);\n    const arrayBuffer = await slice.arrayBuffer();\n    return new Uint8Array(arrayBuffer);\n  }\n\n  async getFileSize() {\n    this.ensureOpen();\n    return this.file.size;\n  }\n\n  async write(data) {\n    this.ensureWritable();\n    \n    // Encode data to binary\n    const binaryData = encode(data);\n    \n    // Create writable stream (truncates existing content)\n    const writable = await this.fileHandle.createWritable();\n    \n    // Write data\n    await writable.write(binaryData);\n    await writable.close();\n    \n    // Refresh file reference to get updated size\n    await this.refreshFile();\n  }\n\n  async read(pointer = new Pointer(0)) {\n    this.ensureOpen();\n    \n    const fileSize = await this.getFileSize();\n    \n    if (fileSize === 0) {\n      throw new Error(`File is empty: ${this.filename}`);\n    }\n\n    const pointerValue = pointer.valueOf();\n    \n    // Validate pointer offset\n    if (pointerValue < 0 || pointerValue >= fileSize) {\n      throw new Error(`Pointer offset ${pointer} out of file bounds [0, ${fileSize})`);\n    }\n    \n    // Read from pointer offset to end of file\n    const binaryData = await this.#readRange(pointerValue, fileSize - pointerValue);\n    \n    // Decode and return the first value\n    return decode(binaryData);\n  }\n\n  async append(data) {\n    this.ensureWritable();\n    \n    // Encode new data to binary\n    const binaryData = encode(data);\n    \n    // Get current file size\n    const existingSize = this.file.size;\n    \n    // Create writable stream with keepExistingData\n    const writable = await this.fileHandle.createWritable({ keepExistingData: true });\n    \n    // Seek to end\n    await writable.seek(existingSize);\n    \n    // Write new data\n    await writable.write(binaryData);\n    await writable.close();\n    \n    // Refresh file reference to get updated size\n    await this.refreshFile();\n  }\n\n  async *scan() {\n    this.ensureOpen();\n    \n    const fileSize = await this.getFileSize();\n      \n      if (fileSize === 0) {\n        return;\n      }\n      \n      let offset = 0;\n      \n      // Scan through and yield each top-level value\n      while (offset < fileSize) {\n        // Helper function to determine how many bytes a value occupies\n        const getValueSize = async (readPosition) => {\n          // Read 1 byte for type\n          let tempData = await this.#readRange(readPosition, 1);\n          let pos = 1;\n          const type = tempData[0];\n          \n          switch (type) {\n            case TYPE.NULL:\n            case TYPE.FALSE:\n            case TYPE.TRUE:\n              return 1;\n            \n            case TYPE.INT:\n            case TYPE.FLOAT:\n            case TYPE.DATE:\n            case TYPE.POINTER:\n              return 1 + 8;\n\n            case TYPE.OID:\n              return 1 + 12;\n            \n            case TYPE.STRING: {\n              // Read length (4 bytes)\n              tempData = await this.#readRange(readPosition + 1, 4);\n              const view = new DataView(tempData.buffer, tempData.byteOffset, 4);\n              const length = view.getUint32(0, true);\n              return 1 + 4 + length;\n            }\n            \n            case TYPE.ARRAY: {\n              // Read size in bytes (4 bytes)\n              tempData = await this.#readRange(readPosition + 1, 4);\n              const view = new DataView(tempData.buffer, tempData.byteOffset, 4);\n              const size = view.getUint32(0, true);\n              return 1 + 4 + size; // type + size + content\n            }\n            \n            case TYPE.OBJECT: {\n              // Read size in bytes (4 bytes)\n              tempData = await this.#readRange(readPosition + 1, 4);\n              const view = new DataView(tempData.buffer, tempData.byteOffset, 4);\n              const size = view.getUint32(0, true);\n              return 1 + 4 + size; // type + size + content\n            }\n            \n            default:\n              throw new Error(`Unknown type byte: 0x${type.toString(16)}`);\n          }\n        };\n        \n        // Determine size of the current value\n        const valueSize = await getValueSize(offset);\n        \n        // Read only the bytes needed for this value\n        const valueData = await this.#readRange(offset, valueSize);\n        offset += valueSize;\n        \n        // Decode and yield this value\n        yield decode(valueData);\n      }\n  }\n\n  async delete() {\n    this.ensureWritable();\n    \n    try {\n      await this.root.removeEntry(this.filename);\n      // File is deleted, mark as closed\n      await this.close();\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        // File doesn't exist, nothing to delete\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async exists() {\n    if (!navigator.storage || !navigator.storage.getDirectory) {\n      throw new Error('Origin Private File System (OPFS) is not supported in this browser');\n    }\n    \n    const root = await navigator.storage.getDirectory();\n    try {\n      await root.getFileHandle(this.filename);\n      return true;\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        return false;\n      }\n      throw error;\n    }\n  }\n}\n\nexport {\n  TYPE,\n  ObjectId,\n  Pointer,\n  encode,\n  decode,\n  BJsonFile\n};\n","/**\n * Utility functions for MicroMongoDB\n */\n\nimport { ObjectId } from 'bjson';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Deep copy an object or array\n */\nexport function copy(o) {\n\t// Handle ObjectId\n\tif (o instanceof ObjectId) {\n\t\treturn new ObjectId(o.id);\n\t}\n\t\n\tvar out, v, key;\n\tout = Array.isArray(o) ? [] : {};\n\tfor (key in o) {\n\t\tv = o[key];\n\t\tout[key] = (typeof v === \"object\" && v !== null) ? copy(v) : v;\n\t}\n\treturn out;\n}\n\n/**\n * Get a property from an object using dot notation\n * Supports array element access via numeric indices (e.g., \"items.0.name\")\n */\nexport function getProp(obj, name) {\n\tvar path = name.split(\".\");\n\tvar result = obj[path[0]];\n\tfor (var i = 1; i < path.length; i++) {\n\t\tif (result == undefined || result == null) return result;\n\t\t\n\t\t// Check if this path segment is a numeric index\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\t// If it's a valid array index, use it\n\t\tif (isArray(result) && !isNaN(numericIndex) && numericIndex >= 0 && numericIndex < result.length) {\n\t\t\tresult = result[numericIndex];\n\t\t} else {\n\t\t\tresult = result[pathSegment];\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Get field values for query matching, handling MongoDB-style array traversal\n * When a path traverses an array, this returns all matching values from array elements\n * Returns an array of values if array traversal occurred, otherwise the single value\n * \n * Example:\n *   doc = { items: [{ price: 10 }, { price: 20 }] }\n *   getFieldValues(doc, 'items.price') -> [10, 20]\n */\nexport function getFieldValues(obj, name) {\n\tvar path = name.split(\".\");\n\tvar results = [obj];\n\t\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\tvar newResults = [];\n\t\t\n\t\tfor (var j = 0; j < results.length; j++) {\n\t\t\tvar current = results[j];\n\t\t\tif (current == undefined || current == null) continue;\n\t\t\t\n\t\t\t// If this is a numeric index and current is an array, access that element\n\t\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\t\tif (numericIndex < current.length) {\n\t\t\t\t\tnewResults.push(current[numericIndex]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If current is an array but path segment is not numeric, traverse all elements\n\t\t\telse if (isArray(current)) {\n\t\t\t\tfor (var k = 0; k < current.length; k++) {\n\t\t\t\t\tif (current[k] != undefined && current[k] != null && typeof current[k] === 'object') {\n\t\t\t\t\t\tnewResults.push(current[k][pathSegment]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, normal property access\n\t\t\telse if (typeof current === 'object') {\n\t\t\t\tnewResults.push(current[pathSegment]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresults = newResults;\n\t}\n\t\n\t// Filter out undefined values\n\tresults = results.filter(function(v) { return v !== undefined; });\n\t\n\t// If we have multiple values, return the array\n\t// If we have exactly one, return it directly\n\t// If we have none, return undefined\n\tif (results.length === 0) return undefined;\n\tif (results.length === 1) return results[0];\n\treturn results;\n}\n\n/**\n * Set a property on an object using dot notation\n * Creates intermediate objects as needed\n * Supports array element access via numeric indices\n * Supports $[] operator to update all array elements\n */\nexport function setProp(obj, name, value) {\n\t// Check if path contains $[] operator\n\tif (name.indexOf('$[]') !== -1) {\n\t\treturn setPropWithAllPositional(obj, name, value);\n\t}\n\t\n\tvar path = name.split(\".\");\n\tvar current = obj;\n\t\n\tfor (var i = 0; i < path.length - 1; i++) {\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\t// If this is a numeric index and current is an array\n\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\t// Ensure the array is large enough\n\t\t\twhile (current.length <= numericIndex) {\n\t\t\t\tcurrent.push(undefined);\n\t\t\t}\n\t\t\t// If the element doesn't exist, create an object\n\t\t\tif (current[numericIndex] == undefined || current[numericIndex] == null) {\n\t\t\t\t// Look ahead to see if next segment is numeric (array) or not (object)\n\t\t\t\tvar nextSegment = path[i + 1];\n\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\tcurrent[numericIndex] = [];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[numericIndex] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[numericIndex];\n\t\t}\n\t\t// Regular property access\n\t\telse {\n\t\t\tif (current[pathSegment] == undefined || current[pathSegment] == null) {\n\t\t\t\t// Look ahead to see if next segment is numeric (array) or not (object)\n\t\t\t\tvar nextSegment = path[i + 1];\n\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[pathSegment] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[pathSegment];\n\t\t}\n\t}\n\t\n\t// Set the final value\n\tvar lastSegment = path[path.length - 1];\n\tvar lastNumericIndex = parseInt(lastSegment, 10);\n\t\n\tif (isArray(current) && !isNaN(lastNumericIndex) && lastNumericIndex >= 0) {\n\t\twhile (current.length <= lastNumericIndex) {\n\t\t\tcurrent.push(undefined);\n\t\t}\n\t\tcurrent[lastNumericIndex] = value;\n\t} else {\n\t\tcurrent[lastSegment] = value;\n\t}\n}\n\n/**\n * Set a property using the $[] all positional operator\n * Updates all elements in an array\n */\nfunction setPropWithAllPositional(obj, name, value) {\n\tvar path = name.split(\".\");\n\tvar current = obj;\n\t\n\t// Navigate to the $[] operator\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\t\n\t\tif (pathSegment === '$[]') {\n\t\t\t// Current should be an array - update all elements\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\tthrow new Error(\"The positional operator did not find the match needed from the query.\");\n\t\t\t}\n\t\t\t\n\t\t\t// Build the remaining path after $[]\n\t\t\tvar remainingPath = path.slice(i + 1).join('.');\n\t\t\t\n\t\t\t// Update all array elements\n\t\t\tfor (var j = 0; j < current.length; j++) {\n\t\t\t\tif (remainingPath) {\n\t\t\t\t\t// There's more path after $[], recursively set on each element\n\t\t\t\t\tsetProp(current[j], remainingPath, value);\n\t\t\t\t} else {\n\t\t\t\t\t// $[] is the last segment, replace each element with value\n\t\t\t\t\tcurrent[j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Navigate to the next level\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\tcurrent = current[numericIndex];\n\t\t} else {\n\t\t\tif (current[pathSegment] == undefined || current[pathSegment] == null) {\n\t\t\t\t// Create intermediate object or array\n\t\t\t\tvar nextSegment = i + 1 < path.length ? path[i + 1] : null;\n\t\t\t\tif (nextSegment === '$[]') {\n\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t} else {\n\t\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathSegment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[pathSegment];\n\t\t}\n\t}\n}\n\n/**\n * Check if value is an array\n */\nexport function isArray(o) {\n\treturn Array == o.constructor;\n}\n\n/**\n * Convert object to array of key-value pairs\n */\nexport function toArray(obj) {\n\tvar arr = [];\n\tfor (var key in obj) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar el = {};\n\t\t\tel[key] = obj[key];\n\t\t\tarr.push(el);\n\t\t}\n\t}\n\treturn arr;\n}\n\n/**\n * Check if a value is in an array\n */\nexport function isIn(val, values) {\n\tfor (var i = 0; i < values.length; i++) {\n\t\tif (valuesEqual(values[i], val)) return true;\n\t}\n\treturn false;\n}\n\n/**\n * Check if two arrays match\n */\nexport function arrayMatches(x, y) {\n\tif (x.length != y.length) return false;\n\tfor (var i = 0; i < x.length; i++) {\n\t\tif (valuesEqual(x[i], y[i])) continue;\n\t\tif (typeof (x[i]) != typeof (y[i])) return false;\n\t\tif (typeof (x[i]) == \"object\" && x[i] !== null) {\n\t\t\tif (isArray(x[i])) {\n\t\t\t\tif (!arrayMatches(x[i], y[i])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[i], y[i])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[i], y[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Check if two objects match\n */\nexport function objectMatches(x, y) {\n\tfor (var p in x) {\n\t\tif (!x.hasOwnProperty(p)) continue;\n\t\tif (!y.hasOwnProperty(p)) return false;\n\t\tif (valuesEqual(x[p], y[p])) continue;\n\t\tif (typeof (x[p]) != typeof (y[p])) return false;\n\t\tif (typeof (x[p]) == \"object\" && x[p] !== null) {\n\t\t\tif (isArray(x[p])) {\n\t\t\t\tif (!arrayMatches(x[p], y[p])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[p], y[p])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[p], y[p])) return false;\n\t\t}\n\t}\n\tfor (var p in y) {\n\t\tif (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Apply projection to a document\n */\nexport function applyProjection(projection, doc) {\n\tvar result = {};\n\tvar keys = Object.keys(projection);\n\tif (keys.length == 0) return doc;\n\t\n\t// Check for mixed inclusion/exclusion (except _id which can be excluded in inclusion projection)\n\tvar hasInclusion = false;\n\tvar hasExclusion = false;\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (keys[i] === '_id') continue; // _id is special\n\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\telse hasExclusion = true;\n\t}\n\t\n\tif (hasInclusion && hasExclusion) {\n\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t}\n\t\n\tif (projection[keys[0]] || hasInclusion) {\n\t\t// Inclusion projection\n\t\t// Include _id unless explicitly excluded\n\t\tif (projection._id !== 0) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i] === '_id') continue;\n\t\t\tif (!projection[keys[i]]) continue;\n\t\t\t\n\t\t\tvar fieldPath = keys[i];\n\t\t\tvar value = getProp(doc, fieldPath);\n\t\t\t\n\t\t\tif (value !== undefined) {\n\t\t\t\t// Use setProp to create nested structure\n\t\t\t\tsetProp(result, fieldPath, value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Exclusion projection - start with a copy of the document\n\t\tfor (var key in doc) {\n\t\t\tif (doc.hasOwnProperty(key)) {\n\t\t\t\t// Deep copy the value\n\t\t\t\tvar val = doc[key];\n\t\t\t\tif (typeof val === 'object' && val !== null && !isArray(val)) {\n\t\t\t\t\tresult[key] = copy(val);\n\t\t\t\t} else if (isArray(val)) {\n\t\t\t\t\tresult[key] = val.slice(); // shallow copy array\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Remove excluded fields\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (projection[keys[i]]) continue; // Skip if value is truthy\n\t\t\t\n\t\t\tvar fieldPath = keys[i];\n\t\t\tvar pathParts = fieldPath.split('.');\n\t\t\t\n\t\t\t// Navigate to the parent object and delete the final property\n\t\t\tif (pathParts.length === 1) {\n\t\t\t\tdelete result[fieldPath];\n\t\t\t} else {\n\t\t\t\tvar parent = result;\n\t\t\t\tfor (var j = 0; j < pathParts.length - 1; j++) {\n\t\t\t\t\tif (parent == undefined || parent == null) break;\n\t\t\t\t\tparent = parent[pathParts[j]];\n\t\t\t\t}\n\t\t\t\tif (parent != undefined && parent != null) {\n\t\t\t\t\tdelete parent[pathParts[pathParts.length - 1]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Convert bbox to GeoJSON\n */\nexport function bboxToGeojson(bbox) {\n\tconst minLon = bbox[0][0];\n\tconst maxLat = bbox[0][1];\n\tconst maxLon = bbox[1][0];\n\tconst minLat = bbox[1][1];\n\treturn {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: [{\n\t\t\ttype: 'Feature',\n\t\t\tproperties: {},\n\t\t\tgeometry: {\n\t\t\t\ttype: 'Polygon',\n\t\t\t\tcoordinates: [[\n\t\t\t\t\t[minLon, maxLat],\n\t\t\t\t\t[minLon, minLat],\n\t\t\t\t\t[maxLon, minLat],\n\t\t\t\t\t[maxLon, maxLat],\n\t\t\t\t\t[minLon, maxLat]\n\t\t\t\t]]\n\t\t\t}\n\t\t}]\n\t};\n}\n","/**\n * MongoDB Error Classes\n * \n * Structured error hierarchy compatible with MongoDB driver\n */\n\n/**\n * Error codes matching MongoDB error codes\n */\nexport const ErrorCodes = {\n\t// General errors\n\tOK: 0,\n\tINTERNAL_ERROR: 1,\n\tBAD_VALUE: 2,\n\tNO_SUCH_KEY: 4,\n\tGRAPH_CONTAINS_CYCLE: 5,\n\tHOST_UNREACHABLE: 6,\n\tHOST_NOT_FOUND: 7,\n\tUNKNOWN_ERROR: 8,\n\tFAILED_TO_PARSE: 17287, // Using test-compatible error code\n\tCANNOT_MUTATE_OBJECT: 10,\n\tUSER_NOT_FOUND: 11,\n\tUNSUPPORTED_FORMAT: 12,\n\tUNAUTHORIZED: 13,\n\tTYPE_MISMATCH: 14,\n\tOVERFLOW: 15,\n\tINVALID_LENGTH: 16,\n\tPROTOCOL_ERROR: 17,\n\tAUTHENTICATION_FAILED: 18,\n\tILLEGAL_OPERATION: 20,\n\tNAMESPACE_NOT_FOUND: 26,\n\tINDEX_NOT_FOUND: 27,\n\tPATH_NOT_VIABLE: 28,\n\tCANNOT_CREATE_INDEX: 67,\n\tINDEX_ALREADY_EXISTS: 68,\n\tINDEX_EXISTS: 68,\n\tCOMMAND_NOT_FOUND: 59,\n\tNAMESPACE_EXISTS: 48,\n\tINVALID_NAMESPACE: 73,\n\tINDEX_OPTIONS_CONFLICT: 85,\n\tINVALID_INDEX_SPECIFICATION_OPTION: 197,\n\t\n\t// Write errors\n\tWRITE_CONFLICT: 112,\n\tDUPLICATE_KEY: 11000,\n\tDUPLICATE_KEY_UPDATE: 11001,\n\t\n\t// Validation errors\n\tDOCUMENT_VALIDATION_FAILURE: 121,\n\t\n\t// Query errors\n\tBAD_QUERY: 2,\n\tCANNOT_INDEX_PARALLEL_ARRAYS: 171,\n\t\n\t// Cursor errors\n\tCURSOR_NOT_FOUND: 43,\n\t\n\t// Collection errors\n\tCOLLECTION_IS_EMPTY: 26,\n\t\n\t// Not implemented (custom code)\n\tNOT_IMPLEMENTED: 999,\n\tOPERATION_NOT_SUPPORTED: 998\n};\n\n/**\n * Base class for all MongoDB errors\n */\nexport class MongoError extends Error {\n\tconstructor(message, options = {}) {\n\t\tsuper(message);\n\t\tthis.name = 'MongoError';\n\t\tthis.code = options.code || ErrorCodes.UNKNOWN_ERROR;\n\t\tthis.codeName = this._getCodeName(this.code);\n\t\t\n\t\t// Backward compatibility: add $err property matching old error format\n\t\tthis.$err = message;\n\t\t\n\t\t// Additional context\n\t\tif (options.collection) this.collection = options.collection;\n\t\tif (options.database) this.database = options.database;\n\t\tif (options.operation) this.operation = options.operation;\n\t\tif (options.query) this.query = options.query;\n\t\tif (options.document) this.document = options.document;\n\t\tif (options.field) this.field = options.field;\n\t\tif (options.index) this.index = options.index;\n\t\t\n\t\t// Capture stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t}\n\t\n\t_getCodeName(code) {\n\t\tconst codeToName = {\n\t\t\t0: 'OK',\n\t\t\t1: 'InternalError',\n\t\t\t2: 'BadValue',\n\t\t\t4: 'NoSuchKey',\n\t\t\t5: 'GraphContainsCycle',\n\t\t\t6: 'HostUnreachable',\n\t\t\t7: 'HostNotFound',\n\t\t\t8: 'UnknownError',\n\t\t\t10: 'CannotMutateObject',\n\t\t\t11: 'UserNotFound',\n\t\t\t12: 'UnsupportedFormat',\n\t\t\t13: 'Unauthorized',\n\t\t\t14: 'TypeMismatch',\n\t\t\t15: 'Overflow',\n\t\t\t16: 'InvalidLength',\n\t\t\t17: 'ProtocolError',\n\t\t\t18: 'AuthenticationFailed',\n\t\t\t20: 'IllegalOperation',\n\t\t\t26: 'NamespaceNotFound',\n\t\t\t27: 'IndexNotFound',\n\t\t\t28: 'PathNotViable',\n\t\t\t43: 'CursorNotFound',\n\t\t\t48: 'NamespaceExists',\n\t\t\t59: 'CommandNotFound',\n\t\t\t67: 'CannotCreateIndex',\n\t\t\t68: 'IndexExists',\n\t\t\t73: 'InvalidNamespace',\n\t\t\t85: 'IndexOptionsConflict',\n\t\t\t112: 'WriteConflict',\n\t\t\t121: 'DocumentValidationFailure',\n\t\t\t171: 'CannotIndexParallelArrays',\n\t\t\t197: 'InvalidIndexSpecificationOption',\n\t\t\t998: 'OperationNotSupported',\n\t\t\t999: 'NotImplemented',\n\t\t\t11000: 'DuplicateKey',\n\t\t\t11001: 'DuplicateKeyUpdate',\n\t\t\t17287: 'FailedToParse'\n\t\t};\n\t\treturn codeToName[code] || 'UnknownError';\n\t}\n\t\n\ttoJSON() {\n\t\tconst json = {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tcode: this.code,\n\t\t\tcodeName: this.codeName\n\t\t};\n\t\t\n\t\t// Include all enumerable properties\n\t\tif (this.collection) json.collection = this.collection;\n\t\tif (this.database) json.database = this.database;\n\t\tif (this.operation) json.operation = this.operation;\n\t\tif (this.index) json.index = this.index;\n\t\tif (this.indexName) json.indexName = this.indexName;\n\t\tif (this.field) json.field = this.field;\n\t\tif (this.query) json.query = this.query;\n\t\tif (this.document) json.document = this.document;\n\t\tif (this.namespace) json.namespace = this.namespace;\n\t\tif (this.cursorId) json.cursorId = this.cursorId;\n\t\tif (this.feature) json.feature = this.feature;\n\t\tif (this.keyPattern) json.keyPattern = this.keyPattern;\n\t\tif (this.keyValue) json.keyValue = this.keyValue;\n\t\tif (this.writeErrors) json.writeErrors = this.writeErrors;\n\t\t\n\t\treturn json;\n\t}\n}\n\n/**\n * Server-side errors\n */\nexport class MongoServerError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoServerError';\n\t}\n}\n\n/**\n * Driver-side errors (client errors)\n */\nexport class MongoDriverError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoDriverError';\n\t\tthis.code = options.code || ErrorCodes.INTERNAL_ERROR;\n\t}\n}\n\n/**\n * Write operation errors\n */\nexport class WriteError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'WriteError';\n\t\tthis.code = options.code || ErrorCodes.WRITE_CONFLICT;\n\t}\n}\n\n/**\n * Duplicate key error\n */\nexport class DuplicateKeyError extends WriteError {\n\tconstructor(key, options = {}) {\n\t\tconst keyStr = JSON.stringify(key);\n\t\tconst message = `E11000 duplicate key error${options.collection ? ` collection: ${options.collection}` : ''} index: ${keyStr} dup key: ${keyStr}`;\n\t\tsuper(message, { ...options, code: ErrorCodes.DUPLICATE_KEY });\n\t\tthis.name = 'DuplicateKeyError';\n\t\tthis.keyPattern = key;\n\t\tthis.keyValue = options.keyValue || key;\n\t}\n}\n\n/**\n * Document validation errors\n */\nexport class ValidationError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'ValidationError';\n\t\tthis.code = options.code || ErrorCodes.DOCUMENT_VALIDATION_FAILURE;\n\t\tthis.validationErrors = options.validationErrors || [];\n\t}\n}\n\n/**\n * Index-related errors\n */\nexport class IndexError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'IndexError';\n\t}\n}\n\n/**\n * Index already exists error\n */\nexport class IndexExistsError extends IndexError {\n\tconstructor(indexName, options = {}) {\n\t\tsuper(`Index with name '${indexName}' already exists`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INDEX_EXISTS\n\t\t});\n\t\tthis.name = 'IndexExistsError';\n\t\tthis.indexName = indexName;\n\t}\n}\n\n/**\n * Index not found error\n */\nexport class IndexNotFoundError extends IndexError {\n\tconstructor(indexName, options = {}) {\n\t\tsuper(`Index '${indexName}' not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INDEX_NOT_FOUND,\n\t\t\tindex: indexName\n\t\t});\n\t\tthis.name = 'IndexNotFoundError';\n\t\tthis.indexName = indexName;\n\t}\n}\n\n/**\n * Cannot create index error\n */\nexport class CannotCreateIndexError extends IndexError {\n\tconstructor(reason, options = {}) {\n\t\tsuper(`Cannot create index: ${reason}`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.CANNOT_CREATE_INDEX\n\t\t});\n\t\tthis.name = 'CannotCreateIndexError';\n\t}\n}\n\n/**\n * Query errors\n */\nexport class QueryError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'QueryError';\n\t\tthis.code = options.code || ErrorCodes.BAD_QUERY;\n\t}\n}\n\n/**\n * Type mismatch error\n */\nexport class TypeMismatchError extends MongoError {\n\tconstructor(field, expectedType, actualType, options = {}) {\n\t\tsuper(\n\t\t\t`Type mismatch for field '${field}': expected ${expectedType}, got ${actualType}`,\n\t\t\t{ ...options, code: ErrorCodes.TYPE_MISMATCH, field }\n\t\t);\n\t\tthis.name = 'TypeMismatchError';\n\t\tthis.expectedType = expectedType;\n\t\tthis.actualType = actualType;\n\t}\n}\n\n/**\n * Namespace errors\n */\nexport class NamespaceError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'NamespaceError';\n\t}\n}\n\n/**\n * Namespace not found\n */\nexport class NamespaceNotFoundError extends NamespaceError {\n\tconstructor(namespace, options = {}) {\n\t\tsuper(`Namespace '${namespace}' not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t\tthis.name = 'NamespaceNotFoundError';\n\t\tthis.namespace = namespace;\n\t}\n}\n\n/**\n * Invalid namespace\n */\nexport class InvalidNamespaceError extends NamespaceError {\n\tconstructor(namespace, reason, options = {}) {\n\t\t// Handle case where reason is actually options\n\t\tif (typeof reason === 'object' && !options) {\n\t\t\toptions = reason;\n\t\t\treason = undefined;\n\t\t}\n\t\tconst msg = reason ? `Invalid namespace '${namespace}': ${reason}` : `Invalid namespace '${namespace}'`;\n\t\tsuper(msg, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INVALID_NAMESPACE\n\t\t});\n\t\tthis.name = 'InvalidNamespaceError';\n\t\tthis.namespace = namespace;\n\t}\n}\n\n/**\n * Cursor errors\n */\nexport class CursorError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'CursorError';\n\t}\n}\n\n/**\n * Cursor not found\n */\nexport class CursorNotFoundError extends CursorError {\n\tconstructor(cursorId, options = {}) {\n\t\tsuper(`Cursor ${cursorId} not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.CURSOR_NOT_FOUND\n\t\t});\n\t\tthis.name = 'CursorNotFoundError';\n\t\tthis.cursorId = cursorId;\n\t}\n}\n\n/**\n * Not implemented error\n */\nexport class NotImplementedError extends MongoError {\n\tconstructor(feature, options = {}) {\n\t\tsuper(`${feature} is not implemented in micro-mongo`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.NOT_IMPLEMENTED\n\t\t});\n\t\tthis.name = 'NotImplementedError';\n\t\tthis.feature = feature;\n\t}\n}\n\n/**\n * Operation not supported\n */\nexport class OperationNotSupportedError extends MongoError {\n\tconstructor(operation, reason, options = {}) {\n\t\t// Handle case where reason is actually options\n\t\tif (typeof reason === 'object' && !options) {\n\t\t\toptions = reason;\n\t\t\treason = undefined;\n\t\t}\n\t\tconst msg = reason ? `Operation '${operation}' is not supported: ${reason}` : `Operation '${operation}' is not supported`;\n\t\tsuper(msg, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.OPERATION_NOT_SUPPORTED,\n\t\t\toperation\n\t\t});\n\t\tthis.name = 'OperationNotSupportedError';\n\t}\n}\n\n/**\n * Bad value error\n */\nexport class BadValueError extends MongoError {\n\tconstructor(field, value, reason, options = {}) {\n\t\tsuper(`Bad value for field '${field}': ${reason}`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.BAD_VALUE,\n\t\t\tfield\n\t\t});\n\t\tthis.name = 'BadValueError';\n\t\tthis.value = value;\n\t}\n}\n\n/**\n * Bulk write error\n */\nexport class BulkWriteError extends MongoError {\n\tconstructor(writeErrors = [], options = {}) {\n\t\tconst message = `Bulk write operation error: ${writeErrors.length} error(s)`;\n\t\tsuper(message, options);\n\t\tthis.name = 'BulkWriteError';\n\t\tthis.writeErrors = writeErrors;\n\t\tthis.code = options.code || ErrorCodes.WRITE_CONFLICT;\n\t}\n}\n\n/**\n * Network error (for API compatibility, not functional in micro-mongo)\n */\nexport class MongoNetworkError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoNetworkError';\n\t\tthis.code = options.code || ErrorCodes.HOST_UNREACHABLE;\n\t}\n}\n\n/**\n * Helper function to create appropriate error\n */\nexport function createError(type, ...args) {\n\tswitch (type) {\n\t\tcase 'duplicate_key':\n\t\t\treturn new DuplicateKeyError(...args);\n\t\tcase 'validation':\n\t\t\treturn new ValidationError(...args);\n\t\tcase 'index_exists':\n\t\t\treturn new IndexExistsError(...args);\n\t\tcase 'index_not_found':\n\t\t\treturn new IndexNotFoundError(...args);\n\t\tcase 'cannot_create_index':\n\t\t\treturn new CannotCreateIndexError(...args);\n\t\tcase 'query':\n\t\t\treturn new QueryError(...args);\n\t\tcase 'type_mismatch':\n\t\t\treturn new TypeMismatchError(...args);\n\t\tcase 'namespace_not_found':\n\t\t\treturn new NamespaceNotFoundError(...args);\n\t\tcase 'invalid_namespace':\n\t\t\treturn new InvalidNamespaceError(...args);\n\t\tcase 'cursor_not_found':\n\t\t\treturn new CursorNotFoundError(...args);\n\t\tcase 'not_implemented':\n\t\t\treturn new NotImplementedError(...args);\n\t\tcase 'operation_not_supported':\n\t\t\treturn new OperationNotSupportedError(...args);\n\t\tcase 'bad_value':\n\t\t\treturn new BadValueError(...args);\n\t\tcase 'write':\n\t\t\treturn new WriteError(...args);\n\t\tdefault:\n\t\t\treturn new MongoError(...args);\n\t}\n}\n","import { applyProjection } from './utils.js';\nimport { NotImplementedError, QueryError, ErrorCodes } from './errors.js';\n\n/**\n * Cursor class for iterating over query results\n * Now a simple iterator over pre-filtered documents\n */\nexport class Cursor {\n\tconstructor(collection, query, projection, documents, SortedCursor) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.projection = projection;\n\t\tthis.documents = documents; // Pre-filtered array of documents\n\t\tthis.SortedCursor = SortedCursor;\n\n\t\t// Validate projection if provided\n\t\tif (projection && Object.keys(projection).length > 0) {\n\t\t\tconst keys = Object.keys(projection);\n\t\t\tlet hasInclusion = false;\n\t\t\tlet hasExclusion = false;\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tif (keys[i] === '_id') continue; // _id is special\n\t\t\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\t\t\telse hasExclusion = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (hasInclusion && hasExclusion) {\n\t\t\t\tthrow new QueryError(\"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", { \n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE,\n\t\t\t\t\tcollection: collection.name \n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.pos = 0;\n\t\tthis._limit = 0;\n\t\tthis._skip = 0;\n\t\tthis._closed = false;\n\t}\n\n\tbatchSize(size) { \n\t\t// No-op for in-memory database, but return this for chaining\n\t\tthis._batchSize = size;\n\t\treturn this;\n\t}\n\tclose() {\n\t\tthis._closed = true;\n\t\tthis.pos = this.documents.length; // Move to end\n\t\treturn undefined;\n\t}\n\tcomment(commentString) {\n\t\tthis._comment = commentString;\n\t\treturn this;\n\t}\n\t\n\tcount() {\n\t\t// Return total count without considering skip/limit applied to this cursor\n\t\treturn this.documents.length;\n\t}\n\t\n\texplain(verbosity = 'queryPlanner') {\n\t\t// Return basic query execution info\n\t\treturn {\n\t\t\tqueryPlanner: {\n\t\t\t\tplannerVersion: 1,\n\t\t\t\tnamespace: `${this.collection.db?.name || 'db'}.${this.collection.name}`,\n\t\t\t\tindexFilterSet: false,\n\t\t\t\tparsedQuery: this.query,\n\t\t\t\twinningPlan: {\n\t\t\t\t\tstage: 'COLLSCAN',\n\t\t\t\t\tfilter: this.query,\n\t\t\t\t\tdirection: 'forward'\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutionStats: verbosity === 'executionStats' || verbosity === 'allPlansExecution' ? {\n\t\t\t\texecutionSuccess: true,\n\t\t\t\tnReturned: this.documents.length,\n\t\t\t\texecutionTimeMillis: 0,\n\t\t\t\ttotalKeysExamined: 0,\n\t\t\t\ttotalDocsExamined: this.documents.length\n\t\t\t} : undefined,\n\t\t\tok: 1\n\t\t};\n\t}\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\tif (this._closed) return false;\n\t\t// Calculate effective max position: skip + limit or total docs\n\t\tlet effectiveMax;\n\t\tif (this._limit > 0) {\n\t\t\teffectiveMax = Math.min(this._skip + this._limit, this.documents.length);\n\t\t} else {\n\t\t\teffectiveMax = this.documents.length;\n\t\t}\n\t\treturn this.pos < effectiveMax;\n\t}\n\t\n\thint(index) {\n\t\t// Store hint for query planner (informational in micro-mongo)\n\t\tthis._hint = index;\n\t\treturn this;\n\t}\n\titcount() {\n\t\tlet count = 0;\n\t\twhile (this.hasNext()) {\n\t\t\tthis.next();\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tlimit(_max) {\n\t\tthis._limit = _max;\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan(maxScan) {\n\t\t// Set maximum number of documents to scan (deprecated in MongoDB 4.0)\n\t\tthis._maxScan = maxScan;\n\t\treturn this;\n\t}\n\tmaxTimeMS(ms) {\n\t\t// Set maximum execution time (informational in micro-mongo)\n\t\tthis._maxTimeMS = ms;\n\t\treturn this;\n\t}\n\tmax(indexBounds) {\n\t\t// Set maximum index bound (informational in micro-mongo)\n\t\tthis._maxIndexBounds = indexBounds;\n\t\treturn this;\n\t}\n\tmin(indexBounds) {\n\t\t// Set minimum index bound (informational in micro-mongo)\n\t\tthis._minIndexBounds = indexBounds;\n\t\treturn this;\n\t}\n\t\n\tnext() {\n\t\tif (!this.hasNext()) {\n\t\t\tthrow new QueryError(\"Error: error hasNext: false\", { \n\t\t\t\tcollection: this.collection.name \n\t\t\t});\n\t\t}\n\t\tconst result = this.documents[this.pos++];\n\t\tif (this.projection) {\n\t\t\treturn applyProjection(this.projection, result);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tnoCursorTimeout() {\n\t\t// Prevent cursor timeout (no-op for in-memory)\n\t\tthis._noCursorTimeout = true;\n\t\treturn this;\n\t}\n\tobjsLeftInBatch() {\n\t\t// Return number of objects left in current batch\n\t\t// For in-memory, this is same as remaining documents\n\t\treturn this.size();\n\t}\n\tpretty() {\n\t\t// Enable pretty printing (no-op but return this for chaining)\n\t\tthis._pretty = true;\n\t\treturn this;\n\t}\n\treadConcern(level) {\n\t\t// Set read concern (no-op for in-memory database)\n\t\tthis._readConcern = level;\n\t\treturn this;\n\t}\n\treadPref(mode, tagSet) {\n\t\t// Set read preference (no-op for in-memory database)\n\t\tthis._readPref = { mode, tagSet };\n\t\treturn this;\n\t}\n\treturnKey(enabled = true) {\n\t\t// Return only the index key (informational in micro-mongo)\n\t\tthis._returnKey = enabled;\n\t\treturn this;\n\t}\n\tshowRecordId(enabled = true) {\n\t\t// Show record ID in results\n\t\tthis._showRecordId = enabled;\n\t\treturn this;\n\t}\n\tsize() {\n\t\t// Return count considering skip and limit\n\t\tconst remaining = this.documents.length - this.pos;\n\t\tif (this._limit > 0) {\n\t\t\t// Calculate how many docs left based on skip+limit boundary\n\t\t\tconst maxPos = this._skip + this._limit;\n\t\t\treturn Math.min(maxPos - this.pos, remaining);\n\t\t}\n\t\treturn remaining;\n\t}\n\t\n\tskip(num) {\n\t\tthis._skip = num;\n\t\t// Move initial position to skip point\n\t\tif (this.pos === 0) {\n\t\t\tthis.pos = Math.min(num, this.documents.length);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tisClosed() {\n\t\treturn this._closed === true;\n\t}\n\t\n\tsnapshot() { throw new NotImplementedError('snapshot'); }\n\t\n\tsort(s) {\n\t\treturn new this.SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\tallowDiskUse(enabled = true) {\n\t\t// Allow disk use for sorts (no-op for in-memory)\n\t\tthis._allowDiskUse = enabled;\n\t\treturn this;\n\t}\n\t\n\tcollation(collationDocument) {\n\t\t// Set collation (no-op for micro-mongo)\n\t\tthis._collation = collationDocument;\n\t\treturn this;\n\t}\n\t\n\ttailable() { throw new NotImplementedError('tailable'); }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","/**\n * SortedCursor class for iterating over sorted query results\n */\nexport class SortedCursor {\n\tconstructor(collection, query, cursor, sort) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.sortSpec = sort;\n\t\tthis.pos = 0;\n\t\tthis.items = [];\n\t\t\n\t\t// Collect all items from the cursor\n\t\twhile (cursor.hasNext()) {\n\t\t\tthis.items.push(cursor.next());\n\t\t}\n\t\t\n\t\t// Sort the items\n\t\tconst sortKeys = Object.keys(sort);\n\t\tthis.items.sort(function(a, b) {\n\t\t\tfor (let i = 0; i < sortKeys.length; i++) {\n\t\t\t\tif (a[sortKeys[i]] == undefined && b[sortKeys[i]] != undefined) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] != undefined && b[sortKeys[i]] == undefined) return 1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] < b[sortKeys[i]]) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] > b[sortKeys[i]]) return 1 * sort[sortKeys[i]];\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\treturn this.items.length;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\treturn this.pos < this.items.length;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(max) {\n\t\tthis.items = this.items.slice(0, max);\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\treturn this.items[this.pos++];\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","// Standard suffix manipulations.\n/** @type {Record<string, string>} */\nconst step2list = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant-vowel sequences.\nconst consonant = '[^aeiou]'\nconst vowel = '[aeiouy]'\nconst consonants = '(' + consonant + '[^aeiouy]*)'\nconst vowels = '(' + vowel + '[aeiou]*)'\n\nconst gt0 = new RegExp('^' + consonants + '?' + vowels + consonants)\nconst eq1 = new RegExp(\n  '^' + consonants + '?' + vowels + consonants + vowels + '?$'\n)\nconst gt1 = new RegExp('^' + consonants + '?(' + vowels + consonants + '){2,}')\nconst vowelInStem = new RegExp('^' + consonants + '?' + vowel)\nconst consonantLike = new RegExp('^' + consonants + vowel + '[^aeiouwxy]$')\n\n// Exception expressions.\nconst sfxLl = /ll$/\nconst sfxE = /^(.+?)e$/\nconst sfxY = /^(.+?)y$/\nconst sfxIon = /^(.+?(s|t))(ion)$/\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/\nconst sfxEED = /^(.+?)eed$/\nconst sfxS = /^.+?[^s]s$/\nconst sfxSsesOrIes = /^.+?(ss|i)es$/\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nexport function stemmer(value) {\n  let result = String(value).toLowerCase()\n\n  // Exit early.\n  if (result.length < 3) {\n    return result\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true\n    result = 'Y' + result.slice(1)\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2)\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1)\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1]\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += 'e'\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += 'e'\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + 'i'\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]]\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]]\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1]\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1]\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1]\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1)\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = 'y' + result.slice(1)\n  }\n\n  return result\n}\n","/**\n * BPlusTree - Persistent immutable B+ tree with BJsonFile storage\n * \n * Usage pattern:\n *   const tree = new BPlusTree('tree.bjson');\n *   await tree.open();\n *   await tree.add(key, value);\n *   await tree.close();\n */\n\nimport { BJsonFile, Pointer } from './bjson.js';\n\n/**\n * Node for persistent storage\n * @private\n */\nclass NodeData {\n    /**\n     * Creates a node data object for serialization\n     * @param {number} id - Unique node ID\n     * @param {boolean} isLeaf - Leaf flag\n     * @param {Array} keys - Key array\n     * @param {Array} values - Value array (leaf nodes)\n     * @param {Array} children - Child pointers (internal nodes)\n     * @param {Pointer} next - Pointer to next leaf\n     */\n    constructor(id, isLeaf, keys, values, children, next) {\n        this.id = id;\n        this.isLeaf = isLeaf;\n        this.keys = keys;\n        this.values = values;\n        this.children = children;\n        for (let v of children) {\n            if (!(v instanceof Pointer)) {\n                throw new Error('Children must be Pointer objects');\n            }\n        }\n        this.next = next;\n    }\n}\n\n/**\n * Persistent immutable B+ tree with append-only file storage\n */\nexport class BPlusTree {\n    /**\n     * Creates a new persistent B+ tree\n     * @param {string} filename - Path to storage file\n     * @param {number} order - Tree order (default: 3)\n     */\n    constructor(filename, order = 3) {\n        if (order < 3) {\n            throw new Error('B+ tree order must be at least 3');\n        }\n        this.filename = filename;\n        this.order = order;\n        this.minKeys = Math.ceil(order / 2) - 1;\n        \n        this.file = new BJsonFile(filename);\n        this.isOpen = false;\n        \n        // Metadata\n        this.rootPointer = null;\n        this.nextNodeId = 0;\n        this._size = 0;\n    }\n\n    /**\n     * Open the tree file (create if doesn't exist)\n     */\n    async open() {\n        if (this.isOpen) {\n            throw new Error('Tree file is already open');\n        }\n\n        const exists = await this.file.exists();\n\n        if (exists) {\n            await this.file.open('rw');\n            await this._loadMetadata();\n        } else {\n            await this.file.open('rw');\n            await this._initializeNewTree();\n        }\n\n        this.isOpen = true;\n    }\n\n    /**\n     * Close the tree file and save metadata\n     */\n    async close() {\n        if (this.isOpen) {\n            await this._saveMetadata();\n            await this.file.close();\n            this.isOpen = false;\n        }\n    }\n\n    /**\n     * Initialize a new empty tree\n     */\n    async _initializeNewTree() {\n        const rootNode = new NodeData(0, true, [], [], [], null);\n        this.nextNodeId = 1;\n        this._size = 0;\n\n        const rootPointer = await this._saveNode(rootNode);\n        this.rootPointer = rootPointer;\n\n        await this._saveMetadata();\n    }\n\n    /**\n     * Save metadata to file\n     */\n    async _saveMetadata() {\n        const metadata = {\n            version: 1,\n            maxEntries: this.order,  // Renamed to match RTree size\n            minEntries: this.minKeys,  // Renamed to match RTree size\n            size: this._size,\n            rootPointer: this.rootPointer,\n            nextId: this.nextNodeId  // Renamed to match RTree size\n        };\n\n        await this.file.append(metadata);\n    }\n\n    /**\n     * Load metadata from file\n     */\n    async _loadMetadata() {\n        const fileSize = await this.file.getFileSize();\n        // Metadata object has 6 INT fields (now encoded as 8-byte ints) plus keys\n        const METADATA_SIZE = 135;\n        \n        if (fileSize < METADATA_SIZE) {\n            throw new Error('Invalid tree file');\n        }\n\n        const metadataOffset = fileSize - METADATA_SIZE;\n        const metadata = await this.file.read(metadataOffset);\n\n        if (!metadata || typeof metadata.maxEntries === 'undefined') {\n            throw new Error(`Failed to read metadata: missing required fields`);\n        }\n\n        this.order = metadata.maxEntries;\n        this.minKeys = metadata.minEntries;\n        this._size = metadata.size;\n        this.nextNodeId = metadata.nextId;\n        this.rootPointer = metadata.rootPointer;\n    }\n\n    /**\n     * Save a node to disk\n     */\n    async _saveNode(node) {\n        const offset = await this.file.getFileSize();\n        await this.file.append(node);\n        return new Pointer(offset);\n    }\n\n    /**\n     * Load a node from disk\n     */\n    async _loadNode(pointer) {\n        if (!(pointer instanceof Pointer)) {\n            throw new Error('Expected Pointer object');\n        }\n\n        const data = await this.file.read(pointer);\n        return new NodeData(\n            data.id,\n            data.isLeaf,\n            data.keys,\n            data.values,\n            data.children,\n            data.next\n        );\n    }\n\n    /**\n     * Load root node\n     */\n    async _loadRoot() {\n        return await this._loadNode(this.rootPointer);\n    }\n\n    /**\n     * Search for a key\n     */\n    async search(key) {\n        const root = await this._loadRoot();\n        return this._searchNode(root, key);\n    }\n\n    /**\n     * Internal search\n     */\n    async _searchNode(node, key) {\n        if (node.isLeaf) {\n            for (let i = 0; i < node.keys.length; i++) {\n                if (key === node.keys[i]) {\n                    return node.values[i];\n                }\n            }\n            return undefined;\n        } else {\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n            const child = await this._loadNode(node.children[i]);\n            return this._searchNode(child, key);\n        }\n    }\n\n    /**\n     * Insert a key-value pair\n     */\n    async add(key, value) {\n        const root = await this._loadRoot();\n        const result = await this._addToNode(root, key, value);\n\n        let newRoot;\n        if (result.newNode) {\n            newRoot = result.newNode;\n        } else {\n            // Split occurred - save the split nodes and create new root with pointers\n            const leftPointer = await this._saveNode(result.left);\n            const rightPointer = await this._saveNode(result.right);\n            newRoot = new NodeData(\n                this.nextNodeId++,\n                false,\n                [result.splitKey],\n                [],\n                [leftPointer, rightPointer],\n                null\n            );\n        }\n\n        const rootPointer = await this._saveNode(newRoot);\n        this.rootPointer = rootPointer;\n\n        this._size++;\n    }\n\n    /**\n     * Internal add\n     */\n    async _addToNode(node, key, value) {\n        if (node.isLeaf) {\n            const keys = [...node.keys];\n            const values = [...node.values];\n\n            const existingIdx = keys.indexOf(key);\n            if (existingIdx !== -1) {\n                values[existingIdx] = value;\n                return {\n                    newNode: new NodeData(node.id, true, keys, values, [], null)\n                };\n            }\n\n            let insertIdx = 0;\n            while (insertIdx < keys.length && key > keys[insertIdx]) {\n                insertIdx++;\n            }\n            keys.splice(insertIdx, 0, key);\n            values.splice(insertIdx, 0, value);\n\n            if (keys.length < this.order) {\n                return {\n                    newNode: new NodeData(node.id, true, keys, values, [], null)\n                };\n            } else {\n                const mid = Math.ceil(keys.length / 2);\n                const leftKeys = keys.slice(0, mid);\n                const leftValues = values.slice(0, mid);\n                const rightKeys = keys.slice(mid);\n                const rightValues = values.slice(mid);\n\n                const rightNode = new NodeData(this.nextNodeId++, true, rightKeys, rightValues, [], null);\n                const leftNode = new NodeData(node.id, true, leftKeys, leftValues, [], null);\n\n                return {\n                    left: leftNode,\n                    right: rightNode,\n                    splitKey: rightKeys[0]\n                };\n            }\n        } else {\n            const keys = [...node.keys];\n            const children = [...node.children];\n\n            let childIdx = 0;\n            while (childIdx < keys.length && key >= keys[childIdx]) {\n                childIdx++;\n            }\n\n            const childNode = await this._loadNode(children[childIdx]);\n            const result = await this._addToNode(childNode, key, value);\n\n            if (result.newNode) {\n                const newChildPointer = await this._saveNode(result.newNode);\n                children[childIdx] = newChildPointer;\n                return {\n                    newNode: new NodeData(node.id, false, keys, [], children, null)\n                };\n            } else {\n                const leftPointer = await this._saveNode(result.left);\n                const rightPointer = await this._saveNode(result.right);\n\n                keys.splice(childIdx, 0, result.splitKey);\n                children.splice(childIdx, 1, leftPointer, rightPointer);\n\n                if (keys.length < this.order) {\n                    return {\n                        newNode: new NodeData(node.id, false, keys, [], children, null)\n                    };\n                } else {\n                    const mid = Math.ceil(keys.length / 2) - 1;\n                    const splitKey = keys[mid];\n                    const leftKeys = keys.slice(0, mid);\n                    const rightKeys = keys.slice(mid + 1);\n                    const leftChildren = children.slice(0, mid + 1);\n                    const rightChildren = children.slice(mid + 1);\n\n                    const leftNode = new NodeData(node.id, false, leftKeys, [], leftChildren, null);\n                    const rightNode = new NodeData(this.nextNodeId++, false, rightKeys, [], rightChildren, null);\n\n                    return {\n                        left: leftNode,\n                        right: rightNode,\n                        splitKey: splitKey\n                    };\n                }\n            }\n        }\n    }\n\n    /**\n     * Delete a key\n     */\n    async delete(key) {\n        const root = await this._loadRoot();\n        const newRoot = await this._deleteFromNode(root, key);\n\n        if (!newRoot) {\n            return; // Key not found\n        }\n\n        let finalRoot = newRoot;\n        if (finalRoot.keys.length === 0 && !finalRoot.isLeaf && finalRoot.children.length > 0) {\n            finalRoot = await this._loadNode(finalRoot.children[0]);\n        }\n\n        const rootPointer = await this._saveNode(finalRoot);\n        this.rootPointer = rootPointer;\n\n        this._size--;\n    }\n\n    /**\n     * Internal delete\n     */\n    async _deleteFromNode(node, key) {\n        if (node.isLeaf) {\n            const keyIndex = node.keys.indexOf(key);\n\n            if (keyIndex === -1) {\n                return null;\n            }\n\n            const newKeys = [...node.keys];\n            const newValues = [...node.values];\n            newKeys.splice(keyIndex, 1);\n            newValues.splice(keyIndex, 1);\n\n            return new NodeData(node.id, true, newKeys, newValues, [], node.next);\n        } else {\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n\n            const childNode = await this._loadNode(node.children[i]);\n            const newChild = await this._deleteFromNode(childNode, key);\n\n            if (!newChild) {\n                return null;\n            }\n\n            const newChildren = [...node.children];\n            const newChildPointer = await this._saveNode(newChild);\n            newChildren[i] = newChildPointer;\n\n            return new NodeData(node.id, false, [...node.keys], [], newChildren, null);\n        }\n    }\n\n    /**\n     * Get all entries as array\n     */\n    async toArray() {\n        const result = [];\n        await this._collectAllEntries(await this._loadRoot(), result);\n        return result;\n    }\n\n    /**\n     * Collect all entries in sorted order by traversing tree\n     * @private\n     */\n    async _collectAllEntries(node, result) {\n        if (node.isLeaf) {\n            for (let i = 0; i < node.keys.length; i++) {\n                result.push({\n                    key: node.keys[i],\n                    value: node.values[i]\n                });\n            }\n        } else {\n            for (const childPointer of node.children) {\n                const child = await this._loadNode(childPointer);\n                await this._collectAllEntries(child, result);\n            }\n        }\n    }\n\n    /**\n     * Get tree size\n     */\n    size() {\n        return this._size;\n    }\n\n    /**\n     * Check if empty\n     */\n    isEmpty() {\n        return this._size === 0;\n    }\n\n    /**\n     * Range search\n     */\n    async rangeSearch(minKey, maxKey) {\n        const result = [];\n        await this._rangeSearchNode(await this._loadRoot(), minKey, maxKey, result);\n        return result;\n    }\n\n    /**\n     * Range search helper that traverses tree\n     * @private\n     */\n    async _rangeSearchNode(node, minKey, maxKey, result) {\n        if (node.isLeaf) {\n            for (let i = 0; i < node.keys.length; i++) {\n                if (node.keys[i] >= minKey && node.keys[i] <= maxKey) {\n                    result.push({\n                        key: node.keys[i],\n                        value: node.values[i]\n                    });\n                }\n            }\n        } else {\n            for (const childPointer of node.children) {\n                const child = await this._loadNode(childPointer);\n                await this._rangeSearchNode(child, minKey, maxKey, result);\n            }\n        }\n    }\n\n    /**\n     * Get tree height\n     */\n    async getHeight() {\n        let height = 0;\n        let current = await this._loadRoot();\n\n        while (!current.isLeaf) {\n            height++;\n            current = await this._loadNode(current.children[0]);\n        }\n\n        return height;\n    }\n\n    /**\n     * Compact the tree into a new file by copying only the current live nodes.\n     * Returns size metrics so callers can see how much space was reclaimed.\n     * @param {string} destinationFilename - New file to write the compacted tree into\n     * @returns {Promise<{oldSize:number,newSize:number,bytesSaved:number,newFilename:string}>}\n     */\n    async compact(destinationFilename) {\n        if (!this.isOpen) {\n            throw new Error('Tree file is not open');\n        }\n        if (!destinationFilename) {\n            throw new Error('Destination filename is required for compaction');\n        }\n\n        // Make sure the current file has up-to-date metadata before measuring size\n        await this._saveMetadata();\n        const oldSize = await this.file.getFileSize();\n\n        // Rebuild a fresh tree with only the live entries\n        const entries = await this.toArray();\n        const newTree = new BPlusTree(destinationFilename, this.order);\n        await newTree.open();\n        for (const entry of entries) {\n            await newTree.add(entry.key, entry.value);\n        }\n        await newTree.close();\n\n        // Measure new file size after metadata has been written on close\n        const tempFile = new BJsonFile(destinationFilename);\n        await tempFile.open('r');\n        const newSize = await tempFile.getFileSize();\n        await tempFile.close();\n\n        return {\n            oldSize,\n            newSize,\n            bytesSaved: Math.max(0, oldSize - newSize),\n            newFilename: destinationFilename\n        };\n    }\n}\n","import { stemmer } from 'stemmer';\nimport { BPlusTree } from './bplustree.js';\n\n// Common English stop words that don't add semantic value to searches\nconst STOPWORDS = new Set([\n  'a', 'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', \n  'around', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'between', 'both', \n  'but', 'by', 'came', 'can', 'come', 'could', 'did', 'do', 'each', 'for', 'from', \n  'get', 'got', 'has', 'had', 'he', 'have', 'her', 'here', 'him', 'himself', 'his', \n  'how', 'i', 'if', 'in', 'into', 'is', 'it', 'like', 'make', 'many', 'me', 'might', \n  'more', 'most', 'much', 'must', 'my', 'never', 'now', 'of', 'on', 'only', 'or', \n  'other', 'our', 'out', 'over', 'said', 'same', 'see', 'should', 'since', 'some', \n  'still', 'such', 'take', 'than', 'that', 'the', 'their', 'them', 'then', 'there', \n  'these', 'they', 'this', 'those', 'through', 'to', 'too', 'under', 'up', 'very', \n  'was', 'way', 'we', 'well', 'were', 'what', 'where', 'which', 'while', 'who', \n  'with', 'would', 'you', 'your'\n]);\n\n/**\n * Tokenize text into individual words\n * @param {string} text - The text to tokenize\n * @returns {string[]} Array of words\n */\nexport function tokenize(text) {\n  if (typeof text !== 'string') {\n    return [];\n  }\n  // Split on non-word characters and filter out empty strings\n  const words = text.toLowerCase()\n    .split(/\\W+/)\n    .filter(word => word.length > 0);\n  \n  // Filter stop words\n  return words.filter(word => !STOPWORDS.has(word));\n}\n\n/**\n * TextIndex - A text index implementation using Porter stemmer algorithm\n * \n * This class provides full-text search capabilities by indexing terms\n * and associating them with document IDs. It uses the Porter stemmer\n * algorithm to normalize words to their root forms.\n */\nexport class TextIndex {\n  constructor(options = {}) {\n    const {\n      baseFilename = `text-index-${Date.now()}-${Math.random().toString(16).slice(2)}`,\n      order = 16,\n      trees\n    } = options;\n\n    this.baseFilename = baseFilename;\n    this.index = trees?.index || new BPlusTree(`${baseFilename}-terms.bjson`, order);\n    this.documentTerms = trees?.documentTerms || new BPlusTree(`${baseFilename}-documents.bjson`, order);\n    this.documentLengths = trees?.documentLengths || new BPlusTree(`${baseFilename}-lengths.bjson`, order);\n    this.isOpen = false;\n  }\n\n  async open() {\n    if (this.isOpen) {\n      throw new Error('TextIndex is already open');\n    }\n\n    await Promise.all([\n      this.index.open(),\n      this.documentTerms.open(),\n      this.documentLengths.open()\n    ]);\n\n    this.isOpen = true;\n  }\n\n  async close() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    await Promise.all([\n      this.index.close(),\n      this.documentTerms.close(),\n      this.documentLengths.close()\n    ]);\n\n    this.isOpen = false;\n  }\n\n  _ensureOpen() {\n    if (!this.isOpen) {\n      throw new Error('TextIndex is not open');\n    }\n  }\n\n  /**\n   * Add terms from text to the index for a given document ID\n   * @param {string} docId - The document identifier\n   * @param {string} text - The text content to index\n   */\n  async add(docId, text) {\n    this._ensureOpen();\n\n    if (!docId) {\n      throw new Error('Document ID is required');\n    }\n\n    const words = tokenize(text);\n    const termFrequency = new Map();\n\n    words.forEach(word => {\n      const stem = stemmer(word);\n      termFrequency.set(stem, (termFrequency.get(stem) || 0) + 1);\n    });\n\n    for (const [stem, frequency] of termFrequency.entries()) {\n      const postings = (await this.index.search(stem)) || {};\n      postings[docId] = frequency;\n      await this.index.add(stem, postings);\n    }\n\n    const existingTerms = (await this.documentTerms.search(docId)) || {};\n    const mergedTerms = { ...existingTerms };\n    termFrequency.forEach((frequency, stem) => {\n      mergedTerms[stem] = frequency;\n    });\n\n    const docLength = Object.values(mergedTerms).reduce((sum, count) => sum + count, 0);\n\n    await this.documentTerms.add(docId, mergedTerms);\n    await this.documentLengths.add(docId, docLength);\n  }\n\n  /**\n   * Remove all indexed terms for a given document ID\n   * @param {string} docId - The document identifier to remove\n   * @returns {boolean} True if document was found and removed, false otherwise\n   */\n  async remove(docId) {\n    this._ensureOpen();\n\n    const terms = await this.documentTerms.search(docId);\n    if (!terms) {\n      return false;\n    }\n\n    for (const [term] of Object.entries(terms)) {\n      const postings = (await this.index.search(term)) || {};\n      delete postings[docId];\n\n      if (Object.keys(postings).length === 0) {\n        await this.index.delete(term);\n      } else {\n        await this.index.add(term, postings);\n      }\n    }\n\n    await this.documentTerms.delete(docId);\n    await this.documentLengths.delete(docId);\n    return true;\n  }\n\n  /**\n   * Query the index for documents containing the given terms with relevance scoring\n   * @param {string} queryText - The search query text\n   * @param {Object} options - Query options\n   * @param {boolean} options.scored - If true, return scored results; if false, return just IDs (default: true)\n   * @param {boolean} options.requireAll - If true, require ALL terms; if false, rank by relevance (default: false)\n   * @returns {Array} Array of document IDs (if scored=false) or objects with {id, score} (if scored=true)\n   */\n  async query(queryText, options = { scored: true, requireAll: false }) {\n    this._ensureOpen();\n\n    const words = tokenize(queryText);\n    if (words.length === 0) {\n      return [];\n    }\n\n    const stemmedTerms = words.map(word => stemmer(word));\n    const uniqueTerms = [...new Set(stemmedTerms)];\n\n    if (options.requireAll) {\n      const docSets = [];\n      for (const term of uniqueTerms) {\n        const termDocs = await this.index.search(term);\n        docSets.push(new Set(Object.keys(termDocs || {})));\n      }\n\n      if (docSets.length === 0) {\n        return [];\n      }\n\n      const intersection = new Set(docSets[0]);\n      for (let i = 1; i < docSets.length; i++) {\n        for (const docId of [...intersection]) {\n          if (!docSets[i].has(docId)) {\n            intersection.delete(docId);\n          }\n        }\n      }\n\n      return Array.from(intersection);\n    }\n\n    const docLengthEntries = await this.documentLengths.toArray();\n    const docLengthMap = new Map(docLengthEntries.map(({ key, value }) => [String(key), value || 1]));\n    const totalDocs = docLengthEntries.length;\n\n    const idf = new Map();\n    for (const term of uniqueTerms) {\n      const termDocs = await this.index.search(term);\n      const docsWithTerm = termDocs ? Object.keys(termDocs).length : 0;\n      if (docsWithTerm > 0) {\n        idf.set(term, Math.log(totalDocs / docsWithTerm));\n      }\n    }\n\n    const docScores = new Map();\n    for (const term of uniqueTerms) {\n      const termDocs = await this.index.search(term);\n      if (!termDocs) {\n        continue;\n      }\n\n      for (const [docId, termFreq] of Object.entries(termDocs)) {\n        const docLength = docLengthMap.get(docId) || 1;\n        const tf = termFreq / docLength;\n        const termIdf = idf.get(term) || 0;\n        const prev = docScores.get(docId) || 0;\n        docScores.set(docId, prev + tf * termIdf);\n      }\n    }\n\n    for (const [docId, score] of docScores.entries()) {\n      const docTerms = (await this.documentTerms.search(docId)) || {};\n      const matchingTerms = uniqueTerms.filter(term => !!docTerms[term]).length;\n      const coverage = matchingTerms / uniqueTerms.length;\n      docScores.set(docId, score * (1 + coverage));\n    }\n\n    const results = Array.from(docScores.entries())\n      .map(([id, score]) => ({ id, score }))\n      .sort((a, b) => b.score - a.score);\n\n    if (options.scored === false) {\n      return results.map(r => r.id);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Get the number of unique terms in the index\n   * @returns {number} Number of unique terms\n   */\n  async getTermCount() {\n    this._ensureOpen();\n    const terms = await this.index.toArray();\n    return terms.length;\n  }\n\n  /**\n   * Get the number of documents in the index\n   * @returns {number} Number of indexed documents\n   */\n  async getDocumentCount() {\n    this._ensureOpen();\n    const docs = await this.documentTerms.toArray();\n    return docs.length;\n  }\n\n  /**\n   * Clear all data from the index\n   */\n  async clear() {\n    this._ensureOpen();\n\n    const [terms, docs, lengths] = await Promise.all([\n      this.index.toArray(),\n      this.documentTerms.toArray(),\n      this.documentLengths.toArray()\n    ]);\n\n    // Run deletes sequentially to avoid overlapping writes on the same underlying file\n    for (const entry of terms) {\n      await this.index.delete(entry.key);\n    }\n\n    for (const entry of docs) {\n      await this.documentTerms.delete(entry.key);\n    }\n\n    for (const entry of lengths) {\n      await this.documentLengths.delete(entry.key);\n    }\n  }\n\n  /**\n   * Compact all internal B+ trees into new files and switch the index to use them.\n   * @param {string} destinationBase - Base filename (without suffixes) for the compacted files\n   * @returns {Promise<{terms: object, documents: object, lengths: object}>}\n   */\n  async compact(destinationBase = `${this.baseFilename}-compact-${Date.now()}`) {\n    this._ensureOpen();\n\n    if (!destinationBase) {\n      throw new Error('Destination base filename is required for compaction');\n    }\n\n    const termsDest = `${destinationBase}-terms.bjson`;\n    const documentsDest = `${destinationBase}-documents.bjson`;\n    const lengthsDest = `${destinationBase}-lengths.bjson`;\n\n    const results = await Promise.all([\n      this.index.compact(termsDest),\n      this.documentTerms.compact(documentsDest),\n      this.documentLengths.compact(lengthsDest)\n    ]);\n\n    const indexOrder = this.index.order;\n    const documentsOrder = this.documentTerms.order;\n    const lengthsOrder = this.documentLengths.order;\n\n    await this.close();\n\n    this.baseFilename = destinationBase;\n    this.index = new BPlusTree(termsDest, indexOrder);\n    this.documentTerms = new BPlusTree(documentsDest, documentsOrder);\n    this.documentLengths = new BPlusTree(lengthsDest, lengthsOrder);\n\n    await this.open();\n\n    return {\n      terms: results[0],\n      documents: results[1],\n      lengths: results[2]\n    };\n  }\n\n}\n\n// Re-export the stemmer so consumers can share the exact same implementation\nexport { stemmer };\n","/**\n * Aggregation Expression Evaluator\n * \n * Implements MongoDB aggregation expression operators for use in\n * $project, $addFields, $set, $group, and other pipeline stages.\n */\n\nimport { getProp } from './utils.js';\n\n/**\n * Evaluate an aggregation expression against a document\n * @param {*} expr - The expression to evaluate (can be literal, field reference, or expression object)\n * @param {Object} doc - The document to evaluate against\n * @returns {*} The evaluated result\n */\nexport function evaluateExpression(expr, doc) {\n\t// Literal values (strings not starting with $, numbers, booleans, null)\n\tif (expr === null || expr === undefined) {\n\t\treturn expr;\n\t}\n\t\n\tif (typeof expr === 'boolean' || typeof expr === 'number') {\n\t\treturn expr;\n\t}\n\t\n\t// Field reference ($fieldName) or variable reference ($$variableName)\n\tif (typeof expr === 'string') {\n\t\tif (expr.startsWith('$$')) {\n\t\t\t// Special system variables for $redact\n\t\t\tif (expr === '$$KEEP' || expr === '$$PRUNE' || expr === '$$DESCEND') {\n\t\t\t\treturn expr;\n\t\t\t}\n\t\t\t// Variable reference ($$var)\n\t\t\treturn getProp(doc, expr.substring(2));\n\t\t} else if (expr.charAt(0) === '$') {\n\t\t\t// Field reference ($field)\n\t\t\treturn getProp(doc, expr.substring(1));\n\t\t}\n\t\treturn expr; // Literal string\n\t}\n\t\n\t// Expression object\n\tif (typeof expr === 'object') {\n\t\t// Check if it's an array literal\n\t\tif (Array.isArray(expr)) {\n\t\t\treturn expr.map(item => evaluateExpression(item, doc));\n\t\t}\n\t\t\n\t\t// Expression operator\n\t\tconst keys = Object.keys(expr);\n\t\tif (keys.length === 0) {\n\t\t\treturn expr; // Empty object literal\n\t\t}\n\t\t\n\t\tconst operator = keys[0];\n\t\t\n\t\t// Check if this is an operator (starts with $) or an object literal\n\t\tif (operator.charAt(0) === '$') {\n\t\t\t// This is an expression operator\n\t\t\tconst operand = expr[operator];\n\t\t\treturn evaluateOperator(operator, operand, doc);\n\t\t} else {\n\t\t\t// This is an object literal - evaluate each field\n\t\t\tconst result = {};\n\t\t\tfor (const key of keys) {\n\t\t\t\tresult[key] = evaluateExpression(expr[key], doc);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\treturn expr;\n}\n\n/**\n * Evaluate a specific operator\n */\nfunction evaluateOperator(operator, operand, doc) {\n\tswitch (operator) {\n\t\t// Arithmetic operators\n\t\tcase '$add': return evalAdd(operand, doc);\n\t\tcase '$subtract': return evalSubtract(operand, doc);\n\t\tcase '$multiply': return evalMultiply(operand, doc);\n\t\tcase '$divide': return evalDivide(operand, doc);\n\t\tcase '$mod': return evalMod(operand, doc);\n\t\tcase '$pow': return evalPow(operand, doc);\n\t\tcase '$sqrt': return evalSqrt(operand, doc);\n\t\tcase '$abs': return evalAbs(operand, doc);\n\t\tcase '$ceil': return evalCeil(operand, doc);\n\t\tcase '$floor': return evalFloor(operand, doc);\n\t\tcase '$trunc': return evalTrunc(operand, doc);\n\t\tcase '$round': return evalRound(operand, doc);\n\t\t\n\t\t// String operators\n\t\tcase '$concat': return evalConcat(operand, doc);\n\t\tcase '$substr': return evalSubstr(operand, doc);\n\t\tcase '$toLower': return evalToLower(operand, doc);\n\t\tcase '$toUpper': return evalToUpper(operand, doc);\n\t\tcase '$trim': return evalTrim(operand, doc);\n\t\tcase '$ltrim': return evalLtrim(operand, doc);\n\t\tcase '$rtrim': return evalRtrim(operand, doc);\n\t\tcase '$split': return evalSplit(operand, doc);\n\t\tcase '$strLenCP': return evalStrLenCP(operand, doc);\n\t\tcase '$strcasecmp': return evalStrcasecmp(operand, doc);\n\t\tcase '$indexOfCP': return evalIndexOfCP(operand, doc);\n\t\tcase '$replaceOne': return evalReplaceOne(operand, doc);\n\t\tcase '$replaceAll': return evalReplaceAll(operand, doc);\n\t\t\n\t\t// Comparison operators\n\t\tcase '$cmp': return evalCmp(operand, doc);\n\t\tcase '$eq': return evalEq(operand, doc);\n\t\tcase '$ne': return evalNe(operand, doc);\n\t\tcase '$gt': return evalGt(operand, doc);\n\t\tcase '$gte': return evalGte(operand, doc);\n\t\tcase '$lt': return evalLt(operand, doc);\n\t\tcase '$lte': return evalLte(operand, doc);\n\t\t\n\t\t// Logical operators\n\t\tcase '$and': return evalAnd(operand, doc);\n\t\tcase '$or': return evalOr(operand, doc);\n\t\tcase '$not': return evalNot(operand, doc);\n\t\t\n\t\t// Conditional operators\n\t\tcase '$cond': return evalCond(operand, doc);\n\t\tcase '$ifNull': return evalIfNull(operand, doc);\n\t\tcase '$switch': return evalSwitch(operand, doc);\n\t\t\n\t\t// Date operators\n\t\tcase '$year': return evalYear(operand, doc);\n\t\tcase '$month': return evalMonth(operand, doc);\n\t\tcase '$dayOfMonth': return evalDayOfMonth(operand, doc);\n\t\tcase '$dayOfWeek': return evalDayOfWeek(operand, doc);\n\t\tcase '$dayOfYear': return evalDayOfYear(operand, doc);\n\t\tcase '$hour': return evalHour(operand, doc);\n\t\tcase '$minute': return evalMinute(operand, doc);\n\t\tcase '$second': return evalSecond(operand, doc);\n\t\tcase '$millisecond': return evalMillisecond(operand, doc);\n\t\tcase '$week': return evalWeek(operand, doc);\n\t\tcase '$isoWeek': return evalIsoWeek(operand, doc);\n\t\tcase '$isoWeekYear': return evalIsoWeekYear(operand, doc);\n\t\tcase '$dateToString': return evalDateToString(operand, doc);\n\t\tcase '$toDate': return evalToDate(operand, doc);\n\t\t\n\t\t// Array operators\n\t\tcase '$arrayElemAt': return evalArrayElemAt(operand, doc);\n\t\tcase '$concatArrays': return evalConcatArrays(operand, doc);\n\t\tcase '$filter': return evalFilter(operand, doc);\n\t\tcase '$in': return evalIn(operand, doc);\n\t\tcase '$indexOfArray': return evalIndexOfArray(operand, doc);\n\t\tcase '$isArray': return evalIsArray(operand, doc);\n\t\tcase '$map': return evalMap(operand, doc);\n\t\tcase '$reduce': return evalReduce(operand, doc);\n\t\tcase '$size': return evalSize(operand, doc);\n\t\tcase '$slice': return evalSlice(operand, doc);\n\t\tcase '$reverseArray': return evalReverseArray(operand, doc);\n\t\tcase '$zip': return evalZip(operand, doc);\n\t\t\n\t\t// Type operators\n\t\tcase '$type': return evalType(operand, doc);\n\t\tcase '$convert': return evalConvert(operand, doc);\n\t\tcase '$toBool': return evalToBool(operand, doc);\n\t\tcase '$toDecimal': return evalToDecimal(operand, doc);\n\t\tcase '$toDouble': return evalToDouble(operand, doc);\n\t\tcase '$toInt': return evalToInt(operand, doc);\n\t\tcase '$toLong': return evalToLong(operand, doc);\n\t\tcase '$toString': return evalToString(operand, doc);\n\t\t\n\t\t// Object operators\n\t\tcase '$objectToArray': return evalObjectToArray(operand, doc);\n\t\tcase '$arrayToObject': return evalArrayToObject(operand, doc);\n\t\tcase '$mergeObjects': return evalMergeObjects(operand, doc);\n\t\t\n\t\t// Literal operator\n\t\tcase '$literal': return operand;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported aggregation operator: ${operator}`);\n\t}\n}\n\n// ============================================================================\n// ARITHMETIC OPERATORS\n// ============================================================================\n\nfunction evalAdd(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet sum = 0;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val instanceof Date) {\n\t\t\tsum += val.getTime();\n\t\t} else if (typeof val === 'number') {\n\t\t\tsum += val;\n\t\t}\n\t}\n\treturn sum;\n}\n\nfunction evalSubtract(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\t\n\tif (val1 instanceof Date && val2 instanceof Date) {\n\t\treturn val1.getTime() - val2.getTime();\n\t} else if (val1 instanceof Date && typeof val2 === 'number') {\n\t\treturn new Date(val1.getTime() - val2);\n\t} else if (typeof val1 === 'number' && typeof val2 === 'number') {\n\t\treturn val1 - val2;\n\t}\n\treturn null;\n}\n\nfunction evalMultiply(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet product = 1;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (typeof val === 'number') {\n\t\t\tproduct *= val;\n\t\t}\n\t}\n\treturn product;\n}\n\nfunction evalDivide(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\tif (typeof val1 === 'number' && typeof val2 === 'number' && val2 !== 0) {\n\t\treturn val1 / val2;\n\t}\n\treturn null;\n}\n\nfunction evalMod(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\tif (typeof val1 === 'number' && typeof val2 === 'number' && val2 !== 0) {\n\t\treturn val1 % val2;\n\t}\n\treturn null;\n}\n\nfunction evalPow(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst base = evaluateExpression(operands[0], doc);\n\tconst exponent = evaluateExpression(operands[1], doc);\n\tif (typeof base === 'number' && typeof exponent === 'number') {\n\t\treturn Math.pow(base, exponent);\n\t}\n\treturn null;\n}\n\nfunction evalSqrt(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number' && val >= 0) {\n\t\treturn Math.sqrt(val);\n\t}\n\treturn null;\n}\n\nfunction evalAbs(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.abs(val);\n\t}\n\treturn null;\n}\n\nfunction evalCeil(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.ceil(val);\n\t}\n\treturn null;\n}\n\nfunction evalFloor(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.floor(val);\n\t}\n\treturn null;\n}\n\nfunction evalTrunc(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.trunc(val);\n\t}\n\treturn null;\n}\n\nfunction evalRound(operands, doc) {\n\tconst val = evaluateExpression(Array.isArray(operands) ? operands[0] : operands, doc);\n\tconst place = Array.isArray(operands) && operands[1] !== undefined \n\t\t? evaluateExpression(operands[1], doc) \n\t\t: 0;\n\t\n\tif (typeof val === 'number' && typeof place === 'number') {\n\t\tconst multiplier = Math.pow(10, place);\n\t\treturn Math.round(val * multiplier) / multiplier;\n\t}\n\treturn null;\n}\n\n// ============================================================================\n// STRING OPERATORS\n// ============================================================================\n\nfunction evalConcat(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet result = '';\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val !== null && val !== undefined) {\n\t\t\tresult += String(val);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalSubstr(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 3) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst start = evaluateExpression(operands[1], doc);\n\tconst length = evaluateExpression(operands[2], doc);\n\tif (typeof start === 'number' && typeof length === 'number') {\n\t\treturn str.substr(start, length);\n\t}\n\treturn null;\n}\n\nfunction evalToLower(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).toLowerCase() : '';\n}\n\nfunction evalToUpper(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).toUpperCase() : '';\n}\n\nfunction evalTrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`^[${escapeRegex(chars)}]+|[${escapeRegex(chars)}]+$`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.trim();\n}\n\nfunction evalLtrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`^[${escapeRegex(chars)}]+`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.replace(/^\\s+/, '');\n}\n\nfunction evalRtrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`[${escapeRegex(chars)}]+$`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.replace(/\\s+$/, '');\n}\n\nfunction evalSplit(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst delimiter = String(evaluateExpression(operands[1], doc) || '');\n\treturn str.split(delimiter);\n}\n\nfunction evalStrLenCP(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).length : 0;\n}\n\nfunction evalStrcasecmp(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst str1 = String(evaluateExpression(operands[0], doc) || '').toLowerCase();\n\tconst str2 = String(evaluateExpression(operands[1], doc) || '').toLowerCase();\n\t\n\tif (str1 < str2) return -1;\n\tif (str1 > str2) return 1;\n\treturn 0;\n}\n\nfunction evalIndexOfCP(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst substr = String(evaluateExpression(operands[1], doc) || '');\n\tconst start = operands[2] !== undefined ? evaluateExpression(operands[2], doc) : 0;\n\tconst end = operands[3] !== undefined ? evaluateExpression(operands[3], doc) : str.length;\n\t\n\tconst searchStr = str.substring(start, end);\n\tconst index = searchStr.indexOf(substr);\n\treturn index === -1 ? -1 : index + start;\n}\n\nfunction evalReplaceOne(operand, doc) {\n\tconst input = String(evaluateExpression(operand.input, doc) || '');\n\tconst find = String(evaluateExpression(operand.find, doc) || '');\n\tconst replacement = String(evaluateExpression(operand.replacement, doc) || '');\n\t\n\treturn input.replace(find, replacement);\n}\n\nfunction evalReplaceAll(operand, doc) {\n\tconst input = String(evaluateExpression(operand.input, doc) || '');\n\tconst find = String(evaluateExpression(operand.find, doc) || '');\n\tconst replacement = String(evaluateExpression(operand.replacement, doc) || '');\n\t\n\treturn input.split(find).join(replacement);\n}\n\nfunction escapeRegex(str) {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// ============================================================================\n// COMPARISON OPERATORS\n// ============================================================================\n\nfunction evalCmp(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\t\n\tif (val1 < val2) return -1;\n\tif (val1 > val2) return 1;\n\treturn 0;\n}\n\nfunction evalEq(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 === val2;\n}\n\nfunction evalNe(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 !== val2;\n}\n\nfunction evalGt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 > val2;\n}\n\nfunction evalGte(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 >= val2;\n}\n\nfunction evalLt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 < val2;\n}\n\nfunction evalLte(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 <= val2;\n}\n\n// ============================================================================\n// LOGICAL OPERATORS\n// ============================================================================\n\nfunction evalAnd(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (!val) return false;\n\t}\n\treturn true;\n}\n\nfunction evalOr(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val) return true;\n\t}\n\treturn false;\n}\n\nfunction evalNot(operand, doc) {\n\tconst val = evaluateExpression(Array.isArray(operand) ? operand[0] : operand, doc);\n\treturn !val;\n}\n\n// ============================================================================\n// CONDITIONAL OPERATORS\n// ============================================================================\n\nfunction evalCond(operand, doc) {\n\t// Supports both array form [if, then, else] and object form {if, then, else}\n\tlet ifExpr, thenExpr, elseExpr;\n\t\n\tif (Array.isArray(operand)) {\n\t\tif (operand.length !== 3) return null;\n\t\t[ifExpr, thenExpr, elseExpr] = operand;\n\t} else if (typeof operand === 'object') {\n\t\tifExpr = operand.if;\n\t\tthenExpr = operand.then;\n\t\telseExpr = operand.else;\n\t} else {\n\t\treturn null;\n\t}\n\t\n\tconst condition = evaluateExpression(ifExpr, doc);\n\treturn condition ? evaluateExpression(thenExpr, doc) : evaluateExpression(elseExpr, doc);\n}\n\nfunction evalIfNull(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\t\n\tfor (let i = 0; i < operands.length; i++) {\n\t\tconst val = evaluateExpression(operands[i], doc);\n\t\tif (val !== null && val !== undefined) {\n\t\t\treturn val;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction evalSwitch(operand, doc) {\n\tif (typeof operand !== 'object' || !Array.isArray(operand.branches)) {\n\t\treturn null;\n\t}\n\t\n\tfor (const branch of operand.branches) {\n\t\tconst caseResult = evaluateExpression(branch.case, doc);\n\t\tif (caseResult) {\n\t\t\treturn evaluateExpression(branch.then, doc);\n\t\t}\n\t}\n\t\n\treturn operand.default !== undefined ? evaluateExpression(operand.default, doc) : null;\n}\n\n// ============================================================================\n// DATE OPERATORS\n// ============================================================================\n\nfunction evalYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCFullYear();\n\t}\n\treturn null;\n}\n\nfunction evalMonth(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMonth() + 1; // MongoDB returns 1-12\n\t}\n\treturn null;\n}\n\nfunction evalDayOfMonth(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCDate();\n\t}\n\treturn null;\n}\n\nfunction evalDayOfWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCDay() + 1; // MongoDB returns 1-7 (Sunday is 1)\n\t}\n\treturn null;\n}\n\nfunction evalDayOfYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst start = new Date(Date.UTC(date.getUTCFullYear(), 0, 0));\n\t\tconst diff = date - start;\n\t\tconst oneDay = 1000 * 60 * 60 * 24;\n\t\treturn Math.floor(diff / oneDay);\n\t}\n\treturn null;\n}\n\nfunction evalHour(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCHours();\n\t}\n\treturn null;\n}\n\nfunction evalMinute(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMinutes();\n\t}\n\treturn null;\n}\n\nfunction evalSecond(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCSeconds();\n\t}\n\treturn null;\n}\n\nfunction evalMillisecond(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMilliseconds();\n\t}\n\treturn null;\n}\n\nfunction evalWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst onejan = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));\n\t\tconst week = Math.ceil((((date - onejan) / 86400000) + onejan.getUTCDay() + 1) / 7);\n\t\treturn week - 1; // MongoDB weeks are 0-indexed\n\t}\n\treturn null;\n}\n\nfunction evalIsoWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst target = new Date(date.valueOf());\n\t\tconst dayNr = (date.getUTCDay() + 6) % 7;\n\t\ttarget.setUTCDate(target.getUTCDate() - dayNr + 3);\n\t\tconst firstThursday = target.valueOf();\n\t\ttarget.setUTCMonth(0, 1);\n\t\tif (target.getUTCDay() !== 4) {\n\t\t\ttarget.setUTCMonth(0, 1 + ((4 - target.getUTCDay()) + 7) % 7);\n\t\t}\n\t\treturn 1 + Math.ceil((firstThursday - target) / 604800000);\n\t}\n\treturn null;\n}\n\nfunction evalIsoWeekYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst target = new Date(date.valueOf());\n\t\ttarget.setUTCDate(target.getUTCDate() - ((date.getUTCDay() + 6) % 7) + 3);\n\t\treturn target.getUTCFullYear();\n\t}\n\treturn null;\n}\n\nfunction evalDateToString(operand, doc) {\n\tconst format = operand.format ? evaluateExpression(operand.format, doc) : '%Y-%m-%dT%H:%M:%S.%LZ';\n\tconst date = evaluateExpression(operand.date, doc);\n\t\n\tif (!(date instanceof Date)) return null;\n\t\n\t// Simple format string implementation using UTC methods\n\treturn format\n\t\t.replace('%Y', date.getUTCFullYear())\n\t\t.replace('%m', String(date.getUTCMonth() + 1).padStart(2, '0'))\n\t\t.replace('%d', String(date.getUTCDate()).padStart(2, '0'))\n\t\t.replace('%H', String(date.getUTCHours()).padStart(2, '0'))\n\t\t.replace('%M', String(date.getUTCMinutes()).padStart(2, '0'))\n\t\t.replace('%S', String(date.getUTCSeconds()).padStart(2, '0'))\n\t\t.replace('%L', String(date.getUTCMilliseconds()).padStart(3, '0'));\n}\n\nfunction evalToDate(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (val instanceof Date) return val;\n\tif (typeof val === 'string' || typeof val === 'number') {\n\t\tconst date = new Date(val);\n\t\treturn isNaN(date.getTime()) ? null : date;\n\t}\n\treturn null;\n}\n\n// ============================================================================\n// ARRAY OPERATORS\n// ============================================================================\n\nfunction evalArrayElemAt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\tconst idx = evaluateExpression(operands[1], doc);\n\t\n\tif (!Array.isArray(arr) || typeof idx !== 'number') return null;\n\t\n\tconst index = idx < 0 ? arr.length + idx : idx;\n\treturn arr[index];\n}\n\nfunction evalConcatArrays(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tconst result = [];\n\tfor (const operand of operands) {\n\t\tconst arr = evaluateExpression(operand, doc);\n\t\tif (Array.isArray(arr)) {\n\t\t\tresult.push(...arr);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalFilter(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst asVar = operand.as || 'this';\n\tconst cond = operand.cond;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\treturn input.filter(item => {\n\t\tconst itemDoc = { ...doc, [asVar]: item };\n\t\treturn evaluateExpression(cond, itemDoc);\n\t});\n}\n\nfunction evalIn(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst value = evaluateExpression(operands[0], doc);\n\tconst arr = evaluateExpression(operands[1], doc);\n\t\n\tif (!Array.isArray(arr)) return false;\n\treturn arr.includes(value);\n}\n\nfunction evalIndexOfArray(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\tconst search = evaluateExpression(operands[1], doc);\n\tconst start = operands[2] !== undefined ? evaluateExpression(operands[2], doc) : 0;\n\tconst end = operands[3] !== undefined ? evaluateExpression(operands[3], doc) : arr.length;\n\t\n\tif (!Array.isArray(arr)) return null;\n\t\n\tfor (let i = start; i < end && i < arr.length; i++) {\n\t\tif (arr[i] === search) return i;\n\t}\n\treturn -1;\n}\n\nfunction evalIsArray(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn Array.isArray(val);\n}\n\nfunction evalMap(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst asVar = operand.as || 'this';\n\tconst inExpr = operand.in;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\treturn input.map(item => {\n\t\tconst itemDoc = { ...doc, [asVar]: item };\n\t\treturn evaluateExpression(inExpr, itemDoc);\n\t});\n}\n\nfunction evalReduce(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst initialValue = evaluateExpression(operand.initialValue, doc);\n\tconst inExpr = operand.in;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\tlet value = initialValue;\n\tfor (const item of input) {\n\t\tconst itemDoc = { ...doc, value, this: item };\n\t\tvalue = evaluateExpression(inExpr, itemDoc);\n\t}\n\treturn value;\n}\n\nfunction evalSize(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\treturn Array.isArray(arr) ? arr.length : null;\n}\n\nfunction evalSlice(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\t\n\tif (!Array.isArray(arr)) return null;\n\t\n\tif (operands.length === 2) {\n\t\tconst n = evaluateExpression(operands[1], doc);\n\t\treturn n >= 0 ? arr.slice(0, n) : arr.slice(n);\n\t} else {\n\t\tconst position = evaluateExpression(operands[1], doc);\n\t\tconst n = evaluateExpression(operands[2], doc);\n\t\treturn arr.slice(position, position + n);\n\t}\n}\n\nfunction evalReverseArray(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\treturn Array.isArray(arr) ? arr.slice().reverse() : null;\n}\n\nfunction evalZip(operand, doc) {\n\tconst inputs = operand.inputs ? evaluateExpression(operand.inputs, doc) : null;\n\tconst useLongestLength = operand.useLongestLength || false;\n\tconst defaults = operand.defaults;\n\t\n\tif (!Array.isArray(inputs)) return null;\n\t\n\tconst arrays = inputs.map(input => evaluateExpression(input, doc));\n\tif (!arrays.every(arr => Array.isArray(arr))) return null;\n\t\n\tconst maxLength = Math.max(...arrays.map(arr => arr.length));\n\tconst length = useLongestLength ? maxLength : Math.min(...arrays.map(arr => arr.length));\n\t\n\tconst result = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tconst tuple = [];\n\t\tfor (let j = 0; j < arrays.length; j++) {\n\t\t\tif (i < arrays[j].length) {\n\t\t\t\ttuple.push(arrays[j][i]);\n\t\t\t} else if (defaults && j < defaults.length) {\n\t\t\t\ttuple.push(defaults[j]);\n\t\t\t} else {\n\t\t\t\ttuple.push(null);\n\t\t\t}\n\t\t}\n\t\tresult.push(tuple);\n\t}\n\treturn result;\n}\n\n// ============================================================================\n// TYPE OPERATORS\n// ============================================================================\n\nfunction evalType(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\t\n\tif (val === null) return 'null';\n\tif (val === undefined) return 'missing';\n\tif (typeof val === 'boolean') return 'bool';\n\tif (typeof val === 'number') return Number.isInteger(val) ? 'int' : 'double';\n\tif (typeof val === 'string') return 'string';\n\tif (val instanceof Date) return 'date';\n\tif (Array.isArray(val)) return 'array';\n\tif (typeof val === 'object') return 'object';\n\t\n\treturn 'unknown';\n}\n\nfunction evalConvert(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst to = operand.to;\n\tconst onError = operand.onError;\n\tconst onNull = operand.onNull;\n\t\n\tif (input === null) {\n\t\treturn onNull !== undefined ? evaluateExpression(onNull, doc) : null;\n\t}\n\t\n\ttry {\n\t\tswitch (to) {\n\t\t\tcase 'double':\n\t\t\tcase 'decimal':\n\t\t\t\treturn parseFloat(input);\n\t\t\tcase 'int':\n\t\t\tcase 'long':\n\t\t\t\treturn parseInt(input);\n\t\t\tcase 'bool':\n\t\t\t\treturn Boolean(input);\n\t\t\tcase 'string':\n\t\t\t\treturn String(input);\n\t\t\tcase 'date':\n\t\t\t\treturn new Date(input);\n\t\t\tdefault:\n\t\t\t\treturn input;\n\t\t}\n\t} catch (e) {\n\t\treturn onError !== undefined ? evaluateExpression(onError, doc) : null;\n\t}\n}\n\nfunction evalToBool(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn Boolean(val);\n}\n\nfunction evalToDecimal(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseFloat(val);\n}\n\nfunction evalToDouble(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseFloat(val);\n}\n\nfunction evalToInt(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseInt(val);\n}\n\nfunction evalToLong(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseInt(val);\n}\n\nfunction evalToString(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (val === null || val === undefined) return null;\n\treturn String(val);\n}\n\n// ============================================================================\n// OBJECT OPERATORS\n// ============================================================================\n\nfunction evalObjectToArray(operand, doc) {\n\tconst obj = evaluateExpression(operand, doc);\n\tif (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n\t\treturn null;\n\t}\n\t\n\treturn Object.keys(obj).map(key => ({ k: key, v: obj[key] }));\n}\n\nfunction evalArrayToObject(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\tif (!Array.isArray(arr)) return null;\n\t\n\tconst result = {};\n\tfor (const item of arr) {\n\t\tif (Array.isArray(item) && item.length === 2) {\n\t\t\tresult[item[0]] = item[1];\n\t\t} else if (typeof item === 'object' && item.k !== undefined && item.v !== undefined) {\n\t\t\tresult[item.k] = item.v;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalMergeObjects(operands, doc) {\n\tif (!Array.isArray(operands)) {\n\t\t// Single object\n\t\treturn evaluateExpression(operands, doc);\n\t}\n\t\n\tconst result = {};\n\tfor (const operand of operands) {\n\t\tconst obj = evaluateExpression(operand, doc);\n\t\tif (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {\n\t\t\tObject.assign(result, obj);\n\t\t}\n\t}\n\treturn result;\n}\n","import { getProp, getFieldValues, isArray, arrayMatches, objectMatches, toArray, isIn, bboxToGeojson } from './utils.js';\nimport { stemmer, tokenize } from 'bjson/textindex';\nimport { ObjectId } from 'bjson';\nimport { evaluateExpression } from './aggregationExpressions.js';\n\n/**\n * BSON type mappings for $type operator\n */\nconst BSON_TYPES = {\n\t1: 'double',\n\t2: 'string',\n\t3: 'object',\n\t4: 'array',\n\t5: 'binData',\n\t6: 'undefined',\n\t7: 'objectId',\n\t8: 'bool',\n\t9: 'date',\n\t10: 'null',\n\t11: 'regex',\n\t13: 'javascript',\n\t15: 'javascriptWithScope',\n\t16: 'int',\n\t17: 'timestamp',\n\t18: 'long',\n\t19: 'decimal',\n\t127: 'maxKey',\n\t'-1': 'minKey'\n};\n\n// Reverse mapping from alias to code\nconst TYPE_ALIASES = Object.entries(BSON_TYPES).reduce((acc, [code, name]) => {\n\tacc[name] = parseInt(code);\n\treturn acc;\n}, {});\n\n/**\n * Check if a value matches a BSON type or type code\n */\nfunction matchesType(value, typeSpec) {\n\t// Handle array of types\n\tif (isArray(typeSpec)) {\n\t\tfor (let i = 0; i < typeSpec.length; i++) {\n\t\t\tif (matchesType(value, typeSpec[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Get type code from spec (can be number or string alias)\n\tconst typeCode = typeof typeSpec === 'number' ? typeSpec : TYPE_ALIASES[typeSpec];\n\tconst typeName = BSON_TYPES[typeCode] || typeSpec;\n\t\n\t// Check value type\n\tif (value === null) return typeName === 'null' || typeCode === 10;\n\tif (value === undefined) return typeName === 'undefined' || typeCode === 6;\n\tif (typeof value === 'number') {\n\t\tif (Number.isInteger(value)) return typeName === 'int' || typeCode === 16;\n\t\treturn typeName === 'double' || typeCode === 1;\n\t}\n\tif (typeof value === 'string') return typeName === 'string' || typeCode === 2;\n\tif (typeof value === 'boolean') return typeName === 'bool' || typeCode === 8;\n\tif (value instanceof Date) return typeName === 'date' || typeCode === 9;\n\tif (value instanceof ObjectId) return typeName === 'objectId' || typeCode === 7;\n\tif (value instanceof RegExp) return typeName === 'regex' || typeCode === 11;\n\tif (isArray(value)) return typeName === 'array' || typeCode === 4;\n\tif (typeof value === 'object') return typeName === 'object' || typeCode === 3;\n\t\n\t// Fallback to simple type check\n\treturn typeof value === typeSpec;\n}\n\n/**\n * Bit query operator helpers\n */\nfunction toBitMask(positions) {\n\tif (isArray(positions)) {\n\t\t// Array of bit positions\n\t\tlet mask = 0;\n\t\tfor (let i = 0; i < positions.length; i++) {\n\t\t\tmask |= (1 << positions[i]);\n\t\t}\n\t\treturn mask;\n\t} else if (typeof positions === 'number') {\n\t\t// Bitmask directly\n\t\treturn positions;\n\t}\n\treturn 0;\n}\n\nfunction matchesBitsAllSet(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) === mask;\n}\n\nfunction matchesBitsAllClear(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) === 0;\n}\n\nfunction matchesBitsAnySet(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) !== 0;\n}\n\nfunction matchesBitsAnyClear(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) !== mask;\n}\n\n/**\n * JSON Schema validator (simplified)\n */\nfunction validateJsonSchema(doc, schema) {\n\t// Basic JSON Schema validation\n\tif (schema.type) {\n\t\tconst docType = isArray(doc) ? 'array' : (doc === null ? 'null' : typeof doc);\n\t\tif (schema.type !== docType) return false;\n\t}\n\t\n\tif (schema.required && isArray(schema.required)) {\n\t\tfor (let i = 0; i < schema.required.length; i++) {\n\t\t\tif (!(schema.required[i] in doc)) return false;\n\t\t}\n\t}\n\t\n\tif (schema.properties) {\n\t\tfor (const key in schema.properties) {\n\t\t\t// When using $jsonSchema as a query operator, properties must exist to match\n\t\t\t// (This is different from standard JSON Schema validation where properties are optional)\n\t\t\tif (!(key in doc)) return false;\n\t\t\t\n\t\t\tconst propSchema = schema.properties[key];\n\t\t\tif (!validateJsonSchema(doc[key], propSchema)) return false;\n\t\t}\n\t}\n\t\n\tif (schema.minimum !== undefined && typeof doc === 'number') {\n\t\tif (doc < schema.minimum) return false;\n\t}\n\t\n\tif (schema.maximum !== undefined && typeof doc === 'number') {\n\t\tif (doc > schema.maximum) return false;\n\t}\n\t\n\tif (schema.minLength !== undefined && typeof doc === 'string') {\n\t\tif (doc.length < schema.minLength) return false;\n\t}\n\t\n\tif (schema.maxLength !== undefined && typeof doc === 'string') {\n\t\tif (doc.length > schema.maxLength) return false;\n\t}\n\t\n\tif (schema.pattern && typeof doc === 'string') {\n\t\tconst regex = new RegExp(schema.pattern);\n\t\tif (!regex.test(doc)) return false;\n\t}\n\t\n\tif (schema.enum && isArray(schema.enum)) {\n\t\tif (!schema.enum.includes(doc)) return false;\n\t}\n\t\n\treturn true;\n}\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId && b instanceof ObjectId) {\n    return a.equals(b);\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Compare two values with a comparison operator, handling ObjectId instances\n */\nfunction compareValues(a, b, operator) {\n\t// Convert ObjectIds to comparable values (use timestamp for ordering)\n\tlet aVal = a;\n\tlet bVal = b;\n\t\n\tif (a instanceof ObjectId) {\n\t\taVal = a.toString();\n\t}\n\tif (b instanceof ObjectId) {\n\t\tbVal = b.toString();\n\t}\n\t\n\tswitch(operator) {\n\t\tcase '>': return aVal > bVal;\n\t\tcase '>=': return aVal >= bVal;\n\t\tcase '<': return aVal < bVal;\n\t\tcase '<=': return aVal <= bVal;\n\t\tdefault: return false;\n\t}\n}\n\n/**\n * Check if a field value (possibly from array traversal) matches a condition\n * Handles both single values and arrays of values (from array traversal)\n */\nfunction fieldValueMatches(fieldValue, checkFn) {\n\t// Use strict equality to allow null values through\n\tif (fieldValue === undefined) return false;\n\t\n\t// Check for null before isArray to avoid crash\n\tif (fieldValue === null) return checkFn(fieldValue);\n\t\n\t// If fieldValue is an array (from array traversal), check if ANY element matches\n\tif (isArray(fieldValue)) {\n\t\tfor (var i = 0; i < fieldValue.length; i++) {\n\t\t\tif (checkFn(fieldValue[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Otherwise check the single value\n\treturn checkFn(fieldValue);\n}\n\n/**\n * Tokenize text for search\n */\nfunction tokenizeText(text) {\n\tif (typeof text !== 'string') return [];\n\n  const words = tokenize(text);\n\treturn words.map(w => stemmer(w));\n}\n\n/**\n * Text search helper\n * Matches if the property contains tokens from the query\n */\nexport function text(prop, queryText) {\n\tif (typeof prop !== 'string') return false;\n\t\n\tconst propTokens = new Set(tokenizeText(prop));\n\tconst queryTokens = tokenizeText(queryText);\n\t\n\t// Match if any query term is in the document\n\treturn queryTokens.some(term => propTokens.has(term));\n}\n\n/**\n * Geo within helper - using bounding box logic instead of de9im\n * This is a simpler implementation that doesn't require de9im dependency\n */\nexport function geoWithin(prop, query) {\n\ttry {\n\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\tif (!Array.isArray(query) || query.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst minLon = query[0][0];\n\t\tconst maxLat = query[0][1];\n\t\tconst maxLon = query[1][0];\n\t\tconst minLat = query[1][1];\n\n\t\t// Check if geometry is within bounding box\n\t\treturn isGeometryWithinBBox(prop, minLon, maxLon, minLat, maxLat);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if a GeoJSON geometry is within a bounding box\n * For Points: checks if the point is within the bbox\n * For Polygons: checks if ALL vertices are within the bbox\n */\nfunction isGeometryWithinBBox(geoJson, minLon, maxLon, minLat, maxLat) {\n\tif (!geoJson) return false;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t// All features must be within the bbox\n\t\tfor (const feature of geoJson.features) {\n\t\t\tif (feature.geometry) {\n\t\t\t\tif (!isGeometryWithinBBox(feature.geometry, minLon, maxLon, minLat, maxLat)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn isGeometryWithinBBox(geoJson.geometry, minLon, maxLon, minLat, maxLat);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn lng >= minLon && lng <= maxLon && lat >= minLat && lat <= maxLat;\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - ALL vertices must be within the bbox\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tfor (const ring of geoJson.coordinates) {\n\t\t\tfor (const coord of ring) {\n\t\t\t\tconst lng = coord[0];\n\t\t\t\tconst lat = coord[1];\n\t\t\t\tif (lng < minLon || lng > maxLon || lat < minLat || lat > maxLat) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Extract coordinates from a GeoJSON object for indexing purposes\n * This uses centroid for polygons to get a single point to index\n * @param {Object} geoJson - The GeoJSON object\n * @returns {Object|null} Object with lat and lng, or null if invalid\n */\nfunction extractCoordinatesFromGeoJSON(geoJson) {\n\tif (!geoJson) return null;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\tconst feature = geoJson.features[0];\n\t\tif (feature.geometry) {\n\t\t\treturn extractCoordinatesFromGeoJSON(feature.geometry);\n\t\t}\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn extractCoordinatesFromGeoJSON(geoJson.geometry);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn { lat, lng };\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - use centroid of first coordinate ring\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tconst ring = geoJson.coordinates[0];\n\t\tif (ring.length > 0) {\n\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\tfor (const coord of ring) {\n\t\t\t\tsumLng += coord[0];\n\t\t\t\tsumLat += coord[1];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\tlng: sumLng / ring.length\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Calculate haversine distance between two points in kilometers\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = \n\t\tMath.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Check if a point is within a certain distance (in meters) of a reference point\n */\nfunction isNear(geoJson, refLng, refLat, maxDistanceMeters) {\n\tconst coords = extractCoordinatesFromGeoJSON(geoJson);\n\tif (!coords) return false;\n\tconst distanceKm = haversineDistance(coords.lat, coords.lng, refLat, refLng);\n\tconst distanceM = distanceKm * 1000;\n\treturn distanceM <= maxDistanceMeters;\n}\n\n/**\n * Check if geometries intersect (simple implementation)\n */\nfunction geoIntersects(geoJson, queryGeo) {\n\tif (!geoJson || !queryGeo) return false;\n\t\n\t// Get coordinates from query geometry\n\tconst queryCoords = extractCoordinatesFromGeoJSON(queryGeo);\n\tif (!queryCoords) return false;\n\t\n\t// Get coordinates from document geometry\n\tconst docCoords = extractCoordinatesFromGeoJSON(geoJson);\n\tif (!docCoords) return false;\n\t\n\t// For now, simple point-in-polygon check for polygons\n\t// If query is a polygon, check if document point is inside\n\tif (queryGeo.type === 'Polygon' && geoJson.type === 'Point') {\n\t\treturn pointInPolygon(docCoords.lng, docCoords.lat, queryGeo.coordinates[0]);\n\t}\n\t\n\t// If document is a polygon and query is a point, check if point is inside\n\tif (geoJson.type === 'Polygon' && queryGeo.type === 'Point') {\n\t\tconst queryPt = queryGeo.coordinates;\n\t\treturn pointInPolygon(queryPt[0], queryPt[1], geoJson.coordinates[0]);\n\t}\n\t\n\t// For points, check if they're the same or very close\n\tif (geoJson.type === 'Point' && queryGeo.type === 'Point') {\n\t\tconst dist = haversineDistance(docCoords.lat, docCoords.lng, queryCoords.lat, queryCoords.lng);\n\t\treturn dist < 0.001; // Within about 1 meter\n\t}\n\t\n\treturn false;\n}\n\n/**\n * Point-in-polygon test using ray casting algorithm\n */\nfunction pointInPolygon(lng, lat, ring) {\n\tlet inside = false;\n\tfor (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n\t\tconst xi = ring[i][0], yi = ring[i][1];\n\t\tconst xj = ring[j][0], yj = ring[j][1];\n\t\tconst intersect = ((yi > lat) !== (yj > lat)) && (lng < (xj - xi) * (lat - yi) / (yj - yi) + xi);\n\t\tif (intersect) inside = !inside;\n\t}\n\treturn inside;\n}\n\n/**\n * $where operator implementation\n * SECURITY NOTE: This uses Function constructor which can execute arbitrary code.\n * This is acceptable for a local/in-memory database but should NOT be used\n * in environments where untrusted user input is processed.\n */\nexport function where(doc, value) {\n\tif (typeof value === 'function') {\n\t\ttry {\n\t\t\treturn value.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t} else if (typeof value === 'string') {\n\t\t// Evaluate the string as a function\n\t\ttry {\n\t\t\tvar fn = new Function('return ' + value);\n\t\t\treturn fn.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Top-level match function\n */\nexport function tlMatches(doc, query) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return and(doc, value);\n\t\telse if (key == \"$or\") return or(doc, value);\n\t\telse if (key == \"$not\") return not(doc, value);\n\t\telse if (key == \"$nor\") return nor(doc, value);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse if (key == \"$comment\") return true; // $comment is metadata, doesn't filter\n\t\telse if (key == \"$jsonSchema\") return validateJsonSchema(doc, value); // Top-level schema validation\n\t\telse if (key == \"$expr\") {\n\t\t\t// Handle $expr at top level\n\t\t\ttry {\n\t\t\t\treturn evaluateExpression(value, doc);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatches(doc, key, value);\n\t}\n}\n\n/**\n * Operator match function\n */\nexport function opMatches(doc, key, value) {\n\t// Get field value using array-aware traversal\n\tvar fieldValue = getFieldValues(doc, key);\n\t\n\tif (typeof (value) == \"string\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"number\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"boolean\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (value instanceof ObjectId) return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return fieldValue != undefined && fieldValueMatches(fieldValue, function(v) { return v && v.match(value); });\n\t\telse if (isArray(value)) return fieldValue != undefined && fieldValueMatches(fieldValue, function(v) { return v && arrayMatches(v, value); });\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = Object.keys(value)[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '>'); })) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '>='); })) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '<'); })) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '<='); })) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return !valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (fieldValueMatches(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$exists\") {\n\t\t\t\t\t\t// For $exists, we need to use getProp which returns undefined if field doesn't exist\n\t\t\t\t\t\t// getFieldValues might return an array which would be truthy\n\t\t\t\t\tvar rawValue = getProp(doc, key);\n\t\t\t\t\tif (operand ? rawValue == undefined : rawValue != undefined) return false;\n\t\t\t\t} else if (operator == \"$type\") {\n\t\t\t\t\t// Support both BSON type codes and aliases\n\t\t\t\t\t// Note: $type checks the field value itself, not array elements\n\t\t\t\t\t// If field doesn't exist (undefined), it can only match type 'undefined' (6)\n\t\t\t\t\tif (fieldValue === undefined) {\n\t\t\t\t\t\tconst expectedTypeCode = typeof operand === 'number' ? operand : TYPE_ALIASES[operand];\n\t\t\t\t\t\tif (expectedTypeCode !== 6) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!matchesType(fieldValue, operand)) return false;\n\t\t\t\t\t}\n\t\t\t\t} else if (operator == \"$mod\") {\n\t\t\t\t\tif (operand.length != 2) throw { $err: \"Can't canonicalize query: BadValue malformed mod, not enough elements\", code: 17287 };\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && (v % operand[0] == operand[1]); })) return false;\n\t\t\t\t} else if (operator == \"$regex\") {\n\t\t\t\t\t// Support string pattern with optional $options\n\t\t\t\t\tvar pattern = operand;\n\t\t\t\t\tvar flags = value.$options || '';\n\t\t\t\t\tvar regex = (typeof pattern === 'string') ? new RegExp(pattern, flags) : pattern;\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && regex.test(v); })) return false;\n\t\t\t\t} else if (operator == \"$options\") {\n\t\t\t\t\t// $options is handled with $regex, skip here\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (operator == \"$text\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && text(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$expr\") {\n\t\t\t\t\t// Evaluate aggregation expression against the document\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = evaluateExpression(operand, doc);\n\t\t\t\t\t\tif (!result) return false;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// If expression evaluation fails, don't match\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (operator == \"$geoWithin\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && geoWithin(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$near\" || operator == \"$nearSphere\") {\n\t\t\t\t\t\t// Handle $near and $nearSphere with distance calculation\n\t\t\t\t\t\tlet coordinates;\n\t\t\t\t\t\tif (operand.$geometry) {\n\t\t\t\t\t\t\tcoordinates = operand.$geometry.coordinates;\n\t\t\t\t\t\t} else if (operand.coordinates) {\n\t\t\t\t\t\t\tcoordinates = operand.coordinates;\n\t\t\t\t\t\t} else if (Array.isArray(operand)) {\n\t\t\t\t\t\t\tcoordinates = operand;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (coordinates && coordinates.length >= 2) {\n\t\t\t\t\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\t\t\t\tconst maxDistanceMeters = operand.$maxDistance || 1000000; // Default to 1000km\n\t\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && isNear(v, lng, lat, maxDistanceMeters); })) return false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$geoIntersects\") {\n\t\t\t\t\t\t// Handle $geoIntersects\n\t\t\t\t\t\tconst geometry = operand.$geometry || operand;\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && geoIntersects(v, geometry); })) return false;\n\t\t\t\t\t} else if (operator == \"$not\") {\n\t\t\t\t\t\tif (opMatches(doc, key, operand)) return false;\n\t\t\t\t\t} else if (operator == \"$all\") {\n\t\t\t\t\t\t// $all requires the field to be an array, use getProp not getFieldValues\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < operand.length; j++) {\n\t\t\t\t\t\t\tif (!isIn(operand[j], arrayFieldValue)) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\t// $elemMatch requires the field to be an array, use getProp not getFieldValues\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor (var j = 0; j < arrayFieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = arrayFieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && !(element == opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && !(element != opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$in\" && !isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$nin\" && isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found) return false;\n\t\t\t\t} else if (operator == \"$size\") {\n\t\t\t\t\tvar sizeFieldValue = getProp(doc, key);\n\t\t\t\t\tif (sizeFieldValue == undefined || !isArray(sizeFieldValue)) return false;\n\t\t\t\t\tif (sizeFieldValue.length != operand) return false;\n\t\t\t\t} else if (operator == \"$bitsAllSet\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAllSet(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAllClear\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAllClear(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAnySet\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAnySet(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAnyClear\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAnyClear(v, operand); })) return false;\n\t\t\t\t} else {\n\t\t\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue unknown operator: \" + operator, code: 17287 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn getProp(doc, key) && objectMatches(getProp(doc, key), value);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * $not operator\n */\nexport function not(doc, value) {\n\treturn !tlMatches(doc, value);\n}\n\n/**\n * $and operator\n */\nexport function and(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatches(doc, els[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * $or operator\n */\nexport function or(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return true;\n\t}\n\treturn false;\n}\n\n/**\n * $nor operator\n */\nexport function nor(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Main matches function - query structure: (top level operators ( \"age\" : (operators) ))\n * top, top level query, implicit $and\n */\nexport function matches(doc, query) {\n\treturn and(doc, toArray(query));\n}\n\n/**\n * Enhanced matching function that also tracks which array index matched for positional operator ($)\n * Returns an object with:\n *   - matched: boolean indicating if the query matched\n *   - arrayFilters: object mapping field paths to the first matched array index\n * \n * Example: if query is { \"grades\": { $gte: 85 } } and doc is { grades: [80, 90, 85] }\n * Returns: { matched: true, arrayFilters: { \"grades\": 1 } } (index 1 is 90, first to match)\n */\nexport function matchWithArrayIndices(doc, query) {\n\tconst arrayFilters = {};\n\tconst matched = andWithTracking(doc, toArray(query), arrayFilters);\n\treturn { matched, arrayFilters };\n}\n\n/**\n * Helper to track array indices during AND matching\n */\nfunction andWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Top level match with tracking\n */\nfunction tlMatchesWithTracking(doc, query, arrayFilters) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return andWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$or\") return orWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$not\") {\n\t\t\t// For $not, we don't track positions as it's a negation\n\t\t\treturn !tlMatches(doc, value);\n\t\t}\n\t\telse if (key == \"$nor\") return norWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse if (key == \"$comment\") return true;\n\t\telse if (key == \"$jsonSchema\") return validateJsonSchema(doc, value);\n\t\telse if (key == \"$expr\") {\n\t\t\ttry {\n\t\t\t\treturn evaluateExpression(value, doc);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatchesWithTracking(doc, key, value, arrayFilters);\n\t}\n}\n\n/**\n * OR operator with tracking - track positions from the first matching clause\n */\nfunction orWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * NOR operator with tracking\n */\nfunction norWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Operator match with array index tracking\n */\nfunction opMatchesWithTracking(doc, key, value, arrayFilters) {\n\t// Get the base field (before any dots)\n\tconst baseField = key.split('.')[0];\n\tconst fieldValue = getFieldValues(doc, key);\n\t\n\t// Helper to track which index matched\n\tconst trackMatchingIndex = (fieldValue, checkFn) => {\n\t\tif (fieldValue === undefined) return false;\n\t\tif (fieldValue === null) return checkFn(fieldValue);\n\t\t\n\t\t// If fieldValue is an array from array traversal\n\t\tif (isArray(fieldValue)) {\n\t\t\t// Check if the base field itself is an array in the document\n\t\t\tconst baseValue = getProp(doc, baseField);\n\t\t\tif (isArray(baseValue)) {\n\t\t\t\t// Find first matching index\n\t\t\t\tfor (var i = 0; i < fieldValue.length; i++) {\n\t\t\t\t\tif (checkFn(fieldValue[i])) {\n\t\t\t\t\t\t// Track this as the matched index for this field\n\t\t\t\t\t\tarrayFilters[key] = i;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Otherwise use regular matching\n\t\treturn fieldValueMatches(fieldValue, checkFn);\n\t};\n\t\n\t// Now perform the actual matching with tracking\n\tif (typeof (value) == \"string\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"number\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"boolean\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (value instanceof ObjectId) return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return v && v.match(value); });\n\t\telse if (isArray(value)) return fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return v && arrayMatches(v, value); });\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\t// Handle operators\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = keys[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '>'); })) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '>='); })) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '<'); })) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '<='); })) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return !valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (trackMatchingIndex(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\t// Special handling for $elemMatch\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < arrayFieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = arrayFieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tarrayFilters[key] = j;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && element != opValue) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && element == opValue) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tarrayFilters[key] = j;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For other operators, use standard matching\n\t\t\t\t\t\tif (!opMatches(doc, key, value)) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// Object equality\n\t\t\t\treturn fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return objectMatches(v, value); });\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n","/**\n * Timestamp class - MongoDB-compatible BSON Timestamp\n * A 64-bit value where the high 32 bits represent seconds since Unix epoch\n * and the low 32 bits represent an incrementing ordinal\n */\nexport class Timestamp {\n  constructor(low, high) {\n    if (arguments.length === 0) {\n      // Generate new timestamp with current time\n      this.low = 0;\n      this.high = Math.floor(Date.now() / 1000);\n    } else if (arguments.length === 1) {\n      // Handle object with low/high properties\n      if (typeof low === 'object' && low !== null) {\n        this.low = low.low || 0;\n        this.high = low.high || 0;\n      } else {\n        // Single argument - use as high (seconds)\n        this.low = 0;\n        this.high = low;\n      }\n    } else {\n      // Two arguments: low (increment) and high (seconds)\n      this.low = low >>> 0; // Ensure unsigned 32-bit integer\n      this.high = high >>> 0; // Ensure unsigned 32-bit integer\n    }\n  }\n\n  /**\n   * Returns the timestamp in a comparable form\n   */\n  valueOf() {\n    return this.high * 0x100000000 + this.low;\n  }\n\n  /**\n   * Returns the timestamp as a string\n   */\n  toString() {\n    return `Timestamp(${this.high}, ${this.low})`;\n  }\n\n  /**\n   * Returns the timestamp as a JSON object\n   */\n  toJSON() {\n    return {\n      $timestamp: {\n        t: this.high,\n        i: this.low\n      }\n    };\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return this.toString();\n  }\n\n  /**\n   * Compares this Timestamp with another for equality\n   */\n  equals(other) {\n    if (!other) return false;\n    \n    if (other instanceof Timestamp) {\n      return this.low === other.low && this.high === other.high;\n    }\n    \n    if (typeof other === 'object' && other.low !== undefined && other.high !== undefined) {\n      return this.low === other.low && this.high === other.high;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get the seconds part of the timestamp\n   */\n  getHighBits() {\n    return this.high;\n  }\n\n  /**\n   * Get the increment part of the timestamp\n   */\n  getLowBits() {\n    return this.low;\n  }\n\n  /**\n   * Returns a Date object representing the timestamp\n   */\n  toDate() {\n    return new Date(this.high * 1000);\n  }\n\n  /**\n   * Creates a Timestamp from a Date object\n   */\n  static fromDate(date) {\n    const seconds = Math.floor(date.getTime() / 1000);\n    return new Timestamp(0, seconds);\n  }\n\n  /**\n   * Creates a Timestamp for the current time\n   */\n  static now() {\n    return new Timestamp();\n  }\n}\n","/**\n * Update operations module\n */\n\nimport { setProp, getProp, isArray } from './utils.js';\nimport { opMatches, matches } from './queryMatcher.js';\nimport { Timestamp } from './Timestamp.js';\n\n/**\n * Extract identifier from a filtered positional operator pattern like $[identifier]\n * Returns null if not a filtered positional operator\n */\nfunction extractFilteredPositionalIdentifier(pathSegment) {\n\tconst match = pathSegment.match(/^\\$\\[([^\\]]+)\\]$/);\n\treturn match ? match[1] : null;\n}\n\n/**\n * Parse a field path and extract filtered positional identifiers\n * Returns an array of path segments with metadata about which are filtered positional operators\n */\nfunction parseFieldPath(fieldPath) {\n\tconst segments = fieldPath.split('.');\n\treturn segments.map(segment => {\n\t\tconst identifier = extractFilteredPositionalIdentifier(segment);\n\t\treturn {\n\t\t\tsegment: segment,\n\t\t\tisFilteredPositional: identifier !== null,\n\t\t\tidentifier: identifier\n\t\t};\n\t});\n}\n\n/**\n * Apply an update operation to array elements matching arrayFilters\n */\nfunction applyToFilteredArrayElements(doc, parsedPath, value, operation, arrayFilters) {\n\t// Navigate through the path and apply updates to matching array elements\n\tfunction traverse(current, pathIndex, filterContext) {\n\t\tif (pathIndex >= parsedPath.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pathInfo = parsedPath[pathIndex];\n\t\tconst isLastSegment = pathIndex === parsedPath.length - 1;\n\n\t\tif (pathInfo.isFilteredPositional) {\n\t\t\t// This is a filtered positional operator like $[elem]\n\t\t\tconst identifier = pathInfo.identifier;\n\t\t\tconst filter = arrayFilters ? arrayFilters.find(f => {\n\t\t\t\t// Find the filter that uses this identifier\n\t\t\t\tconst filterKeys = Object.keys(f);\n\t\t\t\treturn filterKeys.some(key => key.startsWith(identifier + '.') || key === identifier);\n\t\t\t}) : null;\n\n\t\t\t// If arrayFilters is not provided, treat $[identifier] as a literal field name\n\t\t\tif (!arrayFilters) {\n\t\t\t\tif (!current[pathInfo.segment]) {\n\t\t\t\t\t// Create intermediate object/array as needed\n\t\t\t\t\tconst nextPath = parsedPath[pathIndex + 1];\n\t\t\t\t\tif (nextPath && nextPath.isFilteredPositional) {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t\t} else {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isArray(current)) {\n\t\t\t\t// If current is not an array, create it as an object property\n\t\t\t\tif (!current[pathInfo.segment]) {\n\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t}\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t\t} else {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Iterate through array elements and apply to matching ones\n\t\t\tfor (let i = 0; i < current.length; i++) {\n\t\t\t\tconst element = current[i];\n\t\t\t\t\n\t\t\t\t// Check if this element matches the filter\n\t\t\t\tlet shouldUpdate = true;\n\t\t\t\tif (filter) {\n\t\t\t\t\t// Transform filter to check against the element\n\t\t\t\t\t// If filter has identifier.field, check element.field\n\t\t\t\t\t// If filter has just identifier, check element directly\n\t\t\t\t\tlet transformedFilter = {};\n\t\t\t\t\tlet hasDirectMatch = false;\n\t\t\t\t\t\n\t\t\t\t\tObject.keys(filter).forEach(key => {\n\t\t\t\t\t\tif (key.startsWith(identifier + '.')) {\n\t\t\t\t\t\t\t// Replace \"identifier.field\" with just \"field\" for matching against element\n\t\t\t\t\t\t\tconst fieldPath = key.substring(identifier.length + 1);\n\t\t\t\t\t\t\ttransformedFilter[fieldPath] = filter[key];\n\t\t\t\t\t\t} else if (key === identifier) {\n\t\t\t\t\t\t\t// Direct identifier match - the filter condition applies to the element value itself\n\t\t\t\t\t\t\ttransformedFilter = filter[key];\n\t\t\t\t\t\t\thasDirectMatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Check if element matches the filter\n\t\t\t\t\tif (hasDirectMatch) {\n\t\t\t\t\t\t// For primitive values, we need to check against the condition directly\n\t\t\t\t\t\t// Create a wrapper to use the matches function\n\t\t\t\t\t\tconst testDoc = { value: element };\n\t\t\t\t\t\tconst testFilter = { value: transformedFilter };\n\t\t\t\t\t\tshouldUpdate = matches(testDoc, testFilter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For object properties, match against the element as a document\n\t\t\t\t\t\tshouldUpdate = matches(element, transformedFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldUpdate) {\n\t\t\t\t\tif (isLastSegment) {\n\t\t\t\t\t\t// Apply the operation to this array element\n\t\t\t\t\t\tapplyOperationToValue(current, i, value, operation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Continue traversing deeper\n\t\t\t\t\t\tif (element !== null && element !== undefined) {\n\t\t\t\t\t\t\ttraverse(current[i], pathIndex + 1, filterContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Regular path segment\n\t\t\tif (current[pathInfo.segment] === undefined || current[pathInfo.segment] === null) {\n\t\t\t\tif (!isLastSegment) {\n\t\t\t\t\t// Create intermediate object/array\n\t\t\t\t\tconst nextPath = parsedPath[pathIndex + 1];\n\t\t\t\t\tif (nextPath && nextPath.isFilteredPositional) {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isLastSegment) {\n\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t} else {\n\t\t\t\tif (current[pathInfo.segment] !== undefined && current[pathInfo.segment] !== null) {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(doc, 0, {});\n}\n\n/**\n * Apply a specific operation to a value (for use with filtered positional operators)\n */\nfunction applyOperationToValue(container, key, value, operation) {\n\tswitch (operation) {\n\t\tcase '$set':\n\t\t\tcontainer[key] = value;\n\t\t\tbreak;\n\t\tcase '$inc':\n\t\t\tif (container[key] === undefined) container[key] = 0;\n\t\t\tcontainer[key] += value;\n\t\t\tbreak;\n\t\tcase '$mul':\n\t\t\tcontainer[key] = container[key] * value;\n\t\t\tbreak;\n\t\tcase '$min':\n\t\t\tcontainer[key] = Math.min(container[key], value);\n\t\t\tbreak;\n\t\tcase '$max':\n\t\t\tcontainer[key] = Math.max(container[key], value);\n\t\t\tbreak;\n\t\tcase '$unset':\n\t\t\tdelete container[key];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontainer[key] = value;\n\t}\n}\n\n/**\n * Check if a field path contains a filtered positional operator\n */\nfunction hasFilteredPositionalOperator(fieldPath) {\n\treturn /\\$\\[[^\\]]+\\]/.test(fieldPath);\n}\n\n/**\n * Deep equality check for objects\n */\nfunction objectEquals(a, b) {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\t\n\t// Handle arrays\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\tfor (var i = 0; i < a.length; i++) {\n\t\t\tif (!objectEquals(a[i], b[i])) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t// Handle dates\n\tif (a instanceof Date && b instanceof Date) {\n\t\treturn a.getTime() === b.getTime();\n\t}\n\t\n\t// One is array, the other is not\n\tif (Array.isArray(a) !== Array.isArray(b)) return false;\n\t\n\tvar keysA = Object.keys(a);\n\tvar keysB = Object.keys(b);\n\t\n\tif (keysA.length !== keysB.length) return false;\n\t\n\tfor (var i = 0; i < keysA.length; i++) {\n\t\tvar key = keysA[i];\n\t\tif (!keysB.includes(key)) return false;\n\t\tif (!objectEquals(a[key], b[key])) return false;\n\t}\n\t\n\treturn true;\n}\n\n/**\n * Check if a field path contains the $[] positional operator\n */\nfunction hasAllPositional(field) {\n\treturn field.indexOf('$[]') !== -1;\n}\n\n/**\n * Apply an update function to all elements matching $[] operator\n * This is used for operators like $inc, $mul that need to read-modify-write\n */\nfunction applyToAllPositional(doc, field, updateFn) {\n\tvar path = field.split(\".\");\n\tvar current = doc;\n\t\n\t// Navigate to the first $[] operator\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\t\n\t\tif (pathSegment === '$[]') {\n\t\t\t// Current should be an array\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\treturn; // Skip if not an array\n\t\t\t}\n\t\t\t\n\t\t\t// Build the remaining path after this $[]\n\t\t\tvar remainingPath = path.slice(i + 1).join('.');\n\t\t\t\n\t\t\t// Process each array element\n\t\t\tfor (var j = 0; j < current.length; j++) {\n\t\t\t\tif (remainingPath) {\n\t\t\t\t\t// There's more path after $[], recursively apply\n\t\t\t\t\tif (remainingPath.indexOf('$[]') !== -1) {\n\t\t\t\t\t\t// Nested $[] operator\n\t\t\t\t\t\tapplyToAllPositional(current[j], remainingPath, updateFn);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No more $[], apply the update function\n\t\t\t\t\t\tvar currentValue = getProp(current[j], remainingPath);\n\t\t\t\t\t\tvar newValue = updateFn(currentValue);\n\t\t\t\t\t\tsetProp(current[j], remainingPath, newValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// $[] is the last segment, apply to each element directly\n\t\t\t\t\tcurrent[j] = updateFn(current[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Navigate to next level\n\t\tif (current == null || current == undefined) return;\n\t\tcurrent = current[pathSegment];\n\t}\n}\n\n/**\n * Replace $ positional operator in a field path with the matched array index\n * \n * @param {string} fieldPath - The field path potentially containing $\n * @param {object} arrayFilters - Map of field paths to matched array indices\n * @returns {string} The field path with $ replaced by the matched index\n */\nfunction replacePositionalOperator(fieldPath, arrayFilters) {\n\tif (!arrayFilters || !fieldPath.includes('$')) {\n\t\treturn fieldPath;\n\t}\n\t\n\t// Split the path to find the $ placeholder\n\tconst parts = fieldPath.split('.');\n\tconst dollarIndex = parts.indexOf('$');\n\t\n\tif (dollarIndex === -1) {\n\t\treturn fieldPath;\n\t}\n\t\n\t// Build the field path up to the $\n\tconst pathBeforeDollar = parts.slice(0, dollarIndex).join('.');\n\t\n\t// Find the matched index for this field path\n\t// We need to check if we have a match for the field before $\n\tlet matchedIndex = null;\n\t\n\t// Try to find a matching filter by checking various possible field paths\n\t// The query could be on the array itself or a nested field\n\tfor (const filterPath in arrayFilters) {\n\t\t// Check if the filter path matches the beginning of our field path\n\t\tif (filterPath === pathBeforeDollar || filterPath.startsWith(pathBeforeDollar + '.')) {\n\t\t\tmatchedIndex = arrayFilters[filterPath];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// If we found a matched index, replace $ with it\n\tif (matchedIndex !== null && matchedIndex !== undefined) {\n\t\tparts[dollarIndex] = matchedIndex.toString();\n\t\treturn parts.join('.');\n\t}\n\t\n\t// If no matched index found, return original path (update will likely be a no-op)\n\treturn fieldPath;\n}\n\n/**\n * Apply update operators to a document\n * \n * @param {object} updates - The update operators to apply\n * @param {object} doc - The document to update\n * @param {boolean} setOnInsert - Whether to apply $setOnInsert\n * @param {object} arrayFilters - Optional map of field paths to matched array indices for $ operator\n */\nexport function applyUpdates(updates, doc, setOnInsert, positionalMatchInfo, userArrayFilters) {\n\tvar keys = Object.keys(updates);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar value = updates[key];\n\t\tif (key == \"$inc\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$inc', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn (val === undefined ? 0 : val) + amount;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tif (currentValue == undefined) currentValue = 0;\n\t\t\t\t\tsetProp(doc, field, currentValue + amount);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$mul\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$mul', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn val * amount;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tif (currentValue == undefined) currentValue = 0;\n\t\t\t\t\tsetProp(doc, field, currentValue * amount);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$rename\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar newName = replacePositionalOperator(value[fields[j]], positionalMatchInfo);\n\t\t\t\tdoc[newName] = doc[field];\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$setOnInsert\" && setOnInsert) {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tdoc[field] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$set\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, value[fields[j]], '$set', userArrayFilters);\n\t\t\t\t} else {\n\t\t\t\t\tsetProp(doc, field, value[fields[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$unset\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$min\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$min', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn Math.min(val, amount);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tsetProp(doc, field, Math.min(currentValue, amount));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$max\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$max', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn Math.max(val, amount);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tsetProp(doc, field, Math.max(currentValue, amount));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$currentDate\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar typeSpec = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Handle boolean true or { $type: \"date\" }\n\t\t\t\tif (typeSpec === true || (typeof typeSpec === 'object' && typeSpec.$type === 'date')) {\n\t\t\t\t\tsetProp(doc, field, new Date());\n\t\t\t\t}\n\t\t\t\t// Handle { $type: \"timestamp\" }\n\t\t\t\telse if (typeof typeSpec === 'object' && typeSpec.$type === 'timestamp') {\n\t\t\t\t\tsetProp(doc, field, new Timestamp());\n\t\t\t\t}\n\t\t\t\t// Default to Date for backwards compatibility\n\t\t\t\telse {\n\t\t\t\t\tsetProp(doc, field, new Date());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$addToSet\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar addValue = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tcurrentArray.push(addValue);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pop\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar popValue = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tif (popValue == 1) {\n\t\t\t\t\t\tcurrentArray.pop();\n\t\t\t\t\t} else if (popValue == -1) {\n\t\t\t\t\t\tcurrentArray.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pull\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar condition = value[fields[j]];\n\t\t\t\tvar src = getProp(doc, field);\n\t\t\t\t\n\t\t\t\t// Skip if field doesn't exist or is not an array\n\t\t\t\tif (src == undefined || !Array.isArray(src)) continue;\n\t\t\t\t\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar element = src[k];\n\t\t\t\t\tvar shouldRemove = false;\n\t\t\t\t\t\n\t\t\t\t\t// Determine how to match the condition against the element\n\t\t\t\t\tif (typeof condition === 'object' && condition !== null && !Array.isArray(condition)) {\n\t\t\t\t\t\t// Condition is an object (could be a query or a value to match)\n\t\t\t\t\t\tif (typeof element === 'object' && element !== null && !Array.isArray(element)) {\n\t\t\t\t\t\t\t// Element is also an object - use query matching\n\t\t\t\t\t\t\t// This handles both {price: null}, {name: \"test\"}, and {price: {$gte: 10}}\n\t\t\t\t\t\t\tshouldRemove = matches(element, condition);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Element is a primitive but condition is an object with operators like {$gte: 5}\n\t\t\t\t\t\t\tvar tempDoc = { __temp: element };\n\t\t\t\t\t\t\tshouldRemove = opMatches(tempDoc, \"__temp\", condition);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Condition is a simple value (string, number, boolean, null, etc.)\n\t\t\t\t\t\t// Do direct comparison\n\t\t\t\t\t\tshouldRemove = element == condition;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!shouldRemove) notRemoved.push(element);\n\t\t\t\t}\n\t\t\t\tsetProp(doc, field, notRemoved);\n\t\t\t}\n\t\t} else if (key == \"$pullAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar src = getProp(doc, field);\n\t\t\t\tvar toRemove = value[fields[j]];\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar removed = false;\n\t\t\t\t\tfor (var l = 0; l < toRemove.length; l++) {\n\t\t\t\t\t\tif (src[k] == toRemove[l]) {\n\t\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!removed) notRemoved.push(src[k]);\n\t\t\t\t}\n\t\t\t\tsetProp(doc, field, notRemoved);\n\t\t\t}\n\t\t} else if (key == \"$pushAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar values = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tfor (var k = 0; k < values.length; k++) {\n\t\t\t\t\t\tcurrentArray.push(values[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$push\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar pushValue = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this is a modifier-based push\n\t\t\t\tvar isModifierPush = pushValue !== null && typeof pushValue === 'object' && \n\t\t\t\t\t(pushValue.$each !== undefined || pushValue.$position !== undefined || \n\t\t\t\t\t pushValue.$slice !== undefined || pushValue.$sort !== undefined);\n\t\t\t\t\n\t\t\t\tif (isModifierPush) {\n\t\t\t\t\t// Initialize array if it doesn't exist\n\t\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\t\tif (!currentArray) {\n\t\t\t\t\t\tcurrentArray = [];\n\t\t\t\t\t\tsetProp(doc, field, currentArray);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Get the values to push (either from $each or wrap single value)\n\t\t\t\t\tvar valuesToPush = pushValue.$each !== undefined ? pushValue.$each : [pushValue];\n\t\t\t\t\t\n\t\t\t\t\t// Get position (default to end of array)\n\t\t\t\t\tvar position = pushValue.$position !== undefined ? pushValue.$position : currentArray.length;\n\t\t\t\t\t\n\t\t\t\t\t// Handle negative position (from end)\n\t\t\t\t\tif (position < 0) {\n\t\t\t\t\t\tposition = Math.max(0, currentArray.length + position);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Insert values at specified position\n\t\t\t\t\tcurrentArray.splice(position, 0, ...valuesToPush);\n\t\t\t\t\t\n\t\t\t\t\t// Apply $sort if specified\n\t\t\t\t\tif (pushValue.$sort !== undefined) {\n\t\t\t\t\t\tvar sortSpec = pushValue.$sort;\n\t\t\t\t\t\tif (typeof sortSpec === 'number') {\n\t\t\t\t\t\t\t// Simple numeric sort\n\t\t\t\t\t\t\tcurrentArray.sort(function(a, b) {\n\t\t\t\t\t\t\t\tif (a < b) return sortSpec > 0 ? -1 : 1;\n\t\t\t\t\t\t\t\tif (a > b) return sortSpec > 0 ? 1 : -1;\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (typeof sortSpec === 'object') {\n\t\t\t\t\t\t\t// Sort by subdocument fields\n\t\t\t\t\t\t\tcurrentArray.sort(function(a, b) {\n\t\t\t\t\t\t\t\tvar sortKeys = Object.keys(sortSpec);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar sortKey = sortKeys[k];\n\t\t\t\t\t\t\t\t\tvar sortDir = sortSpec[sortKey];\n\t\t\t\t\t\t\t\t\tvar aVal = getProp(a, sortKey);\n\t\t\t\t\t\t\t\t\tvar bVal = getProp(b, sortKey);\n\t\t\t\t\t\t\t\t\tif (aVal < bVal) return sortDir > 0 ? -1 : 1;\n\t\t\t\t\t\t\t\t\tif (aVal > bVal) return sortDir > 0 ? 1 : -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Apply $slice if specified\n\t\t\t\t\tif (pushValue.$slice !== undefined) {\n\t\t\t\t\t\tvar sliceValue = pushValue.$slice;\n\t\t\t\t\t\tif (sliceValue < 0) {\n\t\t\t\t\t\t\t// Keep last N elements\n\t\t\t\t\t\t\tvar sliced = currentArray.slice(sliceValue);\n\t\t\t\t\t\t\tsetProp(doc, field, sliced);\n\t\t\t\t\t\t} else if (sliceValue === 0) {\n\t\t\t\t\t\t\t// Empty the array\n\t\t\t\t\t\t\tsetProp(doc, field, []);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Keep first N elements\n\t\t\t\t\t\t\tvar sliced = currentArray.slice(0, sliceValue);\n\t\t\t\t\t\t\tsetProp(doc, field, sliced);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Simple push (original behavior)\n\t\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\t\tcurrentArray.push(pushValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$bit\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tvar field = replacePositionalOperator(fields[0], positionalMatchInfo);\n\t\t\tvar operation = value[fields[0]];\n\t\t\tvar operator = Object.keys(operation)[0];\n\t\t\tvar operand = operation[operator];\n\t\t\tvar currentValue = getProp(doc, field);\n\t\t\tif (operator == \"and\") {\n\t\t\t\tsetProp(doc, field, currentValue & operand);\n\t\t\t} else if (operator == \"or\") {\n\t\t\t\tsetProp(doc, field, currentValue | operand);\n\t\t\t} else if (operator == \"xor\") {\n\t\t\t\tsetProp(doc, field, currentValue ^ operand);\n\t\t\t} else {\n\t\t\t\tthrow \"unknown $bit operator: \" + operator;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow \"unknown update operator: \" + key;\n\t\t}\n\t}\n}\n\n/**\n * Create a new document from query and update operators for upsert\n */\nexport function createDocFromUpdate(query, updates, idGenerator) {\n\tvar newDoc = { _id: idGenerator() };\n\tvar onlyFields = true;\n\tvar updateKeys = Object.keys(updates);\n\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\tif (updateKeys[i].charAt(0) == \"$\") {\n\t\t\tonlyFields = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (onlyFields) {\n\t\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\t\tnewDoc[updateKeys[i]] = updates[updateKeys[i]];\n\t\t}\n\t} else {\n\t\tvar queryKeys = Object.keys(query);\n\t\tfor (var i = 0; i < queryKeys.length; i++) {\n\t\t\tnewDoc[queryKeys[i]] = query[queryKeys[i]];\n\t\t}\n\t\tapplyUpdates(updates, newDoc, true);\n\t}\n\treturn newDoc;\n}\n","/**\n * Base class for collection indexes\n * Provides a common interface for different types of indexes (e.g., regular, text, geo)\n */\nexport class Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tthis.name = name;\n\t\tthis.keys = keys;\n\t\tthis.storage = storage;\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tthrow new Error('add() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tthrow new Error('remove() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Update a document in the index (remove old, add new)\n\t * @param {Object} oldDoc - The old document\n\t * @param {Object} newDoc - The new document\n\t */\n\tupdate(oldDoc, newDoc) {\n\t\tthis.remove(oldDoc);\n\t\tthis.add(newDoc);\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query to execute\n\t * @returns {Array} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tthrow new Error('query() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthrow new Error('clear() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Get index specification (for getIndexes())\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\tthrow new Error('serialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} data - Serialized index state\n\t */\n\tdeserialize(data) {\n\t\tthrow new Error('deserialize() must be implemented by subclass');\n\t}\n}\n","import { Index } from './Index.js';\nimport { getProp } from './utils.js';\nimport { BPlusTree } from 'bjson/bplustree';\n\n/**\n * Regular index using bjson's persistent BPlusTree with OPFS backing\n * All operations are async\n */\nexport class RegularCollectionIndex extends Index {\n\tconstructor(name, keys, storageFilePath, options = {}) {\n\t\tsuper(name, keys, storageFilePath, options);\n\t\t// Use OPFS-backed B+ tree for persistent index storage\n\t\tthis.data = new BPlusTree(storageFilePath, 50);\n\t\tthis.isOpen = false;\n\t}\n\n\t/**\n\t * Open the index file\n\t * Must be called before using the index\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tawait this.data.open();\n\t\t\tthis.isOpen = true;\n\t\t} catch (error) {\n\t\t\t// If file is corrupted, delete and recreate\n\t\t\tif (error.message && (error.message.includes('Unknown type byte') || \n\t\t\t\t\terror.message.includes('Failed to read metadata') ||\n\t\t\t\t\terror.message.includes('Invalid tree file'))) {\n\t\t\t\t// Try to delete the corrupted file\n\t\t\t\tif (typeof navigator !== 'undefined' && navigator.storage) {\n\t\t\t\t\tconst opfsRoot = await navigator.storage.getDirectory();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait opfsRoot.removeEntry(this.storage);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// File might not exist, ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create fresh BPlusTree\n\t\t\t\tthis.data = new BPlusTree(this.storage, 50);\n\t\t\t\tawait this.data.open();\n\t\t\t\tthis.isOpen = true;\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the index file\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\ttry {\n\t\t\t\tawait this.data.close();\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors from already-closed files\n\t\t\t\tif (!error.message || !error.message.includes('File is not open')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Extract index key value from a document\n\t */\n\textractIndexKey(doc) {\n\t\tconst keyFields = Object.keys(this.keys);\n\t\tif (keyFields.length === 0) return null;\n\n\t\t// For simple single-field index\n\t\tif (keyFields.length === 1) {\n\t\t\tconst field = keyFields[0];\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value === undefined) return null;\n\t\t\t// Preserve type information in the key\n\t\t\treturn value; //JSON.stringify({ t: typeof value, v: value });\n\t\t}\n\n\t\t// For compound index, concatenate values with type preservation\n\t\tconst keyParts = [];\n\t\tfor (let i = 0; i < keyFields.length; i++) {\n\t\t\tconst value = getProp(doc, keyFields[i]);\n\t\t\tif (value === undefined) return null;\n\t\t\tkeyParts.push(value /*JSON.stringify(value) */);\n\t\t}\n\t\t// Use a separator that won't appear in JSON\n\t\treturn keyParts.join('\\x00');\n\t}\n\n\t/**\n\t * Add a document to the index\n   * \n\t * @param {Object} doc - The document to index\n\t */\n\tasync add(doc) {\n\t\tif (!this.isOpen) {\n\t\t\tawait this.open();\n\t\t}\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tconst docId = doc._id.toString();\n\t\t\t// Get existing doc IDs for this key (if any)\n\t\t\tconst existing = await this.data.search(indexKey);\n\t\t\tlet docIds;\n\t\t\tif (Array.isArray(existing)) {\n\t\t\t\t// Avoid duplicates\n\t\t\t\tif (!existing.includes(docId)) {\n\t\t\t\t\tdocIds = [...existing, docId];\n\t\t\t\t} else {\n\t\t\t\t\treturn; // Already indexed\n\t\t\t\t}\n\t\t\t} else if (existing) {\n\t\t\t\t// Single value, convert to array\n\t\t\t\tdocIds = existing === docId ? [existing] : [existing, docId];\n\t\t\t} else {\n\t\t\t\t// No existing value\n\t\t\t\tdocIds = [docId];\n\t\t\t}\n\t\t\tawait this.data.add(indexKey, docIds);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the index\n   * \n\t * @param {Object} doc - The document to remove\n\t */\n\tasync remove(doc) {\n\t\tif (!this.isOpen) {\n\t\t\tawait this.open();\n\t\t}\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tconst docId = doc._id.toString();\n\t\t\tconst existing = await this.data.search(indexKey);\n\t\t\tif (Array.isArray(existing)) {\n\t\t\t\tconst filtered = existing.filter(id => id !== docId);\n\t\t\t\tif (filtered.length > 0) {\n\t\t\t\t\tawait this.data.add(indexKey, filtered);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.data.delete(indexKey);\n\t\t\t\t}\n\t\t\t} else if (existing === docId) {\n\t\t\t\tawait this.data.delete(indexKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the index\n   * \n\t * @param {*} query - The query object\n\t * @returns {Promise<Array|null>} Array of document IDs or null if index cannot satisfy query\n\t */\n\tasync query(query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(this.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst queryValue = query[field];\n\n\t\t// Case 1: Simple equality\n\t\tif (typeof queryValue !== 'object' || queryValue === null) {\n\t\t\tconst indexKey = queryValue;\n\t\t\tconst result = await this.data.search(indexKey);\n\t\t\t// Result might be an array of doc IDs or undefined\n\t\t\treturn result || [];\n\t\t}\n\n\t\t// Case 2: Query with operators\n\t\tif (typeof queryValue === 'object' && !Array.isArray(queryValue)) {\n\t\t\treturn await this._queryWithOperators(field, queryValue);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Query index with comparison operators\n   * \n\t * @private\n\t */\n\tasync _queryWithOperators(field, operators) {\n\t\tconst ops = Object.keys(operators);\n\t\tconst results = new Set();\n\n\t\t// Handle range queries: $gt, $gte, $lt, $lte\n\t\tconst hasRangeOp = ops.some(op => ['$gt', '$gte', '$lt', '$lte'].includes(op));\n\t\t\n\t\tif (hasRangeOp) {\n\t\t\t// Use B+ tree's efficient range search if we have both bounds\n\t\t\tconst hasGt = ops.includes('$gt') || ops.includes('$gte');\n\t\t\tconst hasLt = ops.includes('$lt') || ops.includes('$lte');\n\t\t\t\n\t\t\tif (hasGt && hasLt) {\n\t\t\t\t// Determine min and max bounds\n\t\t\t\tconst minValue = ops.includes('$gte') ? operators['$gte'] : \n\t\t\t\t                ops.includes('$gt') ? operators['$gt'] : -Infinity;\n\t\t\t\tconst maxValue = ops.includes('$lte') ? operators['$lte'] : \n\t\t\t\t                ops.includes('$lt') ? operators['$lt'] : Infinity;\n\t\t\t\t\n\t\t\t\tconst rangeResults = await this.data.rangeSearch(minValue, maxValue);\n\t\t\t\t\n\t\t\t\tfor (const entry of rangeResults) {\n\t\t\t\t\tconst keyValue = entry.key;\n\t\t\t\t\tconst value = entry.value;\n\t\t\t\t\t\n\t\t\t\t\t// Apply exact operator semantics\n\t\t\t\t\tlet matches = true;\n\t\t\t\t\tif (ops.includes('$gt') && !(keyValue > operators['$gt'])) matches = false;\n\t\t\t\t\tif (ops.includes('$gte') && !(keyValue >= operators['$gte'])) matches = false;\n\t\t\t\t\tif (ops.includes('$lt') && !(keyValue < operators['$lt'])) matches = false;\n\t\t\t\t\tif (ops.includes('$lte') && !(keyValue <= operators['$lte'])) matches = false;\n\t\t\t\t\t\n\t\t\t\t\tif (matches && value) {\n\t\t\t\t\t\t// value is an array of document IDs\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tvalue.forEach(id => results.add(id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresults.add(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t} else {\n\t\t\t\t// Scan all entries if we don't have both bounds\n\t\t\t\tconst allEntries = await this.data.toArray();\n\t\t\t\t\n\t\t\t\tfor (const entry of allEntries) {\n\t\t\t\t\tconst keyValue = entry.key;\n\t\t\t\t\tconst value = entry.value;\n\t\t\t\t\t\n\t\t\t\t\t// Check if value matches all operators\n\t\t\t\t\tlet matches = true;\n\t\t\t\t\tfor (const op of ops) {\n\t\t\t\t\t\tconst operand = operators[op];\n\t\t\t\t\t\tif (op === '$gt' && !(keyValue > operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$gte' && !(keyValue >= operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$lt' && !(keyValue < operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$lte' && !(keyValue <= operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$eq' && !(keyValue === operand)) matches = false;\n\t\t\t\t\t\telse if (op === '$ne' && !(keyValue !== operand)) matches = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (matches && value) {\n\t\t\t\t\t\t// value is an array of document IDs\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tvalue.forEach(id => results.add(id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresults.add(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $in operator\n\t\tif (ops.includes('$in')) {\n\t\t\tconst values = operators['$in'];\n\t\t\tif (Array.isArray(values)) {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tconst result = await this.data.search(value);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tif (Array.isArray(result)) {\n\t\t\t\t\t\t\tresult.forEach(id => results.add(id));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresults.add(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $eq operator\n\t\tif (ops.includes('$eq')) {\n\t\t\tconst value = operators['$eq'];\n\t\t\tconst result = await this.data.search(value);\n\t\t\tif (result) {\n\t\t\t\treturn Array.isArray(result) ? result : [result];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\t// Handle $ne operator (requires full scan, not optimal)\n\t\tif (ops.includes('$ne')) {\n\t\t\tconst excludeValue = operators['$ne'];\n\t\t\tconst allEntries = await this.data.toArray();\n\t\t\t\n\t\t\tfor (const entry of allEntries) {\n\t\t\t\tif (entry.key !== excludeValue && entry.value) {\n\t\t\t\t\t// value is an array of document IDs\n\t\t\t\t\tif (Array.isArray(entry.value)) {\n\t\t\t\t\t\tentry.value.forEach(id => results.add(id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresults.add(entry.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Array.from(results);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all entries from the index\n\t */\n\tasync clear() {\n\t\t// For persistent storage, close and recreate the tree\n\t\tif (this.isOpen) {\n\t\t\tawait this.close();\n\t\t}\n\t\t// BPlusTree will be recreated when we open again\n\t\tthis.data = new BPlusTree(this.data.filename, 50);\n\t\tawait this.open();\n\t}\n}\n","import { Index } from './Index.js';\nimport { TextIndex } from 'bjson/textindex';\nimport { getProp } from './utils.js';\n\n/**\n * Text index implementation\n * OPFS-backed async implementation using bjson TextIndex\n */\nexport class TextCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage);\n\t\t// Use OPFS-backed TextIndex for persistent full-text search\n\t\tthis.textIndex = new TextIndex({ baseFilename: storage });\n\t\tthis.isOpen = false;\n\t\t// Track which fields are indexed\n\t\tthis.indexedFields = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\tthis.indexedFields.push(field);\n\t\t\t}\n\t\t}\n\t\tif (this.indexedFields.length === 0) {\n\t\t\tthrow new Error('Text index must have at least one field with type \"text\"');\n\t\t}\n\t}\n\n\t/**\n\t * Open the index files\n\t * Must be called before using the index\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.textIndex.open();\n\t\tthis.isOpen = true;\n\t}\n\n\t/**\n\t * Close the index files\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\ttry {\n\t\t\t\tawait this.textIndex.close();\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors from already-closed files\n\t\t\t\tif (!error.message || !error.message.includes('File is not open')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Extract text content from a document for the indexed fields\n\t * @param {Object} doc - The document\n\t * @returns {string} Combined text from all indexed fields\n\t */\n\t_extractText(doc) {\n\t\tconst textParts = [];\n\t\tfor (const field of this.indexedFields) {\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\ttextParts.push(String(value));\n\t\t\t}\n\t\t}\n\t\treturn textParts.join(' ');\n\t}\n\n\t/**\n\t * Add a document to the text index\n\t * @param {Object} doc - The document to index\n\t */\n\tasync add(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst text = this._extractText(doc);\n\t\tif (text) {\n\t\t\tawait this.textIndex.add(String(doc._id), text);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the text index\n\t * @param {Object} doc - The document to remove\n\t */\n\tasync remove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.textIndex.remove(String(doc._id));\n\t}\n\n\t/**\n\t * Query the text index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a text search\n\t */\n\tquery(query) {\n\t\t// This method is used for query planning\n\t\t// Text queries are handled separately in queryMatcher\n\t\treturn null;\n\t}\n\n\t/**\n\t * Search the text index\n\t * @param {string} searchText - The text to search for\n\t * @param {Object} options - Search options\n\t * @returns {Promise<Array>} Array of document IDs\n\t */\n\tasync search(searchText, options = {}) {\n\t\tconst results = await this.textIndex.query(searchText, { scored: false, ...options });\n\t\treturn results;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tasync clear() {\n\t\t// Recreate the index by closing and reopening\n\t\tif (this.isOpen) {\n\t\t\tawait this.close();\n\t\t}\n\t\tthis.textIndex = new TextIndex({ baseFilename: this.storage });\n\t\tawait this.open();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\ttextIndexVersion: 3,\n\t\t\tweights: this._getWeights()\n\t\t};\n\t}\n\n\t/**\n\t * Get field weights (all default to 1 for now)\n\t */\n\t_getWeights() {\n\t\tconst weights = {};\n\t\tfor (const field of this.indexedFields) {\n\t\t\tweights[field] = 1;\n\t\t}\n\t\treturn weights;\n\t}\n\n}\n","/**\n * On-Disk R-tree implementation using BJsonFile\n * \n * This implementation stores all data in an append-only bjson file:\n * - Nodes are stored as bjson records\n * - Node references use Pointer objects for file offsets\n * - Updates append new versions rather than modifying in place\n * - An in-memory index tracks the latest offset for each node ID\n * \n * File format:\n * - Record 0: Metadata (version, maxEntries, size, rootPointer, nextId)\n * - Records 1+: Node data (id, isLeaf, children, bbox)\n *   - For internal nodes: children are Pointer objects to child nodes\n *   - For leaf nodes: children are data entries with {bbox, lat, lng, data}\n */\n\nimport { BJsonFile, Pointer, encode, decode } from './bjson.js';\n\n/**\n * Calculate distance between two points using Haversine formula\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Convert radius query to bounding box\n */\nfunction radiusToBoundingBox(lat, lng, radiusKm) {\n\tconst latDelta = radiusKm / 111;\n\tconst lngDelta = radiusKm / (111 * Math.cos(lat * Math.PI / 180));\n\t\n\treturn {\n\t\tminLat: lat - latDelta,\n\t\tmaxLat: lat + latDelta,\n\t\tminLng: lng - lngDelta,\n\t\tmaxLng: lng + lngDelta\n\t};\n}\n\n/**\n * Check if two bounding boxes intersect\n */\nfunction intersects(bbox1, bbox2) {\n\treturn !(bbox1.maxLat < bbox2.minLat ||\n\t\tbbox1.minLat > bbox2.maxLat ||\n\t\tbbox1.maxLng < bbox2.minLng ||\n\t\tbbox1.minLng > bbox2.maxLng);\n}\n\n/**\n * Calculate the area of a bounding box\n */\nfunction area(bbox) {\n\treturn (bbox.maxLat - bbox.minLat) * (bbox.maxLng - bbox.minLng);\n}\n\n/**\n * Calculate the bounding box that contains both input boxes\n */\nfunction union(bbox1, bbox2) {\n\treturn {\n\t\tminLat: Math.min(bbox1.minLat, bbox2.minLat),\n\t\tmaxLat: Math.max(bbox1.maxLat, bbox2.maxLat),\n\t\tminLng: Math.min(bbox1.minLng, bbox2.minLng),\n\t\tmaxLng: Math.max(bbox1.maxLng, bbox2.maxLng)\n\t};\n}\n\n/**\n * Calculate the enlargement needed to include bbox2 in bbox1\n */\nfunction enlargement(bbox1, bbox2) {\n\tconst unionBox = union(bbox1, bbox2);\n\treturn area(unionBox) - area(bbox1);\n}\n\n/**\n * R-tree node stored on disk\n */\nclass RTreeNode {\n\tconstructor(rtree, nodeData) {\n\t\tthis.rtree = rtree;\n\t\tthis.id = nodeData.id;\n\t\tthis.isLeaf = nodeData.isLeaf;\n\t\tthis.children = nodeData.children || [];\n\t\tthis.bbox = nodeData.bbox;\n\t}\n\n\t/**\n\t * Update the bounding box to contain all children\n\t */\n\tasync updateBBox() {\n\t\tif (this.children.length === 0) {\n\t\t\tthis.bbox = null;\n\t\t\treturn;\n\t\t}\n\n\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\tlet minLng = Infinity, maxLng = -Infinity;\n\n\t\tfor (const child of this.children) {\n\t\t\tlet bbox;\n\t\t\tif (this.isLeaf) {\n\t\t\t\t// Leaf node: children are data entries\n\t\t\t\tbbox = child.bbox;\n\t\t\t} else {\n\t\t\t\t// Internal node: children are Pointers - need to load child nodes\n\t\t\t\tconst childNode = await this.rtree._loadNode(child);\n\t\t\t\tbbox = childNode.bbox;\n\t\t\t}\n\n\t\t\tif (bbox) {\n\t\t\t\tminLat = Math.min(minLat, bbox.minLat);\n\t\t\t\tmaxLat = Math.max(maxLat, bbox.maxLat);\n\t\t\t\tminLng = Math.min(minLng, bbox.minLng);\n\t\t\t\tmaxLng = Math.max(maxLng, bbox.maxLng);\n\t\t\t}\n\t\t}\n\n\t\tthis.bbox = { minLat, maxLat, minLng, maxLng };\n\t\t\n\t\t// Save updated node to disk\n\t\tawait this.rtree._saveNode(this);\n\t}\n\n\t/**\n\t * Convert node to plain object for serialization\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tisLeaf: this.isLeaf,\n\t\t\tchildren: this.children,\n\t\t\tbbox: this.bbox\n\t\t};\n\t}\n}\n\n/**\n * On-disk R-tree implementation\n */\nexport class RTree {\n\tconstructor(filename, maxEntries = 9) {\n\t\tthis.filename = filename;\n\t\tthis.maxEntries = maxEntries;\n\t\tthis.minEntries = Math.max(2, Math.ceil(maxEntries / 2));\n\t\t\n\t\t// Metadata\n\t\tthis.rootPointer = null;\n\t\tthis.nextId = 1;\n\t\tthis._size = 0;\n\t\t\n\t\t// BJsonFile handle\n\t\tthis.file = new BJsonFile(filename);\n\t\tthis.isOpen = false;\n\t}\n\n\t/**\n\t * Open the R-tree file (create if doesn't exist)\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\tthrow new Error('R-tree file is already open');\n\t\t}\n\n\t\tconst exists = await this.file.exists();\n\t\t\n\t\tif (exists) {\n\t\t\t// Load existing tree\n\t\t\tawait this.file.open('rw');\n\t\t\tawait this._loadFromFile();\n\t\t} else {\n\t\t\t// Create new tree\n\t\t\tawait this.file.open('rw');\n\t\t\tawait this._initializeNewTree();\n\t\t}\n\t\t\n\t\tthis.isOpen = true;\n\t}\n\n\t/**\n\t * Close the R-tree file\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\tawait this._writeMetadata();\n\t\t\tawait this.file.close();\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Initialize a new empty tree\n\t */\n\tasync _initializeNewTree() {\n\t\t// Create root node\n\t\tconst rootNode = new RTreeNode(this, {\n\t\t\tid: 0,\n\t\t\tisLeaf: true,\n\t\t\tchildren: [],\n\t\t\tbbox: null\n\t\t});\n\t\t\n\t\tthis.nextId = 1;\n\t\tthis._size = 0;\n\t\t\n\t\t// Save root node\n\t\tthis.rootPointer = await this._saveNode(rootNode);\n\t\t\n\t\t// Write metadata as first record\n\t\tawait this._writeMetadata();\n\t}\n\n\t/**\n\t * Write metadata record to file\n\t */\n\tasync _writeMetadata() {\n\t\tconst metadata = {\n\t\t\tversion: 1,\n\t\t\tmaxEntries: this.maxEntries,\n\t\t\tminEntries: this.minEntries,\n\t\t\tsize: this._size,\n\t\t\trootPointer: this.rootPointer,\n\t\t\tnextId: this.nextId\n\t\t};\n\t\t\n\t\t// Append metadata to file (don't use write which truncates)\n\t\tawait this.file.append(metadata);\n\t}\n\n\t/**\n\t * Load tree from existing file\n\t */\n\tasync _loadFromFile() {\n\t\t// Calculate fixed metadata size:\n\t\t// Metadata object has 6 fields: version, maxEntries, minEntries, size, rootPointer, nextId\n\t\t// All are INT type encoded as 8-byte ints (1 type byte + 8 bytes payload)\n\t\t// Object encoding: TYPE (1) + SIZE (4) + COUNT (4) + key-value pairs\n\t\t// Total size with 8-byte ints: 135 bytes\n\t\tconst METADATA_SIZE = 135;\n\t\t\n\t\tconst fileSize = await this.file.getFileSize();\n\t\tif (fileSize < METADATA_SIZE) {\n\t\t\tthrow new Error('Invalid R-tree file format: file too small for metadata');\n\t\t}\n\t\t\n\t\t// Read metadata from the end of the file\n\t\tconst metadataOffset = fileSize - METADATA_SIZE;\n\t\tconst metadata = await this.file.read(metadataOffset);\n\t\t\n\t\tthis.maxEntries = metadata.maxEntries;\n\t\tthis.minEntries = metadata.minEntries;\n\t\tthis._size = metadata.size;\n\t\tthis.rootPointer = metadata.rootPointer;\n\t\tthis.nextId = metadata.nextId;\n\t}\n\n\t/**\n\t * Save a node to disk and return its Pointer\n\t */\n\tasync _saveNode(node) {\n\t\tconst nodeData = node.toJSON();\n\t\t\n\t\t// Get current file size (this is where the node will be stored)\n\t\tconst offset = await this.file.getFileSize();\n\t\t\n\t\t// Append node to file\n\t\tawait this.file.append(nodeData);\n\t\t\n\t\t// Return pointer to the saved node\n\t\treturn new Pointer(offset);\n\t}\n\n\t/**\n\t * Load a node from disk by Pointer\n\t */\n\tasync _loadNode(pointer) {\n\t\tif (!(pointer instanceof Pointer)) {\n\t\t\tthrow new Error('Expected Pointer object');\n\t\t}\n\t\t\n\t\tconst offset = pointer.valueOf();\n\t\t\n\t\t// Read the node from file at this offset\n\t\tconst nodeData = await this.file.read(offset);\n\t\t\n\t\treturn new RTreeNode(this, nodeData);\n\t}\n\n\t/**\n\t * Load the root node\n\t */\n\tasync _loadRoot() {\n\t\treturn await this._loadNode(this.rootPointer);\n\t}\n\n\t/**\n\t * Insert a point into the R-tree with an ObjectId\n\t */\n\tasync insert(lat, lng, objectId) {\n\t\tif (!this.isOpen) {\n\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t}\n\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst entry = { bbox, lat, lng, objectId };\n\t\t\n\t\tconst root = await this._loadRoot();\n\t\tconst result = await this._insert(entry, root, 1);\n\t\t\n\t\tif (result.split) {\n\t\t\t// Root was split, create new root\n\t\t\tconst newRoot = new RTreeNode(this, {\n\t\t\t\tid: this.nextId++,\n\t\t\t\tisLeaf: false,\n\t\t\t\tchildren: result.pointers,\n\t\t\t\tbbox: null\n\t\t\t});\n\t\t\t\n\t\t\tawait newRoot.updateBBox();\n\t\t\tthis.rootPointer = await this._saveNode(newRoot);\n\t\t} else {\n\t\t\t// Root was updated but not split, update the pointer\n\t\t\tthis.rootPointer = result.pointer;\n\t\t}\n\t\t\n\t\tthis._size++;\n\t\tawait this._writeMetadata();\n\t}\n\n\t/**\n\t * Internal insert method - returns splitPointers if split occurred, else returns updated node pointer\n\t */\n\tasync _insert(entry, node, level) {\n\t\tif (node.isLeaf) {\n\t\t\tnode.children.push(entry);\n\t\t\tawait node.updateBBox();\n\n\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\tconst [pointer1, pointer2] = await this._split(node);\n\t\t\t\treturn { split: true, pointers: [pointer1, pointer2] };\n\t\t\t}\n\t\t\t\n\t\t\t// Save updated leaf node\n\t\t\tconst pointer = await this._saveNode(node);\n\t\t\treturn { split: false, pointer };\n\t\t} else {\n\t\t\t// Choose subtree\n\t\t\tconst targetPointer = await this._chooseSubtree(entry.bbox, node);\n\t\t\tconst targetNode = await this._loadNode(targetPointer);\n\t\t\tconst result = await this._insert(entry, targetNode, level + 1);\n\n\t\t\tif (result.split) {\n\t\t\t\t// Child was split, find and replace it\n\t\t\t\tlet childIndex = -1;\n\t\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tif (node.children[i].valueOf() === targetPointer.valueOf()) {\n\t\t\t\t\t\tchildIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (childIndex !== -1) {\n\t\t\t\t\t// Replace the old child with both new children\n\t\t\t\t\tnode.children[childIndex] = result.pointers[0];\n\t\t\t\t\tnode.children.push(result.pointers[1]);\n\t\t\t\t} else {\n\t\t\t\t\t// Shouldn't happen, but add both if we can't find\n\t\t\t\t\tnode.children.push(result.pointers[0]);\n\t\t\t\t\tnode.children.push(result.pointers[1]);\n\t\t\t\t}\n\t\t\t\tawait node.updateBBox();\n\n\t\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\t\tconst [pointer1, pointer2] = await this._split(node);\n\t\t\t\t\treturn { split: true, pointers: [pointer1, pointer2] };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Child was not split, but may have been updated with new pointer\n\t\t\t\t// Update the child pointer in this node's children\n\t\t\t\tlet childIndex = -1;\n\t\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\t\tif (node.children[i].valueOf() === targetPointer.valueOf()) {\n\t\t\t\t\t\tchildIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (childIndex !== -1) {\n\t\t\t\t\t// Update child pointer to point to the new version\n\t\t\t\t\tnode.children[childIndex] = result.pointer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update this node's bbox (use the current children pointers)\n\t\t\t\tawait node.updateBBox();\n\t\t\t}\n\t\t\t\n\t\t// Save updated internal node\n\t\tconst pointer = await this._saveNode(node);\n\t\treturn { split: false, pointer };\n    }\n\t}\n\n\t/**\n\t * Choose the best subtree to insert an entry\n\t */\n\tasync _chooseSubtree(bbox, node) {\n\t\tlet minEnlargement = Infinity;\n\t\tlet minArea = Infinity;\n\t\tlet targetPointer = null;\n\n    for (const childPointer of node.children) {\n\t\t\t// Debug: check if we have a Pointer\n\t\t\tif (!(childPointer instanceof Pointer)) {\n\t\t\t\tthrow new Error(`Expected Pointer in _chooseSubtree, got: ${typeof childPointer}`);\n\t\t\t}\n\t\t\t\n\t\t\tconst childNode = await this._loadNode(childPointer);\n\t\t\tconst enl = enlargement(childNode.bbox, bbox);\n\t\t\tconst ar = area(childNode.bbox);\n\n\t\t\tif (enl < minEnlargement || (enl === minEnlargement && ar < minArea)) {\n\t\t\t\tminEnlargement = enl;\n\t\t\t\tminArea = ar;\n\t\t\t\ttargetPointer = childPointer;\n\t\t\t}\n\t\t}\n\n\t\treturn targetPointer;\n\t}\n\n\t/**\n\t * Split an overflowing node\n\t */\n\tasync _split(node) {\n\t\tconst children = node.children;\n\t\tconst isLeaf = node.isLeaf;\n\n\t\t// Find two seeds (most distant entries)\n\t\tlet maxDist = -Infinity;\n\t\tlet seed1Idx = 0, seed2Idx = 1;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tfor (let j = i + 1; j < children.length; j++) {\n\t\t\t\tlet bbox1, bbox2;\n\t\t\t\t\n\t\t\t\tif (isLeaf) {\n\t\t\t\t\tbbox1 = children[i].bbox;\n\t\t\t\t\tbbox2 = children[j].bbox;\n\t\t\t\t} else {\n\t\t\t\t\tconst node1 = await this._loadNode(children[i]);\n\t\t\t\t\tconst node2 = await this._loadNode(children[j]);\n\t\t\t\t\tbbox1 = node1.bbox;\n\t\t\t\t\tbbox2 = node2.bbox;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst dist = area(union(bbox1, bbox2));\n\t\t\t\tif (dist > maxDist) {\n\t\t\t\t\tmaxDist = dist;\n\t\t\t\t\tseed1Idx = i;\n\t\t\t\t\tseed2Idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create two new nodes\n\t\tconst node1 = new RTreeNode(this, {\n\t\t\tid: this.nextId++,\n\t\t\tisLeaf: isLeaf,\n\t\t\tchildren: [children[seed1Idx]],\n\t\t\tbbox: null\n\t\t});\n\n\t\tconst node2 = new RTreeNode(this, {\n\t\t\tid: this.nextId++,\n\t\t\tisLeaf: isLeaf,\n\t\t\tchildren: [children[seed2Idx]],\n\t\t\tbbox: null\n\t\t});\n\n\t\t// Distribute remaining entries\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tif (i === seed1Idx || i === seed2Idx) continue;\n\n\t\t\tconst child = children[i];\n\t\t\t\n\t\t\tlet bbox;\n\t\t\tif (isLeaf) {\n\t\t\t\tbbox = child.bbox;\n\t\t\t} else {\n\t\t\t\tconst childNode = await this._loadNode(child);\n\t\t\t\tbbox = childNode.bbox;\n\t\t\t}\n\t\t\t\n\t\t\tawait node1.updateBBox();\n\t\t\tawait node2.updateBBox();\n\t\t\t\n\t\t\tconst enl1 = node1.bbox ? enlargement(node1.bbox, bbox) : 0;\n\t\t\tconst enl2 = node2.bbox ? enlargement(node2.bbox, bbox) : 0;\n\n\t\t\tif (enl1 < enl2) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (enl2 < enl1) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else {\n\t\t\t\t// Equal enlargement, choose one with fewer children\n\t\t\t\tif (node1.children.length <= node2.children.length) {\n\t\t\t\t\tnode1.children.push(child);\n\t\t\t\t} else {\n\t\t\t\t\tnode2.children.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait node1.updateBBox();\n\t\tawait node2.updateBBox();\n\n\t\t// Save both nodes (don't reuse the original node)\n\t\tconst pointer1 = await this._saveNode(node1);\n\t\tconst pointer2 = await this._saveNode(node2);\n\n\t\t// Return both pointers\n\t\treturn [pointer1, pointer2];\n\t}\n\n\t/**\n\t * Search for points within a bounding box, returning entries with coords\n\t */\n\tasync searchBBox(bbox) {\n\t\tif (!this.isOpen) {\n\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t}\n\n\t\tconst results = [];\n\t\tconst root = await this._loadRoot();\n\t\tawait this._searchBBox(bbox, root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search\n\t */\n\tasync _searchBBox(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\tobjectId: entry.objectId,\n\t\t\t\t\t\tlat: entry.lat,\n\t\t\t\t\t\tlng: entry.lng\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const childPointer of node.children) {\n\t\t\t\tconst childNode = await this._loadNode(childPointer);\n\t\t\t\tawait this._searchBBox(bbox, childNode, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search for points within a radius of a location, returning ObjectIds with distances\n\t */\n\tasync searchRadius(lat, lng, radiusKm) {\n\t\tconst bbox = radiusToBoundingBox(lat, lng, radiusKm);\n\t\tconst root = await this._loadRoot();\n\t\tconst entries = [];\n\t\tawait this._searchBBoxEntries(bbox, root, entries);\n\n\t\tconst results = [];\n\t\tfor (const entry of entries) {\n\t\t\tconst dist = haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\tif (dist <= radiusKm) {\n\t\t\t\tresults.push({\n\t\t\t\t\tobjectId: entry.objectId,\n\t\t\t\t\tlat: entry.lat,\n\t\t\t\t\tlng: entry.lng,\n\t\t\t\t\tdistance: dist\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search that returns full entries (used by radius search)\n\t */\n\tasync _searchBBoxEntries(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const childPointer of node.children) {\n\t\t\t\tconst childNode = await this._loadNode(childPointer);\n\t\t\t\tawait this._searchBBoxEntries(bbox, childNode, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove an entry from the R-tree by ObjectId\n\t */\n\tasync remove(objectId) {\n\t\tif (!this.isOpen) {\n\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t}\n\n\t\tconst root = await this._loadRoot();\n\t\tconst result = await this._remove(objectId, root);\n\n\t\tif (!result.found) {\n\t\t\treturn false; // Entry not found\n\t\t}\n\n\t\tif (result.underflow && result.children) {\n\t\t\t// Root underflowed and has children\n\t\t\tif (result.children.length === 0) {\n\t\t\t\t// Tree is now empty, create new empty root\n\t\t\t\tconst newRoot = new RTreeNode(this, {\n\t\t\t\t\tid: this.nextId++,\n\t\t\t\t\tisLeaf: true,\n\t\t\t\t\tchildren: [],\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tthis.rootPointer = await this._saveNode(newRoot);\n\t\t\t} else if (result.children.length === 1 && !result.isLeaf) {\n\t\t\t\t// Root has only one child and is internal node - make child the new root\n\t\t\t\tthis.rootPointer = result.children[0];\n\t\t\t} else {\n\t\t\t\t// Root underflowed but still has multiple children, save it\n\t\t\t\tconst newRoot = new RTreeNode(this, {\n\t\t\t\t\tid: root.id,\n\t\t\t\t\tisLeaf: result.isLeaf,\n\t\t\t\t\tchildren: result.children,\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tawait newRoot.updateBBox();\n\t\t\t\tthis.rootPointer = await this._saveNode(newRoot);\n\t\t\t}\n\t\t} else if (result.pointer) {\n\t\t\t// Root was updated\n\t\t\tthis.rootPointer = result.pointer;\n\t\t}\n\n\t\tthis._size--;\n\t\tawait this._writeMetadata();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Internal remove method\n\t * Returns: { found: boolean, underflow: boolean, pointer: Pointer, children: Array, isLeaf: boolean }\n\t */\n\tasync _remove(objectId, node) {\n\t\tif (node.isLeaf) {\n\t\t\t// Find and remove the entry\n\t\t\tconst initialLength = node.children.length;\n\t\t\tnode.children = node.children.filter(entry => \n\t\t\t\t!entry.objectId.equals(objectId)\n\t\t\t);\n\n\t\t\tif (node.children.length === initialLength) {\n\t\t\t\t// Entry not found\n\t\t\t\treturn { found: false };\n\t\t\t}\n\n\t\t\tawait node.updateBBox();\n\t\t\tconst pointer = await this._saveNode(node);\n\n\t\t\t// Check for underflow\n\t\t\tconst underflow = node.children.length < this.minEntries && node.children.length > 0;\n\t\t\t\n\t\t\treturn {\n\t\t\t\tfound: true,\n\t\t\t\tunderflow,\n\t\t\t\tpointer,\n\t\t\t\tchildren: node.children,\n\t\t\t\tisLeaf: true\n\t\t\t};\n\t\t} else {\n\t\t\t// Internal node - search children\n\t\t\tlet found = false;\n\t\t\tlet updatedChildren = [...node.children];\n\n\t\t\tfor (let i = 0; i < updatedChildren.length; i++) {\n\t\t\t\tconst childPointer = updatedChildren[i];\n\t\t\t\tconst childNode = await this._loadNode(childPointer);\n\n\t\t\t\t// Check if the child's bbox could contain the entry\n\t\t\t\t// For internal nodes, we need to check all children since we don't store exact coordinates\n\t\t\t\tconst result = await this._remove(objectId, childNode);\n\n\t\t\t\tif (result.found) {\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\tif (result.underflow) {\n\t\t\t\t\t\t// Child underflowed, try to handle it\n\t\t\t\t\t\tconst handled = await this._handleUnderflow(node, i, childNode, result);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (handled.merged) {\n\t\t\t\t\t\t\t// Node was merged or redistributed, update children array\n\t\t\t\t\t\t\tupdatedChildren = handled.children;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Just update the pointer\n\t\t\t\t\t\t\tupdatedChildren[i] = result.pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Update child pointer\n\t\t\t\t\t\tupdatedChildren[i] = result.pointer;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update this node\n\t\t\t\t\tconst updatedNode = new RTreeNode(this, {\n\t\t\t\t\t\tid: node.id,\n\t\t\t\t\t\tisLeaf: false,\n\t\t\t\t\t\tchildren: updatedChildren,\n\t\t\t\t\t\tbbox: null\n\t\t\t\t\t});\n\t\t\t\t\tawait updatedNode.updateBBox();\n\t\t\t\t\tconst pointer = await this._saveNode(updatedNode);\n\n\t\t\t\t\t// Check if this node now underflows\n\t\t\t\t\tconst underflow = updatedChildren.length < this.minEntries && updatedChildren.length > 0;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfound: true,\n\t\t\t\t\t\tunderflow,\n\t\t\t\t\t\tpointer,\n\t\t\t\t\t\tchildren: updatedChildren,\n\t\t\t\t\t\tisLeaf: false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Entry not found in any child\n\t\t\treturn { found: false };\n\t\t}\n\t}\n\n\t/**\n\t * Handle underflow in a child node by merging or redistributing\n\t */\n\tasync _handleUnderflow(parentNode, childIndex, childNode, childResult) {\n\t\tconst siblings = [];\n\n\t\t// Find siblings (nodes before and after)\n\t\tif (childIndex > 0) {\n\t\t\tconst prevPointer = parentNode.children[childIndex - 1];\n\t\t\tconst prevNode = await this._loadNode(prevPointer);\n\t\t\tsiblings.push({ index: childIndex - 1, node: prevNode, pointer: prevPointer });\n\t\t}\n\t\tif (childIndex < parentNode.children.length - 1) {\n\t\t\tconst nextPointer = parentNode.children[childIndex + 1];\n\t\t\tconst nextNode = await this._loadNode(nextPointer);\n\t\t\tsiblings.push({ index: childIndex + 1, node: nextNode, pointer: nextPointer });\n\t\t}\n\n\t\t// Try to borrow from a sibling\n\t\tfor (const sibling of siblings) {\n\t\t\tif (sibling.node.children.length > this.minEntries) {\n\t\t\t\t// Sibling has extra entries, redistribute\n\t\t\t\tconst allChildren = [\n\t\t\t\t\t...childResult.children,\n\t\t\t\t\t...sibling.node.children\n\t\t\t\t];\n\n\t\t\t\tconst mid = Math.ceil(allChildren.length / 2);\n\t\t\t\tconst newChild1Children = allChildren.slice(0, mid);\n\t\t\t\tconst newChild2Children = allChildren.slice(mid);\n\n\t\t\t\tconst newChild1 = new RTreeNode(this, {\n\t\t\t\t\tid: childNode.id,\n\t\t\t\t\tisLeaf: childResult.isLeaf,\n\t\t\t\t\tchildren: newChild1Children,\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tawait newChild1.updateBBox();\n\n\t\t\t\tconst newChild2 = new RTreeNode(this, {\n\t\t\t\t\tid: sibling.node.id,\n\t\t\t\t\tisLeaf: sibling.node.isLeaf,\n\t\t\t\t\tchildren: newChild2Children,\n\t\t\t\t\tbbox: null\n\t\t\t\t});\n\t\t\t\tawait newChild2.updateBBox();\n\n\t\t\t\tconst pointer1 = await this._saveNode(newChild1);\n\t\t\t\tconst pointer2 = await this._saveNode(newChild2);\n\n\t\t\t\t// Update parent's children\n\t\t\t\tconst newChildren = [...parentNode.children];\n\t\t\t\tconst minIndex = Math.min(childIndex, sibling.index);\n\t\t\t\tconst maxIndex = Math.max(childIndex, sibling.index);\n\t\t\t\t\n\t\t\t\tnewChildren[minIndex] = pointer1;\n\t\t\t\tnewChildren[maxIndex] = pointer2;\n\n\t\t\t\treturn { merged: true, children: newChildren };\n\t\t\t}\n\t\t}\n\n\t\t// Can't borrow, merge with a sibling\n\t\tif (siblings.length > 0) {\n\t\t\tconst sibling = siblings[0];\n\t\t\tconst mergedChildren = [\n\t\t\t\t...childResult.children,\n\t\t\t\t...sibling.node.children\n\t\t\t];\n\n\t\t\tconst mergedNode = new RTreeNode(this, {\n\t\t\t\tid: this.nextId++,\n\t\t\t\tisLeaf: childResult.isLeaf,\n\t\t\t\tchildren: mergedChildren,\n\t\t\t\tbbox: null\n\t\t\t});\n\t\t\tawait mergedNode.updateBBox();\n\t\t\tconst mergedPointer = await this._saveNode(mergedNode);\n\n\t\t\t// Update parent's children - remove both old nodes, add merged\n\t\t\tconst newChildren = parentNode.children.filter((_, i) => \n\t\t\t\ti !== childIndex && i !== sibling.index\n\t\t\t);\n\t\t\tnewChildren.push(mergedPointer);\n\n\t\t\treturn { merged: true, children: newChildren };\n\t\t}\n\n\t\t// No siblings (shouldn't happen except for root)\n\t\treturn { merged: false };\n\t}\n\n\t/**\n\t * Get the number of entries in the tree\n\t */\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Clear all entries from the tree\n\t */\n\tasync clear() {\n\t\tawait this.close();\n\t\t\n\t\t// Delete and recreate file\n\t\tconst tempFile = new BJsonFile(this.filename);\n\t\tawait tempFile.open('rw');\n\t\tawait tempFile.delete();\n\t\t\n\t\t// Reinitialize\n\t\tthis.file = new BJsonFile(this.filename);\n\t\tawait this.open();\n\t}\n\n\t\t/**\n\t\t * Compact the R-tree by copying the current root and all reachable nodes into a new file.\n\t\t * Returns size metrics to show reclaimed space.\n\t\t * @param {string} destinationFilename\n\t\t */\n\t\tasync compact(destinationFilename) {\n\t\t\tif (!this.isOpen) {\n\t\t\t\tthrow new Error('R-tree file must be opened before use');\n\t\t\t}\n\t\t\tif (!destinationFilename) {\n\t\t\t\tthrow new Error('Destination filename is required for compaction');\n\t\t\t}\n\n\t\t\t// Flush current metadata so size reflects latest state\n\t\t\tawait this._writeMetadata();\n\t\t\tconst oldSize = await this.file.getFileSize();\n\n\t\t\tconst dest = new RTree(destinationFilename, this.maxEntries);\n\t\t\tdest.minEntries = this.minEntries;\n\t\t\tdest.nextId = this.nextId;\n\t\t\tdest._size = this._size;\n\n\t\t\tawait dest.file.open('rw');\n\t\t\tdest.isOpen = true;\n\n\t\t\tconst pointerMap = new Map();\n\n\t\t\tconst cloneNode = async (pointer) => {\n\t\t\t\tconst offset = pointer.valueOf();\n\t\t\t\tif (pointerMap.has(offset)) {\n\t\t\t\t\treturn pointerMap.get(offset);\n\t\t\t\t}\n\n\t\t\t\tconst sourceNode = await this._loadNode(pointer);\n\t\t\t\tconst clonedChildren = [];\n\n\t\t\t\tif (sourceNode.isLeaf) {\n\t\t\t\t\t// Leaf children are plain entries\n\t\t\t\t\tfor (const child of sourceNode.children) {\n\t\t\t\t\t\tclonedChildren.push(child);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (const childPointer of sourceNode.children) {\n\t\t\t\t\t\tconst newChildPtr = await cloneNode(childPointer);\n\t\t\t\t\t\tclonedChildren.push(newChildPtr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst clonedNode = new RTreeNode(dest, {\n\t\t\t\t\tid: sourceNode.id,\n\t\t\t\t\tisLeaf: sourceNode.isLeaf,\n\t\t\t\t\tchildren: clonedChildren,\n\t\t\t\t\tbbox: sourceNode.bbox\n\t\t\t\t});\n\n\t\t\t\tconst newPointer = await dest._saveNode(clonedNode);\n\t\t\t\tpointerMap.set(offset, newPointer);\n\t\t\t\treturn newPointer;\n\t\t\t};\n\n\t\t\tconst newRootPointer = await cloneNode(this.rootPointer);\n\t\t\tdest.rootPointer = newRootPointer;\n\n\t\t\tawait dest._writeMetadata();\n\t\t\tawait dest.file.close();\n\t\t\tdest.isOpen = false;\n\n\t\t\tconst tempFile = new BJsonFile(destinationFilename);\n\t\t\tawait tempFile.open('r');\n\t\t\tconst newSize = await tempFile.getFileSize();\n\t\t\tawait tempFile.close();\n\n\t\t\treturn {\n\t\t\t\toldSize,\n\t\t\t\tnewSize,\n\t\t\t\tbytesSaved: Math.max(0, oldSize - newSize),\n\t\t\t\tnewFilename: destinationFilename\n\t\t\t};\n\t\t}\n}\n\nexport default RTree;\n","import { Index } from './Index.js';\nimport { RTree } from 'bjson/rtree';\nimport { getProp } from './utils.js';\nimport { ObjectId } from 'bjson';\n\n/**\n * Geospatial index implementation\n * OPFS-backed async implementation using bjson RTree\n */\nexport class GeospatialCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage, options);\n\t\t// Use OPFS-backed RTree for geospatial indexing\n\t\tthis.rtree = new RTree(storage, 9);\n\t\tthis.isOpen = false;\n\t\tthis._idMap = new Map(); // docId string -> ObjectId\n\t\tthis._objectIdMap = new Map(); // ObjectId string -> original docId\n\t\t// Track which field is the geospatial field\n\t\tthis.geoField = null;\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\tthis.geoField = field;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!this.geoField) {\n\t\t\tthrow new Error('Geospatial index must have at least one field with type \"2dsphere\" or \"2d\"');\n\t\t}\n\t}\n\n\n\t/**\n\t * Normalize a value so it can be stored in the RTree and compared via equals()\n\t * @param {*} id - Document identifier\n\t * @returns {*} ObjectId-compatible value with equals()/toString()\n\t */\n\t_normalizeObjectId(id) {\n\t\tif (id instanceof ObjectId) {\n\t\t\tthis._objectIdMap.set(id.toString(), id.toString());\n\t\t\treturn id;\n\t\t}\n\n\t\tconst key = String(id);\n\n\t\tif (this._idMap.has(key)) {\n\t\t\treturn this._idMap.get(key);\n\t\t}\n\n\t\tlet objectId;\n\t\ttry {\n\t\t\tif (typeof id === 'string' && ObjectId.isValid(id)) {\n\t\t\t\tobjectId = new ObjectId(id);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Fall through to deterministic generation\n\t\t}\n\n\t\tif (!objectId) {\n\t\t\tobjectId = this._createDeterministicObjectId(key);\n\t\t}\n\n\t\tthis._idMap.set(key, objectId);\n\t\tthis._objectIdMap.set(objectId.toString(), key);\n\t\treturn objectId;\n\t}\n\n\t_toDocId(id) {\n\t\tif (id instanceof ObjectId) {\n\t\t\tconst mapped = this._objectIdMap.get(id.toString());\n\t\t\treturn mapped !== undefined ? mapped : id.toString();\n\t\t}\n\t\tif (id && typeof id === 'object' && 'objectId' in id) {\n\t\t\treturn this._toDocId(id.objectId);\n\t\t}\n\t\treturn String(id);\n\t}\n\n\t_createDeterministicObjectId(key) {\n\t\tlet hash = 0x811c9dc5;\n\t\tfor (let i = 0; i < key.length; i++) {\n\t\t\thash ^= key.charCodeAt(i);\n\t\t\thash = Math.imul(hash, 0x01000193);\n\t\t}\n\t\tconst hex = (hash >>> 0).toString(16).padStart(8, '0');\n\t\tconst idHex = (hex + hex + hex).slice(0, 24);\n\t\treturn new ObjectId(idHex);\n\t}\n\n\t/**\n\t * Open the index file\n\t * Must be called before using the index\n\t */\n\tasync open() {\n\t\tif (this.isOpen) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.rtree.open();\n\t\tthis.isOpen = true;\n\t}\n\n\t/**\n\t * Close the index file\n\t */\n\tasync close() {\n\t\tif (this.isOpen) {\n\t\t\ttry {\n\t\t\t\tawait this.rtree.close();\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore errors from already-closed files\n\t\t\t\tif (!error.message || !error.message.includes('File is not open')) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.isOpen = false;\n\t\t}\n\t}\n\n\t/**\n\t * Extract coordinates from a GeoJSON object\n\t * @param {Object} geoJson - The GeoJSON object\n\t * @returns {Object|null} Object with lat and lng, or null if invalid\n\t */\n\t_extractCoordinates(geoJson) {\n\t\tif (!geoJson) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t\tconst feature = geoJson.features[0];\n\t\t\tif (feature.geometry) {\n\t\t\t\treturn this._extractCoordinates(feature.geometry);\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\t\treturn this._extractCoordinates(geoJson.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\t\tconst [lng, lat] = geoJson.coordinates;\n\t\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Polygon - use centroid of first coordinate\n\t\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\t\tconst ring = geoJson.coordinates[0];\n\t\t\tif (ring.length > 0) {\n\t\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tsumLng += coord[0];\n\t\t\t\t\tsumLat += coord[1];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\t\tlng: sumLng / ring.length\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add a document to the geospatial index\n\t * @param {Object} doc - The document to index\n\t */\n\tasync add(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\t// RTree.insert expects (lat, lng, objectId)\n\t\t\tconst objectId = this._normalizeObjectId(doc._id);\n\t\t\tawait this.rtree.insert(coords.lat, coords.lng, objectId);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the geospatial index\n\t * @param {Object} doc - The document to remove\n\t */\n\tasync remove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\t// RTree.remove expects just the ObjectId (or compatible value)\n\t\tconst objectId = this._normalizeObjectId(doc._id);\n\t\tawait this.rtree.remove(objectId);\n\t}\n\n\t/**\n\t * Query the geospatial index\n\t * @param {*} query - The query object\n\t * @returns {Promise<Array|null>} Array of document IDs or null if query is not a geospatial query\n\t */\n\tasync query(query) {\n\t\t// Check if this is a geospatial query on our indexed field\n\t\tif (!query[this.geoField]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geoQuery = query[this.geoField];\n\n\t\t// Handle $geoWithin with bounding box\n\t\tif (geoQuery.$geoWithin) {\n\t\t\tconst bbox = geoQuery.$geoWithin;\n\t\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\t\tif (Array.isArray(bbox) && bbox.length === 2) {\n\t\t\t\tconst minLon = bbox[0][0];\n\t\t\t\tconst maxLat = bbox[0][1];\n\t\t\t\tconst maxLon = bbox[1][0];\n\t\t\t\tconst minLat = bbox[1][1];\n\n\t\t\t\tconst results = await this.rtree.searchBBox({\n\t\t\t\t\tminLat: minLat,\n\t\t\t\t\tmaxLat: maxLat,\n\t\t\t\t\tminLng: minLon,\n\t\t\t\t\tmaxLng: maxLon\n\t\t\t\t});\n\n\t\t\t\t// searchBBox returns entries with coords\n\t\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t\t}\n\t\t}\n\n\t\t// Handle $near with radius\n\t\tif (geoQuery.$near) {\n\t\t\tconst nearQuery = geoQuery.$near;\n\t\t\t\n\t\t\t// Extract geometry from $geometry or use direct coordinates\n\t\t\tlet coordinates;\n\t\t\tif (nearQuery.$geometry) {\n\t\t\t\tcoordinates = nearQuery.$geometry.coordinates;\n\t\t\t} else if (nearQuery.coordinates) {\n\t\t\t\tcoordinates = nearQuery.coordinates;\n\t\t\t} else if (Array.isArray(nearQuery)) {\n\t\t\t\tcoordinates = nearQuery;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\n\t\t\t// $maxDistance in meters (default to 1000km if not specified)\n\t\t\tconst maxDistanceMeters = nearQuery.$maxDistance || 1000000;\n\t\t\tconst maxDistanceKm = maxDistanceMeters / 1000;\n\n\t\t\t// Use rtree.searchRadius to find points within distance\n\t\t\t// Returns array of { objectId, lat, lng, distance }\n\t\t\tconst results = await this.rtree.searchRadius(lat, lng, maxDistanceKm);\n\n\t\t\t// Sort by distance (ascending)\n\t\t\tresults.sort((a, b) => a.distance - b.distance);\n\n\t\t\t// Return just the document IDs\n\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t}\n\n\t\t// Handle $nearSphere with radius (uses spherical distance, same as $near)\n\t\tif (geoQuery.$nearSphere) {\n\t\t\tconst nearQuery = geoQuery.$nearSphere;\n\t\t\t\n\t\t\t// Extract geometry from $geometry or use direct coordinates\n\t\t\tlet coordinates;\n\t\t\tif (nearQuery.$geometry) {\n\t\t\t\tcoordinates = nearQuery.$geometry.coordinates;\n\t\t\t} else if (nearQuery.coordinates) {\n\t\t\t\tcoordinates = nearQuery.coordinates;\n\t\t\t} else if (Array.isArray(nearQuery)) {\n\t\t\t\tcoordinates = nearQuery;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\n\t\t\t// $maxDistance in meters (default to 1000km if not specified)\n\t\t\tconst maxDistanceMeters = nearQuery.$maxDistance || 1000000;\n\t\t\tconst maxDistanceKm = maxDistanceMeters / 1000;\n\n\t\t\t// Use rtree.searchRadius to find points within distance (already uses Haversine)\n\t\t\t// Returns array of { objectId, lat, lng, distance }\n\t\t\tconst results = await this.rtree.searchRadius(lat, lng, maxDistanceKm);\n\n\t\t\t// Sort by distance (ascending)\n\t\t\tresults.sort((a, b) => a.distance - b.distance);\n\n\t\t\t// Return just the document IDs\n\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t}\n\n\t\t// Handle $geoIntersects\n\t\tif (geoQuery.$geoIntersects) {\n\t\t\tconst intersectsQuery = geoQuery.$geoIntersects;\n\t\t\t\n\t\t\t// Extract geometry\n\t\t\tlet geometry;\n\t\t\tif (intersectsQuery.$geometry) {\n\t\t\t\tgeometry = intersectsQuery.$geometry;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!geometry || !geometry.type) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// For now, support Point and Polygon geometries\n\t\t\tif (geometry.type === 'Point') {\n\t\t\t\tconst [lng, lat] = geometry.coordinates;\n\t\t\t\t\n\t\t\t\t// Search for points at this exact location\n\t\t\t\t// Use a very small bounding box\n\t\t\t\tconst epsilon = 0.0001; // ~11 meters\n\t\t\t\tconst results = await this.rtree.searchBBox({\n\t\t\t\t\tminLat: lat - epsilon,\n\t\t\t\t\tmaxLat: lat + epsilon,\n\t\t\t\t\tminLng: lng - epsilon,\n\t\t\t\t\tmaxLng: lng + epsilon\n\t\t\t\t});\n\n\t\t\t\t// searchBBox returns entries with coords\n\t\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t\t} else if (geometry.type === 'Polygon') {\n\t\t\t\tconst coordinates = geometry.coordinates;\n\t\t\t\tif (!coordinates || coordinates.length === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Get the exterior ring\n\t\t\t\tconst ring = coordinates[0];\n\t\t\t\tif (!ring || ring.length < 3) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Calculate bounding box of the polygon\n\t\t\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\t\t\tlet minLng = Infinity, maxLng = -Infinity;\n\t\t\t\t\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tconst [lng, lat] = coord;\n\t\t\t\t\tminLat = Math.min(minLat, lat);\n\t\t\t\t\tmaxLat = Math.max(maxLat, lat);\n\t\t\t\t\tminLng = Math.min(minLng, lng);\n\t\t\t\t\tmaxLng = Math.max(maxLng, lng);\n\t\t\t\t}\n\n\t\t\t\t// Search for points within the bounding box\n\t\t\t\tconst candidates = await this.rtree.searchBBox({\n\t\t\t\t\tminLat,\n\t\t\t\t\tmaxLat,\n\t\t\t\t\tminLng,\n\t\t\t\t\tmaxLng\n\t\t\t\t});\n\n\t\t\t\t// Filter by actual point-in-polygon test using returned coordinates\n\t\t\t\tconst results = candidates.filter(entry => this._pointInPolygon(entry.lat, entry.lng, ring));\n\n\t\t\t\treturn results.map(entry => this._toDocId(entry.objectId));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Calculate distance between two points using Haversine formula\n\t * @param {number} lat1 - Latitude of first point\n\t * @param {number} lng1 - Longitude of first point\n\t * @param {number} lat2 - Latitude of second point\n\t * @param {number} lng2 - Longitude of second point\n\t * @returns {number} Distance in kilometers\n\t */\n\t_haversineDistance(lat1, lng1, lat2, lng2) {\n\t\tconst R = 6371; // Earth's radius in kilometers\n\t\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\t\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\t\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\treturn R * c;\n\t}\n\n\t/**\n\t * Test if a point is inside a polygon using ray casting algorithm\n\t * @param {number} lat - Point latitude\n\t * @param {number} lng - Point longitude\n\t * @param {Array} ring - Polygon ring as array of [lng, lat] coordinates\n\t * @returns {boolean} True if point is inside polygon\n\t */\n\t_pointInPolygon(lat, lng, ring) {\n\t\tlet inside = false;\n\t\t\n\t\tfor (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n\t\t\tconst [xi, yi] = ring[i];\n\t\t\tconst [xj, yj] = ring[j];\n\t\t\t\n\t\t\tconst intersect = ((yi > lat) !== (yj > lat)) &&\n\t\t\t\t(lng < (xj - xi) * (lat - yi) / (yj - yi) + xi);\n\t\t\t\n\t\t\tif (intersect) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inside;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tasync clear() {\n\t\tif (!this.isOpen) {\n\t\t\tawait this.rtree.open();\n\t\t\tthis.isOpen = true;\n\t\t}\n\t\t// Delete existing on-disk tree to avoid stale entries\n\t\ttry {\n\t\t\tawait this.rtree.file.delete();\n\t\t} catch (err) {\n\t\t\t// Ignore if file doesn't exist; rethrow other errors\n\t\t\tif (!err || err.name !== 'NotFoundError') {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\tthis.isOpen = false;\n\t\t// Recreate the RTree\n\t\tthis.rtree = new RTree(this.rtree.filename, 9);\n\t\tawait this.open();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\t'2dsphereIndexVersion': 3\n\t\t};\n\t}\n\n}\n","import { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\n\n/**\n * Query execution plan\n */\nclass QueryPlan {\n\tconstructor() {\n\t\tthis.type = 'full_scan'; // 'full_scan', 'index_scan', 'index_intersection', 'index_union'\n\t\tthis.indexes = []; // Indexes to use\n\t\tthis.indexScans = []; // Array of { indexName, docIds }\n\t\tthis.estimatedCost = Infinity;\n\t\tthis.indexOnly = false; // If true, only use index results (no full scan fallback)\n\t}\n}\n\n/**\n * Query planner - analyzes queries and generates optimal execution plans\n */\nexport class QueryPlanner {\n\tconstructor(indexes) {\n\t\tthis.indexes = indexes; // Map<string, CollectionIndex>\n\t}\n\n\t/**\n\t * Generate an execution plan for a query\n\t * @param {Object} query - MongoDB query object\n\t * @returns {QueryPlan} Execution plan\n\t */\n\tplan(query) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Empty query - full scan\n\t\tif (!query || Object.keys(query).length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Analyze query structure\n\t\tconst analysis = this._analyzeQuery(query);\n\n\t\t// Check for text search\n\t\tif (analysis.hasTextSearch) {\n\t\t\tconst textPlan = this._planTextSearch(query, analysis);\n\t\t\tif (textPlan) {\n\t\t\t\treturn textPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for geospatial query\n\t\tif (analysis.hasGeoQuery) {\n\t\t\tconst geoPlan = this._planGeoQuery(query, analysis);\n\t\t\tif (geoPlan) {\n\t\t\t\treturn geoPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $and queries - can use index intersection\n\t\tif (analysis.type === 'and') {\n\t\t\tconst andPlan = this._planAndQuery(query, analysis);\n\t\t\tif (andPlan.type !== 'full_scan') {\n\t\t\t\treturn andPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $or queries - can use index union\n\t\tif (analysis.type === 'or') {\n\t\t\tconst orPlan = this._planOrQuery(query, analysis);\n\t\t\tif (orPlan.type !== 'full_scan') {\n\t\t\t\treturn orPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Try to find a single index for simple queries\n\t\tconst simplePlan = this._planSimpleQuery(query);\n\t\tif (simplePlan.type !== 'full_scan') {\n\t\t\treturn simplePlan;\n\t\t}\n\n\t\t// Fall back to full scan\n\t\treturn plan;\n\t}\n\n\t/**\n\t * Analyze query structure\n\t * @private\n\t */\n\t_analyzeQuery(query) {\n\t\tconst analysis = {\n\t\t\ttype: 'simple', // 'simple', 'and', 'or', 'complex'\n\t\t\tfields: [],\n\t\t\toperators: {},\n\t\t\thasTextSearch: false,\n\t\t\thasGeoQuery: false,\n\t\t\tconditions: []\n\t\t};\n\n\t\tconst keys = Object.keys(query);\n\n\t\t// Check for top-level logical operators\n\t\tif (keys.length === 1) {\n\t\t\tconst key = keys[0];\n\t\t\tif (key === '$and') {\n\t\t\t\tanalysis.type = 'and';\n\t\t\t\tanalysis.conditions = query.$and;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t} else if (key === '$or') {\n\t\t\t\tanalysis.type = 'or';\n\t\t\t\tanalysis.conditions = query.$or;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t}\n\t\t}\n\n\t\t// Analyze simple field conditions\n\t\tfor (const field of keys) {\n\t\t\tif (field.startsWith('$')) {\n\t\t\t\tcontinue; // Skip top-level operators we don't handle yet\n\t\t\t}\n\n\t\t\tanalysis.fields.push(field);\n\t\t\tconst value = query[field];\n\n\t\t\t// Check for operators\n\t\t\tif (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n\t\t\t\tconst ops = Object.keys(value);\n\t\t\t\tanalysis.operators[field] = ops;\n\n\t\t\t\t// Check for text search\n\t\t\t\tif (ops.includes('$text')) {\n\t\t\t\t\tanalysis.hasTextSearch = true;\n\t\t\t\t}\n\n\t\t\t\t// Check for geospatial operators\n\t\t\t\tif (ops.some(op => ['$geoWithin', '$geoIntersects', '$near', '$nearSphere'].includes(op))) {\n\t\t\t\t\tanalysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If multiple fields, it's an implicit $and\n\t\tif (keys.length > 1) {\n\t\t\tanalysis.type = 'and';\n\t\t}\n\n\t\treturn analysis;\n\t}\n\n\t/**\n\t * Plan for text search queries\n\t * @private\n\t */\n\t_planTextSearch(query, analysis) {\n\t\t// Find text index\n\t\tfor (const [indexName,index] of this.indexes) {\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Look for $text operator in query\n\t\t\t\tconst textQuery = this._extractTextQuery(query);\n\t\t\t\tif (textQuery) {\n\t\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\t\tplan.type = 'index_scan';\n\t\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\t\tplan.indexScans = [{ indexName, index, textQuery }];\n\t\t\t\t\tplan.estimatedCost = 100; // Rough estimate without executing\n\t\t\t\t\tplan.indexOnly = true; // Text search must use index\n\t\t\t\t\treturn plan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extract $text query from query object\n\t * @private\n\t */\n\t_extractTextQuery(query) {\n\t\tfor (const field in query) {\n\t\t\tconst value = query[field];\n\t\t\tif (typeof value === 'object' && value !== null && value.$text) {\n\t\t\t\treturn typeof value.$text === 'string' ? value.$text : value.$text.$search;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for geospatial queries\n\t * @private\n\t */\n\t_planGeoQuery(query, analysis) {\n\t\t// Find geospatial index\n\t\tfor (const [indexName,index] of this.indexes) {\n\t\t\tif (index instanceof GeospatialCollectionIndex) {\n\t\t\t\t// Check if this index can handle the query (don't execute yet)\n\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\tplan.indexScans = [{ indexName, index, query }];\n\t\t\t\tplan.estimatedCost = 100; // Rough estimate without executing\n\t\t\t\tplan.indexOnly = true; // Geospatial queries must use index\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for $and queries (index intersection)\n\t * @private\n\t */\n\t_planAndQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Extract conditions\n\t\tlet conditions;\n\t\tif (query.$and) {\n\t\t\tconditions = query.$and;\n\t\t} else {\n\t\t\t// Implicit AND - convert to array of conditions\n\t\t\tconditions = Object.keys(query).map(field => ({ [field]: query[field] }));\n\t\t}\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have multiple indexable conditions, use index intersection\n\t\tif (indexableConditions.length > 1) {\n\t\t\tplan.type = 'index_intersection';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost (rough estimate without executing)\n\t\t\tplan.estimatedCost = 50; // Intersection typically reduces result set\n\t\t\treturn plan;\n\t\t}\n\n\t\t// If we have one indexable condition, use it\n\t\tif (indexableConditions.length === 1) {\n\t\t\tplan.type = 'index_scan';\n\t\t\tplan.indexScans = [indexableConditions[0]];\n\t\t\tplan.indexes = [indexableConditions[0].indexName];\n\t\t\tplan.estimatedCost = 50; // Rough estimate without executing\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for $or queries (index union)\n\t * @private\n\t */\n\t_planOrQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\tif (!query.$or) {\n\t\t\treturn plan;\n\t\t}\n\n\t\tconst conditions = query.$or;\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have at least one indexable condition, use index union\n\t\tif (indexableConditions.length > 0) {\n\t\t\tplan.type = 'index_union';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost (rough estimate without executing)\n\t\t\tplan.estimatedCost = 100 * indexableConditions.length; // Union typically increases result set\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for simple single-field queries\n\t * @private\n\t */\n\t_planSimpleQuery(query) {\n\t\tconst plan = new QueryPlan();\n\t\tconst queryKeys = Object.keys(query);\n\n\t\tif (queryKeys.length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Try each index\n\t\tfor (const [indexName,index] of this.indexes) {\n\n\t\t\t// Skip special index types (they have their own planning)\n\t\t\tif (index instanceof TextCollectionIndex || index instanceof GeospatialCollectionIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if this index CAN handle the query (don't execute yet)\n\t\t\tif (this._canIndexHandleQuery(index, query)) {\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\tplan.indexScans = [{ indexName, index, query }];\n\t\t\t\tplan.estimatedCost = 50; // Rough estimate without executing\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Execute a single index scan that was deferred from planning\n\t * @private\n\t */\n\tasync _executeIndexScan(scan) {\n\t\tconst { index, query, textQuery } = scan;\n\t\t\n\t\t// Handle text search\n\t\tif (textQuery !== undefined) {\n\t\t\treturn await index.search(textQuery);\n\t\t}\n\t\t\n\t\t// Handle regular index query\n\t\tif (query !== undefined) {\n\t\t\tconst docIds = await index.query(query);\n\t\t\treturn docIds !== null ? docIds : [];\n\t\t}\n\t\t\n\t\t// Fallback: if docIds were already computed (backward compatibility)\n\t\tif (scan.docIds !== undefined) {\n\t\t\treturn scan.docIds;\n\t\t}\n\t\t\n\t\treturn [];\n\t}\n\n\t/**\n\t * Check if an index can handle a query (without executing it)\n\t * @private\n\t */\n\t_canIndexHandleQuery(index, query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(index.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Execute a query plan and return document IDs\n\t * @param {QueryPlan} plan - The execution plan\n\t * @returns {Promise<Array|null>} Array of document IDs or null for full scan\n\t */\n\tasync execute(plan) {\n\t\tif (plan.type === 'full_scan') {\n\t\t\treturn null; // Signals cursor to do full scan\n\t\t}\n\n\t\tif (plan.type === 'index_scan') {\n\t\t\t// Execute the query now\n\t\t\tconst scan = plan.indexScans[0];\n\t\t\treturn await this._executeIndexScan(scan);\n\t\t}\n\n\t\tif (plan.type === 'index_intersection') {\n\t\t\t// Intersection: docs must be in ALL index results\n\t\t\tif (plan.indexScans.length === 0) return null;\n\t\t\t\n\t\t\t// Execute all scans\n\t\t\tconst results = [];\n\t\t\tfor (const scan of plan.indexScans) {\n\t\t\t\tresults.push({\n\t\t\t\t\tdocIds: await this._executeIndexScan(scan),\n\t\t\t\t\tindexName: scan.indexName\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// Start with the smallest set for efficiency\n\t\t\tconst sorted = results.slice().sort((a, b) => a.docIds.length - b.docIds.length);\n\t\t\tlet result = new Set(sorted[0].docIds);\n\t\t\t\n\t\t\t// Intersect with each subsequent set\n\t\t\tfor (let i = 1; i < sorted.length; i++) {\n\t\t\t\tconst currentSet = new Set(sorted[i].docIds);\n\t\t\t\tresult = new Set([...result].filter(id => currentSet.has(id)));\n\t\t\t\t\n\t\t\t\t// Early exit if intersection becomes empty\n\t\t\t\tif (result.size === 0) break;\n\t\t\t}\n\t\t\t\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\tif (plan.type === 'index_union') {\n\t\t\t// Union: docs in ANY index result\n\t\t\tconst result = new Set();\n\t\t\tfor (const scan of plan.indexScans) {\n\t\t\t\tconst docIds = await this._executeIndexScan(scan);\n\t\t\t\tdocIds.forEach(id => result.add(id));\n\t\t\t}\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","import { EventEmitter } from 'events';\nimport { matches } from './queryMatcher.js';\n\n/**\n * ChangeStream watches for changes in collections and emits change events\n * Compatible with MongoDB Change Streams API\n */\nexport class ChangeStream extends EventEmitter {\n\tconstructor(target, pipeline = [], options = {}) {\n\t\tsuper();\n\t\t\n\t\tthis.target = target; // MongoClient, DB, or Collection\n\t\tthis.pipeline = pipeline;\n\t\tthis.options = options;\n\t\tthis.closed = false;\n\t\tthis._listeners = new Map();\n\t\tthis._changeCounter = 0;\n\t\t\n\t\t// Start watching immediately (synchronously)\n\t\tthis._startWatching();\n\t}\n\n\t/**\n\t * Start watching for changes\n\t * @private\n\t */\n\t_startWatching() {\n\t\tif (this.closed) return;\n\t\t\n\t\tconst collections = this._getCollectionsToWatch();\n\t\t\n\t\tfor (const collection of collections) {\n\t\t\tthis._watchCollection(collection);\n\t\t}\n\t\t\n\t\t// For DB watching, we also need to intercept new collection creation\n\t\tif (this.target.constructor.name === 'DB') {\n\t\t\tthis._interceptDBCollectionCreation();\n\t\t}\n\t\t\n\t\t// For MongoClient watching, intercept db() calls\n\t\tif (this.target.constructor.name === 'MongoClient') {\n\t\t\tthis._interceptClientDBCreation();\n\t\t}\n\t}\n\n\t/**\n\t * Get collections to watch based on target type\n\t * @private\n\t */\n\t_getCollectionsToWatch() {\n\t\tconst collections = [];\n\t\t\n\t\t// MongoClient - watch all collections in all databases\n\t\tif (this.target.constructor.name === 'MongoClient') {\n\t\t\t// Store reference to monitor for new databases/collections\n\t\t\tthis._monitorClient();\n\t\t\treturn collections;\n\t\t}\n\t\t\n\t\t// DB - watch all collections in the database\n\t\tif (this.target.constructor.name === 'DB') {\n\t\t\tconst collectionNames = this.target.getCollectionNames();\n\t\t\tfor (const name of collectionNames) {\n\t\t\t\tconst collection = this.target[name];\n\t\t\t\tif (collection && collection.isCollection) {\n\t\t\t\t\tcollections.push(collection);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Also monitor for new collections\n\t\t\tthis._monitorDB();\n\t\t}\n\t\t\n\t\t// Collection - watch specific collection\n\t\tif (this.target.isCollection) {\n\t\t\tcollections.push(this.target);\n\t\t}\n\t\t\n\t\treturn collections;\n\t}\n\n\t/**\n\t * Watch a specific collection for changes\n\t * @private\n\t */\n\t_watchCollection(collection) {\n\t\tif (this.closed) return;\n\t\tif (!collection) return; // Skip null/undefined\n\t\tif (typeof collection.on !== 'function') return; // Skip non-EventEmitters\n\t\tif (!collection.isCollection) return; // Skip non-collections\n\t\tif (this._listeners.has(collection)) return; // Already watching\n\t\t\n\t\tconst handlers = {\n\t\t\tinsert: (doc) => this._emitChange('insert', collection, doc),\n\t\t\tupdate: (doc, updateDescription) => this._emitChange('update', collection, doc, updateDescription),\n\t\t\treplace: (doc) => this._emitChange('replace', collection, doc),\n\t\t\tdelete: (doc) => this._emitChange('delete', collection, doc)\n\t\t};\n\t\t\n\t\t// Store handlers for cleanup\n\t\tthis._listeners.set(collection, handlers);\n\t\t\n\t\t// Listen to collection change events\n\t\tcollection.on('insert', handlers.insert);\n\t\tcollection.on('update', handlers.update);\n\t\tcollection.on('replace', handlers.replace);\n\t\tcollection.on('delete', handlers.delete);\n\t}\n\n\t/**\n\t * Emit a change event\n\t * @private\n\t */\n\t_emitChange(operationType, collection, doc, updateDescription = null) {\n\t\tif (this.closed) return;\n\t\t\n\t\tconst changeEvent = this._createChangeEvent(\n\t\t\toperationType,\n\t\t\tcollection,\n\t\t\tdoc,\n\t\t\tupdateDescription\n\t\t);\n\t\t\n\t\t// Apply pipeline filters if any\n\t\tif (!this._matchesPipeline(changeEvent)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.emit('change', changeEvent);\n\t}\n\n\t/**\n\t * Create a MongoDB-compatible change event document\n\t * @private\n\t */\n\t_createChangeEvent(operationType, collection, doc, updateDescription) {\n\t\tconst event = {\n\t\t\t_id: {\n\t\t\t\t_data: Buffer.from(String(++this._changeCounter)).toString('base64')\n\t\t\t},\n\t\t\toperationType,\n\t\t\tclusterTime: new Date(),\n\t\t\tns: {\n\t\t\t\tdb: collection.db.dbName,\n\t\t\t\tcoll: collection.name\n\t\t\t},\n\t\t\tdocumentKey: {\n\t\t\t\t_id: doc._id\n\t\t\t}\n\t\t};\n\t\t\n\t\tswitch (operationType) {\n\t\t\tcase 'insert':\n\t\t\t\tevent.fullDocument = doc;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'update':\n\t\t\t\tevent.updateDescription = updateDescription || {\n\t\t\t\t\tupdatedFields: {},\n\t\t\t\t\tremovedFields: [],\n\t\t\t\t\ttruncatedArrays: []\n\t\t\t\t};\n\t\t\t\t// Include full document if requested\n\t\t\t\tif (this.options.fullDocument === 'updateLookup') {\n\t\t\t\t\tevent.fullDocument = doc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'replace':\n\t\t\t\tevent.fullDocument = doc;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'delete':\n\t\t\t\t// For delete, doc contains the deleted document's _id\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn event;\n\t}\n\n\t/**\n\t * Check if change event matches pipeline filters\n\t * @private\n\t */\n\t_matchesPipeline(changeEvent) {\n\t\tif (!this.pipeline || this.pipeline.length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// Process pipeline stages\n\t\tfor (const stage of this.pipeline) {\n\t\t\tif (stage.$match) {\n\t\t\t\t// Use the same query matcher as find()\n\t\t\t\t// Note: matches(document, query) - document first, query second\n\t\t\t\tif (!matches(changeEvent, stage.$match)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get nested value from object using dot notation\n\t * @private\n\t */\n\t_getNestedValue(obj, path) {\n\t\treturn path.split('.').reduce((current, part) => current?.[part], obj);\n\t}\n\n\t/**\n\t * Monitor client for new databases/collections (simplified)\n\t * @private\n\t */\n\t_monitorClient() {\n\t\t// Handled by _interceptClientDBCreation\n\t}\n\n\t/**\n\t * Intercept DB creation on a MongoClient\n\t * @private\n\t */\n\t_interceptClientDBCreation() {\n\t\tconst client = this.target;\n\t\tconst originalDb = client.db.bind(client);\n\t\tconst self = this;\n\t\t\n\t\t// Track databases we're watching\n\t\tthis._watchedDBs = new Map();\n\t\t\n\t\t// Override db() method to watch new databases\n\t\tclient.db = function(name, opts) {\n\t\t\tconst database = originalDb(name, opts);\n\t\t\tconst dbName = database.dbName;\n\t\t\t\n\t\t\t// Only set up watch once per database\n\t\t\tif (!self._watchedDBs.has(dbName)) {\n\t\t\t\tself._watchedDBs.set(dbName, database);\n\t\t\t\t\n\t\t\t\t// Watch existing collections in this database\n\t\t\t\tconst collectionNames = database.getCollectionNames();\n\t\t\t\tfor (const colName of collectionNames) {\n\t\t\t\t\tconst col = database[colName];\n\t\t\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\t\t\tself._watchCollection(col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Intercept new collection creation on this database\n\t\t\t\tself._interceptDBCollectionCreationForClient(database);\n\t\t\t}\n\t\t\t\n\t\t\treturn database;\n\t\t};\n\t\t\n\t\t// Store original for cleanup\n\t\tthis._originalClientMethods = { db: originalDb };\n\t}\n\n\t/**\n\t * Intercept collection creation for a database in client watch mode\n\t * @private\n\t */\n\t_interceptDBCollectionCreationForClient(db) {\n\t\tconst originalCollection = db.collection.bind(db);\n\t\tconst originalCreateCollection = db.createCollection.bind(db);\n\t\tconst self = this;\n\t\t\n\t\tdb.collection = function(name) {\n\t\t\tconst col = originalCollection(name);\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t\treturn col;\n\t\t};\n\t\t\n\t\tdb.createCollection = function(name) {\n\t\t\toriginalCreateCollection(name);\n\t\t\tconst col = db[name];\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Monitor database for new collections\n\t * @private\n\t */\n\t_monitorDB() {\n\t\t// Handled by _interceptDBCollectionCreation\n\t}\n\n\t/**\n\t * Intercept new collection creation on a DB\n\t * @private\n\t */\n\t_interceptDBCollectionCreation() {\n\t\tconst db = this.target;\n\t\tconst originalCollection = db.collection.bind(db);\n\t\tconst originalCreateCollection = db.createCollection.bind(db);\n\t\tconst self = this;\n\t\t\n\t\t// Override collection() method to watch new collections\n\t\tdb.collection = function(name) {\n\t\t\tconst col = originalCollection(name);\n\t\t\t// Watch this collection if we haven't already\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t\treturn col;\n\t\t};\n\t\t\n\t\t// Override createCollection() method\n\t\tdb.createCollection = function(name) {\n\t\t\toriginalCreateCollection(name);\n\t\t\tconst col = db[name];\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Store originals for cleanup\n\t\tthis._originalDBMethods = { collection: originalCollection, createCollection: originalCreateCollection };\n\t}\n\n\t/**\n\t * Close the change stream\n\t */\n\tclose() {\n\t\tif (this.closed) return;\n\t\t\n\t\tthis.closed = true;\n\t\t\n\t\t// Remove all collection listeners\n\t\tfor (const [collection, handlers] of this._listeners) {\n\t\t\tcollection.off('insert', handlers.insert);\n\t\t\tcollection.off('update', handlers.update);\n\t\t\tcollection.off('replace', handlers.replace);\n\t\t\tcollection.off('delete', handlers.delete);\n\t\t}\n\t\t\n\t\tthis._listeners.clear();\n\t\t\n\t\t// Restore original DB methods if we intercepted them\n\t\tif (this._originalDBMethods && this.target.constructor.name === 'DB') {\n\t\t\tthis.target.collection = this._originalDBMethods.collection;\n\t\t\tthis.target.createCollection = this._originalDBMethods.createCollection;\n\t\t}\n\t\t\n\t\t// Restore original MongoClient methods if we intercepted them\n\t\tif (this._originalClientMethods && this.target.constructor.name === 'MongoClient') {\n\t\t\tthis.target.db = this._originalClientMethods.db;\n\t\t}\n\t\t\n\t\t// Emit close before removing all listeners\n\t\tthis.emit('close');\n\t\tthis.removeAllListeners();\n\t}\n\n\t/**\n\t * Check if the stream is closed\n\t */\n\tget isClosed() {\n\t\treturn this.closed;\n\t}\n\n\t/**\n\t * Async iterator support for for-await-of loops\n\t */\n\tasync *[Symbol.asyncIterator]() {\n\t\tconst queue = [];\n\t\tlet resolveNext = null;\n\t\tlet streamClosed = false;\n\t\t\n\t\tconst onChange = (change) => {\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext({ value: change, done: false });\n\t\t\t\tresolveNext = null;\n\t\t\t} else {\n\t\t\t\tqueue.push(change);\n\t\t\t}\n\t\t};\n\t\t\n\t\tconst onClose = () => {\n\t\t\tstreamClosed = true;\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext({ done: true });\n\t\t\t\tresolveNext = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tconst onError = (error) => {\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext(Promise.reject(error));\n\t\t\t\tresolveNext = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tthis.on('change', onChange);\n\t\tthis.on('close', onClose);\n\t\tthis.on('error', onError);\n\t\t\n\t\ttry {\n\t\t\twhile (!streamClosed) {\n\t\t\t\tif (queue.length > 0) {\n\t\t\t\t\tyield queue.shift();\n\t\t\t\t} else {\n\t\t\t\t\tconst next = await new Promise((resolve) => {\n\t\t\t\t\t\tresolveNext = resolve;\n\t\t\t\t\t\t// Check if stream was closed while waiting\n\t\t\t\t\t\tif (streamClosed) {\n\t\t\t\t\t\t\tresolve({ done: true });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif (next.done) break;\n\t\t\t\t\tyield next.value;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.off('change', onChange);\n\t\t\tthis.off('close', onClose);\n\t\t\tthis.off('error', onError);\n\t\t}\n\t}\n\n\t/**\n\t * Get next change (for compatibility)\n\t */\n\tasync next() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst onChange = (change) => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(change);\n\t\t\t};\n\t\t\t\n\t\t\tconst onClose = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(null);\n\t\t\t};\n\t\t\t\n\t\t\tconst onError = (error) => {\n\t\t\t\tcleanup();\n\t\t\t\treject(error);\n\t\t\t};\n\t\t\t\n\t\t\tconst cleanup = () => {\n\t\t\t\tthis.off('change', onChange);\n\t\t\t\tthis.off('close', onClose);\n\t\t\t\tthis.off('error', onError);\n\t\t\t};\n\t\t\t\n\t\t\tif (this.closed) {\n\t\t\t\tresolve(null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis.once('change', onChange);\n\t\t\tthis.once('close', onClose);\n\t\t\tthis.once('error', onError);\n\t\t});\n\t}\n}\n","import { EventEmitter } from 'events';\nimport { Cursor } from './Cursor.js';\nimport { SortedCursor } from './SortedCursor.js';\nimport { isArray, getProp, applyProjection, copy } from './utils.js';\nimport { matches, matchWithArrayIndices } from './queryMatcher.js';\nimport { applyUpdates, createDocFromUpdate } from './updates.js';\nimport { RegularCollectionIndex } from './RegularCollectionIndex.js';\nimport { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\nimport { QueryPlanner } from './QueryPlanner.js';\nimport { evaluateExpression } from './aggregationExpressions.js';\nimport { ChangeStream } from './ChangeStream.js';\nimport { \n\tNotImplementedError, \n\tQueryError, \n\tBadValueError, \n\tIndexError, \n\tIndexNotFoundError,\n\tErrorCodes \n} from './errors.js';\n\n/**\n * Collection class\n */\nexport class Collection extends EventEmitter {\n\tconstructor(db, name, storage, idGenerator) {\n\t\tsuper();\n\t\tthis.db = db;\n\t\tthis.name = name;\n\t\tthis.storage = storage;\n\t\tthis.idGenerator = idGenerator;\n\t\tthis.indexes = new Map(); // Index storage - map of index name to index structure\n\t\tthis.queryPlanner = new QueryPlanner(this.indexes); // Query planner\n\t\tthis.isCollection = true; // TODO used by dropDatabase, ugly\n\n\t\t// Indexes are loaded async via createIndex/openIndexes\n\t\t// No synchronous index loading in OPFS-only mode\n\t\tthis._restoreIndexesFromStorage();\n\t}\n\n\t_restoreIndexesFromStorage() {\n\t\tif (!this.storage || !this.storage.indexes || typeof this.storage.indexes[Symbol.iterator] !== 'function') {\n\t\t\treturn;\n\t\t}\n\t\tfor (const [indexName, indexStore] of this.storage.indexes) {\n\t\t\tconst meta = indexStore && typeof indexStore.getAllMeta === 'function' ? indexStore.getAllMeta() : null;\n\t\t\tif (!meta || !meta.type || !meta.baseFilename || !meta.keys) continue;\n\t\t\tconst name = meta.name || indexName;\n\t\t\tlet index;\n\t\t\tif (meta.type === 'text') {\n\t\t\t\tindex = new TextCollectionIndex(name, meta.keys, meta.baseFilename, meta.options || {});\n\t\t\t} else if (meta.type === 'geospatial') {\n\t\t\t\tconst storageFile = meta.storage || `${meta.baseFilename}-geo.bjson`;\n\t\t\t\tindex = new GeospatialCollectionIndex(name, meta.keys, storageFile, meta.options || {});\n\t\t\t} else {\n\t\t\t\tconst storageFile = meta.storage || `${meta.baseFilename}.bjson`;\n\t\t\t\tindex = new RegularCollectionIndex(name, meta.keys, storageFile, meta.options || {});\n\t\t\t}\n\t\t\tthis.indexes.set(name, index);\n\t\t}\n\t}\n\n\tasync _ensureIndexOpen(index) {\n\t\tif (index && typeof index.open === 'function' && !index.isOpen) {\n\t\t\tawait index.open();\n\t\t}\n\t}\n\n\t/**\n\t * Close all indexes\n\t */\n\tasync close() {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index && typeof index.close === 'function') {\n\t\t\t\tawait index.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Determine if keys specify a text index\n\t */\n\tisTextIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine if keys specify a geospatial index\n\t */\n\tisGeospatialIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build a safe base filename for OPFS-backed index files\n\t */\n\t_getIndexBaseFilename(indexName) {\n\t\tconst sanitize = value => String(value).replace(/[^a-zA-Z0-9_-]/g, '_');\n\t\tconst dbName = this.db.dbName || this.db.name || 'db';\n\t\treturn `${sanitize(dbName)}-${sanitize(this.name)}-${sanitize(indexName)}`;\n\t}\n\n\t/**\n\t * Build/rebuild an index\n\t */\n\tasync buildIndex(indexName, keys, options = {}) {\n\t\tlet index;\n\t\tconst baseFilename = this._getIndexBaseFilename(indexName);\n\t\tlet storageFile;\n\t\tlet type;\n\t\t\n\t\t// Create appropriate index type\n\t\tif (this.isTextIndex(keys)) {\n\t\t\ttype = 'text';\n\t\t\tstorageFile = baseFilename; // TextIndex uses base filename for its multiple files\n\t\t\tindex = new TextCollectionIndex(indexName, keys, storageFile, options);\n\t\t} else if (this.isGeospatialIndex(keys)) {\n\t\t\ttype = 'geospatial';\n\t\t\tstorageFile = `${baseFilename}-geo.bjson`;\n\t\t\tindex = new GeospatialCollectionIndex(indexName, keys, storageFile, options);\n\t\t} else {\n\t\t\ttype = 'regular';\n\t\t\tstorageFile = `${baseFilename}.bjson`;\n\t\t\tindex = new RegularCollectionIndex(indexName, keys, storageFile, options);\n\t\t}\n\n\t\t// Persist index metadata in the collection store so we can restore on reloads\n\t\tif (this.storage && typeof this.storage.createIndexStore === 'function') {\n\t\t\tthis.storage.createIndexStore(indexName, {\n\t\t\t\tname: indexName,\n\t\t\t\tkeys,\n\t\t\t\ttype,\n\t\t\t\tbaseFilename,\n\t\t\t\tstorage: storageFile,\n\t\t\t\toptions\n\t\t\t});\n\t\t}\n\n\t\t// Open the index for use\n\t\tawait index.open();\n\n\t\t// Rebuild from a clean slate to avoid stale persisted entries\n\t\tif (typeof index.clear === 'function') {\n\t\t\tawait index.clear();\n\t\t}\n\n\t\t// Build index by scanning all documents\n\t\tconst allDocs = this.storage.getAllDocuments();\n\t\tfor (const doc of allDocs) {\n\t\t\tif (doc) {\n\t\t\t\tawait index.add(doc);\n\t\t\t}\n\t\t}\n\n\t\tthis.indexes.set(indexName, index);\n\t\treturn index;\n\t}\n\n\t/**\n\t * Update indexes when a document is inserted\n\t */\n\tasync updateIndexesOnInsert(doc) {\n\t\tconst promises = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tpromises.push((async () => {\n\t\t\t\tawait this._ensureIndexOpen(index);\n\t\t\t\tawait index.add(doc);\n\t\t\t})());\n\t\t}\n\t\t// Wait for all index operations to complete\n\t\tif (promises.length > 0) {\n\t\t\tawait Promise.all(promises);\n\t\t}\n\t}\n\n\t/**\n\t * Update indexes when a document is deleted\n\t */\n\tasync updateIndexesOnDelete(doc) {\n\t\tconst promises = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tpromises.push((async () => {\n\t\t\t\tawait this._ensureIndexOpen(index);\n\t\t\t\tawait index.remove(doc);\n\t\t\t})());\n\t\t}\n\t\t// Wait for all index operations to complete\n\t\tif (promises.length > 0) {\n\t\t\tawait Promise.all(promises);\n\t\t}\n\t}\n\n\t/**\n\t * Query planner - analyze query and determine optimal execution plan\n\t */\n\tplanQuery(query) {\n\t\tconst plan = this.queryPlanner.plan(query);\n\t\t// Note: With OPFS storage, indexes are async. Callers should use planQueryAsync\n\t\t// For now, we return null docIds to signal full scan\n\t\t// Actual async query execution happens via planQueryAsync\n\t\t\n\t\treturn {\n\t\t\tuseIndex: plan.type !== 'full_scan',\n\t\t\tplanType: plan.type,\n\t\t\tindexNames: plan.indexes,\n\t\t\tdocIds: null, // Force full scan for now - use planQueryAsync for index results\n\t\t\testimatedCost: plan.estimatedCost,\n\t\t\tindexOnly: plan.indexOnly || false\n\t\t};\n\t}\n\n\t/**\n\t * Async version of query planner - for use with async indexes\n\t */\n\tasync planQueryAsync(query) {\n\t\tconst plan = this.queryPlanner.plan(query);\n\t\tconst docIds = await this.queryPlanner.execute(plan);\n\t\t\n\t\treturn {\n\t\t\tuseIndex: plan.type !== 'full_scan',\n\t\t\tplanType: plan.type,\n\t\t\tindexNames: plan.indexes,\n\t\t\tdocIds: docIds,\n\t\t\testimatedCost: plan.estimatedCost,\n\t\t\tindexOnly: plan.indexOnly || false\n\t\t};\n\t}\n\n\t/**\n\t * Get a text index for the given field\n\t * @param {string} field - The field name\n\t * @returns {TextCollectionIndex|null} The text index or null if not found\n\t */\n\tgetTextIndex(field) {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Check if this field is indexed\n\t\t\t\tif (index.indexedFields.includes(field)) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Collection methods\n\taggregate(pipeline) {\n\t\tif (!pipeline || !isArray(pipeline)) {\n\t\t\tthrow new QueryError('Pipeline must be an array', { \n\t\t\t\tcollection: this.name, \n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t\t\t});\n\t\t}\n\n\t\t// Start with all documents\n\t\tlet results = [];\n\t\tconst cursor = this.find({});\n\t\twhile (cursor.hasNext()) {\n\t\t\tresults.push(cursor.next());\n\t\t}\n\n\t\t// Process each stage in the pipeline\n\t\tfor (let i = 0; i < pipeline.length; i++) {\n\t\t\tconst stage = pipeline[i];\n\t\t\tconst stageKeys = Object.keys(stage);\n\t\t\tif (stageKeys.length !== 1) {\n\t\t\t\tthrow new QueryError('Each pipeline stage must have exactly one key', { \n\t\t\t\t\tcollection: this.name, \n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t\t\t\t});\n\t\t\t}\n\t\t\tconst stageType = stageKeys[0];\n\t\t\tconst stageSpec = stage[stageType];\n\n\t\t\tif (stageType === \"$match\") {\n\t\t\t\t// Filter documents based on query\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tif (matches(results[j], stageSpec)) {\n\t\t\t\t\t\tmatched.push(results[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults = matched;\n\t\t\t} else if (stageType === \"$project\") {\n\t\t\t\t// Reshape documents with expression support\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tprojected.push(applyProjectionWithExpressions(stageSpec, results[j]));\n\t\t\t\t}\n\t\t\t\tresults = projected;\n\t\t\t} else if (stageType === \"$addFields\" || stageType === \"$set\") {\n\t\t\t\t// Add/set fields with computed expressions\n\t\t\t\tconst modified = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = copy(results[j]);\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tconst expr = stageSpec[field];\n\t\t\t\t\t\tdoc[field] = evaluateExpression(expr, results[j]);\n\t\t\t\t\t}\n\t\t\t\t\tmodified.push(doc);\n\t\t\t\t}\n\t\t\t\tresults = modified;\n\t\t\t} else if (stageType === \"$unset\") {\n\t\t\t\t// Remove fields from documents\n\t\t\t\tconst modified = [];\n\t\t\t\t// $unset can be a string (single field), array of strings, or object\n\t\t\t\tlet fieldsToRemove = [];\n\t\t\t\tif (typeof stageSpec === 'string') {\n\t\t\t\t\tfieldsToRemove = [stageSpec];\n\t\t\t\t} else if (Array.isArray(stageSpec)) {\n\t\t\t\t\tfieldsToRemove = stageSpec;\n\t\t\t\t} else if (typeof stageSpec === 'object') {\n\t\t\t\t\t// Object form: { field1: \"\", field2: \"\" } or { field1: 1, field2: 1 }\n\t\t\t\t\tfieldsToRemove = Object.keys(stageSpec);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = copy(results[j]);\n\t\t\t\t\tfor (let k = 0; k < fieldsToRemove.length; k++) {\n\t\t\t\t\t\tconst field = fieldsToRemove[k];\n\t\t\t\t\t\t// Support dot notation for nested field removal\n\t\t\t\t\t\tconst pathParts = field.split('.');\n\t\t\t\t\t\tif (pathParts.length === 1) {\n\t\t\t\t\t\t\tdelete doc[field];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Navigate to parent and delete nested field\n\t\t\t\t\t\t\tlet parent = doc;\n\t\t\t\t\t\t\tfor (let m = 0; m < pathParts.length - 1; m++) {\n\t\t\t\t\t\t\t\tif (parent == undefined || parent == null) break;\n\t\t\t\t\t\t\t\tparent = parent[pathParts[m]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (parent != undefined && parent != null) {\n\t\t\t\t\t\t\t\tdelete parent[pathParts[pathParts.length - 1]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmodified.push(doc);\n\t\t\t\t}\n\t\t\t\tresults = modified;\n\t\t\t} else if (stageType === \"$sort\") {\n\t\t\t\t// Sort documents\n\t\t\t\tconst sortKeys = Object.keys(stageSpec);\n\t\t\t\tresults.sort(function (a, b) {\n\t\t\t\t\tfor (let k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\tconst key = sortKeys[k];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * stageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (stageType === \"$limit\") {\n\t\t\t\t// Limit number of documents\n\t\t\t\tresults = results.slice(0, stageSpec);\n\t\t\t} else if (stageType === \"$skip\") {\n\t\t\t\t// Skip documents\n\t\t\t\tresults = results.slice(stageSpec);\n\t\t\t} else if (stageType === \"$group\") {\n\t\t\t\t// Group documents\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = stageSpec._id;\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\t// Compute group key using expression evaluator\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = evaluateExpression(groupId, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\t// Initialize group\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\t// Process each accumulator field\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = stageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$min') {\n\t\t\t\t\t\t\tlet min = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (min === undefined || val < min)) {\n\t\t\t\t\t\t\t\t\tmin = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = min;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\t\t\t\tconst set = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (const valKey in set) {\n\t\t\t\t\t\t\t\tarr.push(set[valKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$first') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tresult[field] = evaluateExpression(accExpr, group.docs[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$last') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tresult[field] = evaluateExpression(accExpr, group.docs[group.docs.length - 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$stdDevPop') {\n\t\t\t\t\t\t\t// Population standard deviation\n\t\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (values.length > 0) {\n\t\t\t\t\t\t\t\tconst mean = values.reduce((a, b) => a + b, 0) / values.length;\n\t\t\t\t\t\t\t\tconst variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n\t\t\t\t\t\t\t\tresult[field] = Math.sqrt(variance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$stdDevSamp') {\n\t\t\t\t\t\t\t// Sample standard deviation\n\t\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (values.length > 1) {\n\t\t\t\t\t\t\t\tconst mean = values.reduce((a, b) => a + b, 0) / values.length;\n\t\t\t\t\t\t\t\tconst variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (values.length - 1);\n\t\t\t\t\t\t\t\tresult[field] = Math.sqrt(variance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$mergeObjects') {\n\t\t\t\t\t\t\t// Merge objects from all documents in group\n\t\t\t\t\t\t\tconst merged = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'object' && val !== null && !Array.isArray(val)) {\n\t\t\t\t\t\t\t\t\tObject.assign(merged, val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = merged;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tresults = grouped;\n\t\t\t} else if (stageType === \"$count\") {\n\t\t\t\t// Count documents and return single document with count\n\t\t\t\tresults = [{ [stageSpec]: results.length }];\n\t\t\t} else if (stageType === \"$unwind\") {\n\t\t\t\t// Unwind array field\n\t\t\t\tconst unwound = [];\n\t\t\t\tlet fieldPath = stageSpec;\n\t\t\t\tif (typeof fieldPath === 'string' && fieldPath.charAt(0) === '$') {\n\t\t\t\t\tfieldPath = fieldPath.substring(1);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tconst arr = getProp(doc, fieldPath);\n\n\t\t\t\t\tif (arr && isArray(arr) && arr.length > 0) {\n\t\t\t\t\t\tfor (let k = 0; k < arr.length; k++) {\n\t\t\t\t\t\t\tconst unwoundDoc = copy(doc);\n\t\t\t\t\t\t\t// Set the unwound value\n\t\t\t\t\t\t\tconst parts = fieldPath.split('.');\n\t\t\t\t\t\t\tlet target = unwoundDoc;\n\t\t\t\t\t\t\tfor (let l = 0; l < parts.length - 1; l++) {\n\t\t\t\t\t\t\t\tif (!target[parts[l]]) {\n\t\t\t\t\t\t\t\t\ttarget[parts[l]] = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget = target[parts[l]];\n\t\t\t}\n\t\t\ttarget[parts[parts.length - 1]] = arr[k];\n\t\t\tunwound.push(unwoundDoc);\n\t\t}\n\t}\n\t// MongoDB's default behavior: skip documents where field is missing, null, empty array, or not an array\n}\nresults = unwound;\n} else if (stageType === \"$sortByCount\") {\n\t// Group by expression value and count occurrences, sorted descending by count\n\tconst groups = {};\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst value = evaluateExpression(stageSpec, doc);\n\t\tconst key = JSON.stringify(value);\n\t\t\n\t\tif (!groups[key]) {\n\t\t\tgroups[key] = {\n\t\t\t\t_id: value,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t}\n\t\tgroups[key].count++;\n\t}\n\t\n\t// Convert to array and sort by count descending\n\tresults = Object.values(groups).sort((a, b) => b.count - a.count);\n} else if (stageType === \"$replaceRoot\" || stageType === \"$replaceWith\") {\n\t// Replace root document with specified document\n\tconst modified = [];\n\tconst newRootSpec = stageType === \"$replaceRoot\" ? stageSpec.newRoot : stageSpec;\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst newRoot = evaluateExpression(newRootSpec, results[j]);\n\t\tif (typeof newRoot === 'object' && newRoot !== null && !Array.isArray(newRoot)) {\n\t\t\tmodified.push(newRoot);\n\t\t} else {\n\t\t\tthrow new QueryError('$replaceRoot expression must evaluate to an object', {\n\t\t\t\tcollection: this.name,\n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t});\n\t\t}\n\t}\n\tresults = modified;\n} else if (stageType === \"$sample\") {\n\t// Random sampling of documents\n\tconst size = stageSpec.size || 1;\n\tif (typeof size !== 'number' || size < 0) {\n\t\tthrow new QueryError('$sample size must be a non-negative number', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Shuffle using Fisher-Yates algorithm and take first 'size' elements\n\tconst shuffled = [...results];\n\tfor (let j = shuffled.length - 1; j > 0; j--) {\n\t\tconst k = Math.floor(Math.random() * (j + 1));\n\t\t[shuffled[j], shuffled[k]] = [shuffled[k], shuffled[j]];\n\t}\n\tresults = shuffled.slice(0, Math.min(size, shuffled.length));\n} else if (stageType === \"$bucket\") {\n\t// Categorize documents into buckets based on boundaries\n\tif (!stageSpec.groupBy || !stageSpec.boundaries) {\n\t\tthrow new QueryError('$bucket requires groupBy and boundaries', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst boundaries = stageSpec.boundaries;\n\tconst defaultBucket = stageSpec.default;\n\tconst output = stageSpec.output || { count: { $sum: 1 } };\n\t\n\t// Initialize buckets\n\tconst buckets = {};\n\tfor (let j = 0; j < boundaries.length - 1; j++) {\n\t\tconst key = JSON.stringify(boundaries[j]);\n\t\tbuckets[key] = {\n\t\t\t_id: boundaries[j],\n\t\t\tdocs: []\n\t\t};\n\t}\n\tif (defaultBucket !== undefined) {\n\t\tbuckets['default'] = {\n\t\t\t_id: defaultBucket,\n\t\t\tdocs: []\n\t\t};\n\t}\n\t\n\t// Categorize documents into buckets\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst value = evaluateExpression(stageSpec.groupBy, doc);\n\t\t\n\t\tlet placed = false;\n\t\tfor (let k = 0; k < boundaries.length - 1; k++) {\n\t\t\tif (value >= boundaries[k] && value < boundaries[k + 1]) {\n\t\t\t\tconst key = JSON.stringify(boundaries[k]);\n\t\t\t\tbuckets[key].docs.push(doc);\n\t\t\t\tplaced = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!placed && defaultBucket !== undefined) {\n\t\t\tbuckets['default'].docs.push(doc);\n\t\t}\n\t}\n\t\n\t// Apply output accumulators\n\tconst bucketed = [];\n\tfor (const bucketKey in buckets) {\n\t\tconst bucket = buckets[bucketKey];\n\t\tif (bucket.docs.length === 0) continue; // Skip empty buckets\n\t\t\n\t\tconst result = { _id: bucket._id };\n\t\t\n\t\tfor (const field in output) {\n\t\t\tconst accumulator = output[field];\n\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\n\t\t\tconst accType = accKeys[0];\n\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\n\t\t\t// Apply accumulator (reuse $group logic)\n\t\t\tif (accType === '$sum') {\n\t\t\t\tlet sum = 0;\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\tsum += val;\n\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[field] = sum;\n\t\t\t} else if (accType === '$avg') {\n\t\t\t\tlet sum = 0;\n\t\t\t\tlet count = 0;\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t} else if (accType === '$push') {\n\t\t\t\tconst arr = [];\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tarr.push(val);\n\t\t\t\t}\n\t\t\t\tresult[field] = arr;\n\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\tconst set = {};\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t}\n\t\t\t\tresult[field] = Object.values(set);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbucketed.push(result);\n\t}\n\t\n\t// Sort by _id (bucket boundary)\n\tresults = bucketed.sort((a, b) => {\n\t\tif (a._id < b._id) return -1;\n\t\tif (a._id > b._id) return 1;\n\t\treturn 0;\n\t});\n} else if (stageType === \"$bucketAuto\") {\n\t// Auto-calculate bucket boundaries and categorize documents\n\tif (!stageSpec.groupBy || !stageSpec.buckets) {\n\t\tthrow new QueryError('$bucketAuto requires groupBy and buckets', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst numBuckets = stageSpec.buckets;\n\tconst output = stageSpec.output || { count: { $sum: 1 } };\n\t\n\tif (results.length === 0) {\n\t\tresults = [];\n\t} else {\n\t\t// Extract and sort values\n\t\tconst values = results.map(doc => ({\n\t\t\tvalue: evaluateExpression(stageSpec.groupBy, doc),\n\t\t\tdoc: doc\n\t\t})).sort((a, b) => {\n\t\t\tif (a.value < b.value) return -1;\n\t\t\tif (a.value > b.value) return 1;\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\t// Calculate bucket size\n\t\tconst bucketSize = Math.ceil(values.length / numBuckets);\n\t\tconst buckets = [];\n\t\t\n\t\tfor (let j = 0; j < numBuckets && j * bucketSize < values.length; j++) {\n\t\t\tconst startIdx = j * bucketSize;\n\t\t\tconst endIdx = Math.min((j + 1) * bucketSize, values.length);\n\t\t\tconst bucketDocs = values.slice(startIdx, endIdx);\n\t\t\t\n\t\t\tif (bucketDocs.length === 0) continue;\n\t\t\t\n\t\t\tconst bucket = {\n\t\t\t\t_id: {\n\t\t\t\t\tmin: bucketDocs[0].value,\n\t\t\t\t\tmax: endIdx < values.length ? bucketDocs[bucketDocs.length - 1].value : bucketDocs[bucketDocs.length - 1].value\n\t\t\t\t},\n\t\t\t\tdocs: bucketDocs.map(v => v.doc)\n\t\t\t};\n\t\t\tbuckets.push(bucket);\n\t\t}\n\t\t\n\t\t// Apply output accumulators\n\t\tconst bucketed = [];\n\t\tfor (let j = 0; j < buckets.length; j++) {\n\t\t\tconst bucket = buckets[j];\n\t\t\tconst result = { _id: bucket._id };\n\t\t\t\n\t\t\tfor (const field in output) {\n\t\t\t\tconst accumulator = output[field];\n\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\t\n\t\t\t\tconst accType = accKeys[0];\n\t\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\t\n\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = sum;\n\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\tconst arr = [];\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = arr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbucketed.push(result);\n\t\t}\n\t\t\n\t\tresults = bucketed;\n\t}\n} else if (stageType === \"$out\") {\n\t// Output results to a collection (replaces existing collection)\n\tconst targetCollectionName = stageSpec;\n\t\n\tif (typeof targetCollectionName !== 'string') {\n\t\tthrow new QueryError('$out requires a string collection name', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Drop and recreate target collection\n\tif (this.db[targetCollectionName]) {\n\t\tthis.db.dropCollection(targetCollectionName);\n\t}\n\tthis.db.createCollection(targetCollectionName);\n\t\n\tconst targetCollection = this.db[targetCollectionName];\n\t\n\t// Insert all results into target collection\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst docId = doc._id;\n\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\ttargetCollection.storage.set(key, doc);\n\t}\n\t\n\t// $out returns empty results (MongoDB behavior)\n\tresults = [];\n} else if (stageType === \"$merge\") {\n\t// Merge results into a collection (MongoDB 4.2+)\n\tlet targetCollectionName;\n\tlet on = '_id';\n\tlet whenMatched = 'merge';\n\tlet whenNotMatched = 'insert';\n\t\n\tif (typeof stageSpec === 'string') {\n\t\ttargetCollectionName = stageSpec;\n\t} else if (typeof stageSpec === 'object') {\n\t\ttargetCollectionName = stageSpec.into;\n\t\ton = stageSpec.on || on;\n\t\twhenMatched = stageSpec.whenMatched || whenMatched;\n\t\twhenNotMatched = stageSpec.whenNotMatched || whenNotMatched;\n\t}\n\t\n\tif (!targetCollectionName) {\n\t\tthrow new QueryError('$merge requires a target collection', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Create target collection if it doesn't exist\n\tif (!this.db[targetCollectionName]) {\n\t\tthis.db.createCollection(targetCollectionName);\n\t}\n\t\n\tconst targetCollection = this.db[targetCollectionName];\n\t\n\t// Merge documents\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst matchField = typeof on === 'string' ? on : on[0];\n\t\tconst matchValue = getProp(doc, matchField);\n\t\t\n\t\t// Find existing document\n\t\tconst existingCursor = targetCollection.find({ [matchField]: matchValue });\n\t\tconst existing = existingCursor.hasNext() ? existingCursor.next() : null;\n\t\t\n\t\tif (existing) {\n\t\t\tif (whenMatched === 'replace') {\n\t\t\t\tconst docId = doc._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, doc);\n\t\t\t} else if (whenMatched === 'merge') {\n\t\t\t\tconst merged = Object.assign({}, existing, doc);\n\t\t\t\tconst docId = merged._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, merged);\n\t\t\t} else if (whenMatched === 'keepExisting') {\n\t\t\t\t// Do nothing\n\t\t\t} else if (whenMatched === 'fail') {\n\t\t\t\tthrow new QueryError('$merge failed: duplicate key', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.DUPLICATE_KEY\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (whenNotMatched === 'insert') {\n\t\t\t\tconst docId = doc._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, doc);\n\t\t\t} else if (whenNotMatched === 'discard') {\n\t\t\t\t// Do nothing\n\t\t\t} else if (whenNotMatched === 'fail') {\n\t\t\t\tthrow new QueryError('$merge failed: document not found', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// $merge returns empty results (MongoDB behavior)\n\tresults = [];\n} else if (stageType === \"$lookup\") {\n\t// Left outer join with another collection\n\tif (!stageSpec.from || !stageSpec.localField || !stageSpec.foreignField || !stageSpec.as) {\n\t\tthrow new QueryError('$lookup requires from, localField, foreignField, and as', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Check if collection exists without triggering auto-creation\n\tconst collectionNames = this.db.getCollectionNames();\n\tif (!collectionNames.includes(stageSpec.from)) {\n\t\tthrow new QueryError('$lookup: collection not found: ' + stageSpec.from, {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t}\n\t\n\tconst fromCollection = this.db[stageSpec.from];\n\t\n\tconst joined = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst localValue = getProp(doc, stageSpec.localField);\n\t\t\n\t\t// Find matching documents in foreign collection\n\t\tconst matches = [];\n\t\tconst foreignCursor = fromCollection.find({ [stageSpec.foreignField]: localValue });\n\t\twhile (foreignCursor.hasNext()) {\n\t\t\tmatches.push(foreignCursor.next());\n\t\t}\n\t\t\n\t\tdoc[stageSpec.as] = matches;\n\t\tjoined.push(doc);\n\t}\n\tresults = joined;\n} else if (stageType === \"$graphLookup\") {\n\t// Recursive graph lookup\n\tif (!stageSpec.from || !stageSpec.startWith || !stageSpec.connectFromField || \n\t    !stageSpec.connectToField || !stageSpec.as) {\n\t\tthrow new QueryError('$graphLookup requires from, startWith, connectFromField, connectToField, and as', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Check if collection exists without triggering auto-creation\n\tconst collectionNames = this.db.getCollectionNames();\n\tif (!collectionNames.includes(stageSpec.from)) {\n\t\tthrow new QueryError('$graphLookup: collection not found: ' + stageSpec.from, {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t}\n\t\n\tconst fromCollection = this.db[stageSpec.from];\n\t\n\tconst maxDepth = stageSpec.maxDepth !== undefined ? stageSpec.maxDepth : Number.MAX_SAFE_INTEGER;\n\tconst depthField = stageSpec.depthField;\n\tconst restrictSearchWithMatch = stageSpec.restrictSearchWithMatch;\n\t\n\tconst graphed = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst startValue = evaluateExpression(stageSpec.startWith, results[j]);\n\t\t\n\t\t// Recursive lookup\n\t\tconst visited = new Set();\n\t\tconst matches = [];\n\t\tconst queue = [{ value: startValue, depth: 0 }];\n\t\t\n\t\twhile (queue.length > 0) {\n\t\t\tconst { value, depth } = queue.shift();\n\t\t\tif (depth > maxDepth) continue;\n\t\t\t\n\t\t\tconst valueKey = JSON.stringify(value);\n\t\t\tif (visited.has(valueKey)) continue;\n\t\t\tvisited.add(valueKey);\n\t\t\t\n\t\t\t// Find matching documents\n\t\t\tlet query = { [stageSpec.connectToField]: value };\n\t\t\tif (restrictSearchWithMatch) {\n\t\t\t\tquery = { $and: [query, restrictSearchWithMatch] };\n\t\t\t}\n\t\t\t\n\t\t\tconst cursor = fromCollection.find(query);\n\t\t\twhile (cursor.hasNext()) {\n\t\t\t\tconst match = cursor.next();\n\t\t\t\tconst matchCopy = copy(match);\n\t\t\t\t\n\t\t\t\tif (depthField) {\n\t\t\t\t\tmatchCopy[depthField] = depth;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmatches.push(matchCopy);\n\t\t\t\t\n\t\t\t\t// Add connected value to queue for next iteration\n\t\t\t\tconst nextValue = getProp(match, stageSpec.connectFromField);\n\t\t\t\tif (nextValue !== undefined && nextValue !== null) {\n\t\t\t\t\tqueue.push({ value: nextValue, depth: depth + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdoc[stageSpec.as] = matches;\n\t\tgraphed.push(doc);\n\t}\n\tresults = graphed;\n} else if (stageType === \"$facet\") {\n\t// Multiple parallel pipelines\n\tif (typeof stageSpec !== 'object' || Array.isArray(stageSpec)) {\n\t\tthrow new QueryError('$facet requires an object with pipeline definitions', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst facetResult = {};\n\t\n\tfor (const facetName in stageSpec) {\n\t\tconst facetPipeline = stageSpec[facetName];\n\t\t\n\t\tif (!Array.isArray(facetPipeline)) {\n\t\t\tthrow new QueryError('$facet pipeline must be an array', {\n\t\t\t\tcollection: this.name,\n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t});\n\t\t}\n\t\t\n\t\t// Execute the sub-pipeline on a copy of current results\n\t\tlet facetResults = results.map(r => copy(r));\n\t\t\n\t\tfor (let k = 0; k < facetPipeline.length; k++) {\n\t\t\tconst facetStage = facetPipeline[k];\n\t\t\tconst facetStageKeys = Object.keys(facetStage);\n\t\t\tif (facetStageKeys.length !== 1) {\n\t\t\t\tthrow new QueryError('Each pipeline stage must have exactly one key', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tconst facetStageType = facetStageKeys[0];\n\t\t\tconst facetStageSpec = facetStage[facetStageType];\n\t\t\t\n\t\t\t// Process facet stage (recursive call to aggregation logic)\n\t\t\t// We need to inline the stage processing here\n\t\t\tif (facetStageType === \"$match\") {\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tif (matches(facetResults[m], facetStageSpec)) {\n\t\t\t\t\t\tmatched.push(facetResults[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfacetResults = matched;\n\t\t\t} else if (facetStageType === \"$project\") {\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tprojected.push(applyProjectionWithExpressions(facetStageSpec, facetResults[m]));\n\t\t\t\t}\n\t\t\t\tfacetResults = projected;\n\t\t\t} else if (facetStageType === \"$limit\") {\n\t\t\t\tfacetResults = facetResults.slice(0, facetStageSpec);\n\t\t\t} else if (facetStageType === \"$skip\") {\n\t\t\t\tfacetResults = facetResults.slice(facetStageSpec);\n\t\t\t} else if (facetStageType === \"$sort\") {\n\t\t\t\tconst sortKeys = Object.keys(facetStageSpec);\n\t\t\t\tfacetResults.sort(function (a, b) {\n\t\t\t\t\tfor (let n = 0; n < sortKeys.length; n++) {\n\t\t\t\t\t\tconst key = sortKeys[n];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * facetStageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (facetStageType === \"$count\") {\n\t\t\t\tfacetResults = [{ [facetStageSpec]: facetResults.length }];\n\t\t\t} else if (facetStageType === \"$group\") {\n\t\t\t\t// Handle $group in facet sub-pipelines\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = facetStageSpec._id;\n\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = evaluateExpression(groupId, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators (simplified version)\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\tfor (const field in facetStageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = facetStageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tfacetResults = grouped;\n\t\t\t} else if (facetStageType === \"$sortByCount\") {\n\t\t\t\t// Handle $sortByCount in facet sub-pipelines\n\t\t\t\tconst groups = {};\n\t\t\t\t\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tconst value = evaluateExpression(facetStageSpec, doc);\n\t\t\t\t\tconst key = JSON.stringify(value);\n\t\t\t\t\t\n\t\t\t\t\tif (!groups[key]) {\n\t\t\t\t\t\tgroups[key] = {\n\t\t\t\t\t\t\t_id: value,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tgroups[key].count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfacetResults = Object.values(groups).sort((a, b) => b.count - a.count);\n\t\t\t} else if (facetStageType === \"$sample\") {\n\t\t\t\t// Handle $sample in facet sub-pipelines\n\t\t\t\tconst size = facetStageSpec.size || 1;\n\t\t\t\tconst shuffled = [...facetResults];\n\t\t\t\tfor (let m = shuffled.length - 1; m > 0; m--) {\n\t\t\t\t\tconst k = Math.floor(Math.random() * (m + 1));\n\t\t\t\t\t[shuffled[m], shuffled[k]] = [shuffled[k], shuffled[m]];\n\t\t\t\t}\n\t\t\t\tfacetResults = shuffled.slice(0, Math.min(size, shuffled.length));\n\t\t\t} else if (facetStageType === \"$bucket\") {\n\t\t\t\t// Handle $bucket in facet sub-pipelines\n\t\t\t\tconst boundaries = facetStageSpec.boundaries;\n\t\t\t\tconst defaultBucket = facetStageSpec.default;\n\t\t\t\tconst output = facetStageSpec.output || { count: { $sum: 1 } };\n\t\t\t\t\n\t\t\t\tconst buckets = {};\n\t\t\t\tfor (let m = 0; m < boundaries.length - 1; m++) {\n\t\t\t\t\tconst key = JSON.stringify(boundaries[m]);\n\t\t\t\t\tbuckets[key] = {\n\t\t\t\t\t\t_id: boundaries[m],\n\t\t\t\t\t\tdocs: []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (defaultBucket !== undefined) {\n\t\t\t\t\tbuckets['default'] = {\n\t\t\t\t\t\t_id: defaultBucket,\n\t\t\t\t\t\tdocs: []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Categorize documents\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tconst value = evaluateExpression(facetStageSpec.groupBy, doc);\n\t\t\t\t\t\n\t\t\t\t\tlet placed = false;\n\t\t\t\t\tfor (let n = 0; n < boundaries.length - 1; n++) {\n\t\t\t\t\t\tif (value >= boundaries[n] && value < boundaries[n + 1]) {\n\t\t\t\t\t\t\tconst key = JSON.stringify(boundaries[n]);\n\t\t\t\t\t\t\tbuckets[key].docs.push(doc);\n\t\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!placed && defaultBucket !== undefined) {\n\t\t\t\t\t\tbuckets['default'].docs.push(doc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst bucketed = [];\n\t\t\t\tfor (const bucketKey in buckets) {\n\t\t\t\t\tconst bucket = buckets[bucketKey];\n\t\t\t\t\tif (bucket.docs.length === 0) continue;\n\t\t\t\t\t\n\t\t\t\t\tconst result = { _id: bucket._id };\n\t\t\t\t\t\n\t\t\t\t\tfor (const field in output) {\n\t\t\t\t\t\tconst accumulator = output[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < bucket.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[n]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbucketed.push(result);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfacetResults = bucketed.sort((a, b) => {\n\t\t\t\t\tif (a._id < b._id) return -1;\n\t\t\t\t\tif (a._id > b._id) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add more stage types as needed for facet sub-pipelines\n\t\t}\n\t\t\n\t\tfacetResult[facetName] = facetResults;\n\t}\n\t\n\tresults = [facetResult];\n} else if (stageType === \"$redact\") {\n\t// Conditionally filter or redact document content\n\tconst redacted = [];\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst decision = evaluateExpression(stageSpec, doc);\n\t\t\n\t\tif (decision === '$$DESCEND') {\n\t\t\t// Include document and recurse into subdocuments (simplified: just include)\n\t\t\tredacted.push(doc);\n\t\t} else if (decision === '$$PRUNE') {\n\t\t\t// Exclude this document\n\t\t\tcontinue;\n\t\t} else if (decision === '$$KEEP') {\n\t\t\t// Include this document\n\t\t\tredacted.push(doc);\n\t\t} else {\n\t\t\t// If result is a conditional expression, evaluate it\n\t\t\tif (decision) {\n\t\t\t\tredacted.push(doc);\n\t\t\t}\n\t\t}\n\t}\n\tresults = redacted;\n} else if (stageType === \"$geoNear\") {\n\t// Geospatial aggregation with distance calculation\n\tif (!stageSpec.near || !stageSpec.distanceField) {\n\t\tthrow new QueryError('$geoNear requires near and distanceField', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst near = stageSpec.near;\n\tconst distanceField = stageSpec.distanceField;\n\tconst maxDistance = stageSpec.maxDistance;\n\tconst minDistance = stageSpec.minDistance || 0;\n\tconst spherical = stageSpec.spherical !== false;\n\tconst key = stageSpec.key || 'location';\n\t\n\t// Calculate distance for each document\n\tconst withDistances = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst location = getProp(doc, key);\n\t\t\n\t\tif (!location || !Array.isArray(location) || location.length < 2) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Calculate distance (using Haversine formula for spherical or Euclidean for planar)\n\t\tlet distance;\n\t\tif (spherical) {\n\t\t\t// Haversine formula for great circle distance\n\t\t\tconst R = 6371000; // Earth radius in meters\n\t\t\tconst lat1 = near[1] * Math.PI / 180;\n\t\t\tconst lat2 = location[1] * Math.PI / 180;\n\t\t\tconst deltaLat = (location[1] - near[1]) * Math.PI / 180;\n\t\t\tconst deltaLon = (location[0] - near[0]) * Math.PI / 180;\n\t\t\t\n\t\t\tconst a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\n\t\t\t          Math.cos(lat1) * Math.cos(lat2) *\n\t\t\t          Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n\t\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\t\tdistance = R * c;\n\t\t} else {\n\t\t\t// Euclidean distance\n\t\t\tconst dx = location[0] - near[0];\n\t\t\tconst dy = location[1] - near[1];\n\t\t\tdistance = Math.sqrt(dx * dx + dy * dy);\n\t\t}\n\t\t\n\t\t// Filter by distance\n\t\tif (distance >= minDistance && (!maxDistance || distance <= maxDistance)) {\n\t\t\tdoc[distanceField] = distance;\n\t\t\twithDistances.push(doc);\n\t\t}\n\t}\n\t\n\t// Sort by distance (nearest first)\n\twithDistances.sort((a, b) => a[distanceField] - b[distanceField]);\n\t\n\t// Apply limit if specified\n\tif (stageSpec.limit) {\n\t\tresults = withDistances.slice(0, stageSpec.limit);\n\t} else {\n\t\tresults = withDistances;\n\t}\n} else {\n\tthrow new QueryError('Unsupported aggregation stage: ' + stageType, { \n\t\tcollection: this.name, \n\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t});\n}\n}\n\nreturn results;\n}\tbulkWrite() { throw new NotImplementedError('bulkWrite', { collection: this.name }); }\n\n\tasync count() {\n\t\treturn this.storage.size();\n\t}\n\n\tasync copyTo(destCollectionName) {\n\t\tif (!this.db[destCollectionName]) {\n\t\t\tthis.db.createCollection(destCollectionName);\n\t\t}\n\t\tconst destCol = this.db[destCollectionName];\n\t\tlet numCopied = 0;\n\t\tconst c = this.find({});\n\t\twhile (c.hasNext()) {\n\t\t\tawait destCol.insertOne(c.next());\n\t\t\tnumCopied++;\n\t\t}\n\t\treturn numCopied;\n\t}\n\n\tasync createIndex(keys, options) {\n\t\t// MongoDB-compliant createIndex\n\t\t// keys: { fieldName: 1 } for ascending, { fieldName: -1 } for descending, { fieldName: 'text' } for text\n\t\t// options: { name: \"indexName\", unique: true, ... }\n\n\t\tif (!keys || typeof keys !== 'object' || Array.isArray(keys)) {\n\t\t\tthrow new BadValueError('keys', keys, 'createIndex requires a key specification object', { \n\t\t\t\tcollection: this.name \n\t\t\t});\n\t\t}\n\n\t\tconst indexName = (options && options.name) ? options.name : this.generateIndexName(keys);\n\n\t\t// Check if index already exists\n\t\tif (this.indexes.has(indexName)) {\n\t\t\t// MongoDB checks for key specification conflicts\n\t\t\tconst existingIndex = this.indexes.get(indexName);\n\t\t\tconst existingKeys = JSON.stringify(existingIndex.keys);\n\t\t\tconst newKeys = JSON.stringify(keys);\n\t\t\tif (existingKeys !== newKeys) {\n\t\t\t\tthrow new IndexError(\n\t\t\t\t\t\"Index with name '\" + indexName + \"' already exists with a different key specification\", \n\t\t\t\t\t{ \n\t\t\t\t\t\tcode: ErrorCodes.INDEX_OPTIONS_CONFLICT,\n\t\t\t\t\t\tindex: indexName, \n\t\t\t\t\t\tcollection: this.name \n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Same index, return without error\n\t\t\treturn indexName;\n\t\t}\n\n\t\t// Build the index\n\t\tawait this.buildIndex(indexName, keys, options);\n\n\t\treturn indexName;\n\t}\n\n\tdataSize() { throw new NotImplementedError('dataSize', { collection: this.name }); }\n\n\tasync deleteOne(query) {\n\t\tconst doc = await this.findOne(query);\n\t\tif (doc) {\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id.toString());\n\t\t\tthis.emit('delete', { _id: doc._id });\n\t\t\treturn { deletedCount: 1 };\n\t\t} else {\n\t\t\treturn { deletedCount: 0 };\n\t\t}\n\t}\n\n\tasync deleteMany(query) {\n\t\tconst c = this.find(query);\n\t\tconst ids = [];\n\t\tconst docs = [];\n\t\twhile (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tids.push(doc._id);\n\t\t\tdocs.push(doc);\n\t\t}\n\t\tconst deletedCount = ids.length;\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tawait this.updateIndexesOnDelete(docs[i]);\n\t\t\tthis.storage.remove(ids[i].toString());\n\t\t\tthis.emit('delete', { _id: ids[i] });\n\t\t}\n\t\treturn { deletedCount: deletedCount };\n\t}\n\n\tasync distinct(field, query) {\n\t\tconst vals = {};\n\t\tconst c = this.find(query);\n\t\twhile (c.hasNext()) {\n\t\t\tconst d = c.next();\n\t\t\tif (d[field]) {\n\t\t\t\tvals[d[field]] = true;\n\t\t\t}\n\t\t}\n\t\treturn Object.keys(vals);\n\t}\n\n\tasync drop() {\n\t\t// Clear all indexes\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index && typeof index.clear === 'function') {\n\t\t\t\tawait index.clear();\n\t\t\t}\n\t\t}\n\t\tthis.storage.clear();\n\t}\n\n\tdropIndex(indexName) {\n\t\tif (!this.indexes.has(indexName)) {\n\t\t\tthrow new IndexNotFoundError(indexName, { collection: this.name });\n\t\t}\n\t\tthis.indexes.get(indexName).clear();\n\t\tthis.indexes.delete(indexName);\n\t\treturn { nIndexesWas: this.indexes.size + 1, ok: 1 };\n\t}\n\n\tdropIndexes() {\n\t\tconst count = this.indexes.size;\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tindex.clear();\n\t\t}\n\t\tthis.indexes.clear();\n\t\treturn { nIndexesWas: count, msg: \"non-_id indexes dropped\", ok: 1 };\n\t}\n\tensureIndex() { throw new NotImplementedError('ensureIndex', { collection: this.name }); }\n\texplain() { throw new NotImplementedError('explain', { collection: this.name }); }\n\n\tfind(query, projection) {\n\t\tconst normalizedQuery = query == undefined ? {} : query;\n\t\tconst nearSpec = this._extractNearSpec(normalizedQuery);\n\t\t\n\t\t// Get query plan (synchronous, returns null for index docIds)\n\t\tconst queryPlan = this.planQuery(normalizedQuery);\n\t\tconst documents = [];\n\t\tconst seen = {}; // Track which docs we've seen to avoid duplicates\n\t\t\n\t\t// For now, always do full scan since index queries are async\n\t\t// In the future, use planQueryAsync for index-based queries\n\t\tconst allDocs = this.storage.getAllDocuments();\n\t\tfor (const doc of allDocs) {\n\t\t\tif (!seen[doc._id] && matches(doc, normalizedQuery)) {\n\t\t\t\tseen[doc._id] = true;\n\t\t\t\tdocuments.push(doc);\n\t\t\t}\n\t\t}\n\n\t\tif (nearSpec) {\n\t\t\tthis._sortByNearDistance(documents, nearSpec);\n\t\t}\n\t\t\n\t\treturn new Cursor(\n\t\t\tthis,\n\t\t\tnormalizedQuery,\n\t\t\tprojection,\n\t\t\tdocuments,\n\t\t\tSortedCursor\n\t\t);\n\t}\n\n\t_extractNearSpec(query) {\n\t\tfor (const field of Object.keys(query || {})) {\n\t\t\tif (field.startsWith('$')) continue;\n\t\t\tconst value = query[field];\n\t\t\tif (!value || typeof value !== 'object') continue;\n\n\t\t\tif (value.$near) {\n\t\t\t\tconst coords = this._parseNearCoordinates(value.$near);\n\t\t\t\tif (coords) return { field, ...coords };\n\t\t\t}\n\n\t\t\tif (value.$nearSphere) {\n\t\t\t\tconst coords = this._parseNearCoordinates(value.$nearSphere);\n\t\t\t\tif (coords) return { field, ...coords };\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t_parseNearCoordinates(spec) {\n\t\tlet coordinates;\n\t\tif (spec && typeof spec === 'object') {\n\t\t\tif (spec.$geometry && spec.$geometry.coordinates) {\n\t\t\t\tcoordinates = spec.$geometry.coordinates;\n\t\t\t} else if (spec.coordinates) {\n\t\t\t\tcoordinates = spec.coordinates;\n\t\t\t} else if (Array.isArray(spec)) {\n\t\t\t\tcoordinates = spec;\n\t\t\t}\n\t\t}\n\n\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst [lng, lat] = coordinates;\n\t\tif (typeof lat !== 'number' || typeof lng !== 'number') {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { lat, lng };\n\t}\n\n\t_extractPointCoordinates(value) {\n\t\tif (!value) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (value.type === 'FeatureCollection' && Array.isArray(value.features) && value.features.length > 0) {\n\t\t\treturn this._extractPointCoordinates(value.features[0].geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (value.type === 'Feature' && value.geometry) {\n\t\t\treturn this._extractPointCoordinates(value.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (value.type === 'Point' && Array.isArray(value.coordinates) && value.coordinates.length >= 2) {\n\t\t\tconst [lng, lat] = value.coordinates;\n\t\t\tif (typeof lat === 'number' && typeof lng === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_sortByNearDistance(documents, nearSpec) {\n\t\tconst { field, lat: targetLat, lng: targetLng } = nearSpec;\n\t\tdocuments.sort((a, b) => {\n\t\t\tconst aPoint = this._extractPointCoordinates(getProp(a, field));\n\t\t\tconst bPoint = this._extractPointCoordinates(getProp(b, field));\n\n\t\t\tconst aDist = aPoint ? this._haversineDistance(aPoint.lat, aPoint.lng, targetLat, targetLng) : Infinity;\n\t\t\tconst bDist = bPoint ? this._haversineDistance(bPoint.lat, bPoint.lng, targetLat, targetLng) : Infinity;\n\n\t\t\treturn aDist - bDist;\n\t\t});\n\t}\n\n\t_haversineDistance(lat1, lng1, lat2, lng2) {\n\t\tconst R = 6371; // Earth's radius in kilometers\n\t\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\t\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\t\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\treturn R * c;\n\t}\n\n\tfindAndModify() { throw new NotImplementedError('findAndModify', { collection: this.name }); }\n\n\tasync findOne(query, projection) {\n\t\tconst cursor = this.find(query, projection);\n\t\tif (cursor.hasNext()) {\n\t\t\treturn cursor.next();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync findOneAndDelete(filter, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tthis.storage.remove(doc._id.toString());\n\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\telse return doc;\n\t}\n\n\tasync findOneAndReplace(filter, replacement, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\treplacement._id = doc._id;\n\t\tthis.storage.set(doc._id.toString(), replacement);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, replacement);\n\t\t\telse return replacement;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tasync findOneAndUpdate(filter, update, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tconst clone = Object.assign({}, doc);\n\t\t\n\t\t// Get array filter information for positional operator support\n\t\tconst matchInfo = matchWithArrayIndices(doc, filter);\n\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\n\t\tapplyUpdates(update, clone, false, positionalMatchInfo, userArrayFilters);\n\t\tthis.storage.set(doc._id.toString(), clone);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, clone);\n\t\t\telse return clone;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tgetIndexes() {\n\t\t// Return array of index specifications\n\t\tconst result = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tresult.push(index.getSpec());\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetShardDistribution() { throw new NotImplementedError('getShardDistribution', { collection: this.name }); }\n\tgetShardVersion() { throw new NotImplementedError('getShardVersion', { collection: this.name }); }\n\n\t// non-mongo\n\tgetStore() {\n\t\treturn this.storage.getStore();\n\t}\n\n\tgroup() { throw new NotImplementedError('group', { collection: this.name }); }\n\n\tasync insert(doc) {\n\t\tif (Array == doc.constructor) {\n\t\t\treturn await this.insertMany(doc);\n\t\t} else {\n\t\t\treturn await this.insertOne(doc);\n\t\t}\n\t}\n\n\tasync insertOne(doc) {\n\t\tif (doc._id == undefined) doc._id = this.idGenerator();\n\t\tthis.storage.set(doc._id.toString(), doc);\n\t\tawait this.updateIndexesOnInsert(doc);\n\t\tthis.emit('insert', doc);\n\t\treturn { insertedId: doc._id };\n\t}\n\n\tasync insertMany(docs) {\n\t\tconst insertedIds = [];\n\t\tfor (let i = 0; i < docs.length; i++) {\n\t\t\tconst result = await this.insertOne(docs[i]);\n\t\t\tinsertedIds.push(result.insertedId);\n\t\t}\n\t\treturn { insertedIds: insertedIds };\n\t}\n\n\tisCapped() { throw new NotImplementedError('isCapped', { collection: this.name }); }\n\tmapReduce() { throw new NotImplementedError('mapReduce', { collection: this.name }); }\n\treIndex() { throw new NotImplementedError('reIndex', { collection: this.name }); }\n\n\tasync replaceOne(query, replacement, options) { // only replace\n\t\t// first\n\t\tconst result = {};\n\t\tconst c = this.find(query);\n\t\tresult.matchedCount = c.count();\n\t\tif (result.matchedCount == 0) {\n\t\t\tresult.modifiedCount = 0;\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = replacement;\n\t\t\t\tnewDoc._id = this.idGenerator();\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t\tresult.upsertedId = newDoc._id;\n\t\t\t}\n\t\t} else {\n\t\t\tresult.modifiedCount = 1;\n\t\t\tconst doc = c.next();\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\treplacement._id = doc._id;\n\t\t\tthis.storage.set(doc._id.toString(), replacement);\n\t\t\tawait this.updateIndexesOnInsert(replacement);\n\t\t\tthis.emit('replace', replacement);\n\t\t}\n\t\treturn result;\n\t}\n\n\tasync remove(query, options) {\n\t\tconst c = this.find(query);\n\t\tif (!c.hasNext()) return;\n\t\tif (options === true || (options && options.justOne)) {\n\t\t\tconst doc = c.next();\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id.toString());\n\t\t} else {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\tthis.storage.remove(doc._id.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\trenameCollection() { throw new NotImplementedError('renameCollection', { collection: this.name }); }\n\tsave() { throw new NotImplementedError('save', { collection: this.name }); }\n\tstats() { throw new NotImplementedError('stats', { collection: this.name }); }\n\tstorageSize() { throw new NotImplementedError('storageSize', { collection: this.name }); }\n\ttotalSize() { throw new NotImplementedError('totalSize', { collection: this.name }); }\n\ttotalIndexSize() { throw new NotImplementedError('totalIndexSize', { collection: this.name }); }\n\n\tasync update(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tif (options && options.multi) {\n\t\t\t\twhile (c.hasNext()) {\n\t\t\t\t\tconst doc = c.next();\n\t\t\t\t\t\n\t\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\t\n\t\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst doc = c.next();\n\t\t\t\t\n\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\n\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateOne(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tconst originalDoc = JSON.parse(JSON.stringify(doc));\n\t\t\t\n\t\t\t// Get array filter information for positional operator support\n\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\n\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\tconst updateDescription = this._getUpdateDescription(originalDoc, doc);\n\t\t\tthis.emit('update', doc, updateDescription);\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateMany(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tconst originalDoc = JSON.parse(JSON.stringify(doc));\n\t\t\t\t\n\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\n\t\t\t\tawait this.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\tawait this.updateIndexesOnInsert(doc);\n\t\t\t\tconst updateDescription = this._getUpdateDescription(originalDoc, doc);\n\t\t\t\tthis.emit('update', doc, updateDescription);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tawait this.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidate() { throw new NotImplementedError('validate', { collection: this.name }); }\n\n\t/**\n\t * Generate updateDescription for change events\n\t * Compares original and updated documents to track changes\n\t */\n\t_getUpdateDescription(originalDoc, updatedDoc) {\n\t\tconst updatedFields = {};\n\t\tconst removedFields = [];\n\n\t\t// Find updated and new fields\n\t\tfor (const key in updatedDoc) {\n\t\t\tif (key === '_id') continue;\n\t\t\tif (JSON.stringify(originalDoc[key]) !== JSON.stringify(updatedDoc[key])) {\n\t\t\t\tupdatedFields[key] = updatedDoc[key];\n\t\t\t}\n\t\t}\n\n\t\t// Find removed fields\n\t\tfor (const key in originalDoc) {\n\t\t\tif (key === '_id') continue;\n\t\t\tif (!(key in updatedDoc)) {\n\t\t\t\tremovedFields.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tupdatedFields,\n\t\t\tremovedFields,\n\t\t\ttruncatedArrays: [] // Not implemented in micro-mongo\n\t\t};\n\t}\n\n\t/**\n\t * Watch for changes to this collection\n\t * @param {Array} pipeline - Aggregation pipeline to filter changes\n\t * @param {Object} options - Watch options (fullDocument, etc.)\n\t * @returns {ChangeStream} A change stream instance\n\t */\n\twatch(pipeline = [], options = {}) {\n\t\treturn new ChangeStream(this, pipeline, options);\n\t}\n\n}\n\n/**\n * Apply projection with expression support\n * Enhanced version of applyProjection that supports computed expressions\n */\nfunction applyProjectionWithExpressions(projection, doc) {\n\tconst result = {};\n\tconst keys = Object.keys(projection);\n\t\n\t// Check if this is an inclusion or exclusion projection\n\tlet isInclusion = false;\n\tlet isExclusion = false;\n\tlet hasComputedFields = false;\n\t\n\tfor (const key of keys) {\n\t\tif (key === '_id') continue;\n\t\tconst value = projection[key];\n\t\t\n\t\tif (value === 1 || value === true) {\n\t\t\tisInclusion = true;\n\t\t} else if (value === 0 || value === false) {\n\t\t\tisExclusion = true;\n\t\t} else {\n\t\t\t// Computed field (expression)\n\t\t\thasComputedFields = true;\n\t\t}\n\t}\n\t\n\t// Handle computed fields - they imply inclusion mode\n\tif (hasComputedFields || isInclusion) {\n\t\t// Inclusion mode: only include specified fields\n\t\t// Always include _id unless explicitly excluded\n\t\tif (projection._id !== 0 && projection._id !== false) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tconst value = projection[key];\n\t\t\t\n\t\t\tif (key === '_id') {\n\t\t\t\tif (value === 0 || value === false) {\n\t\t\t\t\tdelete result._id;\n\t\t\t\t}\n\t\t\t} else if (value === 1 || value === true) {\n\t\t\t\t// Simple field inclusion\n\t\t\t\tresult[key] = getProp(doc, key);\n\t\t\t} else {\n\t\t\t\t// Computed field (expression)\n\t\t\t\tresult[key] = evaluateExpression(value, doc);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Exclusion mode: include all fields except specified ones\n\t\tfor (const key in doc) {\n\t\t\tif (doc.hasOwnProperty(key)) {\n\t\t\t\tresult[key] = doc[key];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tif (projection[key] === 0 || projection[key] === false) {\n\t\t\t\tdelete result[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\n","/**\n * DocumentStore - In-memory document storage for collections\n * Simple key-value store using a plain JavaScript object\n */\nexport class DocumentStore {\n\tconstructor() {\n\t\tthis.data = new Map();\n\t}\n\n\tclear() {\n\t\tthis.data = new Map();\n\t}\n\n  keys() {\n    return this.data.keys();\n  }\n\n\tget(index) {\n\t\treturn this.data.get(index);\n\t}\n\n\tremove(key) {\n\t\tthis.data.delete(key);\n\t}\n\n\tset(key, value) {\n\t\tthis.data.set(key, value);\n\t}\n\n\tsize() {\n\t\treturn this.data.size;\n\t}\n}\n","/**\n * IndexStore - In-memory index storage for collections\n * \n * Simple key-value store using a plain JavaScript object\n */\nexport class IndexStore {\n\tconstructor(meta) {\n    this._meta = new Map();\n\t\tthis._data = new Map();\n    \n    if (meta) {\n      for (const [key, value] of Object.entries(meta)) {\n        this._meta.set(key, value);\n      }\n    }\n\t}\n\n  /**\n   * Return all metadata as a plain object\n   */\n  getAllMeta() {\n    const meta = {};\n    for (const [key, value] of this._meta) {\n      meta[key] = value;\n    }\n    return meta;\n  }\n\n\tsetMeta(key, value) {\n\t\tthis._meta.set(key, value);\n\t}\n\n  hasMeta(key) {\n    return this._meta.has(key);\n  }\n\n  getMeta(key) {\n\t\treturn this._meta.get(key);\n\t}\n\n  hasDataMap(name) {\n    return this._data.has(name);\n  }\n\n  getDataMap(name) {\n    if (!this._data.has(name)) {\n      this._data.set(name, new Map());\n    }\n    return this._data.get(name);\n  }\n\n\t// clear() {\n\t// \tthis._data.clear();\n\t// }\n\n  // keys() {\n  //   return this._data.keys();\n  // }\n\n  // has(index) {\n  //   return this._data.has(index);\n  // }\n\n\t// get(index) {\n\t// \treturn this._data.get(index);\n\t// }\n\n\t// remove(key) {\n\t// \tthis._data.delete(key);\n\t// }\n\n\t// set(key, value) {\n\t// \tthis._data.set(key, value);\n\t// }\n\n\t// size() {\n\t// \treturn this._data.size;\n\t// }\n}\n","import { DocumentStore } from './DocumentStore.js';\nimport { IndexStore } from './IndexStore.js';\n\n/**\n * CollectionStore - Unified storage for collection documents and indexes\n * \n * Provides:\n * - Document storage (via DocumentStore)\n * - Index data storage (plain objects for each index)\n * - Unified interface for Collection to manage all its data\n */\nexport class CollectionStore {\n\tconstructor() {\n\n\t\t// Document storage - uses DocumentStore for document CRUD operations\n\t\tthis.documents = new DocumentStore();\n\t\t\n\t\t// Index storage - plain object to store index data\n\t\t// Structure: { indexName: indexDataObject }\n\t\tthis.indexes = new Map();\n\t}\n\n\t/**\n\t * Clear all documents and indexes\n\t */\n\tclear() {\n\t\tthis.documents.clear();\n    this.indexes.clear();\n\t}\n\n  /**\n   * Get all document keys\n   * @returns {[string]} Array of document keys\n   */\n  documentKeys() {\n    return this.documents.keys();\n  }\n\n\t/**\n\t * Get all documents as an array\n\t * @returns {Array} Array of all documents\n\t */\n\tgetAllDocuments() {\n\t\treturn Array.from(this.documents.data.values());\n\t}\n\n\t/**\n\t * Get document by ID\n\t * @param {string} docId - Document ID\n\t * @returns {Object|undefined} Document or undefined\n\t */\n\tget(key) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n\t\treturn this.documents.get(key);\n\t}\n\n\t/**\n\t * \n\t */\n\tset(key, value) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n    this.documents.set(key, value);\n\t}\n\n\t/**\n\t * \n\t */\n\tremove(key) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n\t\tthis.documents.remove(key);\n\t}\n\n\t/**\n\t *\n\t */\n\tsize() {\n\t\treturn this.documents.size();\n\t}\n\n\t/**\n\t * Get entire document store (for export/save)\n\t * @returns {Object} Document store object\n\t */\n\tgetStore() {\n\t\tconst store = {};\n\t\tfor (const key of this.documents.keys()) {\n\t\t\tstore[key] = this.documents.get(key);\n\t\t}\n\t\treturn store;\n\t}\n\n\t// ==========================================\n\t// Index Storage Interface\n\t// ==========================================\n\n  indexesCount() {\n    return this.indexes.size;\n  }\n\n  indexKeys() {\n    return this.indexes.keys();\n  }\n\n\t/**\n\t * Get index data for a specific index\n\t * @param {string} indexName - Name of the index\n\t * @returns {Object} Index data object (or creates empty one if doesn't exist)\n\t */\n\tcreateIndexStore(name,meta) {\n\t\tif (!this.indexes.has(name)) {\n\t\t\tthis.indexes.set(name, new IndexStore(meta));\n\t\t}\n\t\treturn this.indexes.get(name);\n\t}\n\n}\n","import { CollectionStore } from './CollectionStore.js';\n\n/**\n * In-memory storage engine (default)\n */\nexport class StorageEngine {\n\tconstructor() {\n\t\tthis.collections = new Map();\n\t}\n\n  collectionsCount() {\n    return this.collections.size;\n  }\n  \n  /**\n   * \n   * @returns {[string]} list of collection names\n   */\n  collectionStoreKeys() {\n    return this.collections.keys();\n  }\n\n  /**\n   * \n   * @param {*} collectionName \n   * @returns \n   */\n  getCollectionStore(collectionName) {\n    return this.collections.get(collectionName);\n  }\n\n\t/**\n\t * Create a collection's state\n\t * @param {string} collectionName - The collection name\n\t * @returns {CollectionStore} The collection store\n\t */\n\tcreateCollectionStore(collectionName) {\n    if (this.collections.has(collectionName)) {\n      return this.collections.get(collectionName);\n    }\n    const collectionStore = new CollectionStore();\n    this.collections.set(collectionName, collectionStore);\n    return collectionStore;\n  }\n\n\t/**\n\t * Delete a collection\n\t * @param {string} collectionName - The collection name\n\t */\n\tremoveCollectionStore(collectionName) {\n    this.collections.delete(collectionName);\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @returns {Promise<void>}\n\t */\n\tsave() {\n\t\t// In-memory storage does not persist data\n\t}\n\n}\n","import { Collection } from './Collection.js';\nimport { StorageEngine } from './StorageEngine.js';\nimport { ObjectId } from 'bjson';\nimport { ChangeStream } from './ChangeStream.js';\nimport { NotImplementedError } from './errors.js';\n\n/**\n * DB class\n */\nexport class DB {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t\tthis.dbName = this.options.dbName || 'default';\n\t\t\t\n\t\t// StorageEngine\n\t\tthis.storageEngine = this.options.storageEngine || new StorageEngine();\n\n\t\t// Load existing collections from storage engine\n\t\tthis._loadExistingCollections();\n\n\t\t// Return a Proxy to enable dynamic collection creation\n\t\treturn new Proxy(this, {\n\t\t\tget(target, property, receiver) {\n\t\t\t\t// If property exists on target (including undefined values), return it\n\t\t\t\tif (property in target) {\n\t\t\t\t\treturn Reflect.get(target, property, receiver);\n\t\t\t\t}\n\n\t\t\t\t// If property is a symbol or special property, return undefined\n\t\t\t\tif (typeof property === 'symbol' || property.startsWith('_')) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n        // For collection names, create the collection if it doesn't exist\n        // Only auto-create if it's a valid collection name and doesn't already exist\n        if (typeof property === 'string') {\n          // Don't auto-create if property was explicitly deleted\n          if (Object.prototype.hasOwnProperty.call(target, property)) {\n            return target[property];\n          }\n          // Auto-create the collection\n          target.createCollection(property);\n          return target[property];\n        }\n        return undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Log function\n\t */\n\t_log(msg) {\n\t\tif (this.options && this.options.print) this.options.print(msg);\n\t\telse console.log(msg);\n\t}\n\n\t/**\n\t * ID generator function\n\t */\n\t_id() {\n\t\tif (this.options && this.options.id) return this.options.id();\n\t\telse return new ObjectId();\n\t}\n\n\t/**\n\t * Load existing collections from storage engine\n\t * @private\n\t */\n\t_loadExistingCollections() {\n\t\t// Iterate through all collection stores in the storage engine\n\t\tfor (const collectionName of this.storageEngine.collectionStoreKeys()) {\n\t\t\tconst collectionStore = this.storageEngine.getCollectionStore(collectionName);\n\t\t\t// Create Collection instance for each existing collection\n\t\t\tthis[collectionName] = new Collection(\n\t\t\t\tthis,\n\t\t\t\tcollectionName,\n\t\t\t\tcollectionStore,\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Close all collections\n\t */\n\tasync close() {\n\t\t// Iterate through all collection properties and close them\n\t\tfor (const key of Object.keys(this)) {\n\t\t\tconst collection = this[key];\n\t\t\tif (collection && collection.isCollection && typeof collection.close === 'function') {\n\t\t\t\tawait collection.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t// DB Methods\n\tcloneCollection() { throw new NotImplementedError('cloneCollection', { database: this.dbName }); }\n\tcloneDatabase() { throw new NotImplementedError('cloneDatabase', { database: this.dbName }); }\n\tcommandHelp() { throw new NotImplementedError('commandHelp', { database: this.dbName }); }\n\tcopyDatabase() { throw new NotImplementedError('copyDatabase', { database: this.dbName }); }\n\n\tcreateCollection(name) {\n\t\tif (!name) return;\n\t\tthis[name] = new Collection(\n\t\t\tthis,\n      name,\n\t\t\tthis.storageEngine.createCollectionStore(name),\n\t\t\tthis._id.bind(this)\n\t\t);\n\t}\n\n\t/**\n\t * Get or create a collection by name (MongoDB-compatible method)\n\t * @param {string} name - Collection name\n\t * @returns {Collection} The collection instance\n\t */\n\tcollection(name) {\n\t\tif (!name) throw new Error('Collection name is required');\n\t\t\n\t\t// Return existing collection if it exists\n\t\tif (this[name] && this[name].isCollection) {\n\t\t\treturn this[name];\n\t\t}\n\t\t\n\t\t// Create and return new collection\n\t\tthis.createCollection(name);\n\t\treturn this[name];\n\t}\n\n\tcurrentOp() { throw new NotImplementedError('currentOp', { database: this.dbName }); }\n\n\tasync dropCollection(collectionName) {\n\t\tif (this[collectionName]) {\n\t\t\t// Close/clear collection data\n\t\t\tif (typeof this[collectionName].drop === 'function') {\n\t\t\t\tawait this[collectionName].drop();\n\t\t\t}\n\t\t\t// Remove from storage engine\n\t\t\tthis.storageEngine.removeCollectionStore(collectionName);\n\t\t\t// Delete the collection property from DB\n\t\t\tdelete this[collectionName];\n\t\t}\n\t}\n\n\tasync dropDatabase() {\n\t\t// Get all collection names\n\t\tconst collectionNames = this.getCollectionNames();\n\t\t\n\t\t// Close and drop each collection\n\t\tfor (const name of collectionNames) {\n\t\t\t// Close collection (which closes all indexes)\n\t\t\tif (this[name] && typeof this[name].close === 'function') {\n\t\t\t\tawait this[name].close();\n\t\t\t}\n\t\t\t// Remove from storage engine\n\t\t\tthis.storageEngine.removeCollectionStore(name);\n\t\t\t// Delete the collection property from DB\n\t\t\tdelete this[name];\n\t\t}\n\t}\n\n\teval() { throw new NotImplementedError('eval', { database: this.dbName }); }\n\tfsyncLock() { throw new NotImplementedError('fsyncLock', { database: this.dbName }); }\n\tfsyncUnlock() { throw new NotImplementedError('fsyncUnlock', { database: this.dbName }); }\n\tgetCollection() { throw new NotImplementedError('getCollection', { database: this.dbName }); }\n\tgetCollectionInfos() { throw new NotImplementedError('getCollectionInfos', { database: this.dbName }); }\n\n\tgetCollectionNames() {\n\t\tconst names = [];\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tnames.push(key);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tgetLastError() { throw new NotImplementedError('getLastError', { database: this.dbName }); }\n\tgetLastErrorObj() { throw new NotImplementedError('getLastErrorObj', { database: this.dbName }); }\n\tgetLogComponents() { throw new NotImplementedError('getLogComponents', { database: this.dbName }); }\n\tgetMongo() { throw new NotImplementedError('getMongo', { database: this.dbName }); }\n\tgetName() { throw new NotImplementedError('getName', { database: this.dbName }); }\n\tgetPrevError() { throw new NotImplementedError('getPrevError', { database: this.dbName }); }\n\tgetProfilingLevel() { throw new NotImplementedError('getProfilingLevel', { database: this.dbName }); }\n\tgetProfilingStatus() { throw new NotImplementedError('getProfilingStatus', { database: this.dbName }); }\n\tgetReplicationInfo() { throw new NotImplementedError('getReplicationInfo', { database: this.dbName }); }\n\tgetSiblingDB() { throw new NotImplementedError('getSiblingDB', { database: this.dbName }); }\n\n\thelp() {\n\t\tthis._log(\"        help mr                      mapreduce\");\n\t\tthis._log(\"        db.foo.find()                list objects in collection foo\");\n\t\tthis._log(\"        db.foo.find( { a : 1 } )     list objects in foo where a == 1\");\n\t\tthis._log(\"        it                           result of the last line evaluated; use to further iterate\");\n\t}\n\n\thostInfo() { throw new NotImplementedError('hostInfo', { database: this.dbName }); }\n\tisMaster() { throw new NotImplementedError('isMaster', { database: this.dbName }); }\n\tkillOp() { throw new NotImplementedError('killOp', { database: this.dbName }); }\n\tlistCommands() { throw new NotImplementedError('listCommands', { database: this.dbName }); }\n\tloadServerScripts() { throw new NotImplementedError('loadServerScripts', { database: this.dbName }); }\n\tlogout() { throw new NotImplementedError('logout', { database: this.dbName }); }\n\tprintCollectionStats() { throw new NotImplementedError('printCollectionStats', { database: this.dbName }); }\n\tprintReplicationInfo() { throw new NotImplementedError('printReplicationInfo', { database: this.dbName }); }\n\tprintShardingStatus() { throw new NotImplementedError('printShardingStatus', { database: this.dbName }); }\n\tprintSlaveReplicationInfo() { throw new NotImplementedError('printSlaveReplicationInfo', { database: this.dbName }); }\n\trepairDatabase() { throw new NotImplementedError('repairDatabase', { database: this.dbName }); }\n\tresetError() { throw new NotImplementedError('resetError', { database: this.dbName }); }\n\trunCommand() { throw new NotImplementedError('runCommand', { database: this.dbName }); }\n\tserverBuildInfo() { throw new NotImplementedError('serverBuildInfo', { database: this.dbName }); }\n\tserverCmdLineOpts() { throw new NotImplementedError('serverCmdLineOpts', { database: this.dbName }); }\n\tserverStatus() { throw new NotImplementedError('serverStatus', { database: this.dbName }); }\n\tsetLogLevel() { throw new NotImplementedError('setLogLevel', { database: this.dbName }); }\n\tsetProfilingLevel() { throw new NotImplementedError('setProfilingLevel', { database: this.dbName }); }\n\tshutdownServer() { throw new NotImplementedError('shutdownServer', { database: this.dbName }); }\n\tstats() { throw new NotImplementedError('stats', { database: this.dbName }); }\n\tversion() { throw new NotImplementedError('version', { database: this.dbName }); }\n\tupgradeCheck() { throw new NotImplementedError('upgradeCheck', { database: this.dbName }); }\n\tupgradeCheckAllDBs() { throw new NotImplementedError('upgradeCheckAllDBs', { database: this.dbName }); }\n\n\t/**\n\t * Watch for changes across all collections in this database\n\t * @param {Array} pipeline - Aggregation pipeline to filter changes\n\t * @param {Object} options - Watch options\n\t * @returns {ChangeStream} A change stream instance\n\t */\n\twatch(pipeline = [], options = {}) {\n\t\treturn new ChangeStream(this, pipeline, options);\n\t}\n}\n","import { EventEmitter } from 'events';\r\nimport { DB } from './DB.js';\r\nimport { ChangeStream } from './ChangeStream.js';\r\n\r\nexport class MongoClient extends EventEmitter {\r\n  constructor(uri = 'mongodb://localhost:27017', options = {}) {\r\n    super();\r\n    this.uri = uri;\r\n    this.options = Object.freeze({ ...options }); // Make immutable\r\n    this._isConnected = false;\r\n    this._defaultDb = this._parseDefaultDbName(uri);\r\n    this._databases = new Map(); // Track database instances\r\n  }\r\n\r\n  static async connect(uri, options = {}) {\r\n    const client = new MongoClient(uri, options);\r\n    await client.connect();\r\n    return client;\r\n  }\r\n\r\n  async connect() {\r\n    if (this._isConnected) return this;\r\n    \r\n    this._isConnected = true;\r\n    this.emit('open', this);\r\n    return this;\r\n  }\r\n\r\n  db(name, opts = {}) {\r\n    // Use default from URI if no name provided\r\n    const dbName = name || this._defaultDb;\r\n    if (!dbName) {\r\n      throw new Error('No database name provided and no default in connection string');\r\n    }\r\n    \r\n    // Return cached database instance if it exists\r\n    if (this._databases.has(dbName)) {\r\n      return this._databases.get(dbName);\r\n    }\r\n    \r\n    const dbOptions = { ...this.options, ...opts, dbName };\r\n    const database = new DB(dbOptions);\r\n    this._databases.set(dbName, database);\r\n    return database;\r\n  }\r\n\r\n  async close(force = false) {\r\n    if (!this._isConnected) return;\r\n    \r\n    // Close all database connections (which closes all collections and indexes)\r\n    for (const [dbName, database] of this._databases) {\r\n      if (database && typeof database.close === 'function') {\r\n        await database.close();\r\n      }\r\n    }\r\n    this._databases.clear();\r\n    \r\n    this._isConnected = false;\r\n    this.emit('close');\r\n  }\r\n\r\n  // Session management stubs\r\n  startSession(options = {}) {\r\n    // Return minimal session object for compatibility\r\n    return {\r\n      id: crypto.randomUUID(),\r\n      endSession: () => {},\r\n      withTransaction: async (fn) => await fn(this)\r\n    };\r\n  }\r\n\r\n  async withSession(optionsOrExecutor, executor) {\r\n    const session = this.startSession(\r\n      typeof optionsOrExecutor === 'function' ? {} : optionsOrExecutor\r\n    );\r\n    const fn = typeof optionsOrExecutor === 'function' ? optionsOrExecutor : executor;\r\n    \r\n    try {\r\n      return await fn(session);\r\n    } finally {\r\n      session.endSession();\r\n    }\r\n  }\r\n\r\n  // Configuration getters\r\n  get readConcern() { return this.options.readConcern; }\r\n  get writeConcern() { return this.options.writeConcern; }\r\n  get readPreference() { return this.options.readPreference; }\r\n\r\n  /**\r\n   * Watch for changes across all databases and collections\r\n   * @param {Array} pipeline - Aggregation pipeline to filter changes\r\n   * @param {Object} options - Watch options\r\n   * @returns {ChangeStream} A change stream instance\r\n   */\r\n  watch(pipeline = [], options = {}) {\r\n    return new ChangeStream(this, pipeline, options);\r\n  }\r\n\r\n  _parseDefaultDbName(uri) {\r\n    // Parse mongodb://host:port/dbname format\r\n    const match = uri.match(/\\/([^/?]+)/);\r\n    return match ? match[1] : null;\r\n  }\r\n}","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * IndexedDB-based storage engine for persistent storage\n * Stores each collection separately in IndexedDB\n */\nexport class IndexedDbStorageEngine extends StorageEngine {\n\tconstructor(dbName = 'micro-mongo') {\n\t\tsuper();\n\t\tthis.dbName = dbName;\n\t\tthis.db = null;\n\t\tthis.indexedDBName = `micro-mongo-${dbName}`;\n\t}\n\n\t/**\n\t * Initialize the IndexedDB connection\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open(this.indexedDBName, 1);\n\n\t\t\trequest.onerror = () => {\n\t\t\t\treject(new Error('Failed to open IndexedDB: ' + request.error));\n\t\t\t};\n\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tthis.db = request.result;\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = event.target.result;\n\t\t\t\t\n\t\t\t\t// Create object stores for collections and metadata\n\t\t\t\tif (!db.objectStoreNames.contains('collections')) {\n\t\t\t\t\tdb.createObjectStore('collections', { keyPath: 'name' });\n\t\t\t\t}\n\t\t\t\tif (!db.objectStoreNames.contains('metadata')) {\n\t\t\t\t\tdb.createObjectStore('metadata', { keyPath: 'key' });\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\t// Save metadata\n\t\tconst transaction = this.db.transaction(['metadata'], 'readwrite');\n\t\tconst metadataStore = transaction.objectStore('metadata');\n\t\t\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst request = metadataStore.put({\n\t\t\t\tkey: 'dbName',\n\t\t\t\tvalue: dbState.name\n\t\t\t});\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\n\t\t// Save each collection\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tawait this.saveCollection(dbState.name, collectionName, dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.getAll();\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst collections = {};\n\t\t\t\tfor (const collectionData of request.result) {\n\t\t\t\t\tcollections[collectionData.name] = {\n\t\t\t\t\t\tdocuments: collectionData.documents || [],\n\t\t\t\t\t\tindexes: collectionData.indexes || []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolve({\n\t\t\t\t\tname: dbName,\n\t\t\t\t\tcollections: collections\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.put({\n\t\t\t\tname: collectionName,\n\t\t\t\tdocuments: collectionState.documents || [],\n\t\t\t\tindexes: collectionState.indexes || []\n\t\t\t});\n\t\t\t\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.get(collectionName);\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tif (request.result) {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tdocuments: request.result.documents || [],\n\t\t\t\t\t\tindexes: request.result.indexes || []\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.delete(collectionName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.deleteDatabase(this.indexedDBName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\t}\n}\n"],"names":["ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","eventsModule","exports","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","TYPE","ObjectId","constructor","id","generate","isValid","toLowerCase","Uint8Array","from","map","b","toString","padStart","join","toHexString","getTimestamp","timestamp","parseInt","substring","Date","equals","other","compare","localeCompare","toJSON","inspect","toBytes","bytes","test","createFromTime","tsHex","Math","floor","ts","now","rand","crypto","getRandomValues","tail","random","padEnd","Pointer","offset","isInteger","MAX_SAFE_INTEGER","valueOf","encode","buffers","encodeValue","val","buffer","ArrayBuffer","DataView","setBigInt64","BigInt","getTime","setBigUint64","isSafeInteger","setFloat64","encoded","TextEncoder","lengthBuffer","setUint32","isArray","tempBuffers","startLength","item","elementBuffers","splice","contentSize","reduce","sum","buf","sizeBuffer","keyLengthBuffer","kvBuffers","totalLength","result","decode","data","decodeValue","byteOffset","getBigInt64","MIN_SAFE_INTEGER","getFloat64","getUint32","stringData","TextDecoder","oidBytes","pointerOffset","getBigUint64","size","obj","keyLength","keyData","BJsonFile","filename","root","fileHandle","file","mode","isOpen","open","navigator","storage","getDirectory","getFileHandle","getFile","close","ensureOpen","ensureWritable","refreshFile","readRange","start","arrayBuffer","getFileSize","write","binaryData","writable","createWritable","read","pointer","fileSize","pointerValue","append","existingSize","keepExistingData","seek","scan","getValueSize","async","readPosition","tempData","valueSize","valueData","removeEntry","exists","valuesEqual","a","o","out","v","getProp","path","split","pathSegment","numericIndex","getFieldValues","results","newResults","j","current","k","filter","setProp","indexOf","remainingPath","nextSegment","nextNumeric","setPropWithAllPositional","lastSegment","lastNumericIndex","toArray","hasOwnProperty","el","isIn","values","arrayMatches","x","y","objectMatches","p","applyProjection","projection","doc","hasInclusion","hasExclusion","$err","code","_id","fieldPath","pathParts","parent","ErrorCodes","OK","INTERNAL_ERROR","BAD_VALUE","NO_SUCH_KEY","GRAPH_CONTAINS_CYCLE","HOST_UNREACHABLE","HOST_NOT_FOUND","UNKNOWN_ERROR","FAILED_TO_PARSE","CANNOT_MUTATE_OBJECT","USER_NOT_FOUND","UNSUPPORTED_FORMAT","UNAUTHORIZED","TYPE_MISMATCH","OVERFLOW","INVALID_LENGTH","PROTOCOL_ERROR","AUTHENTICATION_FAILED","ILLEGAL_OPERATION","NAMESPACE_NOT_FOUND","INDEX_NOT_FOUND","PATH_NOT_VIABLE","CANNOT_CREATE_INDEX","INDEX_ALREADY_EXISTS","INDEX_EXISTS","COMMAND_NOT_FOUND","NAMESPACE_EXISTS","INVALID_NAMESPACE","INDEX_OPTIONS_CONFLICT","INVALID_INDEX_SPECIFICATION_OPTION","WRITE_CONFLICT","DUPLICATE_KEY","DUPLICATE_KEY_UPDATE","DOCUMENT_VALIDATION_FAILURE","BAD_QUERY","CANNOT_INDEX_PARALLEL_ARRAYS","CURSOR_NOT_FOUND","COLLECTION_IS_EMPTY","NOT_IMPLEMENTED","OPERATION_NOT_SUPPORTED","MongoError","options","super","codeName","_getCodeName","collection","database","operation","query","document","field","captureStackTrace","json","indexName","namespace","cursorId","feature","keyPattern","keyValue","writeErrors","MongoServerError","MongoDriverError","WriteError","DuplicateKeyError","keyStr","JSON","stringify","ValidationError","validationErrors","IndexError","IndexExistsError","IndexNotFoundError","CannotCreateIndexError","reason","QueryError","TypeMismatchError","expectedType","actualType","NamespaceError","NamespaceNotFoundError","InvalidNamespaceError","CursorError","CursorNotFoundError","NotImplementedError","OperationNotSupportedError","BadValueError","BulkWriteError","MongoNetworkError","Cursor","documents","SortedCursor","pos","_limit","_skip","_closed","batchSize","_batchSize","comment","commentString","_comment","explain","verbosity","queryPlanner","plannerVersion","db","indexFilterSet","parsedQuery","winningPlan","stage","direction","executionStats","executionSuccess","nReturned","executionTimeMillis","totalKeysExamined","totalDocsExamined","ok","forEach","fn","hasNext","next","effectiveMax","min","hint","_hint","itcount","limit","_max","maxScan","_maxScan","maxTimeMS","ms","_maxTimeMS","max","indexBounds","_maxIndexBounds","_minIndexBounds","noCursorTimeout","_noCursorTimeout","objsLeftInBatch","pretty","_pretty","readConcern","level","_readConcern","readPref","tagSet","_readPref","returnKey","enabled","_returnKey","showRecordId","_showRecordId","remaining","maxPos","skip","num","isClosed","snapshot","sort","s","allowDiskUse","_allowDiskUse","collation","collationDocument","_collation","tailable","Symbol","asyncIterator","cursor","sortSpec","items","sortKeys","step2list","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3list","icate","ative","alize","iciti","ical","ful","ness","vowel","consonants","vowels","gt0","RegExp","eq1","gt1","vowelInStem","consonantLike","sfxLl","sfxE","sfxY","sfxIon","sfxEdOrIng","sfxAtOrBlOrIz","sfxEED","sfxS","sfxSsesOrIes","sfxMultiConsonantLike","step2","step3","step4","stemmer","match","firstCharacterWasLowerCaseY","codePointAt","exec","NodeData","isLeaf","children","BPlusTree","order","minKeys","ceil","rootPointer","nextNodeId","_size","_loadMetadata","_initializeNewTree","_saveMetadata","rootNode","_saveNode","metadata","version","maxEntries","minEntries","nextId","metadataOffset","node","_loadNode","_loadRoot","search","_searchNode","child","add","_addToNode","newRoot","newNode","leftPointer","left","rightPointer","right","splitKey","existingIdx","insertIdx","mid","leftKeys","leftValues","rightKeys","rightValues","rightNode","childIdx","childNode","newChildPointer","leftChildren","rightChildren","_deleteFromNode","finalRoot","keyIndex","newKeys","newValues","newChild","newChildren","_collectAllEntries","childPointer","isEmpty","rangeSearch","minKey","maxKey","_rangeSearchNode","getHeight","height","compact","destinationFilename","oldSize","entries","newTree","entry","tempFile","newSize","bytesSaved","newFilename","STOPWORDS","Set","tokenize","text","word","has","TextIndex","baseFilename","trees","documentTerms","documentLengths","all","_ensureOpen","docId","words","termFrequency","Map","stem","frequency","postings","mergedTerms","docLength","remove","terms","term","delete","queryText","scored","requireAll","stemmedTerms","uniqueTerms","docSets","termDocs","intersection","docLengthEntries","docLengthMap","totalDocs","idf","docsWithTerm","log","docScores","termFreq","tf","termIdf","prev","score","docTerms","coverage","r","getTermCount","getDocumentCount","clear","docs","lengths","destinationBase","termsDest","documentsDest","lengthsDest","indexOrder","documentsOrder","lengthsOrder","evaluateExpression","expr","startsWith","charAt","operator","operand","operands","evalAdd","val1","val2","evalSubtract","product","evalMultiply","evalDivide","evalMod","base","exponent","pow","evalPow","sqrt","evalSqrt","abs","evalAbs","evalCeil","evalFloor","trunc","evalTrunc","place","multiplier","round","evalRound","evalConcat","str","substr","evalSubstr","evalToLower","toUpperCase","evalToUpper","input","chars","charsRegex","escapeRegex","replace","trim","evalTrim","evalLtrim","evalRtrim","delimiter","evalSplit","evalStrLenCP","str1","str2","evalStrcasecmp","end","evalIndexOfCP","find","replacement","evalReplaceOne","evalReplaceAll","evalCmp","evalEq","evalNe","evalGt","evalGte","evalLt","evalLte","evalAnd","evalOr","evalNot","ifExpr","thenExpr","elseExpr","if","then","else","condition","evalCond","evalIfNull","branches","branch","case","default","evalSwitch","date","getUTCFullYear","evalYear","getUTCMonth","evalMonth","getUTCDate","evalDayOfMonth","getUTCDay","evalDayOfWeek","UTC","diff","oneDay","evalDayOfYear","getUTCHours","evalHour","getUTCMinutes","evalMinute","getUTCSeconds","evalSecond","getUTCMilliseconds","evalMillisecond","onejan","evalWeek","dayNr","setUTCDate","firstThursday","setUTCMonth","evalIsoWeek","evalIsoWeekYear","format","evalDateToString","evalToDate","idx","evalArrayElemAt","evalConcatArrays","asVar","as","cond","itemDoc","evalFilter","includes","evalIn","evalIndexOfArray","evalIsArray","inExpr","in","evalMap","initialValue","evalReduce","evalSize","evalSlice","reverse","evalReverseArray","inputs","useLongestLength","defaults","arrays","every","maxLength","tuple","evalZip","evalType","to","onError","onNull","parseFloat","Boolean","e","evalConvert","evalToBool","evalToDecimal","evalToDouble","evalToInt","evalToLong","evalToString","evalObjectToArray","evalArrayToObject","assign","evalMergeObjects","evaluateOperator","BSON_TYPES","TYPE_ALIASES","acc","matchesType","typeSpec","typeCode","typeName","toBitMask","positions","mask","matchesBitsAllSet","matchesBitsAllClear","matchesBitsAnySet","matchesBitsAnyClear","validateJsonSchema","schema","docType","required","properties","propSchema","minimum","maximum","minLength","pattern","enum","compareValues","aVal","bVal","fieldValueMatches","fieldValue","checkFn","tokenizeText","prop","propTokens","some","geoWithin","minLon","maxLat","maxLon","isGeometryWithinBBox","geoJson","minLat","features","geometry","coordinates","lng","lat","ring","coord","extractCoordinatesFromGeoJSON","sumLat","sumLng","haversineDistance","lat1","lng1","lat2","lng2","dLat","PI","dLng","sin","cos","atan2","isNear","refLng","refLat","maxDistanceMeters","coords","geoIntersects","queryGeo","queryCoords","docCoords","pointInPolygon","queryPt","inside","xi","yi","xj","yj","where","tlMatches","opMatches","and","els","or","not","nor","rawValue","$options","regex","$geometry","$maxDistance","arrayFieldValue","found","element","matchesPrimitive","opKeys","op","opValue","matches","sizeFieldValue","matchWithArrayIndices","arrayFilters","matched","andWithTracking","tlMatchesWithTracking","baseField","trackMatchingIndex","opMatchesWithTracking","orWithTracking","norWithTracking","Timestamp","low","high","$timestamp","t","getHighBits","getLowBits","toDate","fromDate","seconds","parseFieldPath","segment","identifier","extractFilteredPositionalIdentifier","isFilteredPositional","applyToFilteredArrayElements","parsedPath","traverse","pathIndex","filterContext","pathInfo","isLastSegment","f","nextPath","applyOperationToValue","shouldUpdate","transformedFilter","hasDirectMatch","container","hasFilteredPositionalOperator","hasAllPositional","applyToAllPositional","updateFn","newValue","replacePositionalOperator","parts","dollarIndex","pathBeforeDollar","matchedIndex","filterPath","applyUpdates","updates","setOnInsert","positionalMatchInfo","userArrayFilters","fields","amount","currentValue","$type","addValue","currentArray","popValue","src","notRemoved","shouldRemove","__temp","toRemove","removed","l","pushValue","$each","$position","$slice","$sort","valuesToPush","sortKey","sortDir","sliceValue","createDocFromUpdate","idGenerator","newDoc","onlyFields","updateKeys","queryKeys","Index","update","oldDoc","getSpec","serialize","deserialize","RegularCollectionIndex","storageFilePath","opfsRoot","extractIndexKey","keyFields","keyParts","indexKey","docIds","filtered","indexFields","queryValue","_queryWithOperators","operators","ops","hasGt","hasLt","minValue","Infinity","maxValue","rangeResults","allEntries","excludeValue","TextCollectionIndex","textIndex","indexedFields","_extractText","textParts","searchText","textIndexVersion","weights","_getWeights","intersects","bbox1","bbox2","maxLng","minLng","area","bbox","union","enlargement","RTreeNode","rtree","nodeData","updateBBox","RTree","_loadFromFile","_writeMetadata","insert","objectId","_insert","pointers","pointer1","pointer2","_split","targetPointer","_chooseSubtree","targetNode","childIndex","minEnlargement","minArea","enl","ar","maxDist","seed1Idx","seed2Idx","node1","node2","dist","enl1","enl2","searchBBox","_searchBBox","searchRadius","radiusKm","latDelta","lngDelta","radiusToBoundingBox","_searchBBoxEntries","distance","_remove","underflow","initialLength","updatedChildren","handled","_handleUnderflow","merged","updatedNode","parentNode","childResult","siblings","prevPointer","prevNode","nextPointer","nextNode","sibling","allChildren","newChild1Children","newChild2Children","newChild1","newChild2","minIndex","maxIndex","mergedChildren","mergedNode","mergedPointer","_","dest","pointerMap","cloneNode","sourceNode","clonedChildren","newChildPtr","clonedNode","newPointer","newRootPointer","GeospatialCollectionIndex","_idMap","_objectIdMap","geoField","_normalizeObjectId","_createDeterministicObjectId","_toDocId","mapped","hash","charCodeAt","imul","hex","idHex","_extractCoordinates","geoValue","geoQuery","$geoWithin","$near","nearQuery","maxDistanceKm","$nearSphere","$geoIntersects","intersectsQuery","epsilon","_pointInPolygon","_haversineDistance","QueryPlan","indexes","indexScans","estimatedCost","indexOnly","QueryPlanner","plan","analysis","_analyzeQuery","hasTextSearch","textPlan","_planTextSearch","hasGeoQuery","geoPlan","_planGeoQuery","andPlan","_planAndQuery","orPlan","_planOrQuery","simplePlan","_planSimpleQuery","conditions","$and","subAnalysis","$or","textQuery","_extractTextQuery","$text","$search","indexableConditions","conditionPlan","_canIndexHandleQuery","_executeIndexScan","execute","sorted","currentSet","ChangeStream","pipeline","closed","_changeCounter","_startWatching","collections","_getCollectionsToWatch","_watchCollection","_interceptDBCollectionCreation","_interceptClientDBCreation","_monitorClient","collectionNames","getCollectionNames","isCollection","_monitorDB","handlers","_emitChange","updateDescription","operationType","changeEvent","_createChangeEvent","_matchesPipeline","event","_data","Buffer","clusterTime","ns","dbName","coll","documentKey","fullDocument","updatedFields","removedFields","truncatedArrays","$match","_getNestedValue","part","client","originalDb","self","_watchedDBs","opts","colName","col","_interceptDBCollectionCreationForClient","_originalClientMethods","originalCollection","originalCreateCollection","createCollection","_originalDBMethods","queue","resolveNext","streamClosed","onChange","change","done","onClose","cleanup","Collection","_restoreIndexesFromStorage","iterator","indexStore","meta","getAllMeta","storageFile","_ensureIndexOpen","generateIndexName","isTextIndex","isGeospatialIndex","_getIndexBaseFilename","sanitize","buildIndex","createIndexStore","allDocs","getAllDocuments","updateIndexesOnInsert","promises","updateIndexesOnDelete","planQuery","useIndex","planType","indexNames","planQueryAsync","getTextIndex","aggregate","stageKeys","stageType","stageSpec","projected","applyProjectionWithExpressions","modified","fieldsToRemove","groups","groupId","accumulators","grouped","groupKey","group","accumulator","accKeys","accType","accExpr","valKey","mean","variance","unwound","unwoundDoc","newRootSpec","shuffled","groupBy","boundaries","defaultBucket","output","$sum","buckets","placed","bucketed","bucketKey","bucket","numBuckets","bucketSize","startIdx","endIdx","bucketDocs","targetCollectionName","dropCollection","targetCollection","whenMatched","whenNotMatched","into","matchField","matchValue","existingCursor","localField","foreignField","fromCollection","joined","localValue","foreignCursor","startWith","connectFromField","connectToField","maxDepth","depthField","restrictSearchWithMatch","graphed","startValue","visited","depth","valueKey","matchCopy","nextValue","facetResult","facetName","facetPipeline","facetResults","facetStage","facetStageKeys","facetStageType","facetStageSpec","redacted","decision","near","distanceField","maxDistance","minDistance","spherical","withDistances","location","deltaLat","deltaLon","dx","dy","bulkWrite","copyTo","destCollectionName","destCol","numCopied","c","insertOne","createIndex","existingIndex","dataSize","deleteOne","findOne","deletedCount","deleteMany","ids","distinct","vals","d","drop","dropIndex","nIndexesWas","dropIndexes","msg","ensureIndex","normalizedQuery","nearSpec","_extractNearSpec","seen","_sortByNearDistance","_parseNearCoordinates","spec","_extractPointCoordinates","targetLat","targetLng","aPoint","bPoint","findAndModify","findOneAndDelete","findOneAndReplace","returnNewDocument","findOneAndUpdate","clone","getIndexes","getShardDistribution","getShardVersion","getStore","insertMany","insertedId","insertedIds","isCapped","mapReduce","reIndex","replaceOne","matchedCount","modifiedCount","upsert","upsertedId","justOne","renameCollection","save","stats","storageSize","totalSize","totalIndexSize","multi","updateOne","originalDoc","parse","_getUpdateDescription","updateMany","validate","updatedDoc","watch","isInclusion","hasComputedFields","DocumentStore","IndexStore","_meta","setMeta","hasMeta","getMeta","hasDataMap","getDataMap","CollectionStore","documentKeys","store","indexesCount","indexKeys","StorageEngine","collectionsCount","collectionStoreKeys","getCollectionStore","collectionName","createCollectionStore","collectionStore","removeCollectionStore","DB","storageEngine","_loadExistingCollections","Proxy","property","_log","print","cloneCollection","cloneDatabase","commandHelp","copyDatabase","currentOp","dropDatabase","eval","fsyncLock","fsyncUnlock","getCollection","getCollectionInfos","names","getLastError","getLastErrorObj","getLogComponents","getMongo","getName","getPrevError","getProfilingLevel","getProfilingStatus","getReplicationInfo","getSiblingDB","help","hostInfo","isMaster","killOp","listCommands","loadServerScripts","logout","printCollectionStats","printReplicationInfo","printShardingStatus","printSlaveReplicationInfo","repairDatabase","resetError","runCommand","serverBuildInfo","serverCmdLineOpts","serverStatus","setLogLevel","setProfilingLevel","shutdownServer","upgradeCheck","upgradeCheckAllDBs","MongoClient","uri","freeze","_isConnected","_defaultDb","_parseDefaultDbName","_databases","connect","dbOptions","force","startSession","randomUUID","endSession","withTransaction","withSession","optionsOrExecutor","executor","session","writeConcern","readPreference","IndexedDbStorageEngine","indexedDBName","initialize","request","indexedDB","onerror","onsuccess","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","saveDatabase","dbState","metadataStore","transaction","objectStore","put","saveCollection","loadDatabase","collectionsStore","getAll","collectionData","collectionState","loadCollection","deleteCollection","deleteDatabase"],"mappings":"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","x_google_ignoreList":[0,1,6,7,8,16]}