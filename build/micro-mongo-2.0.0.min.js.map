{"version":3,"file":"micro-mongo-2.0.0.min.js","sources":["../node_modules/events/events.js","../node_modules/bjson/bjson.js","../src/utils.js","../src/errors.js","../src/Cursor.js","../src/SortedCursor.js","../node_modules/stemmer/index.js","../src/IndexStore.js","../src/TextIndex.js","../src/aggregationExpressions.js","../src/queryMatcher.js","../src/Timestamp.js","../src/updates.js","../src/Index.js","../src/BPlusTree.js","../src/RegularCollectionIndex.js","../src/TextCollectionIndex.js","../src/RTree.js","../src/GeospatialCollectionIndex.js","../src/QueryPlanner.js","../src/ChangeStream.js","../src/Collection.js","../src/DocumentStore.js","../src/CollectionStore.js","../src/StorageEngine.js","../src/DB.js","../src/MongoClient.js","../src/IndexedDbStorageEngine.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Binary JSON Encoder/Decoder\n * \n * Encodes JavaScript values to a compact binary format compatible with\n * Origin Private File System (OPFS).\n */\n\nconst TYPE = {\n  NULL: 0x00,\n  FALSE: 0x01,\n  TRUE: 0x02,\n  INT: 0x03,\n  FLOAT: 0x04,\n  STRING: 0x05,\n  OID: 0x06,\n  DATE: 0x07,\n  ARRAY: 0x10,\n  OBJECT: 0x11\n};\n\n\n/**\n * ObjectId class - MongoDB-compatible 24-character hex string identifier\n * Format: 8-char timestamp + 16-char random data\n */\nclass ObjectId {\n  constructor(id) {\n    if (id === undefined || id === null) {\n      // Generate new ObjectId\n      this.id = ObjectId.generate();\n    } else if (typeof id === 'string') {\n      // Create from hex string\n      if (!ObjectId.isValid(id)) {\n        throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${id}`);\n      }\n      this.id = id.toLowerCase();\n    } else if (id instanceof Uint8Array && id.length === 12) {\n      this.id = Array.from(id).map(b => b.toString(16).padStart(2, '0')).join('');\n    } else if (id instanceof ObjectId) {\n      // Copy constructor\n      this.id = id.id;\n    } else {\n      throw new Error(`Argument passed in must be a string of 24 hex characters or an ObjectId`);\n    }\n  }\n\n  /**\n   * Returns the ObjectId as a 24-character hex string\n   */\n  toString() {\n    return this.id;\n  }\n\n  /**\n   * Returns the ObjectId as a 24-character hex string (alias for toString)\n   */\n  toHexString() {\n    return this.id;\n  }\n\n  /**\n   * Returns the timestamp portion of the ObjectId as a Date\n   */\n  getTimestamp() {\n    const timestamp = parseInt(this.id.substring(0, 8), 16);\n    return new Date(timestamp * 1000);\n  }\n\n  equals(other) {\n    if (!(other instanceof ObjectId)) {\n      throw new Error('Can only compare with another ObjectId');\n    }\n    return this.id === other.id;\n  }\n\n  /**\n   * Compares this ObjectId with another for equality\n   */\n  compare(other) {\n    if (!(other instanceof ObjectId)) {\n      throw new Error('Can only compare with another ObjectId');\n    }\n\n    return this.id.localeCompare(other.id);\n  }\n\n  /**\n   * Returns the ObjectId in JSON format (as hex string)\n   */\n  toJSON() {\n    return this.id;\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return `ObjectId(\"${this.id}\")`;\n  }\n\n  toBytes() {\n    const bytes = new Uint8Array(12);\n    for (let i = 0; i < 12; i++) {\n      bytes[i] = parseInt(this.id.substring(i * 2, i * 2 + 2), 16);\n    }\n    return bytes;\n  }\n\n  /**\n   * Validates if a string is a valid ObjectId hex string\n   */\n  static isValid(id) {\n    if (!id) return false;\n    if (typeof id !== 'string') return false;\n    if (id.length !== 24) return false;\n    return /^[0-9a-fA-F]{24}$/.test(id);\n  }\n\n  /**\n   * Creates an ObjectId from a timestamp\n   */\n  static createFromTime(timestamp) {\n    const ts = Math.floor(timestamp / 1000);\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\n    const tail = '0000000000000000'; // Zero out the random portion\n    return new ObjectId(tsHex + tail);\n  }\n\n  /**\n   * Generates a new ObjectId hex string\n   * Format: 8-char timestamp (4 bytes) + 16-char random data (8 bytes)\n   */\n  static generate() {\n    const ts = Math.floor(Date.now() / 1000);\n    \n    // Generate 8 random bytes\n    const rand = typeof crypto !== 'undefined' && crypto.getRandomValues ? new Uint8Array(8) : null;\n    let tail = '';\n    \n    if (rand) {\n      crypto.getRandomValues(rand);\n      for (let i = 0; i < rand.length; i++) {\n        tail += ('0' + rand[i].toString(16)).slice(-2);\n      }\n    } else {\n      // Fallback for environments without crypto\n      // Generate two 8-character hex strings\n      tail = Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8) +\n             Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8);\n    }\n    \n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\n    return (tsHex + tail).slice(0, 24);\n  }\n}\n\n/**\n * Encode a JavaScript value to binary format\n */\nfunction encode(value) {\n  const buffers = [];\n\n  function encodeValue(val) {\n    if (val === null) {\n      buffers.push(new Uint8Array([TYPE.NULL]));\n    } else if (val === false) {\n      buffers.push(new Uint8Array([TYPE.FALSE]));\n    } else if (val === true) {\n      buffers.push(new Uint8Array([TYPE.TRUE]));\n    } else if (val instanceof ObjectId) {\n      buffers.push(new Uint8Array([TYPE.OID]));\n      buffers.push(val.toBytes());\n    } else if (val instanceof Date) {\n      buffers.push(new Uint8Array([TYPE.DATE]));\n      const buffer = new ArrayBuffer(8);\n      const view = new DataView(buffer);\n      view.setBigInt64(0, BigInt(val.getTime()), true); // little-endian\n      buffers.push(new Uint8Array(buffer));\n    } else if (typeof val === 'number') {\n      if (Number.isInteger(val) && val >= -2147483648 && val <= 2147483647) {\n        // 32-bit signed integer\n        buffers.push(new Uint8Array([TYPE.INT]));\n        const buffer = new ArrayBuffer(4);\n        const view = new DataView(buffer);\n        view.setInt32(0, val, true); // little-endian\n        buffers.push(new Uint8Array(buffer));\n      } else {\n        // 64-bit float\n        buffers.push(new Uint8Array([TYPE.FLOAT]));\n        const buffer = new ArrayBuffer(8);\n        const view = new DataView(buffer);\n        view.setFloat64(0, val, true); // little-endian\n        buffers.push(new Uint8Array(buffer));\n      }\n    } else if (typeof val === 'string') {\n      buffers.push(new Uint8Array([TYPE.STRING]));\n      const encoded = new TextEncoder().encode(val);\n      // Store length as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, encoded.length, true);\n      buffers.push(new Uint8Array(lengthBuffer));\n      buffers.push(encoded);\n    } else if (Array.isArray(val)) {\n      buffers.push(new Uint8Array([TYPE.ARRAY]));\n      // Store array length as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, val.length, true);\n      buffers.push(new Uint8Array(lengthBuffer));\n      // Encode each element\n      for (const item of val) {\n        encodeValue(item);\n      }\n    } else if (typeof val === 'object') {\n      buffers.push(new Uint8Array([TYPE.OBJECT]));\n      const keys = Object.keys(val);\n      // Store number of keys as 32-bit integer\n      const lengthBuffer = new ArrayBuffer(4);\n      const lengthView = new DataView(lengthBuffer);\n      lengthView.setUint32(0, keys.length, true);\n      buffers.push(new Uint8Array(lengthBuffer));\n      // Encode each key-value pair\n      for (const key of keys) {\n        // Encode key as string (without type byte)\n        const encoded = new TextEncoder().encode(key);\n        const keyLengthBuffer = new ArrayBuffer(4);\n        const keyLengthView = new DataView(keyLengthBuffer);\n        keyLengthView.setUint32(0, encoded.length, true);\n        buffers.push(new Uint8Array(keyLengthBuffer));\n        buffers.push(encoded);\n        // Encode value\n        encodeValue(val[key]);\n      }\n    } else {\n      throw new Error(`Unsupported type: ${typeof val}`);\n    }\n  }\n\n  encodeValue(value);\n\n  // Combine all buffers\n  const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buf of buffers) {\n    result.set(buf, offset);\n    offset += buf.length;\n  }\n\n  return result;\n}\n\n/**\n * Decode binary data to JavaScript value\n */\nfunction decode(data) {\n  let offset = 0;\n\n  function decodeValue() {\n    if (offset >= data.length) {\n      throw new Error('Unexpected end of data');\n    }\n\n    const type = data[offset++];\n\n    switch (type) {\n      case TYPE.NULL:\n        return null;\n      \n      case TYPE.FALSE:\n        return false;\n      \n      case TYPE.TRUE:\n        return true;\n      \n      case TYPE.INT: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for INT');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const value = view.getInt32(0, true);\n        offset += 4;\n        return value;\n      }\n      \n      case TYPE.FLOAT: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for FLOAT');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const value = view.getFloat64(0, true);\n        offset += 8;\n        return value;\n      }\n      \n      case TYPE.STRING: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for STRING length');\n        }\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        if (offset + length > data.length) {\n          throw new Error('Unexpected end of data for STRING content');\n        }\n        const stringData = data.slice(offset, offset + length);\n        offset += length;\n        return new TextDecoder().decode(stringData);\n      }\n      \n      case TYPE.OID: {\n        if (offset + 12 > data.length) {\n          throw new Error('Unexpected end of data for OID');\n        }\n        const oidBytes = data.slice(offset, offset + 12);\n        offset += 12;\n        return new ObjectId(oidBytes);\n      }\n      \n      case TYPE.DATE: {\n        if (offset + 8 > data.length) {\n          throw new Error('Unexpected end of data for DATE');\n        }\n        const view = new DataView(data.buffer, data.byteOffset + offset, 8);\n        const timestamp = view.getBigInt64(0, true);\n        offset += 8;\n        return new Date(Number(timestamp));\n      }\n      \n      case TYPE.ARRAY: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for ARRAY length');\n        }\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        const arr = [];\n        for (let i = 0; i < length; i++) {\n          arr.push(decodeValue());\n        }\n        return arr;\n      }\n      \n      case TYPE.OBJECT: {\n        if (offset + 4 > data.length) {\n          throw new Error('Unexpected end of data for OBJECT length');\n        }\n        const lengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n        const length = lengthView.getUint32(0, true);\n        offset += 4;\n        \n        const obj = {};\n        for (let i = 0; i < length; i++) {\n          // Decode key\n          if (offset + 4 > data.length) {\n            throw new Error('Unexpected end of data for OBJECT key length');\n          }\n          const keyLengthView = new DataView(data.buffer, data.byteOffset + offset, 4);\n          const keyLength = keyLengthView.getUint32(0, true);\n          offset += 4;\n          \n          if (offset + keyLength > data.length) {\n            throw new Error('Unexpected end of data for OBJECT key');\n          }\n          const keyData = data.slice(offset, offset + keyLength);\n          offset += keyLength;\n          const key = new TextDecoder().decode(keyData);\n          \n          // Decode value\n          obj[key] = decodeValue();\n        }\n        return obj;\n      }\n      \n      default:\n        throw new Error(`Unknown type byte: 0x${type.toString(16)}`);\n    }\n  }\n\n  return decodeValue();\n}\n\n/**\n * OPFS File Operations\n */\nclass BJsonFile {\n  constructor(filename) {\n    this.filename = filename;\n    this.root = null;\n    this.fileHandle = null;\n  }\n\n  async init() {\n    if (!navigator.storage || !navigator.storage.getDirectory) {\n      throw new Error('Origin Private File System (OPFS) is not supported in this browser');\n    }\n    this.root = await navigator.storage.getDirectory();\n  }\n\n  async write(data) {\n    await this.init();\n    \n    // Encode data to binary\n    const binaryData = encode(data);\n    \n    // Get file handle\n    this.fileHandle = await this.root.getFileHandle(this.filename, { create: true });\n    \n    // Create writable stream\n    const writable = await this.fileHandle.createWritable();\n    \n    // Write data\n    await writable.write(binaryData);\n    await writable.close();\n  }\n\n  async read() {\n    await this.init();\n    \n    try {\n      // Get file handle\n      this.fileHandle = await this.root.getFileHandle(this.filename);\n      \n      // Get file\n      const file = await this.fileHandle.getFile();\n      \n      // Read as array buffer\n      const arrayBuffer = await file.arrayBuffer();\n      const binaryData = new Uint8Array(arrayBuffer);\n      \n      // Decode and return\n      return decode(binaryData);\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        throw new Error(`File not found: ${this.filename}`);\n      }\n      throw error;\n    }\n  }\n\n  async append(data) {\n    await this.init();\n    \n    // Encode new data to binary\n    const binaryData = encode(data);\n    \n    // Get file handle\n    this.fileHandle = await this.root.getFileHandle(this.filename, { create: true });\n    \n    // Get existing file size\n    const file = await this.fileHandle.getFile();\n    const existingSize = file.size;\n    \n    // Create writable stream\n    const writable = await this.fileHandle.createWritable({ keepExistingData: true });\n    \n    // Seek to end\n    await writable.seek(existingSize);\n    \n    // Write new data\n    await writable.write(binaryData);\n    await writable.close();\n  }\n\n  async *scan() {\n    await this.init();\n    \n    try {\n      // Get file handle\n      this.fileHandle = await this.root.getFileHandle(this.filename);\n      \n      // Get file\n      const file = await this.fileHandle.getFile();\n      \n      // Read as array buffer\n      const arrayBuffer = await file.arrayBuffer();\n      const data = new Uint8Array(arrayBuffer);\n      \n      let offset = 0;\n      \n      // Scan through and yield each top-level value\n      while (offset < data.length) {\n        function getValueSize(dataView, startPos) {\n          let pos = startPos;\n          if (pos >= dataView.length) return 0;\n          \n          const type = dataView[pos++];\n          \n          switch (type) {\n            case TYPE.NULL:\n            case TYPE.FALSE:\n            case TYPE.TRUE:\n              return 1;\n            \n            case TYPE.INT:\n              return 1 + 4;\n            \n            case TYPE.FLOAT:\n              return 1 + 8;\n            \n            case TYPE.OID:\n              return 1 + 12;\n            \n            case TYPE.DATE:\n              return 1 + 8;\n            \n            case TYPE.STRING: {\n              const lengthView = new DataView(dataView.buffer, dataView.byteOffset + pos, 4);\n              const length = lengthView.getUint32(0, true);\n              return 1 + 4 + length;\n            }\n            \n            case TYPE.ARRAY: {\n              let size = 1 + 4; // type + length\n              const lengthView = new DataView(dataView.buffer, dataView.byteOffset + pos, 4);\n              const length = lengthView.getUint32(0, true);\n              pos += 4;\n              for (let i = 0; i < length; i++) {\n                const elementSize = getValueSize(dataView, pos);\n                size += elementSize;\n                pos += elementSize;\n              }\n              return size;\n            }\n            \n            case TYPE.OBJECT: {\n              let size = 1 + 4; // type + length\n              const lengthView = new DataView(dataView.buffer, dataView.byteOffset + pos, 4);\n              const numKeys = lengthView.getUint32(0, true);\n              pos += 4;\n              for (let i = 0; i < numKeys; i++) {\n                // Key length + key\n                const keyLengthView = new DataView(dataView.buffer, dataView.byteOffset + pos, 4);\n                const keyLength = keyLengthView.getUint32(0, true);\n                size += 4 + keyLength;\n                pos += 4 + keyLength;\n                // Value\n                const valueSize = getValueSize(dataView, pos);\n                size += valueSize;\n                pos += valueSize;\n              }\n              return size;\n            }\n            \n            default:\n              throw new Error(`Unknown type byte: 0x${type.toString(16)}`);\n          }\n        }\n        \n        const valueSize = getValueSize(data, offset);\n        const valueData = data.slice(offset, offset + valueSize);\n        offset += valueSize;\n        \n        // Decode and yield this value\n        yield decode(valueData);\n      }\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        throw new Error(`File not found: ${this.filename}`);\n      }\n      throw error;\n    }\n  }\n\n  async delete() {\n    await this.init();\n    try {\n      await this.root.removeEntry(this.filename);\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        // File doesn't exist, nothing to delete\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async exists() {\n    await this.init();\n    try {\n      await this.root.getFileHandle(this.filename);\n      return true;\n    } catch (error) {\n      if (error.name === 'NotFoundError') {\n        return false;\n      }\n      throw error;\n    }\n  }\n}\n\nexport {\n  TYPE,\n  ObjectId,\n  encode,\n  decode,\n  BJsonFile\n};\n","/**\n * Utility functions for MicroMongoDB\n */\n\nimport { ObjectId } from 'bjson';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Deep copy an object or array\n */\nexport function copy(o) {\n\t// Handle ObjectId\n\tif (o instanceof ObjectId) {\n\t\treturn new ObjectId(o.id);\n\t}\n\t\n\tvar out, v, key;\n\tout = Array.isArray(o) ? [] : {};\n\tfor (key in o) {\n\t\tv = o[key];\n\t\tout[key] = (typeof v === \"object\" && v !== null) ? copy(v) : v;\n\t}\n\treturn out;\n}\n\n/**\n * Get a property from an object using dot notation\n * Supports array element access via numeric indices (e.g., \"items.0.name\")\n */\nexport function getProp(obj, name) {\n\tvar path = name.split(\".\");\n\tvar result = obj[path[0]];\n\tfor (var i = 1; i < path.length; i++) {\n\t\tif (result == undefined || result == null) return result;\n\t\t\n\t\t// Check if this path segment is a numeric index\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\t// If it's a valid array index, use it\n\t\tif (isArray(result) && !isNaN(numericIndex) && numericIndex >= 0 && numericIndex < result.length) {\n\t\t\tresult = result[numericIndex];\n\t\t} else {\n\t\t\tresult = result[pathSegment];\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Get field values for query matching, handling MongoDB-style array traversal\n * When a path traverses an array, this returns all matching values from array elements\n * Returns an array of values if array traversal occurred, otherwise the single value\n * \n * Example:\n *   doc = { items: [{ price: 10 }, { price: 20 }] }\n *   getFieldValues(doc, 'items.price') -> [10, 20]\n */\nexport function getFieldValues(obj, name) {\n\tvar path = name.split(\".\");\n\tvar results = [obj];\n\t\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\tvar newResults = [];\n\t\t\n\t\tfor (var j = 0; j < results.length; j++) {\n\t\t\tvar current = results[j];\n\t\t\tif (current == undefined || current == null) continue;\n\t\t\t\n\t\t\t// If this is a numeric index and current is an array, access that element\n\t\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\t\tif (numericIndex < current.length) {\n\t\t\t\t\tnewResults.push(current[numericIndex]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If current is an array but path segment is not numeric, traverse all elements\n\t\t\telse if (isArray(current)) {\n\t\t\t\tfor (var k = 0; k < current.length; k++) {\n\t\t\t\t\tif (current[k] != undefined && current[k] != null && typeof current[k] === 'object') {\n\t\t\t\t\t\tnewResults.push(current[k][pathSegment]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, normal property access\n\t\t\telse if (typeof current === 'object') {\n\t\t\t\tnewResults.push(current[pathSegment]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tresults = newResults;\n\t}\n\t\n\t// Filter out undefined values\n\tresults = results.filter(function(v) { return v !== undefined; });\n\t\n\t// If we have multiple values, return the array\n\t// If we have exactly one, return it directly\n\t// If we have none, return undefined\n\tif (results.length === 0) return undefined;\n\tif (results.length === 1) return results[0];\n\treturn results;\n}\n\n/**\n * Set a property on an object using dot notation\n * Creates intermediate objects as needed\n * Supports array element access via numeric indices\n * Supports $[] operator to update all array elements\n */\nexport function setProp(obj, name, value) {\n\t// Check if path contains $[] operator\n\tif (name.indexOf('$[]') !== -1) {\n\t\treturn setPropWithAllPositional(obj, name, value);\n\t}\n\t\n\tvar path = name.split(\".\");\n\tvar current = obj;\n\t\n\tfor (var i = 0; i < path.length - 1; i++) {\n\t\tvar pathSegment = path[i];\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\t// If this is a numeric index and current is an array\n\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\t// Ensure the array is large enough\n\t\t\twhile (current.length <= numericIndex) {\n\t\t\t\tcurrent.push(undefined);\n\t\t\t}\n\t\t\t// If the element doesn't exist, create an object\n\t\t\tif (current[numericIndex] == undefined || current[numericIndex] == null) {\n\t\t\t\t// Look ahead to see if next segment is numeric (array) or not (object)\n\t\t\t\tvar nextSegment = path[i + 1];\n\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\tcurrent[numericIndex] = [];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[numericIndex] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[numericIndex];\n\t\t}\n\t\t// Regular property access\n\t\telse {\n\t\t\tif (current[pathSegment] == undefined || current[pathSegment] == null) {\n\t\t\t\t// Look ahead to see if next segment is numeric (array) or not (object)\n\t\t\t\tvar nextSegment = path[i + 1];\n\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[pathSegment] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[pathSegment];\n\t\t}\n\t}\n\t\n\t// Set the final value\n\tvar lastSegment = path[path.length - 1];\n\tvar lastNumericIndex = parseInt(lastSegment, 10);\n\t\n\tif (isArray(current) && !isNaN(lastNumericIndex) && lastNumericIndex >= 0) {\n\t\twhile (current.length <= lastNumericIndex) {\n\t\t\tcurrent.push(undefined);\n\t\t}\n\t\tcurrent[lastNumericIndex] = value;\n\t} else {\n\t\tcurrent[lastSegment] = value;\n\t}\n}\n\n/**\n * Set a property using the $[] all positional operator\n * Updates all elements in an array\n */\nfunction setPropWithAllPositional(obj, name, value) {\n\tvar path = name.split(\".\");\n\tvar current = obj;\n\t\n\t// Navigate to the $[] operator\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\t\n\t\tif (pathSegment === '$[]') {\n\t\t\t// Current should be an array - update all elements\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\tthrow new Error(\"The positional operator did not find the match needed from the query.\");\n\t\t\t}\n\t\t\t\n\t\t\t// Build the remaining path after $[]\n\t\t\tvar remainingPath = path.slice(i + 1).join('.');\n\t\t\t\n\t\t\t// Update all array elements\n\t\t\tfor (var j = 0; j < current.length; j++) {\n\t\t\t\tif (remainingPath) {\n\t\t\t\t\t// There's more path after $[], recursively set on each element\n\t\t\t\t\tsetProp(current[j], remainingPath, value);\n\t\t\t\t} else {\n\t\t\t\t\t// $[] is the last segment, replace each element with value\n\t\t\t\t\tcurrent[j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Navigate to the next level\n\t\tvar numericIndex = parseInt(pathSegment, 10);\n\t\t\n\t\tif (isArray(current) && !isNaN(numericIndex) && numericIndex >= 0) {\n\t\t\tcurrent = current[numericIndex];\n\t\t} else {\n\t\t\tif (current[pathSegment] == undefined || current[pathSegment] == null) {\n\t\t\t\t// Create intermediate object or array\n\t\t\t\tvar nextSegment = i + 1 < path.length ? path[i + 1] : null;\n\t\t\t\tif (nextSegment === '$[]') {\n\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t} else {\n\t\t\t\t\tvar nextNumeric = parseInt(nextSegment, 10);\n\t\t\t\t\tif (!isNaN(nextNumeric) && nextNumeric >= 0) {\n\t\t\t\t\t\tcurrent[pathSegment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathSegment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current[pathSegment];\n\t\t}\n\t}\n}\n\n/**\n * Check if value is an array\n */\nexport function isArray(o) {\n\treturn Array == o.constructor;\n}\n\n/**\n * Convert object to array of key-value pairs\n */\nexport function toArray(obj) {\n\tvar arr = [];\n\tfor (var key in obj) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar el = {};\n\t\t\tel[key] = obj[key];\n\t\t\tarr.push(el);\n\t\t}\n\t}\n\treturn arr;\n}\n\n/**\n * Check if a value is in an array\n */\nexport function isIn(val, values) {\n\tfor (var i = 0; i < values.length; i++) {\n\t\tif (valuesEqual(values[i], val)) return true;\n\t}\n\treturn false;\n}\n\n/**\n * Check if two arrays match\n */\nexport function arrayMatches(x, y) {\n\tif (x.length != y.length) return false;\n\tfor (var i = 0; i < x.length; i++) {\n\t\tif (valuesEqual(x[i], y[i])) continue;\n\t\tif (typeof (x[i]) != typeof (y[i])) return false;\n\t\tif (typeof (x[i]) == \"object\" && x[i] !== null) {\n\t\t\tif (isArray(x[i])) {\n\t\t\t\tif (!arrayMatches(x[i], y[i])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[i], y[i])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[i], y[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Check if two objects match\n */\nexport function objectMatches(x, y) {\n\tfor (var p in x) {\n\t\tif (!x.hasOwnProperty(p)) continue;\n\t\tif (!y.hasOwnProperty(p)) return false;\n\t\tif (valuesEqual(x[p], y[p])) continue;\n\t\tif (typeof (x[p]) != typeof (y[p])) return false;\n\t\tif (typeof (x[p]) == \"object\" && x[p] !== null) {\n\t\t\tif (isArray(x[p])) {\n\t\t\t\tif (!arrayMatches(x[p], y[p])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[p], y[p])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[p], y[p])) return false;\n\t\t}\n\t}\n\tfor (var p in y) {\n\t\tif (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Apply projection to a document\n */\nexport function applyProjection(projection, doc) {\n\tvar result = {};\n\tvar keys = Object.keys(projection);\n\tif (keys.length == 0) return doc;\n\t\n\t// Check for mixed inclusion/exclusion (except _id which can be excluded in inclusion projection)\n\tvar hasInclusion = false;\n\tvar hasExclusion = false;\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (keys[i] === '_id') continue; // _id is special\n\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\telse hasExclusion = true;\n\t}\n\t\n\tif (hasInclusion && hasExclusion) {\n\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t}\n\t\n\tif (projection[keys[0]] || hasInclusion) {\n\t\t// Inclusion projection\n\t\t// Include _id unless explicitly excluded\n\t\tif (projection._id !== 0) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i] === '_id') continue;\n\t\t\tif (!projection[keys[i]]) continue;\n\t\t\t\n\t\t\tvar fieldPath = keys[i];\n\t\t\tvar value = getProp(doc, fieldPath);\n\t\t\t\n\t\t\tif (value !== undefined) {\n\t\t\t\t// Use setProp to create nested structure\n\t\t\t\tsetProp(result, fieldPath, value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Exclusion projection - start with a copy of the document\n\t\tfor (var key in doc) {\n\t\t\tif (doc.hasOwnProperty(key)) {\n\t\t\t\t// Deep copy the value\n\t\t\t\tvar val = doc[key];\n\t\t\t\tif (typeof val === 'object' && val !== null && !isArray(val)) {\n\t\t\t\t\tresult[key] = copy(val);\n\t\t\t\t} else if (isArray(val)) {\n\t\t\t\t\tresult[key] = val.slice(); // shallow copy array\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Remove excluded fields\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (projection[keys[i]]) continue; // Skip if value is truthy\n\t\t\t\n\t\t\tvar fieldPath = keys[i];\n\t\t\tvar pathParts = fieldPath.split('.');\n\t\t\t\n\t\t\t// Navigate to the parent object and delete the final property\n\t\t\tif (pathParts.length === 1) {\n\t\t\t\tdelete result[fieldPath];\n\t\t\t} else {\n\t\t\t\tvar parent = result;\n\t\t\t\tfor (var j = 0; j < pathParts.length - 1; j++) {\n\t\t\t\t\tif (parent == undefined || parent == null) break;\n\t\t\t\t\tparent = parent[pathParts[j]];\n\t\t\t\t}\n\t\t\t\tif (parent != undefined && parent != null) {\n\t\t\t\t\tdelete parent[pathParts[pathParts.length - 1]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Convert bbox to GeoJSON\n */\nexport function bboxToGeojson(bbox) {\n\tconst minLon = bbox[0][0];\n\tconst maxLat = bbox[0][1];\n\tconst maxLon = bbox[1][0];\n\tconst minLat = bbox[1][1];\n\treturn {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: [{\n\t\t\ttype: 'Feature',\n\t\t\tproperties: {},\n\t\t\tgeometry: {\n\t\t\t\ttype: 'Polygon',\n\t\t\t\tcoordinates: [[\n\t\t\t\t\t[minLon, maxLat],\n\t\t\t\t\t[minLon, minLat],\n\t\t\t\t\t[maxLon, minLat],\n\t\t\t\t\t[maxLon, maxLat],\n\t\t\t\t\t[minLon, maxLat]\n\t\t\t\t]]\n\t\t\t}\n\t\t}]\n\t};\n}\n","/**\n * MongoDB Error Classes\n * \n * Structured error hierarchy compatible with MongoDB driver\n */\n\n/**\n * Error codes matching MongoDB error codes\n */\nexport const ErrorCodes = {\n\t// General errors\n\tOK: 0,\n\tINTERNAL_ERROR: 1,\n\tBAD_VALUE: 2,\n\tNO_SUCH_KEY: 4,\n\tGRAPH_CONTAINS_CYCLE: 5,\n\tHOST_UNREACHABLE: 6,\n\tHOST_NOT_FOUND: 7,\n\tUNKNOWN_ERROR: 8,\n\tFAILED_TO_PARSE: 17287, // Using test-compatible error code\n\tCANNOT_MUTATE_OBJECT: 10,\n\tUSER_NOT_FOUND: 11,\n\tUNSUPPORTED_FORMAT: 12,\n\tUNAUTHORIZED: 13,\n\tTYPE_MISMATCH: 14,\n\tOVERFLOW: 15,\n\tINVALID_LENGTH: 16,\n\tPROTOCOL_ERROR: 17,\n\tAUTHENTICATION_FAILED: 18,\n\tILLEGAL_OPERATION: 20,\n\tNAMESPACE_NOT_FOUND: 26,\n\tINDEX_NOT_FOUND: 27,\n\tPATH_NOT_VIABLE: 28,\n\tCANNOT_CREATE_INDEX: 67,\n\tINDEX_ALREADY_EXISTS: 68,\n\tINDEX_EXISTS: 68,\n\tCOMMAND_NOT_FOUND: 59,\n\tNAMESPACE_EXISTS: 48,\n\tINVALID_NAMESPACE: 73,\n\tINDEX_OPTIONS_CONFLICT: 85,\n\tINVALID_INDEX_SPECIFICATION_OPTION: 197,\n\t\n\t// Write errors\n\tWRITE_CONFLICT: 112,\n\tDUPLICATE_KEY: 11000,\n\tDUPLICATE_KEY_UPDATE: 11001,\n\t\n\t// Validation errors\n\tDOCUMENT_VALIDATION_FAILURE: 121,\n\t\n\t// Query errors\n\tBAD_QUERY: 2,\n\tCANNOT_INDEX_PARALLEL_ARRAYS: 171,\n\t\n\t// Cursor errors\n\tCURSOR_NOT_FOUND: 43,\n\t\n\t// Collection errors\n\tCOLLECTION_IS_EMPTY: 26,\n\t\n\t// Not implemented (custom code)\n\tNOT_IMPLEMENTED: 999,\n\tOPERATION_NOT_SUPPORTED: 998\n};\n\n/**\n * Base class for all MongoDB errors\n */\nexport class MongoError extends Error {\n\tconstructor(message, options = {}) {\n\t\tsuper(message);\n\t\tthis.name = 'MongoError';\n\t\tthis.code = options.code || ErrorCodes.UNKNOWN_ERROR;\n\t\tthis.codeName = this._getCodeName(this.code);\n\t\t\n\t\t// Backward compatibility: add $err property matching old error format\n\t\tthis.$err = message;\n\t\t\n\t\t// Additional context\n\t\tif (options.collection) this.collection = options.collection;\n\t\tif (options.database) this.database = options.database;\n\t\tif (options.operation) this.operation = options.operation;\n\t\tif (options.query) this.query = options.query;\n\t\tif (options.document) this.document = options.document;\n\t\tif (options.field) this.field = options.field;\n\t\tif (options.index) this.index = options.index;\n\t\t\n\t\t// Capture stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t}\n\t\n\t_getCodeName(code) {\n\t\tconst codeToName = {\n\t\t\t0: 'OK',\n\t\t\t1: 'InternalError',\n\t\t\t2: 'BadValue',\n\t\t\t4: 'NoSuchKey',\n\t\t\t5: 'GraphContainsCycle',\n\t\t\t6: 'HostUnreachable',\n\t\t\t7: 'HostNotFound',\n\t\t\t8: 'UnknownError',\n\t\t\t10: 'CannotMutateObject',\n\t\t\t11: 'UserNotFound',\n\t\t\t12: 'UnsupportedFormat',\n\t\t\t13: 'Unauthorized',\n\t\t\t14: 'TypeMismatch',\n\t\t\t15: 'Overflow',\n\t\t\t16: 'InvalidLength',\n\t\t\t17: 'ProtocolError',\n\t\t\t18: 'AuthenticationFailed',\n\t\t\t20: 'IllegalOperation',\n\t\t\t26: 'NamespaceNotFound',\n\t\t\t27: 'IndexNotFound',\n\t\t\t28: 'PathNotViable',\n\t\t\t43: 'CursorNotFound',\n\t\t\t48: 'NamespaceExists',\n\t\t\t59: 'CommandNotFound',\n\t\t\t67: 'CannotCreateIndex',\n\t\t\t68: 'IndexExists',\n\t\t\t73: 'InvalidNamespace',\n\t\t\t85: 'IndexOptionsConflict',\n\t\t\t112: 'WriteConflict',\n\t\t\t121: 'DocumentValidationFailure',\n\t\t\t171: 'CannotIndexParallelArrays',\n\t\t\t197: 'InvalidIndexSpecificationOption',\n\t\t\t998: 'OperationNotSupported',\n\t\t\t999: 'NotImplemented',\n\t\t\t11000: 'DuplicateKey',\n\t\t\t11001: 'DuplicateKeyUpdate',\n\t\t\t17287: 'FailedToParse'\n\t\t};\n\t\treturn codeToName[code] || 'UnknownError';\n\t}\n\t\n\ttoJSON() {\n\t\tconst json = {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tcode: this.code,\n\t\t\tcodeName: this.codeName\n\t\t};\n\t\t\n\t\t// Include all enumerable properties\n\t\tif (this.collection) json.collection = this.collection;\n\t\tif (this.database) json.database = this.database;\n\t\tif (this.operation) json.operation = this.operation;\n\t\tif (this.index) json.index = this.index;\n\t\tif (this.indexName) json.indexName = this.indexName;\n\t\tif (this.field) json.field = this.field;\n\t\tif (this.query) json.query = this.query;\n\t\tif (this.document) json.document = this.document;\n\t\tif (this.namespace) json.namespace = this.namespace;\n\t\tif (this.cursorId) json.cursorId = this.cursorId;\n\t\tif (this.feature) json.feature = this.feature;\n\t\tif (this.keyPattern) json.keyPattern = this.keyPattern;\n\t\tif (this.keyValue) json.keyValue = this.keyValue;\n\t\tif (this.writeErrors) json.writeErrors = this.writeErrors;\n\t\t\n\t\treturn json;\n\t}\n}\n\n/**\n * Server-side errors\n */\nexport class MongoServerError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoServerError';\n\t}\n}\n\n/**\n * Driver-side errors (client errors)\n */\nexport class MongoDriverError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoDriverError';\n\t\tthis.code = options.code || ErrorCodes.INTERNAL_ERROR;\n\t}\n}\n\n/**\n * Write operation errors\n */\nexport class WriteError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'WriteError';\n\t\tthis.code = options.code || ErrorCodes.WRITE_CONFLICT;\n\t}\n}\n\n/**\n * Duplicate key error\n */\nexport class DuplicateKeyError extends WriteError {\n\tconstructor(key, options = {}) {\n\t\tconst keyStr = JSON.stringify(key);\n\t\tconst message = `E11000 duplicate key error${options.collection ? ` collection: ${options.collection}` : ''} index: ${keyStr} dup key: ${keyStr}`;\n\t\tsuper(message, { ...options, code: ErrorCodes.DUPLICATE_KEY });\n\t\tthis.name = 'DuplicateKeyError';\n\t\tthis.keyPattern = key;\n\t\tthis.keyValue = options.keyValue || key;\n\t}\n}\n\n/**\n * Document validation errors\n */\nexport class ValidationError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'ValidationError';\n\t\tthis.code = options.code || ErrorCodes.DOCUMENT_VALIDATION_FAILURE;\n\t\tthis.validationErrors = options.validationErrors || [];\n\t}\n}\n\n/**\n * Index-related errors\n */\nexport class IndexError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'IndexError';\n\t}\n}\n\n/**\n * Index already exists error\n */\nexport class IndexExistsError extends IndexError {\n\tconstructor(indexName, options = {}) {\n\t\tsuper(`Index with name '${indexName}' already exists`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INDEX_EXISTS\n\t\t});\n\t\tthis.name = 'IndexExistsError';\n\t\tthis.indexName = indexName;\n\t}\n}\n\n/**\n * Index not found error\n */\nexport class IndexNotFoundError extends IndexError {\n\tconstructor(indexName, options = {}) {\n\t\tsuper(`Index '${indexName}' not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INDEX_NOT_FOUND,\n\t\t\tindex: indexName\n\t\t});\n\t\tthis.name = 'IndexNotFoundError';\n\t\tthis.indexName = indexName;\n\t}\n}\n\n/**\n * Cannot create index error\n */\nexport class CannotCreateIndexError extends IndexError {\n\tconstructor(reason, options = {}) {\n\t\tsuper(`Cannot create index: ${reason}`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.CANNOT_CREATE_INDEX\n\t\t});\n\t\tthis.name = 'CannotCreateIndexError';\n\t}\n}\n\n/**\n * Query errors\n */\nexport class QueryError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'QueryError';\n\t\tthis.code = options.code || ErrorCodes.BAD_QUERY;\n\t}\n}\n\n/**\n * Type mismatch error\n */\nexport class TypeMismatchError extends MongoError {\n\tconstructor(field, expectedType, actualType, options = {}) {\n\t\tsuper(\n\t\t\t`Type mismatch for field '${field}': expected ${expectedType}, got ${actualType}`,\n\t\t\t{ ...options, code: ErrorCodes.TYPE_MISMATCH, field }\n\t\t);\n\t\tthis.name = 'TypeMismatchError';\n\t\tthis.expectedType = expectedType;\n\t\tthis.actualType = actualType;\n\t}\n}\n\n/**\n * Namespace errors\n */\nexport class NamespaceError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'NamespaceError';\n\t}\n}\n\n/**\n * Namespace not found\n */\nexport class NamespaceNotFoundError extends NamespaceError {\n\tconstructor(namespace, options = {}) {\n\t\tsuper(`Namespace '${namespace}' not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t\tthis.name = 'NamespaceNotFoundError';\n\t\tthis.namespace = namespace;\n\t}\n}\n\n/**\n * Invalid namespace\n */\nexport class InvalidNamespaceError extends NamespaceError {\n\tconstructor(namespace, reason, options = {}) {\n\t\t// Handle case where reason is actually options\n\t\tif (typeof reason === 'object' && !options) {\n\t\t\toptions = reason;\n\t\t\treason = undefined;\n\t\t}\n\t\tconst msg = reason ? `Invalid namespace '${namespace}': ${reason}` : `Invalid namespace '${namespace}'`;\n\t\tsuper(msg, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.INVALID_NAMESPACE\n\t\t});\n\t\tthis.name = 'InvalidNamespaceError';\n\t\tthis.namespace = namespace;\n\t}\n}\n\n/**\n * Cursor errors\n */\nexport class CursorError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'CursorError';\n\t}\n}\n\n/**\n * Cursor not found\n */\nexport class CursorNotFoundError extends CursorError {\n\tconstructor(cursorId, options = {}) {\n\t\tsuper(`Cursor ${cursorId} not found`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.CURSOR_NOT_FOUND\n\t\t});\n\t\tthis.name = 'CursorNotFoundError';\n\t\tthis.cursorId = cursorId;\n\t}\n}\n\n/**\n * Not implemented error\n */\nexport class NotImplementedError extends MongoError {\n\tconstructor(feature, options = {}) {\n\t\tsuper(`${feature} is not implemented in micro-mongo`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.NOT_IMPLEMENTED\n\t\t});\n\t\tthis.name = 'NotImplementedError';\n\t\tthis.feature = feature;\n\t}\n}\n\n/**\n * Operation not supported\n */\nexport class OperationNotSupportedError extends MongoError {\n\tconstructor(operation, reason, options = {}) {\n\t\t// Handle case where reason is actually options\n\t\tif (typeof reason === 'object' && !options) {\n\t\t\toptions = reason;\n\t\t\treason = undefined;\n\t\t}\n\t\tconst msg = reason ? `Operation '${operation}' is not supported: ${reason}` : `Operation '${operation}' is not supported`;\n\t\tsuper(msg, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.OPERATION_NOT_SUPPORTED,\n\t\t\toperation\n\t\t});\n\t\tthis.name = 'OperationNotSupportedError';\n\t}\n}\n\n/**\n * Bad value error\n */\nexport class BadValueError extends MongoError {\n\tconstructor(field, value, reason, options = {}) {\n\t\tsuper(`Bad value for field '${field}': ${reason}`, {\n\t\t\t...options,\n\t\t\tcode: ErrorCodes.BAD_VALUE,\n\t\t\tfield\n\t\t});\n\t\tthis.name = 'BadValueError';\n\t\tthis.value = value;\n\t}\n}\n\n/**\n * Bulk write error\n */\nexport class BulkWriteError extends MongoError {\n\tconstructor(writeErrors = [], options = {}) {\n\t\tconst message = `Bulk write operation error: ${writeErrors.length} error(s)`;\n\t\tsuper(message, options);\n\t\tthis.name = 'BulkWriteError';\n\t\tthis.writeErrors = writeErrors;\n\t\tthis.code = options.code || ErrorCodes.WRITE_CONFLICT;\n\t}\n}\n\n/**\n * Network error (for API compatibility, not functional in micro-mongo)\n */\nexport class MongoNetworkError extends MongoError {\n\tconstructor(message, options = {}) {\n\t\tsuper(message, options);\n\t\tthis.name = 'MongoNetworkError';\n\t\tthis.code = options.code || ErrorCodes.HOST_UNREACHABLE;\n\t}\n}\n\n/**\n * Helper function to create appropriate error\n */\nexport function createError(type, ...args) {\n\tswitch (type) {\n\t\tcase 'duplicate_key':\n\t\t\treturn new DuplicateKeyError(...args);\n\t\tcase 'validation':\n\t\t\treturn new ValidationError(...args);\n\t\tcase 'index_exists':\n\t\t\treturn new IndexExistsError(...args);\n\t\tcase 'index_not_found':\n\t\t\treturn new IndexNotFoundError(...args);\n\t\tcase 'cannot_create_index':\n\t\t\treturn new CannotCreateIndexError(...args);\n\t\tcase 'query':\n\t\t\treturn new QueryError(...args);\n\t\tcase 'type_mismatch':\n\t\t\treturn new TypeMismatchError(...args);\n\t\tcase 'namespace_not_found':\n\t\t\treturn new NamespaceNotFoundError(...args);\n\t\tcase 'invalid_namespace':\n\t\t\treturn new InvalidNamespaceError(...args);\n\t\tcase 'cursor_not_found':\n\t\t\treturn new CursorNotFoundError(...args);\n\t\tcase 'not_implemented':\n\t\t\treturn new NotImplementedError(...args);\n\t\tcase 'operation_not_supported':\n\t\t\treturn new OperationNotSupportedError(...args);\n\t\tcase 'bad_value':\n\t\t\treturn new BadValueError(...args);\n\t\tcase 'write':\n\t\t\treturn new WriteError(...args);\n\t\tdefault:\n\t\t\treturn new MongoError(...args);\n\t}\n}\n","import { applyProjection } from './utils.js';\nimport { NotImplementedError, QueryError, ErrorCodes } from './errors.js';\n\n/**\n * Cursor class for iterating over query results\n * Now a simple iterator over pre-filtered documents\n */\nexport class Cursor {\n\tconstructor(collection, query, projection, documents, SortedCursor) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.projection = projection;\n\t\tthis.documents = documents; // Pre-filtered array of documents\n\t\tthis.SortedCursor = SortedCursor;\n\n\t\t// Validate projection if provided\n\t\tif (projection && Object.keys(projection).length > 0) {\n\t\t\tconst keys = Object.keys(projection);\n\t\t\tlet hasInclusion = false;\n\t\t\tlet hasExclusion = false;\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tif (keys[i] === '_id') continue; // _id is special\n\t\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\t\telse hasExclusion = true;\n\t\t}\n\t\t\n\t\tif (hasInclusion && hasExclusion) {\n\t\t\tthrow new QueryError(\"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", { \n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE,\n\t\t\t\tcollection: collection.name \n\t\t\t});\n\t\t}\n\t}\t\tthis.pos = 0;\n\t\tthis._limit = 0;\n\t\tthis._skip = 0;\n\t\tthis._closed = false;\n\t}\n\n\tbatchSize(size) { \n\t\t// No-op for in-memory database, but return this for chaining\n\t\tthis._batchSize = size;\n\t\treturn this;\n\t}\n\tclose() {\n\t\tthis._closed = true;\n\t\tthis.pos = this.documents.length; // Move to end\n\t\treturn undefined;\n\t}\n\tcomment(commentString) {\n\t\tthis._comment = commentString;\n\t\treturn this;\n\t}\n\t\n\tcount() {\n\t\t// Return total count without considering skip/limit applied to this cursor\n\t\treturn this.documents.length;\n\t}\n\t\n\texplain(verbosity = 'queryPlanner') {\n\t\t// Return basic query execution info\n\t\treturn {\n\t\t\tqueryPlanner: {\n\t\t\t\tplannerVersion: 1,\n\t\t\t\tnamespace: `${this.collection.db?.name || 'db'}.${this.collection.name}`,\n\t\t\t\tindexFilterSet: false,\n\t\t\t\tparsedQuery: this.query,\n\t\t\t\twinningPlan: {\n\t\t\t\t\tstage: 'COLLSCAN',\n\t\t\t\t\tfilter: this.query,\n\t\t\t\t\tdirection: 'forward'\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutionStats: verbosity === 'executionStats' || verbosity === 'allPlansExecution' ? {\n\t\t\t\texecutionSuccess: true,\n\t\t\t\tnReturned: this.documents.length,\n\t\t\t\texecutionTimeMillis: 0,\n\t\t\t\ttotalKeysExamined: 0,\n\t\t\t\ttotalDocsExamined: this.documents.length\n\t\t\t} : undefined,\n\t\t\tok: 1\n\t\t};\n\t}\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\tif (this._closed) return false;\n\t\t// Calculate effective max position: skip + limit or total docs\n\t\tlet effectiveMax;\n\t\tif (this._limit > 0) {\n\t\t\teffectiveMax = Math.min(this._skip + this._limit, this.documents.length);\n\t\t} else {\n\t\t\teffectiveMax = this.documents.length;\n\t\t}\n\t\treturn this.pos < effectiveMax;\n\t}\n\t\n\thint(index) {\n\t\t// Store hint for query planner (informational in micro-mongo)\n\t\tthis._hint = index;\n\t\treturn this;\n\t}\n\titcount() {\n\t\tlet count = 0;\n\t\twhile (this.hasNext()) {\n\t\t\tthis.next();\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tlimit(_max) {\n\t\tthis._limit = _max;\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan(maxScan) {\n\t\t// Set maximum number of documents to scan (deprecated in MongoDB 4.0)\n\t\tthis._maxScan = maxScan;\n\t\treturn this;\n\t}\n\tmaxTimeMS(ms) {\n\t\t// Set maximum execution time (informational in micro-mongo)\n\t\tthis._maxTimeMS = ms;\n\t\treturn this;\n\t}\n\tmax(indexBounds) {\n\t\t// Set maximum index bound (informational in micro-mongo)\n\t\tthis._maxIndexBounds = indexBounds;\n\t\treturn this;\n\t}\n\tmin(indexBounds) {\n\t\t// Set minimum index bound (informational in micro-mongo)\n\t\tthis._minIndexBounds = indexBounds;\n\t\treturn this;\n\t}\n\t\n\tnext() {\n\t\tif (!this.hasNext()) {\n\t\t\tthrow new QueryError(\"Error: error hasNext: false\", { \n\t\t\t\tcollection: this.collection.name \n\t\t\t});\n\t\t}\n\t\tconst result = this.documents[this.pos++];\n\t\tif (this.projection) {\n\t\t\treturn applyProjection(this.projection, result);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tnoCursorTimeout() {\n\t\t// Prevent cursor timeout (no-op for in-memory)\n\t\tthis._noCursorTimeout = true;\n\t\treturn this;\n\t}\n\tobjsLeftInBatch() {\n\t\t// Return number of objects left in current batch\n\t\t// For in-memory, this is same as remaining documents\n\t\treturn this.size();\n\t}\n\tpretty() {\n\t\t// Enable pretty printing (no-op but return this for chaining)\n\t\tthis._pretty = true;\n\t\treturn this;\n\t}\n\treadConcern(level) {\n\t\t// Set read concern (no-op for in-memory database)\n\t\tthis._readConcern = level;\n\t\treturn this;\n\t}\n\treadPref(mode, tagSet) {\n\t\t// Set read preference (no-op for in-memory database)\n\t\tthis._readPref = { mode, tagSet };\n\t\treturn this;\n\t}\n\treturnKey(enabled = true) {\n\t\t// Return only the index key (informational in micro-mongo)\n\t\tthis._returnKey = enabled;\n\t\treturn this;\n\t}\n\tshowRecordId(enabled = true) {\n\t\t// Show record ID in results\n\t\tthis._showRecordId = enabled;\n\t\treturn this;\n\t}\n\tsize() {\n\t\t// Return count considering skip and limit\n\t\tconst remaining = this.documents.length - this.pos;\n\t\tif (this._limit > 0) {\n\t\t\t// Calculate how many docs left based on skip+limit boundary\n\t\t\tconst maxPos = this._skip + this._limit;\n\t\t\treturn Math.min(maxPos - this.pos, remaining);\n\t\t}\n\t\treturn remaining;\n\t}\n\t\n\tskip(num) {\n\t\tthis._skip = num;\n\t\t// Move initial position to skip point\n\t\tif (this.pos === 0) {\n\t\t\tthis.pos = Math.min(num, this.documents.length);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tisClosed() {\n\t\treturn this._closed === true;\n\t}\n\t\n\tsnapshot() { throw new NotImplementedError('snapshot'); }\n\t\n\tsort(s) {\n\t\treturn new this.SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\tallowDiskUse(enabled = true) {\n\t\t// Allow disk use for sorts (no-op for in-memory)\n\t\tthis._allowDiskUse = enabled;\n\t\treturn this;\n\t}\n\t\n\tcollation(collationDocument) {\n\t\t// Set collation (no-op for micro-mongo)\n\t\tthis._collation = collationDocument;\n\t\treturn this;\n\t}\n\t\n\ttailable() { throw new NotImplementedError('tailable'); }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","/**\n * SortedCursor class for iterating over sorted query results\n */\nexport class SortedCursor {\n\tconstructor(collection, query, cursor, sort) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.sortSpec = sort;\n\t\tthis.pos = 0;\n\t\tthis.items = [];\n\t\t\n\t\t// Collect all items from the cursor\n\t\twhile (cursor.hasNext()) {\n\t\t\tthis.items.push(cursor.next());\n\t\t}\n\t\t\n\t\t// Sort the items\n\t\tconst sortKeys = Object.keys(sort);\n\t\tthis.items.sort(function(a, b) {\n\t\t\tfor (let i = 0; i < sortKeys.length; i++) {\n\t\t\t\tif (a[sortKeys[i]] == undefined && b[sortKeys[i]] != undefined) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] != undefined && b[sortKeys[i]] == undefined) return 1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] < b[sortKeys[i]]) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] > b[sortKeys[i]]) return 1 * sort[sortKeys[i]];\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\treturn this.items.length;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\treturn this.pos < this.items.length;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(max) {\n\t\tthis.items = this.items.slice(0, max);\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\treturn this.items[this.pos++];\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","// Standard suffix manipulations.\n/** @type {Record<string, string>} */\nconst step2list = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant-vowel sequences.\nconst consonant = '[^aeiou]'\nconst vowel = '[aeiouy]'\nconst consonants = '(' + consonant + '[^aeiouy]*)'\nconst vowels = '(' + vowel + '[aeiou]*)'\n\nconst gt0 = new RegExp('^' + consonants + '?' + vowels + consonants)\nconst eq1 = new RegExp(\n  '^' + consonants + '?' + vowels + consonants + vowels + '?$'\n)\nconst gt1 = new RegExp('^' + consonants + '?(' + vowels + consonants + '){2,}')\nconst vowelInStem = new RegExp('^' + consonants + '?' + vowel)\nconst consonantLike = new RegExp('^' + consonants + vowel + '[^aeiouwxy]$')\n\n// Exception expressions.\nconst sfxLl = /ll$/\nconst sfxE = /^(.+?)e$/\nconst sfxY = /^(.+?)y$/\nconst sfxIon = /^(.+?(s|t))(ion)$/\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/\nconst sfxEED = /^(.+?)eed$/\nconst sfxS = /^.+?[^s]s$/\nconst sfxSsesOrIes = /^.+?(ss|i)es$/\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nexport function stemmer(value) {\n  let result = String(value).toLowerCase()\n\n  // Exit early.\n  if (result.length < 3) {\n    return result\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true\n    result = 'Y' + result.slice(1)\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2)\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1)\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1]\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += 'e'\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += 'e'\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + 'i'\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]]\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]]\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1]\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1]\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1]\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1)\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = 'y' + result.slice(1)\n  }\n\n  return result\n}\n","/**\n * IndexStore - In-memory index storage for collections\n * \n * Simple key-value store using a plain JavaScript object\n */\nexport class IndexStore {\n\tconstructor(meta) {\n    this._meta = new Map();\n\t\tthis._data = new Map();\n    \n    if (meta) {\n      for (const [key, value] of Object.entries(meta)) {\n        this._meta.set(key, value);\n      }\n    }\n\t}\n\n\tsetMeta(key, value) {\n\t\tthis._meta.set(key, value);\n\t}\n\n  hasMeta(key) {\n    return this._meta.has(key);\n  }\n\n  getMeta(key) {\n\t\treturn this._meta.get(key);\n\t}\n\n  hasDataMap(name) {\n    return this._data.has(name);\n  }\n\n  getDataMap(name) {\n    if (!this._data.has(name)) {\n      this._data.set(name, new Map());\n    }\n    return this._data.get(name);\n  }\n\n\t// clear() {\n\t// \tthis._data.clear();\n\t// }\n\n  // keys() {\n  //   return this._data.keys();\n  // }\n\n  // has(index) {\n  //   return this._data.has(index);\n  // }\n\n\t// get(index) {\n\t// \treturn this._data.get(index);\n\t// }\n\n\t// remove(key) {\n\t// \tthis._data.delete(key);\n\t// }\n\n\t// set(key, value) {\n\t// \tthis._data.set(key, value);\n\t// }\n\n\t// size() {\n\t// \treturn this._data.size;\n\t// }\n}\n","import { stemmer } from 'stemmer';\nimport { IndexStore } from './IndexStore.js';\n\n// Common English stop words that don't add semantic value to searches\nconst STOPWORDS = new Set([\n  'a', 'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', \n  'around', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'between', 'both', \n  'but', 'by', 'came', 'can', 'come', 'could', 'did', 'do', 'each', 'for', 'from', \n  'get', 'got', 'has', 'had', 'he', 'have', 'her', 'here', 'him', 'himself', 'his', \n  'how', 'i', 'if', 'in', 'into', 'is', 'it', 'like', 'make', 'many', 'me', 'might', \n  'more', 'most', 'much', 'must', 'my', 'never', 'now', 'of', 'on', 'only', 'or', \n  'other', 'our', 'out', 'over', 'said', 'same', 'see', 'should', 'since', 'some', \n  'still', 'such', 'take', 'than', 'that', 'the', 'their', 'them', 'then', 'there', \n  'these', 'they', 'this', 'those', 'through', 'to', 'too', 'under', 'up', 'very', \n  'was', 'way', 'we', 'well', 'were', 'what', 'where', 'which', 'while', 'who', \n  'with', 'would', 'you', 'your'\n]);\n\n/**\n * TextIndex - A text index implementation using Porter stemmer algorithm\n * \n * This class provides full-text search capabilities by indexing terms\n * and associating them with document IDs. It uses the Porter stemmer\n * algorithm to normalize words to their root forms.\n */\nexport class TextIndex {\n  constructor(storage = new IndexStore()) {\n    // Storage for persistence\n    this.storage = storage;\n    // Map from stemmed term to Map of document IDs to term frequency\n    // Structure: term -> { docId: frequency }\n    this.index = this.storage.getDataMap('index');\n    // Map from document ID to Map of stemmed terms to their frequency\n    // Structure: docId -> { term: frequency }\n    this.documentTerms = this.storage.getDataMap('documentTerms');\n    // Map from document ID to total term count (for normalization)\n    this.documentLengths = this.storage.getDataMap('documentLengths');\n  }\n\n  /**\n   * Tokenize text into individual words\n   * @param {string} text - The text to tokenize\n   * @returns {string[]} Array of words\n   */\n  _tokenize(text) {\n    if (typeof text !== 'string') {\n      return [];\n    }\n    // Split on non-word characters and filter out empty strings\n    const words = text.toLowerCase()\n      .split(/\\W+/)\n      .filter(word => word.length > 0);\n    \n    // Filter stop words\n    return words.filter(word => !STOPWORDS.has(word));\n  }\n\n  /**\n   * Add terms from text to the index for a given document ID\n   * @param {string} docId - The document identifier\n   * @param {string} text - The text content to index\n   */\n  add(docId, text) {\n    if (!docId) {\n      throw new Error('Document ID is required');\n    }\n\n    const words = this._tokenize(text);\n    const termFrequency = new Map();\n\n    // Count term frequencies\n    words.forEach(word => {\n      const stem = stemmer(word);\n      termFrequency.set(stem, (termFrequency.get(stem) || 0) + 1);\n    });\n\n    // Add to index\n    termFrequency.forEach((frequency, stem) => {\n      if (!this.index.has(stem)) {\n        this.index.set(stem, new Map());\n      }\n      this.index.get(stem).set(docId, frequency);\n    });\n\n    // Track document terms and frequencies\n    this.documentTerms.set(docId, termFrequency);\n    this.documentLengths.set(docId, words.length);\n  }\n\n  /**\n   * Remove all indexed terms for a given document ID\n   * @param {string} docId - The document identifier to remove\n   * @returns {boolean} True if document was found and removed, false otherwise\n   */\n  remove(docId) {\n    if (!this.documentTerms.has(docId)) {\n      return false;\n    }\n\n    // Get all terms associated with this document\n    const terms = this.documentTerms.get(docId);\n\n    // Remove document ID from each term's posting list\n    terms.forEach((frequency, term) => {\n      if (this.index.has(term)) {\n        this.index.get(term).delete(docId);\n        // Clean up empty term entries\n        if (this.index.get(term).size === 0) {\n          this.index.delete(term);\n        }\n      }\n    });\n\n    // Remove document from tracking\n    this.documentTerms.delete(docId);\n    this.documentLengths.delete(docId);\n    return true;\n  }\n\n  /**\n   * Query the index for documents containing the given terms with relevance scoring\n   * @param {string} queryText - The search query text\n   * @param {Object} options - Query options\n   * @param {boolean} options.scored - If true, return scored results; if false, return just IDs (default: true)\n   * @param {boolean} options.requireAll - If true, require ALL terms; if false, rank by relevance (default: false)\n   * @returns {Array} Array of document IDs (if scored=false) or objects with {id, score} (if scored=true)\n   */\n  query(queryText, options = { scored: true, requireAll: false }) {\n    const words = this._tokenize(queryText);\n    if (words.length === 0) {\n      return [];\n    }\n\n    // Get stemmed versions of query terms\n    const stemmedTerms = words.map(word => stemmer(word));\n    const uniqueTerms = [...new Set(stemmedTerms)];\n\n    if (options.requireAll) {\n      // Strict AND logic - document must contain ALL terms\n      const docSets = uniqueTerms.map(term => {\n        const termDocs = this.index.get(term);\n        return termDocs ? new Set(termDocs.keys()) : new Set();\n      });\n\n      if (docSets.length === 0) {\n        return [];\n      }\n\n      // Compute intersection of all document sets\n      const intersection = new Set(docSets[0]);\n      for (let i = 1; i < docSets.length; i++) {\n        for (const docId of intersection) {\n          if (!docSets[i].has(docId)) {\n            intersection.delete(docId);\n          }\n        }\n      }\n\n      return Array.from(intersection);\n    }\n\n    // Relevance-based scoring (OR logic with ranking)\n    // Calculate IDF (Inverse Document Frequency) for each term\n    const totalDocs = this.documentLengths.size;\n    const idf = new Map();\n    \n    uniqueTerms.forEach(term => {\n      const docsWithTerm = this.index.get(term)?.size || 0;\n      if (docsWithTerm > 0) {\n        // IDF = log(totalDocs / docsWithTerm)\n        idf.set(term, Math.log(totalDocs / docsWithTerm));\n      }\n    });\n\n    // Collect all documents that contain at least one query term\n    const docScores = new Map();\n\n    uniqueTerms.forEach(term => {\n      const termDocs = this.index.get(term);\n      if (!termDocs) return;\n\n      termDocs.forEach((termFreq, docId) => {\n        if (!docScores.has(docId)) {\n          docScores.set(docId, 0);\n        }\n\n        // Calculate TF-IDF score\n        // TF = term frequency in document / total terms in document\n        const docLength = this.documentLengths.get(docId) || 1;\n        const tf = termFreq / docLength;\n        \n        // Add to document's total score\n        const termIdf = idf.get(term) || 0;\n        const tfIdf = tf * termIdf;\n        \n        docScores.set(docId, docScores.get(docId) + tfIdf);\n      });\n    });\n\n    // Bonus for documents containing multiple query terms\n    docScores.forEach((score, docId) => {\n      const docTerms = this.documentTerms.get(docId);\n      if (docTerms) {\n        const matchingTerms = uniqueTerms.filter(term => docTerms.has(term)).length;\n        // Boost score based on term coverage (what % of query terms are present)\n        const coverage = matchingTerms / uniqueTerms.length;\n        docScores.set(docId, score * (1 + coverage));\n      }\n    });\n\n    // Sort by score (highest first)\n    const results = Array.from(docScores.entries())\n      .map(([id, score]) => ({ id, score }))\n      .sort((a, b) => b.score - a.score);\n\n    // Return based on options\n    if (options.scored === false) {\n      return results.map(r => r.id);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Get the number of unique terms in the index\n   * @returns {number} Number of unique terms\n   */\n  getTermCount() {\n    return this.index.size;\n  }\n\n  /**\n   * Get the number of documents in the index\n   * @returns {number} Number of indexed documents\n   */\n  getDocumentCount() {\n    return this.documentTerms.size;\n  }\n\n  /**\n   * Clear all data from the index\n   */\n  clear() {\n    this.index.clear();\n    this.documentTerms.clear();\n    this.documentLengths.clear();\n  }\n\n}\n","/**\n * Aggregation Expression Evaluator\n * \n * Implements MongoDB aggregation expression operators for use in\n * $project, $addFields, $set, $group, and other pipeline stages.\n */\n\nimport { getProp } from './utils.js';\n\n/**\n * Evaluate an aggregation expression against a document\n * @param {*} expr - The expression to evaluate (can be literal, field reference, or expression object)\n * @param {Object} doc - The document to evaluate against\n * @returns {*} The evaluated result\n */\nexport function evaluateExpression(expr, doc) {\n\t// Literal values (strings not starting with $, numbers, booleans, null)\n\tif (expr === null || expr === undefined) {\n\t\treturn expr;\n\t}\n\t\n\tif (typeof expr === 'boolean' || typeof expr === 'number') {\n\t\treturn expr;\n\t}\n\t\n\t// Field reference ($fieldName) or variable reference ($$variableName)\n\tif (typeof expr === 'string') {\n\t\tif (expr.startsWith('$$')) {\n\t\t\t// Special system variables for $redact\n\t\t\tif (expr === '$$KEEP' || expr === '$$PRUNE' || expr === '$$DESCEND') {\n\t\t\t\treturn expr;\n\t\t\t}\n\t\t\t// Variable reference ($$var)\n\t\t\treturn getProp(doc, expr.substring(2));\n\t\t} else if (expr.charAt(0) === '$') {\n\t\t\t// Field reference ($field)\n\t\t\treturn getProp(doc, expr.substring(1));\n\t\t}\n\t\treturn expr; // Literal string\n\t}\n\t\n\t// Expression object\n\tif (typeof expr === 'object') {\n\t\t// Check if it's an array literal\n\t\tif (Array.isArray(expr)) {\n\t\t\treturn expr.map(item => evaluateExpression(item, doc));\n\t\t}\n\t\t\n\t\t// Expression operator\n\t\tconst keys = Object.keys(expr);\n\t\tif (keys.length === 0) {\n\t\t\treturn expr; // Empty object literal\n\t\t}\n\t\t\n\t\tconst operator = keys[0];\n\t\t\n\t\t// Check if this is an operator (starts with $) or an object literal\n\t\tif (operator.charAt(0) === '$') {\n\t\t\t// This is an expression operator\n\t\t\tconst operand = expr[operator];\n\t\t\treturn evaluateOperator(operator, operand, doc);\n\t\t} else {\n\t\t\t// This is an object literal - evaluate each field\n\t\t\tconst result = {};\n\t\t\tfor (const key of keys) {\n\t\t\t\tresult[key] = evaluateExpression(expr[key], doc);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\treturn expr;\n}\n\n/**\n * Evaluate a specific operator\n */\nfunction evaluateOperator(operator, operand, doc) {\n\tswitch (operator) {\n\t\t// Arithmetic operators\n\t\tcase '$add': return evalAdd(operand, doc);\n\t\tcase '$subtract': return evalSubtract(operand, doc);\n\t\tcase '$multiply': return evalMultiply(operand, doc);\n\t\tcase '$divide': return evalDivide(operand, doc);\n\t\tcase '$mod': return evalMod(operand, doc);\n\t\tcase '$pow': return evalPow(operand, doc);\n\t\tcase '$sqrt': return evalSqrt(operand, doc);\n\t\tcase '$abs': return evalAbs(operand, doc);\n\t\tcase '$ceil': return evalCeil(operand, doc);\n\t\tcase '$floor': return evalFloor(operand, doc);\n\t\tcase '$trunc': return evalTrunc(operand, doc);\n\t\tcase '$round': return evalRound(operand, doc);\n\t\t\n\t\t// String operators\n\t\tcase '$concat': return evalConcat(operand, doc);\n\t\tcase '$substr': return evalSubstr(operand, doc);\n\t\tcase '$toLower': return evalToLower(operand, doc);\n\t\tcase '$toUpper': return evalToUpper(operand, doc);\n\t\tcase '$trim': return evalTrim(operand, doc);\n\t\tcase '$ltrim': return evalLtrim(operand, doc);\n\t\tcase '$rtrim': return evalRtrim(operand, doc);\n\t\tcase '$split': return evalSplit(operand, doc);\n\t\tcase '$strLenCP': return evalStrLenCP(operand, doc);\n\t\tcase '$strcasecmp': return evalStrcasecmp(operand, doc);\n\t\tcase '$indexOfCP': return evalIndexOfCP(operand, doc);\n\t\tcase '$replaceOne': return evalReplaceOne(operand, doc);\n\t\tcase '$replaceAll': return evalReplaceAll(operand, doc);\n\t\t\n\t\t// Comparison operators\n\t\tcase '$cmp': return evalCmp(operand, doc);\n\t\tcase '$eq': return evalEq(operand, doc);\n\t\tcase '$ne': return evalNe(operand, doc);\n\t\tcase '$gt': return evalGt(operand, doc);\n\t\tcase '$gte': return evalGte(operand, doc);\n\t\tcase '$lt': return evalLt(operand, doc);\n\t\tcase '$lte': return evalLte(operand, doc);\n\t\t\n\t\t// Logical operators\n\t\tcase '$and': return evalAnd(operand, doc);\n\t\tcase '$or': return evalOr(operand, doc);\n\t\tcase '$not': return evalNot(operand, doc);\n\t\t\n\t\t// Conditional operators\n\t\tcase '$cond': return evalCond(operand, doc);\n\t\tcase '$ifNull': return evalIfNull(operand, doc);\n\t\tcase '$switch': return evalSwitch(operand, doc);\n\t\t\n\t\t// Date operators\n\t\tcase '$year': return evalYear(operand, doc);\n\t\tcase '$month': return evalMonth(operand, doc);\n\t\tcase '$dayOfMonth': return evalDayOfMonth(operand, doc);\n\t\tcase '$dayOfWeek': return evalDayOfWeek(operand, doc);\n\t\tcase '$dayOfYear': return evalDayOfYear(operand, doc);\n\t\tcase '$hour': return evalHour(operand, doc);\n\t\tcase '$minute': return evalMinute(operand, doc);\n\t\tcase '$second': return evalSecond(operand, doc);\n\t\tcase '$millisecond': return evalMillisecond(operand, doc);\n\t\tcase '$week': return evalWeek(operand, doc);\n\t\tcase '$isoWeek': return evalIsoWeek(operand, doc);\n\t\tcase '$isoWeekYear': return evalIsoWeekYear(operand, doc);\n\t\tcase '$dateToString': return evalDateToString(operand, doc);\n\t\tcase '$toDate': return evalToDate(operand, doc);\n\t\t\n\t\t// Array operators\n\t\tcase '$arrayElemAt': return evalArrayElemAt(operand, doc);\n\t\tcase '$concatArrays': return evalConcatArrays(operand, doc);\n\t\tcase '$filter': return evalFilter(operand, doc);\n\t\tcase '$in': return evalIn(operand, doc);\n\t\tcase '$indexOfArray': return evalIndexOfArray(operand, doc);\n\t\tcase '$isArray': return evalIsArray(operand, doc);\n\t\tcase '$map': return evalMap(operand, doc);\n\t\tcase '$reduce': return evalReduce(operand, doc);\n\t\tcase '$size': return evalSize(operand, doc);\n\t\tcase '$slice': return evalSlice(operand, doc);\n\t\tcase '$reverseArray': return evalReverseArray(operand, doc);\n\t\tcase '$zip': return evalZip(operand, doc);\n\t\t\n\t\t// Type operators\n\t\tcase '$type': return evalType(operand, doc);\n\t\tcase '$convert': return evalConvert(operand, doc);\n\t\tcase '$toBool': return evalToBool(operand, doc);\n\t\tcase '$toDecimal': return evalToDecimal(operand, doc);\n\t\tcase '$toDouble': return evalToDouble(operand, doc);\n\t\tcase '$toInt': return evalToInt(operand, doc);\n\t\tcase '$toLong': return evalToLong(operand, doc);\n\t\tcase '$toString': return evalToString(operand, doc);\n\t\t\n\t\t// Object operators\n\t\tcase '$objectToArray': return evalObjectToArray(operand, doc);\n\t\tcase '$arrayToObject': return evalArrayToObject(operand, doc);\n\t\tcase '$mergeObjects': return evalMergeObjects(operand, doc);\n\t\t\n\t\t// Literal operator\n\t\tcase '$literal': return operand;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported aggregation operator: ${operator}`);\n\t}\n}\n\n// ============================================================================\n// ARITHMETIC OPERATORS\n// ============================================================================\n\nfunction evalAdd(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet sum = 0;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val instanceof Date) {\n\t\t\tsum += val.getTime();\n\t\t} else if (typeof val === 'number') {\n\t\t\tsum += val;\n\t\t}\n\t}\n\treturn sum;\n}\n\nfunction evalSubtract(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\t\n\tif (val1 instanceof Date && val2 instanceof Date) {\n\t\treturn val1.getTime() - val2.getTime();\n\t} else if (val1 instanceof Date && typeof val2 === 'number') {\n\t\treturn new Date(val1.getTime() - val2);\n\t} else if (typeof val1 === 'number' && typeof val2 === 'number') {\n\t\treturn val1 - val2;\n\t}\n\treturn null;\n}\n\nfunction evalMultiply(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet product = 1;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (typeof val === 'number') {\n\t\t\tproduct *= val;\n\t\t}\n\t}\n\treturn product;\n}\n\nfunction evalDivide(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\tif (typeof val1 === 'number' && typeof val2 === 'number' && val2 !== 0) {\n\t\treturn val1 / val2;\n\t}\n\treturn null;\n}\n\nfunction evalMod(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\tif (typeof val1 === 'number' && typeof val2 === 'number' && val2 !== 0) {\n\t\treturn val1 % val2;\n\t}\n\treturn null;\n}\n\nfunction evalPow(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst base = evaluateExpression(operands[0], doc);\n\tconst exponent = evaluateExpression(operands[1], doc);\n\tif (typeof base === 'number' && typeof exponent === 'number') {\n\t\treturn Math.pow(base, exponent);\n\t}\n\treturn null;\n}\n\nfunction evalSqrt(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number' && val >= 0) {\n\t\treturn Math.sqrt(val);\n\t}\n\treturn null;\n}\n\nfunction evalAbs(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.abs(val);\n\t}\n\treturn null;\n}\n\nfunction evalCeil(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.ceil(val);\n\t}\n\treturn null;\n}\n\nfunction evalFloor(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.floor(val);\n\t}\n\treturn null;\n}\n\nfunction evalTrunc(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (typeof val === 'number') {\n\t\treturn Math.trunc(val);\n\t}\n\treturn null;\n}\n\nfunction evalRound(operands, doc) {\n\tconst val = evaluateExpression(Array.isArray(operands) ? operands[0] : operands, doc);\n\tconst place = Array.isArray(operands) && operands[1] !== undefined \n\t\t? evaluateExpression(operands[1], doc) \n\t\t: 0;\n\t\n\tif (typeof val === 'number' && typeof place === 'number') {\n\t\tconst multiplier = Math.pow(10, place);\n\t\treturn Math.round(val * multiplier) / multiplier;\n\t}\n\treturn null;\n}\n\n// ============================================================================\n// STRING OPERATORS\n// ============================================================================\n\nfunction evalConcat(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tlet result = '';\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val !== null && val !== undefined) {\n\t\t\tresult += String(val);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalSubstr(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 3) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst start = evaluateExpression(operands[1], doc);\n\tconst length = evaluateExpression(operands[2], doc);\n\tif (typeof start === 'number' && typeof length === 'number') {\n\t\treturn str.substr(start, length);\n\t}\n\treturn null;\n}\n\nfunction evalToLower(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).toLowerCase() : '';\n}\n\nfunction evalToUpper(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).toUpperCase() : '';\n}\n\nfunction evalTrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`^[${escapeRegex(chars)}]+|[${escapeRegex(chars)}]+$`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.trim();\n}\n\nfunction evalLtrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`^[${escapeRegex(chars)}]+`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.replace(/^\\s+/, '');\n}\n\nfunction evalRtrim(operand, doc) {\n\tconst val = evaluateExpression(typeof operand === 'object' && operand.input ? operand.input : operand, doc);\n\tconst chars = operand.chars ? evaluateExpression(operand.chars, doc) : null;\n\t\n\tlet str = val !== null && val !== undefined ? String(val) : '';\n\t\n\tif (chars) {\n\t\tconst charsRegex = new RegExp(`[${escapeRegex(chars)}]+$`, 'g');\n\t\treturn str.replace(charsRegex, '');\n\t}\n\treturn str.replace(/\\s+$/, '');\n}\n\nfunction evalSplit(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst delimiter = String(evaluateExpression(operands[1], doc) || '');\n\treturn str.split(delimiter);\n}\n\nfunction evalStrLenCP(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn val !== null && val !== undefined ? String(val).length : 0;\n}\n\nfunction evalStrcasecmp(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst str1 = String(evaluateExpression(operands[0], doc) || '').toLowerCase();\n\tconst str2 = String(evaluateExpression(operands[1], doc) || '').toLowerCase();\n\t\n\tif (str1 < str2) return -1;\n\tif (str1 > str2) return 1;\n\treturn 0;\n}\n\nfunction evalIndexOfCP(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst str = String(evaluateExpression(operands[0], doc) || '');\n\tconst substr = String(evaluateExpression(operands[1], doc) || '');\n\tconst start = operands[2] !== undefined ? evaluateExpression(operands[2], doc) : 0;\n\tconst end = operands[3] !== undefined ? evaluateExpression(operands[3], doc) : str.length;\n\t\n\tconst searchStr = str.substring(start, end);\n\tconst index = searchStr.indexOf(substr);\n\treturn index === -1 ? -1 : index + start;\n}\n\nfunction evalReplaceOne(operand, doc) {\n\tconst input = String(evaluateExpression(operand.input, doc) || '');\n\tconst find = String(evaluateExpression(operand.find, doc) || '');\n\tconst replacement = String(evaluateExpression(operand.replacement, doc) || '');\n\t\n\treturn input.replace(find, replacement);\n}\n\nfunction evalReplaceAll(operand, doc) {\n\tconst input = String(evaluateExpression(operand.input, doc) || '');\n\tconst find = String(evaluateExpression(operand.find, doc) || '');\n\tconst replacement = String(evaluateExpression(operand.replacement, doc) || '');\n\t\n\treturn input.split(find).join(replacement);\n}\n\nfunction escapeRegex(str) {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// ============================================================================\n// COMPARISON OPERATORS\n// ============================================================================\n\nfunction evalCmp(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\t\n\tif (val1 < val2) return -1;\n\tif (val1 > val2) return 1;\n\treturn 0;\n}\n\nfunction evalEq(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 === val2;\n}\n\nfunction evalNe(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 !== val2;\n}\n\nfunction evalGt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 > val2;\n}\n\nfunction evalGte(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 >= val2;\n}\n\nfunction evalLt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 < val2;\n}\n\nfunction evalLte(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst val1 = evaluateExpression(operands[0], doc);\n\tconst val2 = evaluateExpression(operands[1], doc);\n\treturn val1 <= val2;\n}\n\n// ============================================================================\n// LOGICAL OPERATORS\n// ============================================================================\n\nfunction evalAnd(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (!val) return false;\n\t}\n\treturn true;\n}\n\nfunction evalOr(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tfor (const operand of operands) {\n\t\tconst val = evaluateExpression(operand, doc);\n\t\tif (val) return true;\n\t}\n\treturn false;\n}\n\nfunction evalNot(operand, doc) {\n\tconst val = evaluateExpression(Array.isArray(operand) ? operand[0] : operand, doc);\n\treturn !val;\n}\n\n// ============================================================================\n// CONDITIONAL OPERATORS\n// ============================================================================\n\nfunction evalCond(operand, doc) {\n\t// Supports both array form [if, then, else] and object form {if, then, else}\n\tlet ifExpr, thenExpr, elseExpr;\n\t\n\tif (Array.isArray(operand)) {\n\t\tif (operand.length !== 3) return null;\n\t\t[ifExpr, thenExpr, elseExpr] = operand;\n\t} else if (typeof operand === 'object') {\n\t\tifExpr = operand.if;\n\t\tthenExpr = operand.then;\n\t\telseExpr = operand.else;\n\t} else {\n\t\treturn null;\n\t}\n\t\n\tconst condition = evaluateExpression(ifExpr, doc);\n\treturn condition ? evaluateExpression(thenExpr, doc) : evaluateExpression(elseExpr, doc);\n}\n\nfunction evalIfNull(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\t\n\tfor (let i = 0; i < operands.length; i++) {\n\t\tconst val = evaluateExpression(operands[i], doc);\n\t\tif (val !== null && val !== undefined) {\n\t\t\treturn val;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction evalSwitch(operand, doc) {\n\tif (typeof operand !== 'object' || !Array.isArray(operand.branches)) {\n\t\treturn null;\n\t}\n\t\n\tfor (const branch of operand.branches) {\n\t\tconst caseResult = evaluateExpression(branch.case, doc);\n\t\tif (caseResult) {\n\t\t\treturn evaluateExpression(branch.then, doc);\n\t\t}\n\t}\n\t\n\treturn operand.default !== undefined ? evaluateExpression(operand.default, doc) : null;\n}\n\n// ============================================================================\n// DATE OPERATORS\n// ============================================================================\n\nfunction evalYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCFullYear();\n\t}\n\treturn null;\n}\n\nfunction evalMonth(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMonth() + 1; // MongoDB returns 1-12\n\t}\n\treturn null;\n}\n\nfunction evalDayOfMonth(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCDate();\n\t}\n\treturn null;\n}\n\nfunction evalDayOfWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCDay() + 1; // MongoDB returns 1-7 (Sunday is 1)\n\t}\n\treturn null;\n}\n\nfunction evalDayOfYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst start = new Date(Date.UTC(date.getUTCFullYear(), 0, 0));\n\t\tconst diff = date - start;\n\t\tconst oneDay = 1000 * 60 * 60 * 24;\n\t\treturn Math.floor(diff / oneDay);\n\t}\n\treturn null;\n}\n\nfunction evalHour(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCHours();\n\t}\n\treturn null;\n}\n\nfunction evalMinute(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMinutes();\n\t}\n\treturn null;\n}\n\nfunction evalSecond(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCSeconds();\n\t}\n\treturn null;\n}\n\nfunction evalMillisecond(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\treturn date.getUTCMilliseconds();\n\t}\n\treturn null;\n}\n\nfunction evalWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst onejan = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));\n\t\tconst week = Math.ceil((((date - onejan) / 86400000) + onejan.getUTCDay() + 1) / 7);\n\t\treturn week - 1; // MongoDB weeks are 0-indexed\n\t}\n\treturn null;\n}\n\nfunction evalIsoWeek(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst target = new Date(date.valueOf());\n\t\tconst dayNr = (date.getUTCDay() + 6) % 7;\n\t\ttarget.setUTCDate(target.getUTCDate() - dayNr + 3);\n\t\tconst firstThursday = target.valueOf();\n\t\ttarget.setUTCMonth(0, 1);\n\t\tif (target.getUTCDay() !== 4) {\n\t\t\ttarget.setUTCMonth(0, 1 + ((4 - target.getUTCDay()) + 7) % 7);\n\t\t}\n\t\treturn 1 + Math.ceil((firstThursday - target) / 604800000);\n\t}\n\treturn null;\n}\n\nfunction evalIsoWeekYear(operand, doc) {\n\tconst date = evaluateExpression(operand, doc);\n\tif (date instanceof Date) {\n\t\tconst target = new Date(date.valueOf());\n\t\ttarget.setUTCDate(target.getUTCDate() - ((date.getUTCDay() + 6) % 7) + 3);\n\t\treturn target.getUTCFullYear();\n\t}\n\treturn null;\n}\n\nfunction evalDateToString(operand, doc) {\n\tconst format = operand.format ? evaluateExpression(operand.format, doc) : '%Y-%m-%dT%H:%M:%S.%LZ';\n\tconst date = evaluateExpression(operand.date, doc);\n\t\n\tif (!(date instanceof Date)) return null;\n\t\n\t// Simple format string implementation using UTC methods\n\treturn format\n\t\t.replace('%Y', date.getUTCFullYear())\n\t\t.replace('%m', String(date.getUTCMonth() + 1).padStart(2, '0'))\n\t\t.replace('%d', String(date.getUTCDate()).padStart(2, '0'))\n\t\t.replace('%H', String(date.getUTCHours()).padStart(2, '0'))\n\t\t.replace('%M', String(date.getUTCMinutes()).padStart(2, '0'))\n\t\t.replace('%S', String(date.getUTCSeconds()).padStart(2, '0'))\n\t\t.replace('%L', String(date.getUTCMilliseconds()).padStart(3, '0'));\n}\n\nfunction evalToDate(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (val instanceof Date) return val;\n\tif (typeof val === 'string' || typeof val === 'number') {\n\t\tconst date = new Date(val);\n\t\treturn isNaN(date.getTime()) ? null : date;\n\t}\n\treturn null;\n}\n\n// ============================================================================\n// ARRAY OPERATORS\n// ============================================================================\n\nfunction evalArrayElemAt(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\tconst idx = evaluateExpression(operands[1], doc);\n\t\n\tif (!Array.isArray(arr) || typeof idx !== 'number') return null;\n\t\n\tconst index = idx < 0 ? arr.length + idx : idx;\n\treturn arr[index];\n}\n\nfunction evalConcatArrays(operands, doc) {\n\tif (!Array.isArray(operands)) return null;\n\tconst result = [];\n\tfor (const operand of operands) {\n\t\tconst arr = evaluateExpression(operand, doc);\n\t\tif (Array.isArray(arr)) {\n\t\t\tresult.push(...arr);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalFilter(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst asVar = operand.as || 'this';\n\tconst cond = operand.cond;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\treturn input.filter(item => {\n\t\tconst itemDoc = { ...doc, [asVar]: item };\n\t\treturn evaluateExpression(cond, itemDoc);\n\t});\n}\n\nfunction evalIn(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length !== 2) return null;\n\tconst value = evaluateExpression(operands[0], doc);\n\tconst arr = evaluateExpression(operands[1], doc);\n\t\n\tif (!Array.isArray(arr)) return false;\n\treturn arr.includes(value);\n}\n\nfunction evalIndexOfArray(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\tconst search = evaluateExpression(operands[1], doc);\n\tconst start = operands[2] !== undefined ? evaluateExpression(operands[2], doc) : 0;\n\tconst end = operands[3] !== undefined ? evaluateExpression(operands[3], doc) : arr.length;\n\t\n\tif (!Array.isArray(arr)) return null;\n\t\n\tfor (let i = start; i < end && i < arr.length; i++) {\n\t\tif (arr[i] === search) return i;\n\t}\n\treturn -1;\n}\n\nfunction evalIsArray(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn Array.isArray(val);\n}\n\nfunction evalMap(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst asVar = operand.as || 'this';\n\tconst inExpr = operand.in;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\treturn input.map(item => {\n\t\tconst itemDoc = { ...doc, [asVar]: item };\n\t\treturn evaluateExpression(inExpr, itemDoc);\n\t});\n}\n\nfunction evalReduce(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst initialValue = evaluateExpression(operand.initialValue, doc);\n\tconst inExpr = operand.in;\n\t\n\tif (!Array.isArray(input)) return null;\n\t\n\tlet value = initialValue;\n\tfor (const item of input) {\n\t\tconst itemDoc = { ...doc, value, this: item };\n\t\tvalue = evaluateExpression(inExpr, itemDoc);\n\t}\n\treturn value;\n}\n\nfunction evalSize(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\treturn Array.isArray(arr) ? arr.length : null;\n}\n\nfunction evalSlice(operands, doc) {\n\tif (!Array.isArray(operands) || operands.length < 2) return null;\n\tconst arr = evaluateExpression(operands[0], doc);\n\t\n\tif (!Array.isArray(arr)) return null;\n\t\n\tif (operands.length === 2) {\n\t\tconst n = evaluateExpression(operands[1], doc);\n\t\treturn n >= 0 ? arr.slice(0, n) : arr.slice(n);\n\t} else {\n\t\tconst position = evaluateExpression(operands[1], doc);\n\t\tconst n = evaluateExpression(operands[2], doc);\n\t\treturn arr.slice(position, position + n);\n\t}\n}\n\nfunction evalReverseArray(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\treturn Array.isArray(arr) ? arr.slice().reverse() : null;\n}\n\nfunction evalZip(operand, doc) {\n\tconst inputs = operand.inputs ? evaluateExpression(operand.inputs, doc) : null;\n\tconst useLongestLength = operand.useLongestLength || false;\n\tconst defaults = operand.defaults;\n\t\n\tif (!Array.isArray(inputs)) return null;\n\t\n\tconst arrays = inputs.map(input => evaluateExpression(input, doc));\n\tif (!arrays.every(arr => Array.isArray(arr))) return null;\n\t\n\tconst maxLength = Math.max(...arrays.map(arr => arr.length));\n\tconst length = useLongestLength ? maxLength : Math.min(...arrays.map(arr => arr.length));\n\t\n\tconst result = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tconst tuple = [];\n\t\tfor (let j = 0; j < arrays.length; j++) {\n\t\t\tif (i < arrays[j].length) {\n\t\t\t\ttuple.push(arrays[j][i]);\n\t\t\t} else if (defaults && j < defaults.length) {\n\t\t\t\ttuple.push(defaults[j]);\n\t\t\t} else {\n\t\t\t\ttuple.push(null);\n\t\t\t}\n\t\t}\n\t\tresult.push(tuple);\n\t}\n\treturn result;\n}\n\n// ============================================================================\n// TYPE OPERATORS\n// ============================================================================\n\nfunction evalType(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\t\n\tif (val === null) return 'null';\n\tif (val === undefined) return 'missing';\n\tif (typeof val === 'boolean') return 'bool';\n\tif (typeof val === 'number') return Number.isInteger(val) ? 'int' : 'double';\n\tif (typeof val === 'string') return 'string';\n\tif (val instanceof Date) return 'date';\n\tif (Array.isArray(val)) return 'array';\n\tif (typeof val === 'object') return 'object';\n\t\n\treturn 'unknown';\n}\n\nfunction evalConvert(operand, doc) {\n\tconst input = evaluateExpression(operand.input, doc);\n\tconst to = operand.to;\n\tconst onError = operand.onError;\n\tconst onNull = operand.onNull;\n\t\n\tif (input === null) {\n\t\treturn onNull !== undefined ? evaluateExpression(onNull, doc) : null;\n\t}\n\t\n\ttry {\n\t\tswitch (to) {\n\t\t\tcase 'double':\n\t\t\tcase 'decimal':\n\t\t\t\treturn parseFloat(input);\n\t\t\tcase 'int':\n\t\t\tcase 'long':\n\t\t\t\treturn parseInt(input);\n\t\t\tcase 'bool':\n\t\t\t\treturn Boolean(input);\n\t\t\tcase 'string':\n\t\t\t\treturn String(input);\n\t\t\tcase 'date':\n\t\t\t\treturn new Date(input);\n\t\t\tdefault:\n\t\t\t\treturn input;\n\t\t}\n\t} catch (e) {\n\t\treturn onError !== undefined ? evaluateExpression(onError, doc) : null;\n\t}\n}\n\nfunction evalToBool(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn Boolean(val);\n}\n\nfunction evalToDecimal(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseFloat(val);\n}\n\nfunction evalToDouble(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseFloat(val);\n}\n\nfunction evalToInt(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseInt(val);\n}\n\nfunction evalToLong(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\treturn parseInt(val);\n}\n\nfunction evalToString(operand, doc) {\n\tconst val = evaluateExpression(operand, doc);\n\tif (val === null || val === undefined) return null;\n\treturn String(val);\n}\n\n// ============================================================================\n// OBJECT OPERATORS\n// ============================================================================\n\nfunction evalObjectToArray(operand, doc) {\n\tconst obj = evaluateExpression(operand, doc);\n\tif (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n\t\treturn null;\n\t}\n\t\n\treturn Object.keys(obj).map(key => ({ k: key, v: obj[key] }));\n}\n\nfunction evalArrayToObject(operand, doc) {\n\tconst arr = evaluateExpression(operand, doc);\n\tif (!Array.isArray(arr)) return null;\n\t\n\tconst result = {};\n\tfor (const item of arr) {\n\t\tif (Array.isArray(item) && item.length === 2) {\n\t\t\tresult[item[0]] = item[1];\n\t\t} else if (typeof item === 'object' && item.k !== undefined && item.v !== undefined) {\n\t\t\tresult[item.k] = item.v;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction evalMergeObjects(operands, doc) {\n\tif (!Array.isArray(operands)) {\n\t\t// Single object\n\t\treturn evaluateExpression(operands, doc);\n\t}\n\t\n\tconst result = {};\n\tfor (const operand of operands) {\n\t\tconst obj = evaluateExpression(operand, doc);\n\t\tif (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {\n\t\t\tObject.assign(result, obj);\n\t\t}\n\t}\n\treturn result;\n}\n","import { getProp, getFieldValues, isArray, arrayMatches, objectMatches, toArray, isIn, bboxToGeojson } from './utils.js';\nimport { TextIndex } from './TextIndex.js';\nimport { ObjectId } from 'bjson';\nimport { evaluateExpression } from './aggregationExpressions.js';\n\n/**\n * BSON type mappings for $type operator\n */\nconst BSON_TYPES = {\n\t1: 'double',\n\t2: 'string',\n\t3: 'object',\n\t4: 'array',\n\t5: 'binData',\n\t6: 'undefined',\n\t7: 'objectId',\n\t8: 'bool',\n\t9: 'date',\n\t10: 'null',\n\t11: 'regex',\n\t13: 'javascript',\n\t15: 'javascriptWithScope',\n\t16: 'int',\n\t17: 'timestamp',\n\t18: 'long',\n\t19: 'decimal',\n\t127: 'maxKey',\n\t'-1': 'minKey'\n};\n\n// Reverse mapping from alias to code\nconst TYPE_ALIASES = Object.entries(BSON_TYPES).reduce((acc, [code, name]) => {\n\tacc[name] = parseInt(code);\n\treturn acc;\n}, {});\n\n/**\n * Check if a value matches a BSON type or type code\n */\nfunction matchesType(value, typeSpec) {\n\t// Handle array of types\n\tif (isArray(typeSpec)) {\n\t\tfor (let i = 0; i < typeSpec.length; i++) {\n\t\t\tif (matchesType(value, typeSpec[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Get type code from spec (can be number or string alias)\n\tconst typeCode = typeof typeSpec === 'number' ? typeSpec : TYPE_ALIASES[typeSpec];\n\tconst typeName = BSON_TYPES[typeCode] || typeSpec;\n\t\n\t// Check value type\n\tif (value === null) return typeName === 'null' || typeCode === 10;\n\tif (value === undefined) return typeName === 'undefined' || typeCode === 6;\n\tif (typeof value === 'number') {\n\t\tif (Number.isInteger(value)) return typeName === 'int' || typeCode === 16;\n\t\treturn typeName === 'double' || typeCode === 1;\n\t}\n\tif (typeof value === 'string') return typeName === 'string' || typeCode === 2;\n\tif (typeof value === 'boolean') return typeName === 'bool' || typeCode === 8;\n\tif (value instanceof Date) return typeName === 'date' || typeCode === 9;\n\tif (value instanceof ObjectId) return typeName === 'objectId' || typeCode === 7;\n\tif (value instanceof RegExp) return typeName === 'regex' || typeCode === 11;\n\tif (isArray(value)) return typeName === 'array' || typeCode === 4;\n\tif (typeof value === 'object') return typeName === 'object' || typeCode === 3;\n\t\n\t// Fallback to simple type check\n\treturn typeof value === typeSpec;\n}\n\n/**\n * Bit query operator helpers\n */\nfunction toBitMask(positions) {\n\tif (isArray(positions)) {\n\t\t// Array of bit positions\n\t\tlet mask = 0;\n\t\tfor (let i = 0; i < positions.length; i++) {\n\t\t\tmask |= (1 << positions[i]);\n\t\t}\n\t\treturn mask;\n\t} else if (typeof positions === 'number') {\n\t\t// Bitmask directly\n\t\treturn positions;\n\t}\n\treturn 0;\n}\n\nfunction matchesBitsAllSet(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) === mask;\n}\n\nfunction matchesBitsAllClear(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) === 0;\n}\n\nfunction matchesBitsAnySet(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) !== 0;\n}\n\nfunction matchesBitsAnyClear(value, positions) {\n\tif (typeof value !== 'number') return false;\n\tconst mask = toBitMask(positions);\n\treturn (value & mask) !== mask;\n}\n\n/**\n * JSON Schema validator (simplified)\n */\nfunction validateJsonSchema(doc, schema) {\n\t// Basic JSON Schema validation\n\tif (schema.type) {\n\t\tconst docType = isArray(doc) ? 'array' : (doc === null ? 'null' : typeof doc);\n\t\tif (schema.type !== docType) return false;\n\t}\n\t\n\tif (schema.required && isArray(schema.required)) {\n\t\tfor (let i = 0; i < schema.required.length; i++) {\n\t\t\tif (!(schema.required[i] in doc)) return false;\n\t\t}\n\t}\n\t\n\tif (schema.properties) {\n\t\tfor (const key in schema.properties) {\n\t\t\t// When using $jsonSchema as a query operator, properties must exist to match\n\t\t\t// (This is different from standard JSON Schema validation where properties are optional)\n\t\t\tif (!(key in doc)) return false;\n\t\t\t\n\t\t\tconst propSchema = schema.properties[key];\n\t\t\tif (!validateJsonSchema(doc[key], propSchema)) return false;\n\t\t}\n\t}\n\t\n\tif (schema.minimum !== undefined && typeof doc === 'number') {\n\t\tif (doc < schema.minimum) return false;\n\t}\n\t\n\tif (schema.maximum !== undefined && typeof doc === 'number') {\n\t\tif (doc > schema.maximum) return false;\n\t}\n\t\n\tif (schema.minLength !== undefined && typeof doc === 'string') {\n\t\tif (doc.length < schema.minLength) return false;\n\t}\n\t\n\tif (schema.maxLength !== undefined && typeof doc === 'string') {\n\t\tif (doc.length > schema.maxLength) return false;\n\t}\n\t\n\tif (schema.pattern && typeof doc === 'string') {\n\t\tconst regex = new RegExp(schema.pattern);\n\t\tif (!regex.test(doc)) return false;\n\t}\n\t\n\tif (schema.enum && isArray(schema.enum)) {\n\t\tif (!schema.enum.includes(doc)) return false;\n\t}\n\t\n\treturn true;\n}\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId && b instanceof ObjectId) {\n    return a.equals(b);\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Compare two values with a comparison operator, handling ObjectId instances\n */\nfunction compareValues(a, b, operator) {\n\t// Convert ObjectIds to comparable values (use timestamp for ordering)\n\tlet aVal = a;\n\tlet bVal = b;\n\t\n\tif (a instanceof ObjectId) {\n\t\taVal = a.toString();\n\t}\n\tif (b instanceof ObjectId) {\n\t\tbVal = b.toString();\n\t}\n\t\n\tswitch(operator) {\n\t\tcase '>': return aVal > bVal;\n\t\tcase '>=': return aVal >= bVal;\n\t\tcase '<': return aVal < bVal;\n\t\tcase '<=': return aVal <= bVal;\n\t\tdefault: return false;\n\t}\n}\n\n/**\n * Check if a field value (possibly from array traversal) matches a condition\n * Handles both single values and arrays of values (from array traversal)\n */\nfunction fieldValueMatches(fieldValue, checkFn) {\n\t// Use strict equality to allow null values through\n\tif (fieldValue === undefined) return false;\n\t\n\t// Check for null before isArray to avoid crash\n\tif (fieldValue === null) return checkFn(fieldValue);\n\t\n\t// If fieldValue is an array (from array traversal), check if ANY element matches\n\tif (isArray(fieldValue)) {\n\t\tfor (var i = 0; i < fieldValue.length; i++) {\n\t\t\tif (checkFn(fieldValue[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Otherwise check the single value\n\treturn checkFn(fieldValue);\n}\n\n/**\n * Text search helper\n * Creates a temporary TextIndex to check if the text matches the query\n */\nexport function text(prop, query) {\n\tconst textIndex = new TextIndex();\n\ttextIndex.add('id', prop);\n\tconst results = textIndex.query(query, { scored: false });\n\treturn results.length === 1;\n}\n\n/**\n * Geo within helper - using bounding box logic instead of de9im\n * This is a simpler implementation that doesn't require de9im dependency\n */\nexport function geoWithin(prop, query) {\n\ttry {\n\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\tif (!Array.isArray(query) || query.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst minLon = query[0][0];\n\t\tconst maxLat = query[0][1];\n\t\tconst maxLon = query[1][0];\n\t\tconst minLat = query[1][1];\n\n\t\t// Check if geometry is within bounding box\n\t\treturn isGeometryWithinBBox(prop, minLon, maxLon, minLat, maxLat);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if a GeoJSON geometry is within a bounding box\n * For Points: checks if the point is within the bbox\n * For Polygons: checks if ALL vertices are within the bbox\n */\nfunction isGeometryWithinBBox(geoJson, minLon, maxLon, minLat, maxLat) {\n\tif (!geoJson) return false;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t// All features must be within the bbox\n\t\tfor (const feature of geoJson.features) {\n\t\t\tif (feature.geometry) {\n\t\t\t\tif (!isGeometryWithinBBox(feature.geometry, minLon, maxLon, minLat, maxLat)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn isGeometryWithinBBox(geoJson.geometry, minLon, maxLon, minLat, maxLat);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn lng >= minLon && lng <= maxLon && lat >= minLat && lat <= maxLat;\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - ALL vertices must be within the bbox\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tfor (const ring of geoJson.coordinates) {\n\t\t\tfor (const coord of ring) {\n\t\t\t\tconst lng = coord[0];\n\t\t\t\tconst lat = coord[1];\n\t\t\t\tif (lng < minLon || lng > maxLon || lat < minLat || lat > maxLat) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Extract coordinates from a GeoJSON object for indexing purposes\n * This uses centroid for polygons to get a single point to index\n * @param {Object} geoJson - The GeoJSON object\n * @returns {Object|null} Object with lat and lng, or null if invalid\n */\nfunction extractCoordinatesFromGeoJSON(geoJson) {\n\tif (!geoJson) return null;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\tconst feature = geoJson.features[0];\n\t\tif (feature.geometry) {\n\t\t\treturn extractCoordinatesFromGeoJSON(feature.geometry);\n\t\t}\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn extractCoordinatesFromGeoJSON(geoJson.geometry);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn { lat, lng };\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - use centroid of first coordinate ring\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tconst ring = geoJson.coordinates[0];\n\t\tif (ring.length > 0) {\n\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\tfor (const coord of ring) {\n\t\t\t\tsumLng += coord[0];\n\t\t\t\tsumLat += coord[1];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\tlng: sumLng / ring.length\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * $where operator implementation\n * SECURITY NOTE: This uses Function constructor which can execute arbitrary code.\n * This is acceptable for a local/in-memory database but should NOT be used\n * in environments where untrusted user input is processed.\n */\nexport function where(doc, value) {\n\tif (typeof value === 'function') {\n\t\ttry {\n\t\t\treturn value.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t} else if (typeof value === 'string') {\n\t\t// Evaluate the string as a function\n\t\ttry {\n\t\t\tvar fn = new Function('return ' + value);\n\t\t\treturn fn.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Top-level match function\n */\nexport function tlMatches(doc, query) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return and(doc, value);\n\t\telse if (key == \"$or\") return or(doc, value);\n\t\telse if (key == \"$not\") return not(doc, value);\n\t\telse if (key == \"$nor\") return nor(doc, value);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse if (key == \"$comment\") return true; // $comment is metadata, doesn't filter\n\t\telse if (key == \"$jsonSchema\") return validateJsonSchema(doc, value); // Top-level schema validation\n\t\telse if (key == \"$expr\") {\n\t\t\t// Handle $expr at top level\n\t\t\ttry {\n\t\t\t\treturn evaluateExpression(value, doc);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatches(doc, key, value);\n\t}\n}\n\n/**\n * Operator match function\n */\nexport function opMatches(doc, key, value) {\n\t// Get field value using array-aware traversal\n\tvar fieldValue = getFieldValues(doc, key);\n\t\n\tif (typeof (value) == \"string\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"number\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"boolean\") return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (value instanceof ObjectId) return fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return fieldValue != undefined && fieldValueMatches(fieldValue, function(v) { return v && v.match(value); });\n\t\telse if (isArray(value)) return fieldValue != undefined && fieldValueMatches(fieldValue, function(v) { return v && arrayMatches(v, value); });\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = Object.keys(value)[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '>'); })) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '>='); })) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '<'); })) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return compareValues(v, operand, '<='); })) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return !valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (fieldValueMatches(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$exists\") {\n\t\t\t\t\t\t// For $exists, we need to use getProp which returns undefined if field doesn't exist\n\t\t\t\t\t\t// getFieldValues might return an array which would be truthy\n\t\t\t\t\tvar rawValue = getProp(doc, key);\n\t\t\t\t\tif (operand ? rawValue == undefined : rawValue != undefined) return false;\n\t\t\t\t} else if (operator == \"$type\") {\n\t\t\t\t\t// Support both BSON type codes and aliases\n\t\t\t\t\t// Note: $type checks the field value itself, not array elements\n\t\t\t\t\t// If field doesn't exist (undefined), it can only match type 'undefined' (6)\n\t\t\t\t\tif (fieldValue === undefined) {\n\t\t\t\t\t\tconst expectedTypeCode = typeof operand === 'number' ? operand : TYPE_ALIASES[operand];\n\t\t\t\t\t\tif (expectedTypeCode !== 6) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!matchesType(fieldValue, operand)) return false;\n\t\t\t\t\t}\n\t\t\t\t} else if (operator == \"$mod\") {\n\t\t\t\t\tif (operand.length != 2) throw { $err: \"Can't canonicalize query: BadValue malformed mod, not enough elements\", code: 17287 };\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && (v % operand[0] == operand[1]); })) return false;\n\t\t\t\t} else if (operator == \"$regex\") {\n\t\t\t\t\t// Support string pattern with optional $options\n\t\t\t\t\tvar pattern = operand;\n\t\t\t\t\tvar flags = value.$options || '';\n\t\t\t\t\tvar regex = (typeof pattern === 'string') ? new RegExp(pattern, flags) : pattern;\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && regex.test(v); })) return false;\n\t\t\t\t} else if (operator == \"$options\") {\n\t\t\t\t\t// $options is handled with $regex, skip here\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (operator == \"$text\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && text(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$expr\") {\n\t\t\t\t\t// Evaluate aggregation expression against the document\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = evaluateExpression(operand, doc);\n\t\t\t\t\t\tif (!result) return false;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// If expression evaluation fails, don't match\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (operator == \"$geoWithin\") {\n\t\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return v != undefined && geoWithin(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$near\" || operator == \"$nearSphere\" || operator == \"$geoIntersects\") {\n\t\t\t\t\t\t// These operators MUST be handled by an index\n\t\t\t\t\t\t// They should never reach the matcher level\n\t\t\t\t\t\t// If they do, the query planner should have already filtered documents via the index\n\t\t\t\t\t\t// So we just skip validation here - the index already did the work\n\t\t\t\t\t\t// Don't return false, as that would exclude documents that the index already selected\n\t\t\t\t\t} else if (operator == \"$not\") {\n\t\t\t\t\t\tif (opMatches(doc, key, operand)) return false;\n\t\t\t\t\t} else if (operator == \"$all\") {\n\t\t\t\t\t\t// $all requires the field to be an array, use getProp not getFieldValues\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < operand.length; j++) {\n\t\t\t\t\t\t\tif (!isIn(operand[j], arrayFieldValue)) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\t// $elemMatch requires the field to be an array, use getProp not getFieldValues\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor (var j = 0; j < arrayFieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = arrayFieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && !(element == opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && !(element != opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$in\" && !isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$nin\" && isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found) return false;\n\t\t\t\t} else if (operator == \"$size\") {\n\t\t\t\t\tvar sizeFieldValue = getProp(doc, key);\n\t\t\t\t\tif (sizeFieldValue == undefined || !isArray(sizeFieldValue)) return false;\n\t\t\t\t\tif (sizeFieldValue.length != operand) return false;\n\t\t\t\t} else if (operator == \"$bitsAllSet\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAllSet(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAllClear\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAllClear(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAnySet\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAnySet(v, operand); })) return false;\n\t\t\t\t} else if (operator == \"$bitsAnyClear\") {\n\t\t\t\t\tif (!fieldValueMatches(fieldValue, function(v) { return matchesBitsAnyClear(v, operand); })) return false;\n\t\t\t\t} else {\n\t\t\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue unknown operator: \" + operator, code: 17287 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn getProp(doc, key) && objectMatches(getProp(doc, key), value);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * $not operator\n */\nexport function not(doc, value) {\n\treturn !tlMatches(doc, value);\n}\n\n/**\n * $and operator\n */\nexport function and(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatches(doc, els[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * $or operator\n */\nexport function or(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return true;\n\t}\n\treturn false;\n}\n\n/**\n * $nor operator\n */\nexport function nor(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Main matches function - query structure: (top level operators ( \"age\" : (operators) ))\n * top, top level query, implicit $and\n */\nexport function matches(doc, query) {\n\treturn and(doc, toArray(query));\n}\n\n/**\n * Enhanced matching function that also tracks which array index matched for positional operator ($)\n * Returns an object with:\n *   - matched: boolean indicating if the query matched\n *   - arrayFilters: object mapping field paths to the first matched array index\n * \n * Example: if query is { \"grades\": { $gte: 85 } } and doc is { grades: [80, 90, 85] }\n * Returns: { matched: true, arrayFilters: { \"grades\": 1 } } (index 1 is 90, first to match)\n */\nexport function matchWithArrayIndices(doc, query) {\n\tconst arrayFilters = {};\n\tconst matched = andWithTracking(doc, toArray(query), arrayFilters);\n\treturn { matched, arrayFilters };\n}\n\n/**\n * Helper to track array indices during AND matching\n */\nfunction andWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Top level match with tracking\n */\nfunction tlMatchesWithTracking(doc, query, arrayFilters) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return andWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$or\") return orWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$not\") {\n\t\t\t// For $not, we don't track positions as it's a negation\n\t\t\treturn !tlMatches(doc, value);\n\t\t}\n\t\telse if (key == \"$nor\") return norWithTracking(doc, value, arrayFilters);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse if (key == \"$comment\") return true;\n\t\telse if (key == \"$jsonSchema\") return validateJsonSchema(doc, value);\n\t\telse if (key == \"$expr\") {\n\t\t\ttry {\n\t\t\t\treturn evaluateExpression(value, doc);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatchesWithTracking(doc, key, value, arrayFilters);\n\t}\n}\n\n/**\n * OR operator with tracking - track positions from the first matching clause\n */\nfunction orWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * NOR operator with tracking\n */\nfunction norWithTracking(doc, els, arrayFilters) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatchesWithTracking(doc, els[i], arrayFilters)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Operator match with array index tracking\n */\nfunction opMatchesWithTracking(doc, key, value, arrayFilters) {\n\t// Get the base field (before any dots)\n\tconst baseField = key.split('.')[0];\n\tconst fieldValue = getFieldValues(doc, key);\n\t\n\t// Helper to track which index matched\n\tconst trackMatchingIndex = (fieldValue, checkFn) => {\n\t\tif (fieldValue === undefined) return false;\n\t\tif (fieldValue === null) return checkFn(fieldValue);\n\t\t\n\t\t// If fieldValue is an array from array traversal\n\t\tif (isArray(fieldValue)) {\n\t\t\t// Check if the base field itself is an array in the document\n\t\t\tconst baseValue = getProp(doc, baseField);\n\t\t\tif (isArray(baseValue)) {\n\t\t\t\t// Find first matching index\n\t\t\t\tfor (var i = 0; i < fieldValue.length; i++) {\n\t\t\t\t\tif (checkFn(fieldValue[i])) {\n\t\t\t\t\t\t// Track this as the matched index for this field\n\t\t\t\t\t\tarrayFilters[key] = i;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Otherwise use regular matching\n\t\treturn fieldValueMatches(fieldValue, checkFn);\n\t};\n\t\n\t// Now perform the actual matching with tracking\n\tif (typeof (value) == \"string\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"number\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"boolean\") return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (value instanceof ObjectId) return trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, value); });\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return v && v.match(value); });\n\t\telse if (isArray(value)) return fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return v && arrayMatches(v, value); });\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\t// Handle operators\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = keys[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '>'); })) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '>='); })) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '<'); })) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return compareValues(v, operand, '<='); })) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return !valuesEqual(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (!trackMatchingIndex(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (trackMatchingIndex(fieldValue, function(v) { return isIn(v, operand); })) return false;\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\t// Special handling for $elemMatch\n\t\t\t\t\t\tvar arrayFieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (arrayFieldValue == undefined || !isArray(arrayFieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < arrayFieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = arrayFieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tarrayFilters[key] = j;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && element != opValue) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && element == opValue) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tarrayFilters[key] = j;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For other operators, use standard matching\n\t\t\t\t\t\tif (!opMatches(doc, key, value)) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// Object equality\n\t\t\t\treturn fieldValue != undefined && trackMatchingIndex(fieldValue, function(v) { return objectMatches(v, value); });\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n","/**\n * Timestamp class - MongoDB-compatible BSON Timestamp\n * A 64-bit value where the high 32 bits represent seconds since Unix epoch\n * and the low 32 bits represent an incrementing ordinal\n */\nexport class Timestamp {\n  constructor(low, high) {\n    if (arguments.length === 0) {\n      // Generate new timestamp with current time\n      this.low = 0;\n      this.high = Math.floor(Date.now() / 1000);\n    } else if (arguments.length === 1) {\n      // Handle object with low/high properties\n      if (typeof low === 'object' && low !== null) {\n        this.low = low.low || 0;\n        this.high = low.high || 0;\n      } else {\n        // Single argument - use as high (seconds)\n        this.low = 0;\n        this.high = low;\n      }\n    } else {\n      // Two arguments: low (increment) and high (seconds)\n      this.low = low >>> 0; // Ensure unsigned 32-bit integer\n      this.high = high >>> 0; // Ensure unsigned 32-bit integer\n    }\n  }\n\n  /**\n   * Returns the timestamp in a comparable form\n   */\n  valueOf() {\n    return this.high * 0x100000000 + this.low;\n  }\n\n  /**\n   * Returns the timestamp as a string\n   */\n  toString() {\n    return `Timestamp(${this.high}, ${this.low})`;\n  }\n\n  /**\n   * Returns the timestamp as a JSON object\n   */\n  toJSON() {\n    return {\n      $timestamp: {\n        t: this.high,\n        i: this.low\n      }\n    };\n  }\n\n  /**\n   * Custom inspect for Node.js console.log\n   */\n  inspect() {\n    return this.toString();\n  }\n\n  /**\n   * Compares this Timestamp with another for equality\n   */\n  equals(other) {\n    if (!other) return false;\n    \n    if (other instanceof Timestamp) {\n      return this.low === other.low && this.high === other.high;\n    }\n    \n    if (typeof other === 'object' && other.low !== undefined && other.high !== undefined) {\n      return this.low === other.low && this.high === other.high;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get the seconds part of the timestamp\n   */\n  getHighBits() {\n    return this.high;\n  }\n\n  /**\n   * Get the increment part of the timestamp\n   */\n  getLowBits() {\n    return this.low;\n  }\n\n  /**\n   * Returns a Date object representing the timestamp\n   */\n  toDate() {\n    return new Date(this.high * 1000);\n  }\n\n  /**\n   * Creates a Timestamp from a Date object\n   */\n  static fromDate(date) {\n    const seconds = Math.floor(date.getTime() / 1000);\n    return new Timestamp(0, seconds);\n  }\n\n  /**\n   * Creates a Timestamp for the current time\n   */\n  static now() {\n    return new Timestamp();\n  }\n}\n","/**\n * Update operations module\n */\n\nimport { setProp, getProp, isArray } from './utils.js';\nimport { opMatches, matches } from './queryMatcher.js';\nimport { Timestamp } from './Timestamp.js';\n\n/**\n * Extract identifier from a filtered positional operator pattern like $[identifier]\n * Returns null if not a filtered positional operator\n */\nfunction extractFilteredPositionalIdentifier(pathSegment) {\n\tconst match = pathSegment.match(/^\\$\\[([^\\]]+)\\]$/);\n\treturn match ? match[1] : null;\n}\n\n/**\n * Parse a field path and extract filtered positional identifiers\n * Returns an array of path segments with metadata about which are filtered positional operators\n */\nfunction parseFieldPath(fieldPath) {\n\tconst segments = fieldPath.split('.');\n\treturn segments.map(segment => {\n\t\tconst identifier = extractFilteredPositionalIdentifier(segment);\n\t\treturn {\n\t\t\tsegment: segment,\n\t\t\tisFilteredPositional: identifier !== null,\n\t\t\tidentifier: identifier\n\t\t};\n\t});\n}\n\n/**\n * Apply an update operation to array elements matching arrayFilters\n */\nfunction applyToFilteredArrayElements(doc, parsedPath, value, operation, arrayFilters) {\n\t// Navigate through the path and apply updates to matching array elements\n\tfunction traverse(current, pathIndex, filterContext) {\n\t\tif (pathIndex >= parsedPath.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pathInfo = parsedPath[pathIndex];\n\t\tconst isLastSegment = pathIndex === parsedPath.length - 1;\n\n\t\tif (pathInfo.isFilteredPositional) {\n\t\t\t// This is a filtered positional operator like $[elem]\n\t\t\tconst identifier = pathInfo.identifier;\n\t\t\tconst filter = arrayFilters ? arrayFilters.find(f => {\n\t\t\t\t// Find the filter that uses this identifier\n\t\t\t\tconst filterKeys = Object.keys(f);\n\t\t\t\treturn filterKeys.some(key => key.startsWith(identifier + '.') || key === identifier);\n\t\t\t}) : null;\n\n\t\t\t// If arrayFilters is not provided, treat $[identifier] as a literal field name\n\t\t\tif (!arrayFilters) {\n\t\t\t\tif (!current[pathInfo.segment]) {\n\t\t\t\t\t// Create intermediate object/array as needed\n\t\t\t\t\tconst nextPath = parsedPath[pathIndex + 1];\n\t\t\t\t\tif (nextPath && nextPath.isFilteredPositional) {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t\t} else {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isArray(current)) {\n\t\t\t\t// If current is not an array, create it as an object property\n\t\t\t\tif (!current[pathInfo.segment]) {\n\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t}\n\t\t\t\tif (isLastSegment) {\n\t\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t\t} else {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Iterate through array elements and apply to matching ones\n\t\t\tfor (let i = 0; i < current.length; i++) {\n\t\t\t\tconst element = current[i];\n\t\t\t\t\n\t\t\t\t// Check if this element matches the filter\n\t\t\t\tlet shouldUpdate = true;\n\t\t\t\tif (filter) {\n\t\t\t\t\t// Transform filter to check against the element\n\t\t\t\t\t// If filter has identifier.field, check element.field\n\t\t\t\t\t// If filter has just identifier, check element directly\n\t\t\t\t\tlet transformedFilter = {};\n\t\t\t\t\tlet hasDirectMatch = false;\n\t\t\t\t\t\n\t\t\t\t\tObject.keys(filter).forEach(key => {\n\t\t\t\t\t\tif (key.startsWith(identifier + '.')) {\n\t\t\t\t\t\t\t// Replace \"identifier.field\" with just \"field\" for matching against element\n\t\t\t\t\t\t\tconst fieldPath = key.substring(identifier.length + 1);\n\t\t\t\t\t\t\ttransformedFilter[fieldPath] = filter[key];\n\t\t\t\t\t\t} else if (key === identifier) {\n\t\t\t\t\t\t\t// Direct identifier match - the filter condition applies to the element value itself\n\t\t\t\t\t\t\ttransformedFilter = filter[key];\n\t\t\t\t\t\t\thasDirectMatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Check if element matches the filter\n\t\t\t\t\tif (hasDirectMatch) {\n\t\t\t\t\t\t// For primitive values, we need to check against the condition directly\n\t\t\t\t\t\t// Create a wrapper to use the matches function\n\t\t\t\t\t\tconst testDoc = { value: element };\n\t\t\t\t\t\tconst testFilter = { value: transformedFilter };\n\t\t\t\t\t\tshouldUpdate = matches(testDoc, testFilter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For object properties, match against the element as a document\n\t\t\t\t\t\tshouldUpdate = matches(element, transformedFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldUpdate) {\n\t\t\t\t\tif (isLastSegment) {\n\t\t\t\t\t\t// Apply the operation to this array element\n\t\t\t\t\t\tapplyOperationToValue(current, i, value, operation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Continue traversing deeper\n\t\t\t\t\t\tif (element !== null && element !== undefined) {\n\t\t\t\t\t\t\ttraverse(current[i], pathIndex + 1, filterContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Regular path segment\n\t\t\tif (current[pathInfo.segment] === undefined || current[pathInfo.segment] === null) {\n\t\t\t\tif (!isLastSegment) {\n\t\t\t\t\t// Create intermediate object/array\n\t\t\t\t\tconst nextPath = parsedPath[pathIndex + 1];\n\t\t\t\t\tif (nextPath && nextPath.isFilteredPositional) {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[pathInfo.segment] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isLastSegment) {\n\t\t\t\tapplyOperationToValue(current, pathInfo.segment, value, operation);\n\t\t\t} else {\n\t\t\t\tif (current[pathInfo.segment] !== undefined && current[pathInfo.segment] !== null) {\n\t\t\t\t\ttraverse(current[pathInfo.segment], pathIndex + 1, filterContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(doc, 0, {});\n}\n\n/**\n * Apply a specific operation to a value (for use with filtered positional operators)\n */\nfunction applyOperationToValue(container, key, value, operation) {\n\tswitch (operation) {\n\t\tcase '$set':\n\t\t\tcontainer[key] = value;\n\t\t\tbreak;\n\t\tcase '$inc':\n\t\t\tif (container[key] === undefined) container[key] = 0;\n\t\t\tcontainer[key] += value;\n\t\t\tbreak;\n\t\tcase '$mul':\n\t\t\tcontainer[key] = container[key] * value;\n\t\t\tbreak;\n\t\tcase '$min':\n\t\t\tcontainer[key] = Math.min(container[key], value);\n\t\t\tbreak;\n\t\tcase '$max':\n\t\t\tcontainer[key] = Math.max(container[key], value);\n\t\t\tbreak;\n\t\tcase '$unset':\n\t\t\tdelete container[key];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontainer[key] = value;\n\t}\n}\n\n/**\n * Check if a field path contains a filtered positional operator\n */\nfunction hasFilteredPositionalOperator(fieldPath) {\n\treturn /\\$\\[[^\\]]+\\]/.test(fieldPath);\n}\n\n/**\n * Deep equality check for objects\n */\nfunction objectEquals(a, b) {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\t\n\t// Handle arrays\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\tfor (var i = 0; i < a.length; i++) {\n\t\t\tif (!objectEquals(a[i], b[i])) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t// Handle dates\n\tif (a instanceof Date && b instanceof Date) {\n\t\treturn a.getTime() === b.getTime();\n\t}\n\t\n\t// One is array, the other is not\n\tif (Array.isArray(a) !== Array.isArray(b)) return false;\n\t\n\tvar keysA = Object.keys(a);\n\tvar keysB = Object.keys(b);\n\t\n\tif (keysA.length !== keysB.length) return false;\n\t\n\tfor (var i = 0; i < keysA.length; i++) {\n\t\tvar key = keysA[i];\n\t\tif (!keysB.includes(key)) return false;\n\t\tif (!objectEquals(a[key], b[key])) return false;\n\t}\n\t\n\treturn true;\n}\n\n/**\n * Check if a field path contains the $[] positional operator\n */\nfunction hasAllPositional(field) {\n\treturn field.indexOf('$[]') !== -1;\n}\n\n/**\n * Apply an update function to all elements matching $[] operator\n * This is used for operators like $inc, $mul that need to read-modify-write\n */\nfunction applyToAllPositional(doc, field, updateFn) {\n\tvar path = field.split(\".\");\n\tvar current = doc;\n\t\n\t// Navigate to the first $[] operator\n\tfor (var i = 0; i < path.length; i++) {\n\t\tvar pathSegment = path[i];\n\t\t\n\t\tif (pathSegment === '$[]') {\n\t\t\t// Current should be an array\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\treturn; // Skip if not an array\n\t\t\t}\n\t\t\t\n\t\t\t// Build the remaining path after this $[]\n\t\t\tvar remainingPath = path.slice(i + 1).join('.');\n\t\t\t\n\t\t\t// Process each array element\n\t\t\tfor (var j = 0; j < current.length; j++) {\n\t\t\t\tif (remainingPath) {\n\t\t\t\t\t// There's more path after $[], recursively apply\n\t\t\t\t\tif (remainingPath.indexOf('$[]') !== -1) {\n\t\t\t\t\t\t// Nested $[] operator\n\t\t\t\t\t\tapplyToAllPositional(current[j], remainingPath, updateFn);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No more $[], apply the update function\n\t\t\t\t\t\tvar currentValue = getProp(current[j], remainingPath);\n\t\t\t\t\t\tvar newValue = updateFn(currentValue);\n\t\t\t\t\t\tsetProp(current[j], remainingPath, newValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// $[] is the last segment, apply to each element directly\n\t\t\t\t\tcurrent[j] = updateFn(current[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Navigate to next level\n\t\tif (current == null || current == undefined) return;\n\t\tcurrent = current[pathSegment];\n\t}\n}\n\n/**\n * Replace $ positional operator in a field path with the matched array index\n * \n * @param {string} fieldPath - The field path potentially containing $\n * @param {object} arrayFilters - Map of field paths to matched array indices\n * @returns {string} The field path with $ replaced by the matched index\n */\nfunction replacePositionalOperator(fieldPath, arrayFilters) {\n\tif (!arrayFilters || !fieldPath.includes('$')) {\n\t\treturn fieldPath;\n\t}\n\t\n\t// Split the path to find the $ placeholder\n\tconst parts = fieldPath.split('.');\n\tconst dollarIndex = parts.indexOf('$');\n\t\n\tif (dollarIndex === -1) {\n\t\treturn fieldPath;\n\t}\n\t\n\t// Build the field path up to the $\n\tconst pathBeforeDollar = parts.slice(0, dollarIndex).join('.');\n\t\n\t// Find the matched index for this field path\n\t// We need to check if we have a match for the field before $\n\tlet matchedIndex = null;\n\t\n\t// Try to find a matching filter by checking various possible field paths\n\t// The query could be on the array itself or a nested field\n\tfor (const filterPath in arrayFilters) {\n\t\t// Check if the filter path matches the beginning of our field path\n\t\tif (filterPath === pathBeforeDollar || filterPath.startsWith(pathBeforeDollar + '.')) {\n\t\t\tmatchedIndex = arrayFilters[filterPath];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// If we found a matched index, replace $ with it\n\tif (matchedIndex !== null && matchedIndex !== undefined) {\n\t\tparts[dollarIndex] = matchedIndex.toString();\n\t\treturn parts.join('.');\n\t}\n\t\n\t// If no matched index found, return original path (update will likely be a no-op)\n\treturn fieldPath;\n}\n\n/**\n * Apply update operators to a document\n * \n * @param {object} updates - The update operators to apply\n * @param {object} doc - The document to update\n * @param {boolean} setOnInsert - Whether to apply $setOnInsert\n * @param {object} arrayFilters - Optional map of field paths to matched array indices for $ operator\n */\nexport function applyUpdates(updates, doc, setOnInsert, positionalMatchInfo, userArrayFilters) {\n\tvar keys = Object.keys(updates);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar value = updates[key];\n\t\tif (key == \"$inc\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$inc', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn (val === undefined ? 0 : val) + amount;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tif (currentValue == undefined) currentValue = 0;\n\t\t\t\t\tsetProp(doc, field, currentValue + amount);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$mul\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$mul', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn val * amount;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tif (currentValue == undefined) currentValue = 0;\n\t\t\t\t\tsetProp(doc, field, currentValue * amount);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$rename\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar newName = replacePositionalOperator(value[fields[j]], positionalMatchInfo);\n\t\t\t\tdoc[newName] = doc[field];\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$setOnInsert\" && setOnInsert) {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tdoc[field] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$set\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, value[fields[j]], '$set', userArrayFilters);\n\t\t\t\t} else {\n\t\t\t\t\tsetProp(doc, field, value[fields[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$unset\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$min\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$min', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn Math.min(val, amount);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tsetProp(doc, field, Math.min(currentValue, amount));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$max\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar amount = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this field uses filtered positional operator\n\t\t\t\tif (hasFilteredPositionalOperator(field)) {\n\t\t\t\t\tconst parsedPath = parseFieldPath(field);\n\t\t\t\t\tapplyToFilteredArrayElements(doc, parsedPath, amount, '$max', userArrayFilters);\n\t\t\t\t} else if (hasAllPositional(field)) {\n\t\t\t\t\t// Handle $[] all-positional operator\n\t\t\t\t\tapplyToAllPositional(doc, field, function(val) {\n\t\t\t\t\t\treturn Math.max(val, amount);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar currentValue = getProp(doc, field);\n\t\t\t\t\tsetProp(doc, field, Math.max(currentValue, amount));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$currentDate\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar typeSpec = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Handle boolean true or { $type: \"date\" }\n\t\t\t\tif (typeSpec === true || (typeof typeSpec === 'object' && typeSpec.$type === 'date')) {\n\t\t\t\t\tsetProp(doc, field, new Date());\n\t\t\t\t}\n\t\t\t\t// Handle { $type: \"timestamp\" }\n\t\t\t\telse if (typeof typeSpec === 'object' && typeSpec.$type === 'timestamp') {\n\t\t\t\t\tsetProp(doc, field, new Timestamp());\n\t\t\t\t}\n\t\t\t\t// Default to Date for backwards compatibility\n\t\t\t\telse {\n\t\t\t\t\tsetProp(doc, field, new Date());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$addToSet\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar addValue = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tcurrentArray.push(addValue);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pop\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar popValue = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tif (popValue == 1) {\n\t\t\t\t\t\tcurrentArray.pop();\n\t\t\t\t\t} else if (popValue == -1) {\n\t\t\t\t\t\tcurrentArray.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pull\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar condition = value[fields[j]];\n\t\t\t\tvar src = getProp(doc, field);\n\t\t\t\t\n\t\t\t\t// Skip if field doesn't exist or is not an array\n\t\t\t\tif (src == undefined || !Array.isArray(src)) continue;\n\t\t\t\t\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar element = src[k];\n\t\t\t\t\tvar shouldRemove = false;\n\t\t\t\t\t\n\t\t\t\t\t// Determine how to match the condition against the element\n\t\t\t\t\tif (typeof condition === 'object' && condition !== null && !Array.isArray(condition)) {\n\t\t\t\t\t\t// Condition is an object (could be a query or a value to match)\n\t\t\t\t\t\tif (typeof element === 'object' && element !== null && !Array.isArray(element)) {\n\t\t\t\t\t\t\t// Element is also an object - use query matching\n\t\t\t\t\t\t\t// This handles both {price: null}, {name: \"test\"}, and {price: {$gte: 10}}\n\t\t\t\t\t\t\tshouldRemove = matches(element, condition);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Element is a primitive but condition is an object with operators like {$gte: 5}\n\t\t\t\t\t\t\tvar tempDoc = { __temp: element };\n\t\t\t\t\t\t\tshouldRemove = opMatches(tempDoc, \"__temp\", condition);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Condition is a simple value (string, number, boolean, null, etc.)\n\t\t\t\t\t\t// Do direct comparison\n\t\t\t\t\t\tshouldRemove = element == condition;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!shouldRemove) notRemoved.push(element);\n\t\t\t\t}\n\t\t\t\tsetProp(doc, field, notRemoved);\n\t\t\t}\n\t\t} else if (key == \"$pullAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar src = getProp(doc, field);\n\t\t\t\tvar toRemove = value[fields[j]];\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar removed = false;\n\t\t\t\t\tfor (var l = 0; l < toRemove.length; l++) {\n\t\t\t\t\t\tif (src[k] == toRemove[l]) {\n\t\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!removed) notRemoved.push(src[k]);\n\t\t\t\t}\n\t\t\t\tsetProp(doc, field, notRemoved);\n\t\t\t}\n\t\t} else if (key == \"$pushAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar values = value[fields[j]];\n\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\tfor (var k = 0; k < values.length; k++) {\n\t\t\t\t\t\tcurrentArray.push(values[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$push\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = replacePositionalOperator(fields[j], positionalMatchInfo);\n\t\t\t\tvar pushValue = value[fields[j]];\n\t\t\t\t\n\t\t\t\t// Check if this is a modifier-based push\n\t\t\t\tvar isModifierPush = pushValue !== null && typeof pushValue === 'object' && \n\t\t\t\t\t(pushValue.$each !== undefined || pushValue.$position !== undefined || \n\t\t\t\t\t pushValue.$slice !== undefined || pushValue.$sort !== undefined);\n\t\t\t\t\n\t\t\t\tif (isModifierPush) {\n\t\t\t\t\t// Initialize array if it doesn't exist\n\t\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\t\tif (!currentArray) {\n\t\t\t\t\t\tcurrentArray = [];\n\t\t\t\t\t\tsetProp(doc, field, currentArray);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Get the values to push (either from $each or wrap single value)\n\t\t\t\t\tvar valuesToPush = pushValue.$each !== undefined ? pushValue.$each : [pushValue];\n\t\t\t\t\t\n\t\t\t\t\t// Get position (default to end of array)\n\t\t\t\t\tvar position = pushValue.$position !== undefined ? pushValue.$position : currentArray.length;\n\t\t\t\t\t\n\t\t\t\t\t// Handle negative position (from end)\n\t\t\t\t\tif (position < 0) {\n\t\t\t\t\t\tposition = Math.max(0, currentArray.length + position);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Insert values at specified position\n\t\t\t\t\tcurrentArray.splice(position, 0, ...valuesToPush);\n\t\t\t\t\t\n\t\t\t\t\t// Apply $sort if specified\n\t\t\t\t\tif (pushValue.$sort !== undefined) {\n\t\t\t\t\t\tvar sortSpec = pushValue.$sort;\n\t\t\t\t\t\tif (typeof sortSpec === 'number') {\n\t\t\t\t\t\t\t// Simple numeric sort\n\t\t\t\t\t\t\tcurrentArray.sort(function(a, b) {\n\t\t\t\t\t\t\t\tif (a < b) return sortSpec > 0 ? -1 : 1;\n\t\t\t\t\t\t\t\tif (a > b) return sortSpec > 0 ? 1 : -1;\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (typeof sortSpec === 'object') {\n\t\t\t\t\t\t\t// Sort by subdocument fields\n\t\t\t\t\t\t\tcurrentArray.sort(function(a, b) {\n\t\t\t\t\t\t\t\tvar sortKeys = Object.keys(sortSpec);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar sortKey = sortKeys[k];\n\t\t\t\t\t\t\t\t\tvar sortDir = sortSpec[sortKey];\n\t\t\t\t\t\t\t\t\tvar aVal = getProp(a, sortKey);\n\t\t\t\t\t\t\t\t\tvar bVal = getProp(b, sortKey);\n\t\t\t\t\t\t\t\t\tif (aVal < bVal) return sortDir > 0 ? -1 : 1;\n\t\t\t\t\t\t\t\t\tif (aVal > bVal) return sortDir > 0 ? 1 : -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Apply $slice if specified\n\t\t\t\t\tif (pushValue.$slice !== undefined) {\n\t\t\t\t\t\tvar sliceValue = pushValue.$slice;\n\t\t\t\t\t\tif (sliceValue < 0) {\n\t\t\t\t\t\t\t// Keep last N elements\n\t\t\t\t\t\t\tvar sliced = currentArray.slice(sliceValue);\n\t\t\t\t\t\t\tsetProp(doc, field, sliced);\n\t\t\t\t\t\t} else if (sliceValue === 0) {\n\t\t\t\t\t\t\t// Empty the array\n\t\t\t\t\t\t\tsetProp(doc, field, []);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Keep first N elements\n\t\t\t\t\t\t\tvar sliced = currentArray.slice(0, sliceValue);\n\t\t\t\t\t\t\tsetProp(doc, field, sliced);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Simple push (original behavior)\n\t\t\t\t\tvar currentArray = getProp(doc, field);\n\t\t\t\t\tif (currentArray && Array.isArray(currentArray)) {\n\t\t\t\t\t\tcurrentArray.push(pushValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$bit\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tvar field = replacePositionalOperator(fields[0], positionalMatchInfo);\n\t\t\tvar operation = value[fields[0]];\n\t\t\tvar operator = Object.keys(operation)[0];\n\t\t\tvar operand = operation[operator];\n\t\t\tvar currentValue = getProp(doc, field);\n\t\t\tif (operator == \"and\") {\n\t\t\t\tsetProp(doc, field, currentValue & operand);\n\t\t\t} else if (operator == \"or\") {\n\t\t\t\tsetProp(doc, field, currentValue | operand);\n\t\t\t} else if (operator == \"xor\") {\n\t\t\t\tsetProp(doc, field, currentValue ^ operand);\n\t\t\t} else {\n\t\t\t\tthrow \"unknown $bit operator: \" + operator;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow \"unknown update operator: \" + key;\n\t\t}\n\t}\n}\n\n/**\n * Create a new document from query and update operators for upsert\n */\nexport function createDocFromUpdate(query, updates, idGenerator) {\n\tvar newDoc = { _id: idGenerator() };\n\tvar onlyFields = true;\n\tvar updateKeys = Object.keys(updates);\n\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\tif (updateKeys[i].charAt(0) == \"$\") {\n\t\t\tonlyFields = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (onlyFields) {\n\t\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\t\tnewDoc[updateKeys[i]] = updates[updateKeys[i]];\n\t\t}\n\t} else {\n\t\tvar queryKeys = Object.keys(query);\n\t\tfor (var i = 0; i < queryKeys.length; i++) {\n\t\t\tnewDoc[queryKeys[i]] = query[queryKeys[i]];\n\t\t}\n\t\tapplyUpdates(updates, newDoc, true);\n\t}\n\treturn newDoc;\n}\n","/**\n * Base class for collection indexes\n * Provides a common interface for different types of indexes (e.g., regular, text, geo)\n */\nexport class Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tthis.name = name;\n\t\tthis.keys = keys;\n\t\tthis.storage = storage;\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tthrow new Error('add() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tthrow new Error('remove() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Update a document in the index (remove old, add new)\n\t * @param {Object} oldDoc - The old document\n\t * @param {Object} newDoc - The new document\n\t */\n\tupdate(oldDoc, newDoc) {\n\t\tthis.remove(oldDoc);\n\t\tthis.add(newDoc);\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query to execute\n\t * @returns {Array} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tthrow new Error('query() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthrow new Error('clear() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Get index specification (for getIndexes())\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\tthrow new Error('serialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} data - Serialized index state\n\t */\n\tdeserialize(data) {\n\t\tthrow new Error('deserialize() must be implemented by subclass');\n\t}\n}\n","/**\n * BPlusTree - A B+ tree implementation for indexing\n * \n * A B+ tree is a self-balancing tree data structure that maintains sorted data\n * and allows searches, sequential access, insertions, and deletions in logarithmic time.\n * All values are stored in leaf nodes, and internal nodes only store keys for navigation.\n * \n * @class BPlusTree\n */\n\nimport { IndexStore } from \"./IndexStore.js\";\n\nfunction isNumericString(str) {\n  if (typeof str !== 'string' || str.trim() === '') {\n    return false; // Not a string or empty string\n  }\n  return Number.isFinite(+str);\n}\n\n/**\n * Node class representing a node in the B+ tree\n * @private\n */\nclass BPlusTreeNode {\n  /**\n   * Creates a new B+ tree node\n   * @param {boolean} isLeaf - Whether this node is a leaf node\n   */\n  constructor(isLeaf, indexStore, nodeCache) {\n    if (!(indexStore instanceof IndexStore)) {\n      throw new Error('IndexStore is required to create BPlusTreeNode');\n    }\n\n    if (typeof isLeaf === 'object') {\n      // Load existing node from indexStore\n      this._data = isLeaf;\n      this.id = this._data.id;\n      this.keys = this._data.keys;\n      this.values = this._data.values;\n      this.children = [];\n      for (const childId of this._data.children) {\n        if (nodeCache.has(childId)) {\n          this.children.push(nodeCache.get(childId));\n          continue;\n        }\n        const childData = indexStore.getDataMap('nodes').get(childId);\n        if (!childData) {\n          throw new Error(`BPlusTreeNode: Child node with id ${childId} not found in IndexStore`);\n        }\n        const childNode = new BPlusTreeNode(childData, indexStore, nodeCache);\n        this.children.push(childNode);\n        nodeCache.set(childId, childNode);\n      }\n      this.isLeaf = this._data.isLeaf;\n      if (this._data.next) {\n        if (nodeCache.has(this._data.next)) {\n          this.next = nodeCache.get(this._data.next);\n        } else {\n          const nextData = indexStore.getDataMap('nodes').get(this._data.next);\n          if (!nextData) {\n            throw new Error(`BPlusTreeNode: Next leaf node with id ${this._data.next} not found in IndexStore`);\n          }\n          this.next = new BPlusTreeNode(nextData, indexStore, nodeCache);\n          nodeCache.set(this.next.id, this.next);\n        }\n      } else {\n        this.next = null;\n      }\n    } else {\n      this._data = {\n        id: indexStore.getMeta('nextId'),\n        keys: [],      // Array of keys\n        values: [],    // Array of values (only used in leaf nodes)\n        children: [],  // Array of child nodes (only used in internal nodes)\n        isLeaf: isLeaf,\n        next : null,    // Pointer to next leaf node (only used in leaf nodes)\n      };\n      indexStore.setMeta('nextId', this._data.id + 1);\n      indexStore.getDataMap('nodes').set(this._data.id, this._data);\n      this.id = this._data.id;\n      this.keys = this._data.keys;\n      this.values = this._data.values;\n      this.children = [];\n      this.isLeaf = this._data.isLeaf;\n      this.next = null;\n    }\n    const self = this;\n\n    return new Proxy(this, {\n      get(target, prop) {\n        if (prop === 'children') {\n          return new Proxy(target.children, {\n            get(target, property, receiver) {\n              if (!isNumericString(property)) {\n                if (property === 'length') {\n                  return Reflect.get(target, property, receiver);\n                } else if (property === 'splice') {\n                  return function(...args) {\n                    if (args.length == 3) {\n                      if (args[2] instanceof BPlusTreeNode) {\n                        self._data.children.splice(args[0], args[1], args[2].id);\n                        indexStore.getDataMap('nodes').set(self._data.id, self._data);\n                      } else {\n                        throw new Error('BPlusTreeNode: children array can only store BPlusTreeNode instances',args[2]);\n                      }\n                    }\n                    return Reflect.apply(target[property], target, args);\n                  };\n                } else if (property === 'push') {\n                  return function(...args) {\n                    if (args.length !== 1) {\n                      throw new Error('BPlusTreeNode: children.push only supports single argument');\n                    }\n                    if (args[0] instanceof BPlusTreeNode) {\n                      self._data.children.push(args[0].id);\n                      indexStore.getDataMap('nodes').set(self._data.id, self._data);\n                      return self.children.push(args[0]);\n                    } else {\n                      throw new Error('BPlusTreeNode: children array can only store BPlusTreeNode instances',args[2]);\n                    }\n                  };\n                }\n              }\n              // Custom logic for getting properties\n              return Reflect.get(target, property, receiver); // Forward the operation to the original array\n            },\n            set(target, property, value, receiver) {\n              if (isNumericString(property) && value instanceof BPlusTreeNode) {\n                Reflect.set(self._data.children, property, value.id, receiver);\n              } else {\n                Reflect.set(self._data.children, property, value, receiver);\n              }\n              indexStore.getDataMap('nodes').set(self._data.id, self._data);\n              return Reflect.set(target, property, value, receiver); // Forward the operation to the original array\n            }\n          });\n        }\n        return Reflect.get(target, prop);\n      },\n      set(target, prop, value) {\n          if (prop === 'next') {\n            if (value instanceof BPlusTreeNode) {\n              target.next = value;\n              target._data.next = value.id;\n              indexStore.getDataMap('nodes').set(target._data.id, target._data);\n            } else if (value === null) {\n              target.next = null;\n              target._data.next = null;\n              indexStore.getDataMap('nodes').set(target._data.id, target._data);\n            } else {\n              throw new Error('BPlusTreeNode: next pointer must be a BPlusTreeNode or null');\n            }\n          } else if (prop === 'isLeaf') {\n            target.isLeaf = value;\n            target._data.isLeaf = value;\n            indexStore.getDataMap('nodes').set(target._data.id, target._data);\n          } else if (prop === 'children') {\n            target.children = value;\n            target._data.children = value.map(child => child.id);\n            indexStore.getDataMap('nodes').set(target._data.id, target._data);\n          } else {\n            target[prop] = value;\n            target._data[prop] = value;\n            indexStore.getDataMap('nodes').set(target._data.id, target._data);\n          }\n        return true;\n      }\n    });\n  }\n}\n\n/**\n * B+ Tree implementation\n */\nexport class BPlusTree {\n  /**\n   * Creates a new B+ tree\n    * @param {number} order - The maximum number of children per node (default: 3)\n    */\n  constructor(order = 3, indexStore = new IndexStore()) {\n    if (order < 3) {\n      throw new Error('B+ tree order must be at least 3');\n    }\n    this.order = order;\n    this.minKeys = Math.ceil(order / 2) - 1;\n    this.indexStore = indexStore;\n  \n    if (indexStore.hasMeta('order')) {\n      if (indexStore.getMeta('order') !== this.order) {\n        throw new Error(`B+ tree order does not match stored index metadata ${indexStore.getMeta('order')} != ${this.order}`);\n      }\n      if (indexStore.getMeta('minKeys') != this.minKeys) {\n        throw new Error(`B+ tree minKeys does not match stored index metadata ${indexStore.getMeta('minKeys')} != ${this.minKeys}`);\n      }\n\n      this._buildTreeFromStorage();\n\n    } else {\n      this.indexStore.setMeta('order', this.order);\n      this.indexStore.setMeta('minKeys', this.minKeys);\n      this.indexStore.setMeta('nextId', 1);\n      this.root = new BPlusTreeNode(true, this.indexStore);\n      this.indexStore.setMeta('rootId', this.root.id);\n    }\n  }\n\n  /**\n   * Builds the B+ tree from existing data in the IndexStore\n   * @private\n   */\n  _buildTreeFromStorage() {\n    const nodeCache = new Map();\n    const rootData = this.indexStore.getDataMap('nodes').get(this.indexStore.getMeta('rootId'));\n    if (!rootData) {\n      throw new Error('BPlusTree: Root node not found in IndexStore');\n    }\n    this.root = new BPlusTreeNode(rootData,this.indexStore, nodeCache);\n  }\n\n    /**\n     * Searches for a value by key in the B+ tree\n     * @param {*} key - The key to search for\n     * @returns {Array} Array of values associated with the key, or undefined if not found\n     */\n    search(key) {\n        return this._searchNode(this.root, key);\n    }\n\n    /**\n     * Internal method to search for a key in a node\n     * @private\n     * @param {BPlusTreeNode} node - The node to search in\n     * @param {*} key - The key to search for\n     * @returns {Array} Array of values if found, undefined otherwise\n     */\n    _searchNode(node, key) {\n        if (node.isLeaf) {\n            // In a leaf node, collect all values for the key\n            const values = [];\n            for (let i = 0; i < node.keys.length; i++) {\n                if (key === node.keys[i]) {\n                    // Values are stored as arrays, concatenate them\n                    values.push(...node.values[i]);\n                }\n            }\n            return values;//values.length > 0 ? values : undefined;\n        } else {\n            // In an internal node, find the appropriate child\n            // Keys in internal nodes are separators - go right if key >= separator\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n            return this._searchNode(node.children[i], key);\n        }\n    }\n\n    /**\n     * Inserts a key-value pair into the B+ tree.\n     * If the key already exists, its value will be updated.\n     * @param {*} key - The key to insert\n     * @param {*} value - The value to associate with the key\n     */\n    add(key, value) {\n        const root = this.root;\n\n        // If root is full, split it\n        if (root.keys.length === this.indexStore.getMeta('order') - 1) {\n            const newRoot = new BPlusTreeNode(false, this.indexStore);\n            newRoot.children.push(this.root);\n            this._splitChild(newRoot, 0);\n            this.root = newRoot;\n            this.indexStore.setMeta('rootId', this.root.id);\n        }\n\n        this._insertNonFull(this.root, key, value);\n    }\n\n    /**\n     * Inserts a key-value pair into a node that is not full\n     * @private\n     * @param {BPlusTreeNode} node - The node to insert into\n     * @param {*} key - The key to insert\n     * @param {*} value - The value to insert\n     */\n    _insertNonFull(node, key, value) {\n        let i = node.keys.length - 1;\n\n        if (node.isLeaf) {\n            // Check if key already exists and append value\n            for (let j = 0; j < node.keys.length; j++) {\n                if (node.keys[j] === key) {\n                    // Key exists, append value to array\n                    node.values[j].push(value);\n                    return;\n                }\n            }\n\n            // Insert into leaf node in sorted order\n            node.keys.push(null);\n            node.values.push(null);\n\n            while (i >= 0 && key < node.keys[i]) {\n                node.keys[i + 1] = node.keys[i];\n                node.values[i + 1] = node.values[i];\n                i--;\n            }\n\n            node.keys[i + 1] = key;\n            node.values[i + 1] = [value]; // Store as array\n\n        } else {\n            // Find the child to insert into\n            // In internal nodes, go right if key >= separator\n            i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n\n            // If child is full, split it\n            if (node.children[i].keys.length === this.indexStore.getMeta('order') - 1) {\n                this._splitChild(node, i);\n                // After split, re-check which child to insert into\n                if (key >= node.keys[i]) {\n                    i++;\n                }\n            }\n\n            this._insertNonFull(node.children[i], key, value);\n        }\n    }\n\n    /**\n     * Splits a full child node\n     * @private\n     * @param {BPlusTreeNode} parent - The parent node\n     * @param {number} index - The index of the child to split\n     */\n    _splitChild(parent, index) {\n        const fullChild = parent.children[index];\n        const newChild = new BPlusTreeNode(fullChild.isLeaf, this.indexStore);\n        const midIndex = Math.floor((this.indexStore.getMeta('order') - 1) / 2);\n\n        if (fullChild.isLeaf) {\n            // For leaf nodes, copy the upper half to new node\n            newChild.keys = fullChild.keys.splice(midIndex);\n            newChild.values = fullChild.values.splice(midIndex);\n\n            // Link leaf nodes\n            newChild.next = fullChild.next;\n            fullChild.next = newChild;\n\n            // Promote a copy of the first key of newChild to parent\n            parent.keys.splice(index, 0, newChild.keys[0]);\n        } else {\n            // For internal nodes, split children\n            newChild.keys = fullChild.keys.splice(midIndex + 1);\n            const promotedKey = fullChild.keys.pop();\n            newChild.children = fullChild.children.splice(midIndex + 1);\n\n            // Promote the middle key to parent\n            parent.keys.splice(index, 0, promotedKey);\n        }\n\n        parent.children.splice(index + 1, 0, newChild);\n    }\n\n    /**\n     * Deletes a specific value from a key in the B+ tree\n     * @param {*} key - The key to delete from\n     * @param {*} value - The specific value to remove\n     * @returns {boolean} True if the value was found and deleted, false otherwise\n     */\n    deleteValue(key, value) {\n        const deleted = this._deleteValue(this.root, key, value);\n\n        // If root is now empty after deletion, make its only child the new root\n        if (this.root.keys.length === 0) {\n            if (!this.root.isLeaf && this.root.children.length > 0) {\n                this.root = this.root.children[0];\n                this.indexStore.setMeta('rootId', this.root.id);\n            }\n        }\n\n        return deleted;\n    }\n\n    /**\n     * Deletes all values for a key from the B+ tree\n     * @param {*} key - The key to delete\n     * @returns {boolean} True if the key was found and deleted, false otherwise\n     */\n    delete(key) {\n        const deleted = this._delete(this.root, key);\n\n        // If root is now empty after deletion, make its only child the new root\n        if (this.root.keys.length === 0) {\n            if (!this.root.isLeaf && this.root.children.length > 0) {\n                this.root = this.root.children[0];\n                this.indexStore.setMeta('rootId', this.root.id);\n            }\n        }\n\n        return deleted;\n    }\n\n    /**\n     * Internal method to delete a specific value from a key\n     * @private\n     * @param {BPlusTreeNode} node - The node to delete from\n     * @param {*} key - The key to delete from\n     * @param {*} value - The value to delete\n     * @returns {boolean} True if deleted, false otherwise\n     */\n    _deleteValue(node, key, value) {\n        if (node.isLeaf) {\n            // Found the key in a leaf node\n            for (let i = 0; i < node.keys.length; i++) {\n                if (key === node.keys[i]) {\n                    const values = node.values[i];\n                    const valueIndex = values.indexOf(value);\n                    if (valueIndex === -1) {\n                        return false; // Value not found\n                    }\n                    \n                    // Remove the specific value\n                    values.splice(valueIndex, 1);\n                    \n                    // If no values left, remove the key entirely\n                    if (values.length === 0) {\n                        node.keys.splice(i, 1);\n                        node.values.splice(i, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            // Find the appropriate child to delete from\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n\n            // Recursively delete from the appropriate child\n            const deleted = this._deleteValue(node.children[i], key, value);\n\n            if (deleted) {\n                // After deletion, check if child needs rebalancing\n                this._rebalanceAfterDelete(node, i);\n            }\n\n            return deleted;\n        }\n    }\n\n    /**\n     * Internal method to delete a key from a node\n     * @private\n     * @param {BPlusTreeNode} node - The node to delete from\n     * @param {*} key - The key to delete\n     * @returns {boolean} True if deleted, false otherwise\n     */\n    _delete(node, key) {\n        if (node.isLeaf) {\n            // Found the key in a leaf node\n            for (let i = 0; i < node.keys.length; i++) {\n                if (key === node.keys[i]) {\n                    node.keys.splice(i, 1);\n                    node.values.splice(i, 1);\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            // Find the appropriate child to delete from\n            let i = 0;\n            while (i < node.keys.length && key >= node.keys[i]) {\n                i++;\n            }\n\n            // Recursively delete from the appropriate child\n            const deleted = this._delete(node.children[i], key);\n\n            if (deleted) {\n                // After deletion, check if child needs rebalancing\n                this._rebalanceAfterDelete(node, i);\n            }\n\n            return deleted;\n        }\n    }\n\n    /**\n     * Rebalances the tree after a deletion\n     * @private\n     * @param {BPlusTreeNode} parent - The parent node\n     * @param {number} index - The index of the child that was modified\n     */\n    _rebalanceAfterDelete(parent, index) {\n        const child = parent.children[index];\n\n        // If child has enough keys, no rebalancing needed\n        if (child.keys.length >= this.indexStore.getMeta('minKeys')) {\n            return;\n        }\n\n        // Try to borrow from left sibling\n        if (index > 0) {\n            const leftSibling = parent.children[index - 1];\n            if (leftSibling.keys.length > this.indexStore.getMeta('minKeys')) {\n                this._borrowFromLeft(parent, index);\n                return;\n            }\n        }\n\n        // Try to borrow from right sibling\n        if (index < parent.children.length - 1) {\n            const rightSibling = parent.children[index + 1];\n            if (rightSibling.keys.length > this.indexStore.getMeta('minKeys')) {\n                this._borrowFromRight(parent, index);\n                return;\n            }\n        }\n\n        // Merge with a sibling\n        if (index > 0) {\n            this._merge(parent, index - 1);\n        } else {\n            this._merge(parent, index);\n        }\n    }\n\n    /**\n     * Borrows a key from the left sibling\n     * @private\n     * @param {BPlusTreeNode} parent - The parent node\n     * @param {number} index - The index of the child\n     */\n    _borrowFromLeft(parent, index) {\n        const child = parent.children[index];\n        const leftSibling = parent.children[index - 1];\n\n        if (child.isLeaf) {\n            // Move the last key-value from left sibling to child\n            child.keys.unshift(leftSibling.keys.pop());\n            child.values.unshift(leftSibling.values.pop());\n\n            // Update parent key\n            parent.keys[index - 1] = child.keys[0];\n        } else {\n            // Move parent key down and left sibling's last key up\n            child.keys.unshift(parent.keys[index - 1]);\n            parent.keys[index - 1] = leftSibling.keys.pop();\n            child.children.unshift(leftSibling.children.pop());\n        }\n    }\n\n    /**\n     * Borrows a key from the right sibling\n     * @private\n     * @param {BPlusTreeNode} parent - The parent node\n     * @param {number} index - The index of the child\n     */\n    _borrowFromRight(parent, index) {\n        const child = parent.children[index];\n        const rightSibling = parent.children[index + 1];\n\n        if (child.isLeaf) {\n            // Move the first key-value from right sibling to child\n            child.keys.push(rightSibling.keys.shift());\n            child.values.push(rightSibling.values.shift());\n\n            // Update parent key\n            parent.keys[index] = rightSibling.keys[0];\n        } else {\n            // Move parent key down and right sibling's first key up\n            child.keys.push(parent.keys[index]);\n            parent.keys[index] = rightSibling.keys.shift();\n            child.children.push(rightSibling.children.shift());\n        }\n    }\n\n    /**\n     * Merges a child with its right sibling\n     * @private\n     * @param {BPlusTreeNode} parent - The parent node\n     * @param {number} index - The index of the left child to merge\n     */\n    _merge(parent, index) {\n        const leftChild = parent.children[index];\n        const rightChild = parent.children[index + 1];\n\n        if (leftChild.isLeaf) {\n            // Merge leaf nodes\n            leftChild.keys = leftChild.keys.concat(rightChild.keys);\n            leftChild.values = leftChild.values.concat(rightChild.values);\n            leftChild.next = rightChild.next;\n\n            // Remove the parent key\n            parent.keys.splice(index, 1);\n        } else {\n            // Merge internal nodes\n            leftChild.keys.push(parent.keys[index]);\n            leftChild.keys = leftChild.keys.concat(rightChild.keys);\n            leftChild.children = leftChild.children.concat(rightChild.children);\n\n            // Remove the parent key\n            parent.keys.splice(index, 1);\n        }\n\n        // Remove the right child\n        parent.children.splice(index + 1, 1);\n    }\n\n    /**\n     * Returns all key-value pairs in sorted order\n     * @returns {Array} Array of {key, value} objects\n     */\n    toArray() {\n        const result = [];\n        let current = this._getFirstLeaf(this.root);\n\n        while (current) {\n            for (let i = 0; i < current.keys.length; i++) {\n                // Each key can have multiple values\n                const values = current.values[i];\n                for (let j = 0; j < values.length; j++) {\n                    result.push({\n                        key: current.keys[i],\n                        value: values[j]\n                    });\n                }\n            }\n            current = current.next;\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the first (leftmost) leaf node\n     * @private\n     * @param {BPlusTreeNode} node - The node to start from\n     * @returns {BPlusTreeNode} The leftmost leaf node\n     */\n    _getFirstLeaf(node) {\n        if (node.isLeaf) {\n            return node;\n        }\n        return this._getFirstLeaf(node.children[0]);\n    }\n\n    /**\n     * Returns the number of key-value pairs in the tree\n     * @returns {number} The size of the tree\n     */\n    size() {\n        let count = 0;\n        let current = this._getFirstLeaf(this.root);\n\n        while (current) {\n            // Count all values (each key can have multiple values)\n            for (let i = 0; i < current.values.length; i++) {\n                count += current.values[i].length;\n            }\n            current = current.next;\n        }\n\n        return count;\n    }\n\n    /**\n     * Checks if the tree is empty\n     * @returns {boolean} True if the tree is empty\n     */\n    isEmpty() {\n        return this.root.keys.length === 0;\n    }\n\n    /**\n     * Clears all entries from the tree\n     */\n    clear() {\n      this.indexStore.getDataMap('nodes').clear();\n      this.root = new BPlusTreeNode(true, this.indexStore);\n      this.indexStore.setMeta('rootId', this.root.id);\n    }\n\n    /**\n     * Performs a range search for all keys between min and max (inclusive)\n     * @param {*} minKey - The minimum key (inclusive)\n     * @param {*} maxKey - The maximum key (inclusive)\n     * @returns {Array} Array of {key, value} objects in range\n     */\n    rangeSearch(minKey, maxKey) {\n        const result = [];\n        let current = this._getFirstLeaf(this.root);\n\n        // Skip to the first node that might contain minKey\n        while (current && current.keys[current.keys.length - 1] < minKey) {\n            current = current.next;\n        }\n\n        // Collect all keys in range\n        while (current) {\n            for (let i = 0; i < current.keys.length; i++) {\n                if (current.keys[i] >= minKey && current.keys[i] <= maxKey) {\n                    // Each key can have multiple values\n                    const values = current.values[i];\n                    for (let j = 0; j < values.length; j++) {\n                        result.push({\n                            key: current.keys[i],\n                            value: values[j]\n                        });\n                    }\n                } else if (current.keys[i] > maxKey) {\n                    return result;\n                }\n            }\n            current = current.next;\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the height of the tree\n     * @returns {number} The height of the tree\n     */\n    getHeight() {\n        let height = 0;\n        let current = this.root;\n\n        while (!current.isLeaf) {\n            height++;\n            current = current.children[0];\n        }\n\n        return height;\n    }\n}\n","import { Index } from './Index.js';\nimport { getProp } from './utils.js';\nimport { BPlusTree } from './BPlusTree.js';\n\n/**\n * Uses B+ tree for efficient storage and range queries\n */\nexport class RegularCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage, options);\n\t\t// B+ tree mapping index key to array of document _ids\n\t\t// Order 50 provides good balance between node size and tree height\n\t\tthis.data = new BPlusTree(50,storage);\n\t}\n\n\t/**\n\t * Extract index key value from a document\n\t */\n\textractIndexKey(doc) {\n\t\tconst keyFields = Object.keys(this.keys);\n\t\tif (keyFields.length === 0) return null;\n\n\t\t// For simple single-field index\n\t\tif (keyFields.length === 1) {\n\t\t\tconst field = keyFields[0];\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value === undefined) return null;\n\t\t\t// Preserve type information in the key\n\t\t\treturn value; //JSON.stringify({ t: typeof value, v: value });\n\t\t}\n\n\t\t// For compound index, concatenate values with type preservation\n\t\tconst keyParts = [];\n\t\tfor (let i = 0; i < keyFields.length; i++) {\n\t\t\tconst value = getProp(doc, keyFields[i]);\n\t\t\tif (value === undefined) return null;\n\t\t\tkeyParts.push(value /*JSON.stringify(value) */);\n\t\t}\n\t\t// Use a separator that won't appear in JSON\n\t\treturn keyParts.join('\\x00');\n\t}\n\n\t/**\n\t * Add a document to the index\n   * \n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tthis.data.add(indexKey, doc._id.toString());\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the index\n   * \n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n      this.data.delete(indexKey, doc._id.toString());\n\t\t}\n\t}\n\n\t/**\n\t * Query the index\n   * \n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(this.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst queryValue = query[field];\n\n\t\t// Case 1: Simple equality\n\t\tif (typeof queryValue !== 'object' || queryValue === null) {\n\t\t\tconst indexKey = queryValue; //JSON.stringify({ t: typeof queryValue, v: queryValue });\n\t\t\treturn this.data.search(indexKey);\n\t\t}\n\n\t\t// Case 2: Query with operators\n\t\tif (typeof queryValue === 'object' && !Array.isArray(queryValue)) {\n\t\t\treturn this._queryWithOperators(field, queryValue);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Query index with comparison operators\n   * \n\t * @private\n\t */\n\t_queryWithOperators(field, operators) {\n\t\tconst ops = Object.keys(operators);\n\t\tconst results = new Set();\n\n\t\t// Handle range queries: $gt, $gte, $lt, $lte\n\t\tconst hasRangeOp = ops.some(op => ['$gt', '$gte', '$lt', '$lte'].includes(op));\n\t\t\n\t\tif (hasRangeOp) {\n\t\t\t// Use B+ tree's efficient range search if we have both bounds\n\t\t\tconst hasGt = ops.includes('$gt') || ops.includes('$gte');\n\t\t\tconst hasLt = ops.includes('$lt') || ops.includes('$lte');\n\t\t\t\n\t\t\tif (hasGt && hasLt) {\n\t\t\t\t// Determine min and max bounds\n\t\t\t\tconst minValue = ops.includes('$gte') ? operators['$gte'] : \n\t\t\t\t                ops.includes('$gt') ? operators['$gt'] : -Infinity;\n\t\t\t\tconst maxValue = ops.includes('$lte') ? operators['$lte'] : \n\t\t\t\t                ops.includes('$lt') ? operators['$lt'] : Infinity;\n\t\t\t\t\n\t\t\t\tconst minKey = minValue; //JSON.stringify({ t: typeof minValue, v: minValue });\n\t\t\t\tconst maxKey = maxValue; //JSON.stringify({ t: typeof maxValue, v: maxValue });\n\t\t\t\t\n\t\t\t\t// Use B+ tree range search\n\t\t\t\tconst rangeResults = this.data.rangeSearch(minKey, maxKey);\n\t\t\t\t\n\t\t\t\tfor (const {key, value} of rangeResults) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//const parsed = JSON.parse(key);\n\t\t\t\t\t\tconst keyValue = key; //parsed.v;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply exact operator semantics\n\t\t\t\t\t\tlet matches = true;\n\t\t\t\t\t\tif (ops.includes('$gt') && !(keyValue > operators['$gt'])) matches = false;\n\t\t\t\t\t\tif (ops.includes('$gte') && !(keyValue >= operators['$gte'])) matches = false;\n\t\t\t\t\t\tif (ops.includes('$lt') && !(keyValue < operators['$lt'])) matches = false;\n\t\t\t\t\t\tif (ops.includes('$lte') && !(keyValue <= operators['$lte'])) matches = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (matches && value) {\n\t\t\t\t\t\t\t// value is now a single document ID (from the flattened array)\n\t\t\t\t\t\t\tresults.add(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// Skip malformed entries\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t} else {\n\t\t\t\t// Scan all entries if we don't have both bounds\n\t\t\t\tconst allEntries = this.data.toArray();\n\t\t\t\tfor (const {key, value} of allEntries) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//const parsed = JSON.parse(key);\n\t\t\t\t\t\tconst keyValue = key; //parsed.v;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check if value matches all operators\n\t\t\t\t\t\tlet matches = true;\n\t\t\t\t\t\tfor (const op of ops) {\n\t\t\t\t\t\t\tconst operand = operators[op];\n\t\t\t\t\t\t\tif (op === '$gt' && !(keyValue > operand)) matches = false;\n\t\t\t\t\t\t\telse if (op === '$gte' && !(keyValue >= operand)) matches = false;\n\t\t\t\t\t\t\telse if (op === '$lt' && !(keyValue < operand)) matches = false;\n\t\t\t\t\t\t\telse if (op === '$lte' && !(keyValue <= operand)) matches = false;\n\t\t\t\t\t\t\telse if (op === '$eq' && !(keyValue === operand)) matches = false;\n\t\t\t\t\t\t\telse if (op === '$ne' && !(keyValue !== operand)) matches = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (matches && value) {\n\t\t\t\t\t\t\t// value is now a single document ID (from the flattened array)\n\t\t\t\t\t\t\tresults.add(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// Skip malformed entries\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $in operator\n\t\tif (ops.includes('$in')) {\n\t\t\tconst values = operators['$in'];\n\t\t\tif (Array.isArray(values)) {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tconst indexKey = value; //JSON.stringify({ t: typeof value, v: value });\n\t\t\t\t\tconst idArray = this.data.search(indexKey);\n\t\t\t\t\tif (idArray) {\n\t\t\t\t\t\tidArray.forEach(id => results.add(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(results);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $eq operator\n\t\tif (ops.includes('$eq')) {\n\t\t\tconst value = operators['$eq'];\n\t\t\tconst indexKey = value; //JSON.stringify({ t: typeof value, v: value });\n\t\t\tconst result = this.data.search(indexKey);\n\t\t\treturn result || [];\n\t\t}\n\n\t\t// Handle $ne operator (requires full scan, not optimal)\n\t\tif (ops.includes('$ne')) {\n\t\t\tconst excludeValue = operators['$ne'];\n\t\t\tconst excludeKey = excludeValue; //JSON.stringify({ t: typeof excludeValue, v: excludeValue });\n\t\t\tconst allEntries = this.data.toArray();\n\t\t\tfor (const {key, value} of allEntries) {\n\t\t\t\tif (key !== excludeKey && value) {\n\t\t\t\t\t// value is now a single document ID (from the flattened array)\n\t\t\t\t\tresults.add(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Array.from(results);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all entries from the index\n\t */\n\tclear() {\n\t\tthis.data.clear();\n\t}\n}\n","import { Index } from './Index.js';\nimport { TextIndex } from './TextIndex.js';\nimport { getProp } from './utils.js';\n\n/**\n * Text index implementation using TextIndex\n * Supports full-text search on one or more fields\n */\nexport class TextCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage, options);\n\t\t// Create the underlying TextIndex\n\t\tthis.textIndex = new TextIndex(storage);\n\t\t// Track which fields are indexed\n\t\tthis.indexedFields = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\tthis.indexedFields.push(field);\n\t\t\t}\n\t\t}\n\t\tif (this.indexedFields.length === 0) {\n\t\t\tthrow new Error('Text index must have at least one field with type \"text\"');\n\t\t}\n\t\t\n\t}\n\n\t/**\n\t * Extract text content from a document for the indexed fields\n\t * @param {Object} doc - The document\n\t * @returns {string} Combined text from all indexed fields\n\t */\n\t_extractText(doc) {\n\t\tconst textParts = [];\n\t\tfor (const field of this.indexedFields) {\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\ttextParts.push(String(value));\n\t\t\t}\n\t\t}\n\t\treturn textParts.join(' ');\n\t}\n\n\t/**\n\t * Add a document to the text index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst text = this._extractText(doc);\n\t\tif (text) {\n\t\t\tthis.textIndex.add(String(doc._id), text);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the text index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tthis.textIndex.remove(String(doc._id));\n\t}\n\n\t/**\n\t * Query the text index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a text search\n\t */\n\tquery(query) {\n\t\t// This method is used for query planning\n\t\t// Text queries are handled separately in queryMatcher\n\t\treturn null;\n\t}\n\n\t/**\n\t * Search the text index\n\t * @param {string} searchText - The text to search for\n\t * @param {Object} options - Search options\n\t * @returns {Array} Array of document IDs\n\t */\n\tsearch(searchText, options = {}) {\n\t\tconst results = this.textIndex.query(searchText, { scored: false, ...options });\n\t\treturn results;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.textIndex.clear();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\ttextIndexVersion: 3,\n\t\t\tweights: this._getWeights()\n\t\t};\n\t}\n\n\t/**\n\t * Get field weights (all default to 1 for now)\n\t */\n\t_getWeights() {\n\t\tconst weights = {};\n\t\tfor (const field of this.indexedFields) {\n\t\t\tweights[field] = 1;\n\t\t}\n\t\treturn weights;\n\t}\n\n}\n","\nimport { IndexStore } from './IndexStore.js';\n\n/**\n * R-tree implementation for geospatial indexing\n * \n * This implementation supports:\n * - Adding points with lat/lng coordinates\n * - Removing points\n * - Bounding box queries\n * - Location + radius queries (converted to bounding box)\n */\n\n/**\n * Calculate distance between two points using Haversine formula\n * @param {number} lat1 - Latitude of first point\n * @param {number} lng1 - Longitude of first point\n * @param {number} lat2 - Latitude of second point\n * @param {number} lng2 - Longitude of second point\n * @returns {number} Distance in kilometers\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Convert radius query to bounding box\n * Approximation: 1 degree latitude  111 km\n * @param {number} lat - Center latitude\n * @param {number} lng - Center longitude\n * @param {number} radiusKm - Radius in kilometers\n * @returns {Object} Bounding box {minLat, maxLat, minLng, maxLng}\n */\nfunction radiusToBoundingBox(lat, lng, radiusKm) {\n\tconst latDelta = radiusKm / 111; // degrees\n\tconst lngDelta = radiusKm / (111 * Math.cos(lat * Math.PI / 180)); // degrees\n\t\n\treturn {\n\t\tminLat: lat - latDelta,\n\t\tmaxLat: lat + latDelta,\n\t\tminLng: lng - lngDelta,\n\t\tmaxLng: lng + lngDelta\n\t};\n}\n\n/**\n * Check if two bounding boxes intersect\n */\nfunction intersects(bbox1, bbox2) {\n\treturn !(bbox1.maxLat < bbox2.minLat ||\n\t\tbbox1.minLat > bbox2.maxLat ||\n\t\tbbox1.maxLng < bbox2.minLng ||\n\t\tbbox1.minLng > bbox2.maxLng);\n}\n\n/**\n * Check if bbox1 contains bbox2\n */\nfunction contains(bbox1, bbox2) {\n\treturn bbox1.minLat <= bbox2.minLat &&\n\t\tbbox1.maxLat >= bbox2.maxLat &&\n\t\tbbox1.minLng <= bbox2.minLng &&\n\t\tbbox1.maxLng >= bbox2.maxLng;\n}\n\n/**\n * Calculate the area of a bounding box\n */\nfunction area(bbox) {\n\treturn (bbox.maxLat - bbox.minLat) * (bbox.maxLng - bbox.minLng);\n}\n\n/**\n * Calculate the bounding box that contains both input boxes\n */\nfunction union(bbox1, bbox2) {\n\treturn {\n\t\tminLat: Math.min(bbox1.minLat, bbox2.minLat),\n\t\tmaxLat: Math.max(bbox1.maxLat, bbox2.maxLat),\n\t\tminLng: Math.min(bbox1.minLng, bbox2.minLng),\n\t\tmaxLng: Math.max(bbox1.maxLng, bbox2.maxLng)\n\t};\n}\n\n/**\n * Calculate the enlargement needed to include bbox2 in bbox1\n */\nfunction enlargement(bbox1, bbox2) {\n\tconst unionBox = union(bbox1, bbox2);\n\treturn area(unionBox) - area(bbox1);\n}\n\n/**\n * R-tree Node class\n */\nclass RTreeNode {\n\tconstructor(isLeaf = false, indexStore) {\n    if (!(indexStore instanceof IndexStore)) {\n      throw new Error('IndexStore is required to create RTreeNode');\n    }\n\n    this.indexStore = indexStore;\n\n    if (typeof isLeaf === 'object') {\n      this._data = isLeaf;\n      this.id = this._data.id;\n      this.isLeaf = this._data.isLeaf;\n      this.children = [];\n      this.bbox = Object.assign({}, this._data.bbox);\n\n      // leaf nodes will have data entries as children\n      // internal nodes will have child node IDs\n      if (!this.isLeaf) {\n        for (const childId of this._data.children) {\n          const childData = indexStore.getDataMap('nodes').get(childId);\n          if (!childData) {\n            throw new Error(`RTreeNode: Child node with id ${childId} not found in IndexStore`);\n          }\n          const childNode = new RTreeNode(childData, indexStore);\n          this.children.push(childNode);\n        }\n      } else {\n        this.children = [...this._data.children];\n      }\n\n    } else {\n      this._data = {\n        id: indexStore.getMeta('nextId'),\n        isLeaf: isLeaf,\n        children: [],\n        bbox: null\n      };\n      indexStore.setMeta('nextId', this._data.id + 1);\n      indexStore.getDataMap('nodes').set(this._data.id, this._data);\n      this.id = this._data.id;\n      this.isLeaf = isLeaf;\n      this.children = []; // For internal nodes: child nodes; For leaf nodes: data entries\n      this.bbox = null;\n    }\n\n    return new Proxy(this, {\n      set(target, prop, value) {\n        if (prop === 'children') {\n          // console.warn('Directly modifying children', value);\n          target.children = value;\n          // Update the stored children IDs\n          if (!target.isLeaf) {\n            target._data.children = target.children.map(child => child.id);\n          } else {\n            target._data.children = [...target.children];\n          }\n          indexStore.getDataMap('nodes').set(target.id, target._data);\n          return true;\n        }\n        target[prop] = value;\n        return true;\n      },\n      get(target, prop) {\n        if (prop === 'children') {\n          return new Proxy(target.children, {\n            set(childTarget, childProp, childValue) {\n              childTarget[childProp] = childValue;\n              // Update the stored children IDs\n              if (!target.isLeaf) {\n                target._data.children = target.children.map(child => child.id);\n              } else {\n                target._data.children = [...target.children];\n              }\n              indexStore.getDataMap('nodes').set(target.id, target._data);\n              return true;\n            }\n          });\n        }\n        return target[prop];\n      }\n    });\n\t}\n\n\t/**\n\t * Update the bounding box to contain all children\n\t */\n\tupdateBBox() {\n\t\tif (this.children.length === 0) {\n\t\t\tthis.bbox = null;\n\t\t\treturn;\n\t\t}\n\n\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\tlet minLng = Infinity, maxLng = -Infinity;\n\n\t\tfor (const child of this.children) {\n\t\t\tconst bbox = child.bbox;\n\t\t\tminLat = Math.min(minLat, bbox.minLat);\n\t\t\tmaxLat = Math.max(maxLat, bbox.maxLat);\n\t\t\tminLng = Math.min(minLng, bbox.minLng);\n\t\t\tmaxLng = Math.max(maxLng, bbox.maxLng);\n\t\t}\n\n\t\tthis.bbox = { minLat, maxLat, minLng, maxLng };\n    this._data.bbox = Object.assign({}, this.bbox);\n    this.indexStore.getDataMap('nodes').set(this.id, this._data);\n\t}\n}\n\n/**\n * R-tree implementation\n */\nexport class RTree {\n\tconstructor(maxEntries = 9, indexStore = new IndexStore()) {\n\t\tthis.maxEntries = maxEntries;\n\t\tthis.minEntries = Math.max(2, Math.ceil(maxEntries / 2));\n    this.indexStore = indexStore;\n\n    if (indexStore.hasMeta('maxEntries')) {\n      if (indexStore.getMeta('maxEntries') !== maxEntries) {\n        throw new Error(`R-tree maxEntries does not match stored index metadata ${indexStore.getMeta('maxEntries')} != ${maxEntries}`);\n      }\n      if (indexStore.getMeta('minEntries') !== this.minEntries) {\n        throw new Error(`R-tree minEntries does not match stored index metadata ${indexStore.getMeta('minEntries')} != ${this.minEntries}`);\n      }\n\n      this._size = this.indexStore.getMeta('size');\n      this.root = new RTreeNode(this.indexStore.getDataMap('nodes').get(this.indexStore.getMeta('rootId')), this.indexStore);\n    } else {\n      this.indexStore.setMeta('maxEntries', this.maxEntries);\n      this.indexStore.setMeta('minEntries', this.minEntries);\n      this.indexStore.setMeta('nextId', 1);\n      this.root = new RTreeNode(true, this.indexStore);\n      this.indexStore.setMeta('rootId', this.root.id);\n      this.indexStore.setMeta('size', 0);\n      this._size = 0;\n    }\n\t}\n\n\t/**\n\t * Insert a point into the R-tree\n\t * @param {number} lat - Latitude\n\t * @param {number} lng - Longitude\n\t * @param {*} data - Associated data\n\t */\n\tinsert(lat, lng, data) {\n\t\t// Create a point bounding box (bbox with zero area)\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst entry = { bbox, lat, lng, data };\n\t\tthis._insert(entry, this.root, 1);\n\t\tthis._size++;\n    this.indexStore.setMeta('size', this._size);\n\t}\n\n\t/**\n\t * Internal insert method\n\t */\n\t_insert(entry, node, level) {\n\t\tif (node.isLeaf) {\n\t\t\tnode.children.push(entry);\n\t\t\tnode.updateBBox();\n\n\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\treturn this._split(node);\n\t\t\t}\n\t\t} else {\n\t\t\t// Choose subtree\n\t\t\tconst target = this._chooseSubtree(entry.bbox, node);\n\t\t\tconst splitNode = this._insert(entry, target, level + 1);\n\n\t\t\tif (splitNode) {\n\t\t\t\tnode.children.push(splitNode);\n\t\t\t\tnode.updateBBox();\n\n\t\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\t\treturn this._split(node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.updateBBox();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Choose the best subtree to insert an entry\n\t */\n\t_chooseSubtree(bbox, node) {\n\t\tlet minEnlargement = Infinity;\n\t\tlet minArea = Infinity;\n\t\tlet targetNode = null;\n\n\t\tfor (const child of node.children) {\n\t\t\tconst enl = enlargement(child.bbox, bbox);\n\t\t\tconst ar = area(child.bbox);\n\n\t\t\tif (enl < minEnlargement || (enl === minEnlargement && ar < minArea)) {\n\t\t\t\tminEnlargement = enl;\n\t\t\t\tminArea = ar;\n\t\t\t\ttargetNode = child;\n\t\t\t}\n\t\t}\n\n\t\treturn targetNode;\n\t}\n\n\t/**\n\t * Split an overflowing node\n\t */\n\t_split(node) {\n\n    // console.log(`Splitting node ${node.id} with ${node.children.length} children`);\n\t\t// Simple linear split algorithm\n\t\tconst children = node.children;\n\t\tconst isLeaf = node.isLeaf;\n\n\t\t// Find two seeds (most distant entries)\n\t\tlet maxDist = -Infinity;\n\t\tlet seed1Idx = 0, seed2Idx = 1;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tfor (let j = i + 1; j < children.length; j++) {\n\t\t\t\tconst bbox1 = children[i].bbox;\n\t\t\t\tconst bbox2 = children[j].bbox;\n\t\t\t\tconst combinedBox = union(bbox1, bbox2);\n\t\t\t\tconst waste = area(combinedBox) - area(bbox1) - area(bbox2);\n\t\t\t\t\n\t\t\t\tif (waste > maxDist) {\n\t\t\t\t\tmaxDist = waste;\n\t\t\t\t\tseed1Idx = i;\n\t\t\t\t\tseed2Idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create two new nodes\n\t\tconst node1 = new RTreeNode(isLeaf, this.indexStore);\n\t\tconst node2 = new RTreeNode(isLeaf, this.indexStore);\n\n\t\tnode1.children.push(children[seed1Idx]);\n\t\tnode2.children.push(children[seed2Idx]);\n\n    // console.log('node1 children after seeds:', node1);\n    // console.log('node2 children after seeds:', node2);\n\n\t\t// Distribute remaining entries\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tif (i === seed1Idx || i === seed2Idx) continue;\n\n\t\t\tconst child = children[i];\n\t\t\tconst bbox = child.bbox;\n\t\t\t\n\t\t\tconst enl1 = node1.children.length === 0 ? Infinity : enlargement(node1.bbox || bbox, bbox);\n\t\t\tconst enl2 = node2.children.length === 0 ? Infinity : enlargement(node2.bbox || bbox, bbox);\n\n\t\t\tif (node1.children.length < this.minEntries && \n\t\t\t\tchildren.length - i + node1.children.length <= this.minEntries) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (node2.children.length < this.minEntries && \n\t\t\t\tchildren.length - i + node2.children.length <= this.minEntries) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else if (enl1 < enl2) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (enl2 < enl1) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else {\n\t\t\t\t// Equal enlargement, choose the one with smaller area\n\t\t\t\tconst area1 = node1.bbox ? area(node1.bbox) : 0;\n\t\t\t\tconst area2 = node2.bbox ? area(node2.bbox) : 0;\n\t\t\t\tif (area1 < area2) {\n\t\t\t\t\tnode1.children.push(child);\n\t\t\t\t} else {\n\t\t\t\t\tnode2.children.push(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode1.updateBBox();\n\t\t\tnode2.updateBBox();\n\t\t}\n\n\t\t// Update the original node with one group\n\t\tnode.children = node1.children;\n\t\tnode.updateBBox();\n\n\t\t// If this was the root, create a new root\n\t\tif (node === this.root) {\n\t\t\tconst newRoot = new RTreeNode(false, this.indexStore);\n\t\t\tnewRoot.children = [node1, node2];\n\t\t\tnewRoot.updateBBox();\n\t\t\tthis.root = newRoot;\n      this.indexStore.setMeta('rootId', this.root.id);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn node2;\n\t}\n\n\t/**\n\t * Search for points within a bounding box\n\t * @param {Object} bbox - Bounding box {minLat, maxLat, minLng, maxLng}\n\t * @returns {Array} Array of matching entries\n\t */\n\tsearchBBox(bbox) {\n\t\tconst results = [];\n\t\tthis._searchBBox(bbox, this.root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search\n\t */\n\t_searchBBox(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tthis._searchBBox(bbox, child, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search for points within a radius of a location\n\t * @param {number} lat - Center latitude\n\t * @param {number} lng - Center longitude\n\t * @param {number} radiusKm - Radius in kilometers\n\t * @returns {Array} Array of matching entries\n\t */\n\tsearchRadius(lat, lng, radiusKm) {\n\t\t// Convert radius to bounding box for initial filtering\n\t\tconst bbox = radiusToBoundingBox(lat, lng, radiusKm);\n\t\tconst candidates = this.searchBBox(bbox);\n\n\t\t// Filter by actual distance\n\t\tconst results = [];\n\t\tfor (const entry of candidates) {\n\t\t\tconst dist = haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\tif (dist <= radiusKm) {\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Remove a point from the R-tree\n\t * @param {number} lat - Latitude\n\t * @param {number} lng - Longitude\n\t * @param {*} data - Associated data (optional, for exact match)\n\t * @returns {boolean} True if removed, false if not found\n\t */\n\tremove(lat, lng, data = null) {\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst removed = this._remove(bbox, data, this.root, null, -1);\n\t\t\n\t\tif (removed) {\n\t\t\tthis._size--;\n      this.indexStore.setMeta('size', this._size);\n\t\t}\n\t\t\n\t\t// If root has only one child after removal, make that child the new root\n\t\tif (this.root.children.length === 1 && !this.root.isLeaf) {\n\t\t\tthis.root = this.root.children[0];\n      this.indexStore.setMeta('rootId', this.root.id);\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Internal remove method\n\t */\n\t_remove(bbox, data, node, parent, indexInParent) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst entry = node.children[i];\n\t\t\t\tif (entry.lat === bbox.minLat && entry.lng === bbox.minLng) {\n\t\t\t\t\t// If data is specified, check for match\n\t\t\t\t\tconst dataMatches = data === null || \n\t\t\t\t\t\tJSON.stringify(entry.data) === JSON.stringify(data);\n\t\t\t\t\t\n\t\t\t\t\tif (dataMatches) {\n\t\t\t\t\t\tnode.children.splice(i, 1);\n\t\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Handle underflow\n\t\t\t\t\t\tif (node.children.length < this.minEntries && node !== this.root) {\n\t\t\t\t\t\t\t// Simple approach: reinsert all entries from this node\n\t\t\t\t\t\t\tconst entries = node.children.slice();\n\t\t\t\t\t\t\tnode.children = [];\n\t\t\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Remove this node from parent\n\t\t\t\t\t\t\tif (parent) {\n\t\t\t\t\t\t\t\tparent.children.splice(indexInParent, 1);\n\t\t\t\t\t\t\t\tparent.updateBBox();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Reinsert entries\n\t\t\t\t\t\t\tfor (const e of entries) {\n\t\t\t\t\t\t\t\tthis._insert(e, this.root, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\t\t\t\tif (this._remove(bbox, data, child, node, i)) {\n\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get all entries in the tree\n\t * @returns {Array} All entries\n\t */\n\tgetAll() {\n\t\tconst results = [];\n\t\tthis._getAll(this.root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal method to get all entries\n\t */\n\t_getAll(node, results) {\n\t\tif (node.isLeaf) {\n\t\t\tresults.push(...node.children);\n\t\t} else {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tthis._getAll(child, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the number of entries in the tree\n\t * @returns {number} Number of entries\n\t */\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Clear all entries from the tree\n\t */\n\tclear() {\n\t\tthis.root = new RTreeNode(true, this.indexStore);\n    this.indexStore.setMeta('rootId', this.root.id);\n\t\tthis._size = 0;\n    this.indexStore.setMeta('size', 0);\n\t}\n\n}\n\nexport default RTree;\n","import { Index } from './Index.js';\nimport { RTree } from './RTree.js';\nimport { getProp } from './utils.js';\n\n/**\n * Geospatial index implementation using RTree\n * Supports geospatial queries on GeoJSON fields\n */\nexport class GeospatialCollectionIndex extends Index {\n\tconstructor(name, keys, storage, options = {}) {\n\t\tsuper(name, keys, storage, options);\n\t\t// Create the underlying RTree\n\t\tthis.rtree = new RTree(9, storage);\n\t\t// Track which field is the geospatial field\n\t\tthis.geoField = null;\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\tthis.geoField = field;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!this.geoField) {\n\t\t\tthrow new Error('Geospatial index must have at least one field with type \"2dsphere\" or \"2d\"');\n\t\t}\n\t}\n\n\t/**\n\t * Extract coordinates from a GeoJSON object\n\t * @param {Object} geoJson - The GeoJSON object\n\t * @returns {Object|null} Object with lat and lng, or null if invalid\n\t */\n\t_extractCoordinates(geoJson) {\n\t\tif (!geoJson) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t\tconst feature = geoJson.features[0];\n\t\t\tif (feature.geometry) {\n\t\t\t\treturn this._extractCoordinates(feature.geometry);\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\t\treturn this._extractCoordinates(geoJson.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\t\tconst [lng, lat] = geoJson.coordinates;\n\t\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Polygon - use centroid of first coordinate\n\t\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\t\tconst ring = geoJson.coordinates[0];\n\t\t\tif (ring.length > 0) {\n\t\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tsumLng += coord[0];\n\t\t\t\t\tsumLat += coord[1];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\t\tlng: sumLng / ring.length\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add a document to the geospatial index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\tthis.rtree.insert(coords.lat, coords.lng, { \n\t\t\t\t_id: doc._id, \n\t\t\t\tgeoJson: geoValue \n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the geospatial index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\tthis.rtree.remove(coords.lat, coords.lng, { \n\t\t\t\t_id: doc._id, \n\t\t\t\tgeoJson: geoValue \n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Query the geospatial index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a geospatial query\n\t */\n\tquery(query) {\n\t\t// Check if this is a geospatial query on our indexed field\n\t\tif (!query[this.geoField]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geoQuery = query[this.geoField];\n\n\t\t// Handle $geoWithin with bounding box\n\t\tif (geoQuery.$geoWithin) {\n\t\t\tconst bbox = geoQuery.$geoWithin;\n\t\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\t\tif (Array.isArray(bbox) && bbox.length === 2) {\n\t\t\t\tconst minLon = bbox[0][0];\n\t\t\t\tconst maxLat = bbox[0][1];\n\t\t\t\tconst maxLon = bbox[1][0];\n\t\t\t\tconst minLat = bbox[1][1];\n\n\t\t\t\tconst results = this.rtree.searchBBox({\n\t\t\t\t\tminLat: minLat,\n\t\t\t\t\tmaxLat: maxLat,\n\t\t\t\t\tminLng: minLon,\n\t\t\t\t\tmaxLng: maxLon\n\t\t\t\t});\n\n\t\t\t\t// Extract document IDs\n\t\t\t\treturn results.map(entry => entry.data._id);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $near with radius\n\t\tif (geoQuery.$near) {\n\t\t\tconst nearQuery = geoQuery.$near;\n\t\t\t\n\t\t\t// Extract geometry from $geometry or use direct coordinates\n\t\t\tlet coordinates;\n\t\t\tif (nearQuery.$geometry) {\n\t\t\t\tcoordinates = nearQuery.$geometry.coordinates;\n\t\t\t} else if (nearQuery.coordinates) {\n\t\t\t\tcoordinates = nearQuery.coordinates;\n\t\t\t} else if (Array.isArray(nearQuery)) {\n\t\t\t\tcoordinates = nearQuery;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\n\t\t\t// $maxDistance in meters (default to 1000km if not specified)\n\t\t\tconst maxDistanceMeters = nearQuery.$maxDistance || 1000000;\n\t\t\tconst maxDistanceKm = maxDistanceMeters / 1000;\n\n\t\t\t// Use rtree.searchRadius to find points within distance\n\t\t\tconst results = this.rtree.searchRadius(lat, lng, maxDistanceKm);\n\n\t\t\t// Calculate actual distances and sort by distance\n\t\t\tconst withDistances = results.map(entry => {\n\t\t\t\tconst dist = this._haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\t\treturn {\n\t\t\t\t\t_id: entry.data._id,\n\t\t\t\t\tdistance: dist\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Sort by distance (ascending)\n\t\t\twithDistances.sort((a, b) => a.distance - b.distance);\n\n\t\t\t// Return just the document IDs\n\t\t\treturn withDistances.map(entry => entry._id);\n\t\t}\n\n\t\t// Handle $nearSphere with radius (uses spherical distance, same as $near)\n\t\tif (geoQuery.$nearSphere) {\n\t\t\tconst nearQuery = geoQuery.$nearSphere;\n\t\t\t\n\t\t\t// Extract geometry from $geometry or use direct coordinates\n\t\t\tlet coordinates;\n\t\t\tif (nearQuery.$geometry) {\n\t\t\t\tcoordinates = nearQuery.$geometry.coordinates;\n\t\t\t} else if (nearQuery.coordinates) {\n\t\t\t\tcoordinates = nearQuery.coordinates;\n\t\t\t} else if (Array.isArray(nearQuery)) {\n\t\t\t\tcoordinates = nearQuery;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!coordinates || coordinates.length < 2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [lng, lat] = coordinates;\n\t\t\t\n\t\t\t// $maxDistance in meters (default to 1000km if not specified)\n\t\t\tconst maxDistanceMeters = nearQuery.$maxDistance || 1000000;\n\t\t\tconst maxDistanceKm = maxDistanceMeters / 1000;\n\n\t\t\t// Use rtree.searchRadius to find points within distance (already uses Haversine)\n\t\t\tconst results = this.rtree.searchRadius(lat, lng, maxDistanceKm);\n\n\t\t\t// Calculate actual distances and sort by distance\n\t\t\tconst withDistances = results.map(entry => {\n\t\t\t\tconst dist = this._haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\t\treturn {\n\t\t\t\t\t_id: entry.data._id,\n\t\t\t\t\tdistance: dist\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Sort by distance (ascending)\n\t\t\twithDistances.sort((a, b) => a.distance - b.distance);\n\n\t\t\t// Return just the document IDs\n\t\t\treturn withDistances.map(entry => entry._id);\n\t\t}\n\n\t\t// Handle $geoIntersects\n\t\tif (geoQuery.$geoIntersects) {\n\t\t\tconst intersectsQuery = geoQuery.$geoIntersects;\n\t\t\t\n\t\t\t// Extract geometry\n\t\t\tlet geometry;\n\t\t\tif (intersectsQuery.$geometry) {\n\t\t\t\tgeometry = intersectsQuery.$geometry;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!geometry || !geometry.type) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// For now, support Point and Polygon geometries\n\t\t\tif (geometry.type === 'Point') {\n\t\t\t\tconst [lng, lat] = geometry.coordinates;\n\t\t\t\t\n\t\t\t\t// Search for points at this exact location\n\t\t\t\t// Use a very small bounding box\n\t\t\t\tconst epsilon = 0.0001; // ~11 meters\n\t\t\t\tconst results = this.rtree.searchBBox({\n\t\t\t\t\tminLat: lat - epsilon,\n\t\t\t\t\tmaxLat: lat + epsilon,\n\t\t\t\t\tminLng: lng - epsilon,\n\t\t\t\t\tmaxLng: lng + epsilon\n\t\t\t\t});\n\n\t\t\t\t// Return document IDs\n\t\t\t\treturn results.map(entry => entry.data._id);\n\t\t\t} else if (geometry.type === 'Polygon') {\n\t\t\t\tconst coordinates = geometry.coordinates;\n\t\t\t\tif (!coordinates || coordinates.length === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Get the exterior ring\n\t\t\t\tconst ring = coordinates[0];\n\t\t\t\tif (!ring || ring.length < 3) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Calculate bounding box of the polygon\n\t\t\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\t\t\tlet minLng = Infinity, maxLng = -Infinity;\n\t\t\t\t\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tconst [lng, lat] = coord;\n\t\t\t\t\tminLat = Math.min(minLat, lat);\n\t\t\t\t\tmaxLat = Math.max(maxLat, lat);\n\t\t\t\t\tminLng = Math.min(minLng, lng);\n\t\t\t\t\tmaxLng = Math.max(maxLng, lng);\n\t\t\t\t}\n\n\t\t\t\t// Search for points within the bounding box\n\t\t\t\tconst candidates = this.rtree.searchBBox({\n\t\t\t\t\tminLat,\n\t\t\t\t\tmaxLat,\n\t\t\t\t\tminLng,\n\t\t\t\t\tmaxLng\n\t\t\t\t});\n\n\t\t\t\t// Filter by actual point-in-polygon test\n\t\t\t\tconst results = candidates.filter(entry => {\n\t\t\t\t\treturn this._pointInPolygon(entry.lat, entry.lng, ring);\n\t\t\t\t});\n\n\t\t\t\treturn results.map(entry => entry.data._id);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Calculate distance between two points using Haversine formula\n\t * @param {number} lat1 - Latitude of first point\n\t * @param {number} lng1 - Longitude of first point\n\t * @param {number} lat2 - Latitude of second point\n\t * @param {number} lng2 - Longitude of second point\n\t * @returns {number} Distance in kilometers\n\t */\n\t_haversineDistance(lat1, lng1, lat2, lng2) {\n\t\tconst R = 6371; // Earth's radius in kilometers\n\t\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\t\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\t\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\treturn R * c;\n\t}\n\n\t/**\n\t * Test if a point is inside a polygon using ray casting algorithm\n\t * @param {number} lat - Point latitude\n\t * @param {number} lng - Point longitude\n\t * @param {Array} ring - Polygon ring as array of [lng, lat] coordinates\n\t * @returns {boolean} True if point is inside polygon\n\t */\n\t_pointInPolygon(lat, lng, ring) {\n\t\tlet inside = false;\n\t\t\n\t\tfor (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n\t\t\tconst [xi, yi] = ring[i];\n\t\t\tconst [xj, yj] = ring[j];\n\t\t\t\n\t\t\tconst intersect = ((yi > lat) !== (yj > lat)) &&\n\t\t\t\t(lng < (xj - xi) * (lat - yi) / (yj - yi) + xi);\n\t\t\t\n\t\t\tif (intersect) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inside;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.rtree.clear();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\t'2dsphereIndexVersion': 3\n\t\t};\n\t}\n\n}\n","import { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\n\n/**\n * Query execution plan\n */\nclass QueryPlan {\n\tconstructor() {\n\t\tthis.type = 'full_scan'; // 'full_scan', 'index_scan', 'index_intersection', 'index_union'\n\t\tthis.indexes = []; // Indexes to use\n\t\tthis.indexScans = []; // Array of { indexName, docIds }\n\t\tthis.estimatedCost = Infinity;\n\t\tthis.indexOnly = false; // If true, only use index results (no full scan fallback)\n\t}\n}\n\n/**\n * Query planner - analyzes queries and generates optimal execution plans\n */\nexport class QueryPlanner {\n\tconstructor(indexes) {\n\t\tthis.indexes = indexes; // Map<string, CollectionIndex>\n\t}\n\n\t/**\n\t * Generate an execution plan for a query\n\t * @param {Object} query - MongoDB query object\n\t * @returns {QueryPlan} Execution plan\n\t */\n\tplan(query) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Empty query - full scan\n\t\tif (!query || Object.keys(query).length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Analyze query structure\n\t\tconst analysis = this._analyzeQuery(query);\n\n\t\t// Check for text search\n\t\tif (analysis.hasTextSearch) {\n\t\t\tconst textPlan = this._planTextSearch(query, analysis);\n\t\t\tif (textPlan) {\n\t\t\t\treturn textPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for geospatial query\n\t\tif (analysis.hasGeoQuery) {\n\t\t\tconst geoPlan = this._planGeoQuery(query, analysis);\n\t\t\tif (geoPlan) {\n\t\t\t\treturn geoPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $and queries - can use index intersection\n\t\tif (analysis.type === 'and') {\n\t\t\tconst andPlan = this._planAndQuery(query, analysis);\n\t\t\tif (andPlan.type !== 'full_scan') {\n\t\t\t\treturn andPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Check for $or queries - can use index union\n\t\tif (analysis.type === 'or') {\n\t\t\tconst orPlan = this._planOrQuery(query, analysis);\n\t\t\tif (orPlan.type !== 'full_scan') {\n\t\t\t\treturn orPlan;\n\t\t\t}\n\t\t}\n\n\t\t// Try to find a single index for simple queries\n\t\tconst simplePlan = this._planSimpleQuery(query);\n\t\tif (simplePlan.type !== 'full_scan') {\n\t\t\treturn simplePlan;\n\t\t}\n\n\t\t// Fall back to full scan\n\t\treturn plan;\n\t}\n\n\t/**\n\t * Analyze query structure\n\t * @private\n\t */\n\t_analyzeQuery(query) {\n\t\tconst analysis = {\n\t\t\ttype: 'simple', // 'simple', 'and', 'or', 'complex'\n\t\t\tfields: [],\n\t\t\toperators: {},\n\t\t\thasTextSearch: false,\n\t\t\thasGeoQuery: false,\n\t\t\tconditions: []\n\t\t};\n\n\t\tconst keys = Object.keys(query);\n\n\t\t// Check for top-level logical operators\n\t\tif (keys.length === 1) {\n\t\t\tconst key = keys[0];\n\t\t\tif (key === '$and') {\n\t\t\t\tanalysis.type = 'and';\n\t\t\t\tanalysis.conditions = query.$and;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t} else if (key === '$or') {\n\t\t\t\tanalysis.type = 'or';\n\t\t\t\tanalysis.conditions = query.$or;\n\t\t\t\t// Analyze each condition\n\t\t\t\tfor (const condition of analysis.conditions) {\n\t\t\t\t\tconst subAnalysis = this._analyzeQuery(condition);\n\t\t\t\t\tanalysis.fields.push(...subAnalysis.fields);\n\t\t\t\t\tif (subAnalysis.hasTextSearch) analysis.hasTextSearch = true;\n\t\t\t\t\tif (subAnalysis.hasGeoQuery) analysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t\treturn analysis;\n\t\t\t}\n\t\t}\n\n\t\t// Analyze simple field conditions\n\t\tfor (const field of keys) {\n\t\t\tif (field.startsWith('$')) {\n\t\t\t\tcontinue; // Skip top-level operators we don't handle yet\n\t\t\t}\n\n\t\t\tanalysis.fields.push(field);\n\t\t\tconst value = query[field];\n\n\t\t\t// Check for operators\n\t\t\tif (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n\t\t\t\tconst ops = Object.keys(value);\n\t\t\t\tanalysis.operators[field] = ops;\n\n\t\t\t\t// Check for text search\n\t\t\t\tif (ops.includes('$text')) {\n\t\t\t\t\tanalysis.hasTextSearch = true;\n\t\t\t\t}\n\n\t\t\t\t// Check for geospatial operators\n\t\t\t\tif (ops.some(op => ['$geoWithin', '$geoIntersects', '$near', '$nearSphere'].includes(op))) {\n\t\t\t\t\tanalysis.hasGeoQuery = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If multiple fields, it's an implicit $and\n\t\tif (keys.length > 1) {\n\t\t\tanalysis.type = 'and';\n\t\t}\n\n\t\treturn analysis;\n\t}\n\n\t/**\n\t * Plan for text search queries\n\t * @private\n\t */\n\t_planTextSearch(query, analysis) {\n\t\t// Find text index\n\t\tfor (const [indexName,index] of this.indexes) {\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Look for $text operator in query\n\t\t\t\tconst textQuery = this._extractTextQuery(query);\n\t\t\t\tif (textQuery) {\n\t\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\t\tplan.type = 'index_scan';\n\t\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\t\tplan.indexScans = [{ indexName, index, textQuery }];\n\t\t\t\t\tplan.estimatedCost = 100; // Rough estimate without executing\n\t\t\t\t\tplan.indexOnly = true; // Text search must use index\n\t\t\t\t\treturn plan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extract $text query from query object\n\t * @private\n\t */\n\t_extractTextQuery(query) {\n\t\tfor (const field in query) {\n\t\t\tconst value = query[field];\n\t\t\tif (typeof value === 'object' && value !== null && value.$text) {\n\t\t\t\treturn typeof value.$text === 'string' ? value.$text : value.$text.$search;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for geospatial queries\n\t * @private\n\t */\n\t_planGeoQuery(query, analysis) {\n\t\t// Find geospatial index\n\t\tfor (const [indexName,index] of this.indexes) {\n\t\t\tif (index instanceof GeospatialCollectionIndex) {\n\t\t\t\t// Check if this index can handle the query (don't execute yet)\n\t\t\t\tconst plan = new QueryPlan();\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\tplan.indexScans = [{ indexName, index, query }];\n\t\t\t\tplan.estimatedCost = 100; // Rough estimate without executing\n\t\t\t\tplan.indexOnly = true; // Geospatial queries must use index\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Plan for $and queries (index intersection)\n\t * @private\n\t */\n\t_planAndQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\t// Extract conditions\n\t\tlet conditions;\n\t\tif (query.$and) {\n\t\t\tconditions = query.$and;\n\t\t} else {\n\t\t\t// Implicit AND - convert to array of conditions\n\t\t\tconditions = Object.keys(query).map(field => ({ [field]: query[field] }));\n\t\t}\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have multiple indexable conditions, use index intersection\n\t\tif (indexableConditions.length > 1) {\n\t\t\tplan.type = 'index_intersection';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost (rough estimate without executing)\n\t\t\tplan.estimatedCost = 50; // Intersection typically reduces result set\n\t\t\treturn plan;\n\t\t}\n\n\t\t// If we have one indexable condition, use it\n\t\tif (indexableConditions.length === 1) {\n\t\t\tplan.type = 'index_scan';\n\t\t\tplan.indexScans = [indexableConditions[0]];\n\t\t\tplan.indexes = [indexableConditions[0].indexName];\n\t\t\tplan.estimatedCost = 50; // Rough estimate without executing\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for $or queries (index union)\n\t * @private\n\t */\n\t_planOrQuery(query, analysis) {\n\t\tconst plan = new QueryPlan();\n\n\t\tif (!query.$or) {\n\t\t\treturn plan;\n\t\t}\n\n\t\tconst conditions = query.$or;\n\n\t\t// Try to find indexes for each condition\n\t\tconst indexableConditions = [];\n\t\tfor (const condition of conditions) {\n\t\t\tconst conditionPlan = this._planSimpleQuery(condition);\n\t\t\tif (conditionPlan.type === 'index_scan') {\n\t\t\t\tindexableConditions.push(conditionPlan.indexScans[0]);\n\t\t\t}\n\t\t}\n\n\t\t// If we have at least one indexable condition, use index union\n\t\tif (indexableConditions.length > 0) {\n\t\t\tplan.type = 'index_union';\n\t\t\tplan.indexScans = indexableConditions;\n\t\t\tplan.indexes = indexableConditions.map(scan => scan.indexName);\n\t\t\t\n\t\t\t// Estimate cost (rough estimate without executing)\n\t\t\tplan.estimatedCost = 100 * indexableConditions.length; // Union typically increases result set\n\t\t\treturn plan;\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Plan for simple single-field queries\n\t * @private\n\t */\n\t_planSimpleQuery(query) {\n\t\tconst plan = new QueryPlan();\n\t\tconst queryKeys = Object.keys(query);\n\n\t\tif (queryKeys.length === 0) {\n\t\t\treturn plan;\n\t\t}\n\n\t\t// Try each index\n\t\tfor (const [indexName,index] of this.indexes) {\n\n\t\t\t// Skip special index types (they have their own planning)\n\t\t\tif (index instanceof TextCollectionIndex || index instanceof GeospatialCollectionIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if this index CAN handle the query (don't execute yet)\n\t\t\tif (this._canIndexHandleQuery(index, query)) {\n\t\t\t\tplan.type = 'index_scan';\n\t\t\t\tplan.indexes = [indexName];\n\t\t\t\t// Store query info for execution phase, don't execute yet\n\t\t\t\tplan.indexScans = [{ indexName, index, query }];\n\t\t\t\tplan.estimatedCost = 50; // Rough estimate without executing\n\t\t\t\treturn plan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan; // full_scan\n\t}\n\n\t/**\n\t * Execute a single index scan that was deferred from planning\n\t * @private\n\t */\n\t_executeIndexScan(scan) {\n\t\tconst { index, query, textQuery } = scan;\n\t\t\n\t\t// Handle text search\n\t\tif (textQuery !== undefined) {\n\t\t\treturn index.search(textQuery);\n\t\t}\n\t\t\n\t\t// Handle regular index query\n\t\tif (query !== undefined) {\n\t\t\tconst docIds = index.query(query);\n\t\t\treturn docIds !== null ? docIds : [];\n\t\t}\n\t\t\n\t\t// Fallback: if docIds were already computed (backward compatibility)\n\t\tif (scan.docIds !== undefined) {\n\t\t\treturn scan.docIds;\n\t\t}\n\t\t\n\t\treturn [];\n\t}\n\n\t/**\n\t * Check if an index can handle a query (without executing it)\n\t * @private\n\t */\n\t_canIndexHandleQuery(index, query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(index.keys);\n\n\t\t// Only support single-field index queries for now\n\t\tif (indexFields.length !== 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst field = indexFields[0];\n\t\t\n\t\t// Check if query has this field\n\t\tif (queryKeys.indexOf(field) === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Execute a query plan and return document IDs\n\t * @param {QueryPlan} plan - The execution plan\n\t * @returns {Array|null} Array of document IDs or null for full scan\n\t */\n\texecute(plan) {\n\t\tif (plan.type === 'full_scan') {\n\t\t\treturn null; // Signals cursor to do full scan\n\t\t}\n\n\t\tif (plan.type === 'index_scan') {\n\t\t\t// Execute the query now\n\t\t\tconst scan = plan.indexScans[0];\n\t\t\treturn this._executeIndexScan(scan);\n\t\t}\n\n\t\tif (plan.type === 'index_intersection') {\n\t\t\t// Intersection: docs must be in ALL index results\n\t\t\tif (plan.indexScans.length === 0) return null;\n\t\t\t\n\t\t\t// Execute all scans\n\t\t\tconst results = plan.indexScans.map(scan => ({\n\t\t\t\tdocIds: this._executeIndexScan(scan),\n\t\t\t\tindexName: scan.indexName\n\t\t\t}));\n\t\t\t\n\t\t\t// Start with the smallest set for efficiency\n\t\t\tconst sorted = results.slice().sort((a, b) => a.docIds.length - b.docIds.length);\n\t\t\tlet result = new Set(sorted[0].docIds);\n\t\t\t\n\t\t\t// Intersect with each subsequent set\n\t\t\tfor (let i = 1; i < sorted.length; i++) {\n\t\t\t\tconst currentSet = new Set(sorted[i].docIds);\n\t\t\t\tresult = new Set([...result].filter(id => currentSet.has(id)));\n\t\t\t\t\n\t\t\t\t// Early exit if intersection becomes empty\n\t\t\t\tif (result.size === 0) break;\n\t\t\t}\n\t\t\t\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\tif (plan.type === 'index_union') {\n\t\t\t// Union: docs in ANY index result\n\t\t\tconst result = new Set();\n\t\t\tfor (const scan of plan.indexScans) {\n\t\t\t\tconst docIds = this._executeIndexScan(scan);\n\t\t\t\tdocIds.forEach(id => result.add(id));\n\t\t\t}\n\t\t\treturn Array.from(result);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","import { EventEmitter } from 'events';\nimport { matches } from './queryMatcher.js';\n\n/**\n * ChangeStream watches for changes in collections and emits change events\n * Compatible with MongoDB Change Streams API\n */\nexport class ChangeStream extends EventEmitter {\n\tconstructor(target, pipeline = [], options = {}) {\n\t\tsuper();\n\t\t\n\t\tthis.target = target; // MongoClient, DB, or Collection\n\t\tthis.pipeline = pipeline;\n\t\tthis.options = options;\n\t\tthis.closed = false;\n\t\tthis._listeners = new Map();\n\t\tthis._changeCounter = 0;\n\t\t\n\t\t// Start watching immediately (synchronously)\n\t\tthis._startWatching();\n\t}\n\n\t/**\n\t * Start watching for changes\n\t * @private\n\t */\n\t_startWatching() {\n\t\tif (this.closed) return;\n\t\t\n\t\tconst collections = this._getCollectionsToWatch();\n\t\t\n\t\tfor (const collection of collections) {\n\t\t\tthis._watchCollection(collection);\n\t\t}\n\t\t\n\t\t// For DB watching, we also need to intercept new collection creation\n\t\tif (this.target.constructor.name === 'DB') {\n\t\t\tthis._interceptDBCollectionCreation();\n\t\t}\n\t\t\n\t\t// For MongoClient watching, intercept db() calls\n\t\tif (this.target.constructor.name === 'MongoClient') {\n\t\t\tthis._interceptClientDBCreation();\n\t\t}\n\t}\n\n\t/**\n\t * Get collections to watch based on target type\n\t * @private\n\t */\n\t_getCollectionsToWatch() {\n\t\tconst collections = [];\n\t\t\n\t\t// MongoClient - watch all collections in all databases\n\t\tif (this.target.constructor.name === 'MongoClient') {\n\t\t\t// Store reference to monitor for new databases/collections\n\t\t\tthis._monitorClient();\n\t\t\treturn collections;\n\t\t}\n\t\t\n\t\t// DB - watch all collections in the database\n\t\tif (this.target.constructor.name === 'DB') {\n\t\t\tconst collectionNames = this.target.getCollectionNames();\n\t\t\tfor (const name of collectionNames) {\n\t\t\t\tconst collection = this.target[name];\n\t\t\t\tif (collection && collection.isCollection) {\n\t\t\t\t\tcollections.push(collection);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Also monitor for new collections\n\t\t\tthis._monitorDB();\n\t\t}\n\t\t\n\t\t// Collection - watch specific collection\n\t\tif (this.target.isCollection) {\n\t\t\tcollections.push(this.target);\n\t\t}\n\t\t\n\t\treturn collections;\n\t}\n\n\t/**\n\t * Watch a specific collection for changes\n\t * @private\n\t */\n\t_watchCollection(collection) {\n\t\tif (this.closed) return;\n\t\tif (!collection) return; // Skip null/undefined\n\t\tif (typeof collection.on !== 'function') return; // Skip non-EventEmitters\n\t\tif (!collection.isCollection) return; // Skip non-collections\n\t\tif (this._listeners.has(collection)) return; // Already watching\n\t\t\n\t\tconst handlers = {\n\t\t\tinsert: (doc) => this._emitChange('insert', collection, doc),\n\t\t\tupdate: (doc, updateDescription) => this._emitChange('update', collection, doc, updateDescription),\n\t\t\treplace: (doc) => this._emitChange('replace', collection, doc),\n\t\t\tdelete: (doc) => this._emitChange('delete', collection, doc)\n\t\t};\n\t\t\n\t\t// Store handlers for cleanup\n\t\tthis._listeners.set(collection, handlers);\n\t\t\n\t\t// Listen to collection change events\n\t\tcollection.on('insert', handlers.insert);\n\t\tcollection.on('update', handlers.update);\n\t\tcollection.on('replace', handlers.replace);\n\t\tcollection.on('delete', handlers.delete);\n\t}\n\n\t/**\n\t * Emit a change event\n\t * @private\n\t */\n\t_emitChange(operationType, collection, doc, updateDescription = null) {\n\t\tif (this.closed) return;\n\t\t\n\t\tconst changeEvent = this._createChangeEvent(\n\t\t\toperationType,\n\t\t\tcollection,\n\t\t\tdoc,\n\t\t\tupdateDescription\n\t\t);\n\t\t\n\t\t// Apply pipeline filters if any\n\t\tif (!this._matchesPipeline(changeEvent)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.emit('change', changeEvent);\n\t}\n\n\t/**\n\t * Create a MongoDB-compatible change event document\n\t * @private\n\t */\n\t_createChangeEvent(operationType, collection, doc, updateDescription) {\n\t\tconst event = {\n\t\t\t_id: {\n\t\t\t\t_data: Buffer.from(String(++this._changeCounter)).toString('base64')\n\t\t\t},\n\t\t\toperationType,\n\t\t\tclusterTime: new Date(),\n\t\t\tns: {\n\t\t\t\tdb: collection.db.dbName,\n\t\t\t\tcoll: collection.name\n\t\t\t},\n\t\t\tdocumentKey: {\n\t\t\t\t_id: doc._id\n\t\t\t}\n\t\t};\n\t\t\n\t\tswitch (operationType) {\n\t\t\tcase 'insert':\n\t\t\t\tevent.fullDocument = doc;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'update':\n\t\t\t\tevent.updateDescription = updateDescription || {\n\t\t\t\t\tupdatedFields: {},\n\t\t\t\t\tremovedFields: [],\n\t\t\t\t\ttruncatedArrays: []\n\t\t\t\t};\n\t\t\t\t// Include full document if requested\n\t\t\t\tif (this.options.fullDocument === 'updateLookup') {\n\t\t\t\t\tevent.fullDocument = doc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'replace':\n\t\t\t\tevent.fullDocument = doc;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 'delete':\n\t\t\t\t// For delete, doc contains the deleted document's _id\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn event;\n\t}\n\n\t/**\n\t * Check if change event matches pipeline filters\n\t * @private\n\t */\n\t_matchesPipeline(changeEvent) {\n\t\tif (!this.pipeline || this.pipeline.length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// Process pipeline stages\n\t\tfor (const stage of this.pipeline) {\n\t\t\tif (stage.$match) {\n\t\t\t\t// Use the same query matcher as find()\n\t\t\t\t// Note: matches(document, query) - document first, query second\n\t\t\t\tif (!matches(changeEvent, stage.$match)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get nested value from object using dot notation\n\t * @private\n\t */\n\t_getNestedValue(obj, path) {\n\t\treturn path.split('.').reduce((current, part) => current?.[part], obj);\n\t}\n\n\t/**\n\t * Monitor client for new databases/collections (simplified)\n\t * @private\n\t */\n\t_monitorClient() {\n\t\t// Handled by _interceptClientDBCreation\n\t}\n\n\t/**\n\t * Intercept DB creation on a MongoClient\n\t * @private\n\t */\n\t_interceptClientDBCreation() {\n\t\tconst client = this.target;\n\t\tconst originalDb = client.db.bind(client);\n\t\tconst self = this;\n\t\t\n\t\t// Track databases we're watching\n\t\tthis._watchedDBs = new Map();\n\t\t\n\t\t// Override db() method to watch new databases\n\t\tclient.db = function(name, opts) {\n\t\t\tconst database = originalDb(name, opts);\n\t\t\tconst dbName = database.dbName;\n\t\t\t\n\t\t\t// Only set up watch once per database\n\t\t\tif (!self._watchedDBs.has(dbName)) {\n\t\t\t\tself._watchedDBs.set(dbName, database);\n\t\t\t\t\n\t\t\t\t// Watch existing collections in this database\n\t\t\t\tconst collectionNames = database.getCollectionNames();\n\t\t\t\tfor (const colName of collectionNames) {\n\t\t\t\t\tconst col = database[colName];\n\t\t\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\t\t\tself._watchCollection(col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Intercept new collection creation on this database\n\t\t\t\tself._interceptDBCollectionCreationForClient(database);\n\t\t\t}\n\t\t\t\n\t\t\treturn database;\n\t\t};\n\t\t\n\t\t// Store original for cleanup\n\t\tthis._originalClientMethods = { db: originalDb };\n\t}\n\n\t/**\n\t * Intercept collection creation for a database in client watch mode\n\t * @private\n\t */\n\t_interceptDBCollectionCreationForClient(db) {\n\t\tconst originalCollection = db.collection.bind(db);\n\t\tconst originalCreateCollection = db.createCollection.bind(db);\n\t\tconst self = this;\n\t\t\n\t\tdb.collection = function(name) {\n\t\t\tconst col = originalCollection(name);\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t\treturn col;\n\t\t};\n\t\t\n\t\tdb.createCollection = function(name) {\n\t\t\toriginalCreateCollection(name);\n\t\t\tconst col = db[name];\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Monitor database for new collections\n\t * @private\n\t */\n\t_monitorDB() {\n\t\t// Handled by _interceptDBCollectionCreation\n\t}\n\n\t/**\n\t * Intercept new collection creation on a DB\n\t * @private\n\t */\n\t_interceptDBCollectionCreation() {\n\t\tconst db = this.target;\n\t\tconst originalCollection = db.collection.bind(db);\n\t\tconst originalCreateCollection = db.createCollection.bind(db);\n\t\tconst self = this;\n\t\t\n\t\t// Override collection() method to watch new collections\n\t\tdb.collection = function(name) {\n\t\t\tconst col = originalCollection(name);\n\t\t\t// Watch this collection if we haven't already\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t\treturn col;\n\t\t};\n\t\t\n\t\t// Override createCollection() method\n\t\tdb.createCollection = function(name) {\n\t\t\toriginalCreateCollection(name);\n\t\t\tconst col = db[name];\n\t\t\tif (col && col.isCollection && !self._listeners.has(col)) {\n\t\t\t\tself._watchCollection(col);\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Store originals for cleanup\n\t\tthis._originalDBMethods = { collection: originalCollection, createCollection: originalCreateCollection };\n\t}\n\n\t/**\n\t * Close the change stream\n\t */\n\tclose() {\n\t\tif (this.closed) return;\n\t\t\n\t\tthis.closed = true;\n\t\t\n\t\t// Remove all collection listeners\n\t\tfor (const [collection, handlers] of this._listeners) {\n\t\t\tcollection.off('insert', handlers.insert);\n\t\t\tcollection.off('update', handlers.update);\n\t\t\tcollection.off('replace', handlers.replace);\n\t\t\tcollection.off('delete', handlers.delete);\n\t\t}\n\t\t\n\t\tthis._listeners.clear();\n\t\t\n\t\t// Restore original DB methods if we intercepted them\n\t\tif (this._originalDBMethods && this.target.constructor.name === 'DB') {\n\t\t\tthis.target.collection = this._originalDBMethods.collection;\n\t\t\tthis.target.createCollection = this._originalDBMethods.createCollection;\n\t\t}\n\t\t\n\t\t// Restore original MongoClient methods if we intercepted them\n\t\tif (this._originalClientMethods && this.target.constructor.name === 'MongoClient') {\n\t\t\tthis.target.db = this._originalClientMethods.db;\n\t\t}\n\t\t\n\t\t// Emit close before removing all listeners\n\t\tthis.emit('close');\n\t\tthis.removeAllListeners();\n\t}\n\n\t/**\n\t * Check if the stream is closed\n\t */\n\tget isClosed() {\n\t\treturn this.closed;\n\t}\n\n\t/**\n\t * Async iterator support for for-await-of loops\n\t */\n\tasync *[Symbol.asyncIterator]() {\n\t\tconst queue = [];\n\t\tlet resolveNext = null;\n\t\tlet streamClosed = false;\n\t\t\n\t\tconst onChange = (change) => {\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext({ value: change, done: false });\n\t\t\t\tresolveNext = null;\n\t\t\t} else {\n\t\t\t\tqueue.push(change);\n\t\t\t}\n\t\t};\n\t\t\n\t\tconst onClose = () => {\n\t\t\tstreamClosed = true;\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext({ done: true });\n\t\t\t\tresolveNext = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tconst onError = (error) => {\n\t\t\tif (resolveNext) {\n\t\t\t\tresolveNext(Promise.reject(error));\n\t\t\t\tresolveNext = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tthis.on('change', onChange);\n\t\tthis.on('close', onClose);\n\t\tthis.on('error', onError);\n\t\t\n\t\ttry {\n\t\t\twhile (!streamClosed) {\n\t\t\t\tif (queue.length > 0) {\n\t\t\t\t\tyield queue.shift();\n\t\t\t\t} else {\n\t\t\t\t\tconst next = await new Promise((resolve) => {\n\t\t\t\t\t\tresolveNext = resolve;\n\t\t\t\t\t\t// Check if stream was closed while waiting\n\t\t\t\t\t\tif (streamClosed) {\n\t\t\t\t\t\t\tresolve({ done: true });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif (next.done) break;\n\t\t\t\t\tyield next.value;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.off('change', onChange);\n\t\t\tthis.off('close', onClose);\n\t\t\tthis.off('error', onError);\n\t\t}\n\t}\n\n\t/**\n\t * Get next change (for compatibility)\n\t */\n\tasync next() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst onChange = (change) => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(change);\n\t\t\t};\n\t\t\t\n\t\t\tconst onClose = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(null);\n\t\t\t};\n\t\t\t\n\t\t\tconst onError = (error) => {\n\t\t\t\tcleanup();\n\t\t\t\treject(error);\n\t\t\t};\n\t\t\t\n\t\t\tconst cleanup = () => {\n\t\t\t\tthis.off('change', onChange);\n\t\t\t\tthis.off('close', onClose);\n\t\t\t\tthis.off('error', onError);\n\t\t\t};\n\t\t\t\n\t\t\tif (this.closed) {\n\t\t\t\tresolve(null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis.once('change', onChange);\n\t\t\tthis.once('close', onClose);\n\t\t\tthis.once('error', onError);\n\t\t});\n\t}\n}\n","import { EventEmitter } from 'events';\nimport { Cursor } from './Cursor.js';\nimport { SortedCursor } from './SortedCursor.js';\nimport { isArray, getProp, applyProjection, copy } from './utils.js';\nimport { matches, matchWithArrayIndices } from './queryMatcher.js';\nimport { applyUpdates, createDocFromUpdate } from './updates.js';\nimport { RegularCollectionIndex } from './RegularCollectionIndex.js';\nimport { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\nimport { QueryPlanner } from './QueryPlanner.js';\nimport { evaluateExpression } from './aggregationExpressions.js';\nimport { ChangeStream } from './ChangeStream.js';\nimport { \n\tNotImplementedError, \n\tQueryError, \n\tBadValueError, \n\tIndexError, \n\tIndexNotFoundError,\n\tErrorCodes \n} from './errors.js';\n\n/**\n * Collection class\n */\nexport class Collection extends EventEmitter {\n\tconstructor(db, name, storage, idGenerator) {\n\t\tsuper();\n\t\tthis.db = db;\n\t\tthis.name = name;\n\t\tthis.storage = storage;\n\t\tthis.idGenerator = idGenerator;\n\t\tthis.indexes = new Map(); // Index storage - map of index name to index structure\n\t\tthis.queryPlanner = new QueryPlanner(this.indexes); // Query planner\n\t\tthis.isCollection = true; // TODO used by dropDatabase, ugly\n\n\t\t// Load existing indexes from storage\n\t\tfor (const [indexName, indexStore] of this.storage.indexes) {\n\t\t\tlet index;\n\t\t\tif (indexStore.getMeta('type') === 'text') {\n\t\t\t\tindex = new TextCollectionIndex(indexName, indexStore.getMeta('keys'), indexStore);\n\t\t\t} else if (indexStore.getMeta('type') === 'geospatial') {\n\t\t\t\tindex = new GeospatialCollectionIndex(indexName, indexStore.getMeta('keys'), indexStore);\n\t\t\t} else if (indexStore.getMeta('type') === 'regular') {\n\t\t\t\t// Default to regular index\n\t\t\t\tindex = new RegularCollectionIndex(indexName, indexStore.getMeta('keys'), indexStore);\n\t\t\t}\n\t\t\tif (index) {\n\t\t\t\tthis.indexes.set(index.name, index);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Determine if keys specify a text index\n\t */\n\tisTextIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine if keys specify a geospatial index\n\t */\n\tisGeospatialIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build/rebuild an index\n\t */\n\tbuildIndex(indexName, keys, options = {}) {\n\t\tlet index;\n\t\t\n\t\t// Create appropriate index type\n\t\tif (this.isTextIndex(keys)) {\n\t\t\tconst meta = { type: 'text', keys };\n\t\t\tindex = new TextCollectionIndex(indexName, keys, this.storage.createIndexStore(indexName, meta), options);\n\t\t} else if (this.isGeospatialIndex(keys)) {\n\t\t\tconst meta = { type: 'geospatial', keys };\n\t\t\tindex = new GeospatialCollectionIndex(indexName, keys, this.storage.createIndexStore(indexName, meta), options);\n\t\t} else {\n\t\t\tconst meta = { type: 'regular', keys };\n\t\t\tindex = new RegularCollectionIndex(indexName, keys, this.storage.createIndexStore(indexName, meta), options);\n\t\t}\n\n\t\t// Build index by scanning all documents\n\t\tconst allDocs = this.storage.getAllDocuments();\n\t\tfor (const doc of allDocs) {\n\t\t\tif (doc) {\n\t\t\t\tindex.add(doc);\n\t\t\t}\n\t\t}\n\n\t\tthis.indexes.set(indexName, index);\n\t\treturn index;\n\t}\n\n\t/**\n\t * Update indexes when a document is inserted\n\t */\n\tupdateIndexesOnInsert(doc) {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tindex.add(doc);\n\t\t}\n\t}\n\n\t/**\n\t * Update indexes when a document is deleted\n\t */\n\tupdateIndexesOnDelete(doc) {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tindex.remove(doc);\n\t\t}\n\t}\n\n\t/**\n\t * Query planner - analyze query and determine optimal execution plan\n\t */\n\tplanQuery(query) {\n\t\tconst plan = this.queryPlanner.plan(query);\n\t\tconst docIds = this.queryPlanner.execute(plan);\n\t\t\n\t\treturn {\n\t\t\tuseIndex: plan.type !== 'full_scan',\n\t\t\tplanType: plan.type,\n\t\t\tindexNames: plan.indexes,\n\t\t\tdocIds: docIds,\n\t\t\testimatedCost: plan.estimatedCost,\n\t\t\tindexOnly: plan.indexOnly || false\n\t\t};\n\t}\n\n\t/**\n\t * Get a text index for the given field\n\t * @param {string} field - The field name\n\t * @returns {TextCollectionIndex|null} The text index or null if not found\n\t */\n\tgetTextIndex(field) {\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t// Check if this field is indexed\n\t\t\t\tif (index.indexedFields.includes(field)) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Collection methods\n\taggregate(pipeline) {\n\t\tif (!pipeline || !isArray(pipeline)) {\n\t\t\tthrow new QueryError('Pipeline must be an array', { \n\t\t\t\tcollection: this.name, \n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t\t\t});\n\t\t}\n\n\t\t// Start with all documents\n\t\tlet results = [];\n\t\tconst cursor = this.find({});\n\t\twhile (cursor.hasNext()) {\n\t\t\tresults.push(cursor.next());\n\t\t}\n\n\t\t// Process each stage in the pipeline\n\t\tfor (let i = 0; i < pipeline.length; i++) {\n\t\t\tconst stage = pipeline[i];\n\t\t\tconst stageKeys = Object.keys(stage);\n\t\t\tif (stageKeys.length !== 1) {\n\t\t\t\tthrow new QueryError('Each pipeline stage must have exactly one key', { \n\t\t\t\t\tcollection: this.name, \n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t\t\t\t});\n\t\t\t}\n\t\t\tconst stageType = stageKeys[0];\n\t\t\tconst stageSpec = stage[stageType];\n\n\t\t\tif (stageType === \"$match\") {\n\t\t\t\t// Filter documents based on query\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tif (matches(results[j], stageSpec)) {\n\t\t\t\t\t\tmatched.push(results[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults = matched;\n\t\t\t} else if (stageType === \"$project\") {\n\t\t\t\t// Reshape documents with expression support\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tprojected.push(applyProjectionWithExpressions(stageSpec, results[j]));\n\t\t\t\t}\n\t\t\t\tresults = projected;\n\t\t\t} else if (stageType === \"$addFields\" || stageType === \"$set\") {\n\t\t\t\t// Add/set fields with computed expressions\n\t\t\t\tconst modified = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = copy(results[j]);\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tconst expr = stageSpec[field];\n\t\t\t\t\t\tdoc[field] = evaluateExpression(expr, results[j]);\n\t\t\t\t\t}\n\t\t\t\t\tmodified.push(doc);\n\t\t\t\t}\n\t\t\t\tresults = modified;\n\t\t\t} else if (stageType === \"$unset\") {\n\t\t\t\t// Remove fields from documents\n\t\t\t\tconst modified = [];\n\t\t\t\t// $unset can be a string (single field), array of strings, or object\n\t\t\t\tlet fieldsToRemove = [];\n\t\t\t\tif (typeof stageSpec === 'string') {\n\t\t\t\t\tfieldsToRemove = [stageSpec];\n\t\t\t\t} else if (Array.isArray(stageSpec)) {\n\t\t\t\t\tfieldsToRemove = stageSpec;\n\t\t\t\t} else if (typeof stageSpec === 'object') {\n\t\t\t\t\t// Object form: { field1: \"\", field2: \"\" } or { field1: 1, field2: 1 }\n\t\t\t\t\tfieldsToRemove = Object.keys(stageSpec);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = copy(results[j]);\n\t\t\t\t\tfor (let k = 0; k < fieldsToRemove.length; k++) {\n\t\t\t\t\t\tconst field = fieldsToRemove[k];\n\t\t\t\t\t\t// Support dot notation for nested field removal\n\t\t\t\t\t\tconst pathParts = field.split('.');\n\t\t\t\t\t\tif (pathParts.length === 1) {\n\t\t\t\t\t\t\tdelete doc[field];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Navigate to parent and delete nested field\n\t\t\t\t\t\t\tlet parent = doc;\n\t\t\t\t\t\t\tfor (let m = 0; m < pathParts.length - 1; m++) {\n\t\t\t\t\t\t\t\tif (parent == undefined || parent == null) break;\n\t\t\t\t\t\t\t\tparent = parent[pathParts[m]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (parent != undefined && parent != null) {\n\t\t\t\t\t\t\t\tdelete parent[pathParts[pathParts.length - 1]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmodified.push(doc);\n\t\t\t\t}\n\t\t\t\tresults = modified;\n\t\t\t} else if (stageType === \"$sort\") {\n\t\t\t\t// Sort documents\n\t\t\t\tconst sortKeys = Object.keys(stageSpec);\n\t\t\t\tresults.sort(function (a, b) {\n\t\t\t\t\tfor (let k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\tconst key = sortKeys[k];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * stageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (stageType === \"$limit\") {\n\t\t\t\t// Limit number of documents\n\t\t\t\tresults = results.slice(0, stageSpec);\n\t\t\t} else if (stageType === \"$skip\") {\n\t\t\t\t// Skip documents\n\t\t\t\tresults = results.slice(stageSpec);\n\t\t\t} else if (stageType === \"$group\") {\n\t\t\t\t// Group documents\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = stageSpec._id;\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\t// Compute group key using expression evaluator\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = evaluateExpression(groupId, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\t// Initialize group\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\t// Process each accumulator field\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = stageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$min') {\n\t\t\t\t\t\t\tlet min = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (min === undefined || val < min)) {\n\t\t\t\t\t\t\t\t\tmin = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = min;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\t\t\t\tconst set = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (const valKey in set) {\n\t\t\t\t\t\t\t\tarr.push(set[valKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$first') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tresult[field] = evaluateExpression(accExpr, group.docs[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$last') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tresult[field] = evaluateExpression(accExpr, group.docs[group.docs.length - 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$stdDevPop') {\n\t\t\t\t\t\t\t// Population standard deviation\n\t\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (values.length > 0) {\n\t\t\t\t\t\t\t\tconst mean = values.reduce((a, b) => a + b, 0) / values.length;\n\t\t\t\t\t\t\t\tconst variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n\t\t\t\t\t\t\t\tresult[field] = Math.sqrt(variance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$stdDevSamp') {\n\t\t\t\t\t\t\t// Sample standard deviation\n\t\t\t\t\t\t\tconst values = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (values.length > 1) {\n\t\t\t\t\t\t\t\tconst mean = values.reduce((a, b) => a + b, 0) / values.length;\n\t\t\t\t\t\t\t\tconst variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (values.length - 1);\n\t\t\t\t\t\t\t\tresult[field] = Math.sqrt(variance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$mergeObjects') {\n\t\t\t\t\t\t\t// Merge objects from all documents in group\n\t\t\t\t\t\t\tconst merged = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[k]);\n\t\t\t\t\t\t\t\tif (typeof val === 'object' && val !== null && !Array.isArray(val)) {\n\t\t\t\t\t\t\t\t\tObject.assign(merged, val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = merged;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tresults = grouped;\n\t\t\t} else if (stageType === \"$count\") {\n\t\t\t\t// Count documents and return single document with count\n\t\t\t\tresults = [{ [stageSpec]: results.length }];\n\t\t\t} else if (stageType === \"$unwind\") {\n\t\t\t\t// Unwind array field\n\t\t\t\tconst unwound = [];\n\t\t\t\tlet fieldPath = stageSpec;\n\t\t\t\tif (typeof fieldPath === 'string' && fieldPath.charAt(0) === '$') {\n\t\t\t\t\tfieldPath = fieldPath.substring(1);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tconst arr = getProp(doc, fieldPath);\n\n\t\t\t\t\tif (arr && isArray(arr) && arr.length > 0) {\n\t\t\t\t\t\tfor (let k = 0; k < arr.length; k++) {\n\t\t\t\t\t\t\tconst unwoundDoc = copy(doc);\n\t\t\t\t\t\t\t// Set the unwound value\n\t\t\t\t\t\t\tconst parts = fieldPath.split('.');\n\t\t\t\t\t\t\tlet target = unwoundDoc;\n\t\t\t\t\t\t\tfor (let l = 0; l < parts.length - 1; l++) {\n\t\t\t\t\t\t\t\tif (!target[parts[l]]) {\n\t\t\t\t\t\t\t\t\ttarget[parts[l]] = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget = target[parts[l]];\n\t\t\t}\n\t\t\ttarget[parts[parts.length - 1]] = arr[k];\n\t\t\tunwound.push(unwoundDoc);\n\t\t}\n\t}\n\t// MongoDB's default behavior: skip documents where field is missing, null, empty array, or not an array\n}\nresults = unwound;\n} else if (stageType === \"$sortByCount\") {\n\t// Group by expression value and count occurrences, sorted descending by count\n\tconst groups = {};\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst value = evaluateExpression(stageSpec, doc);\n\t\tconst key = JSON.stringify(value);\n\t\t\n\t\tif (!groups[key]) {\n\t\t\tgroups[key] = {\n\t\t\t\t_id: value,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t}\n\t\tgroups[key].count++;\n\t}\n\t\n\t// Convert to array and sort by count descending\n\tresults = Object.values(groups).sort((a, b) => b.count - a.count);\n} else if (stageType === \"$replaceRoot\" || stageType === \"$replaceWith\") {\n\t// Replace root document with specified document\n\tconst modified = [];\n\tconst newRootSpec = stageType === \"$replaceRoot\" ? stageSpec.newRoot : stageSpec;\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst newRoot = evaluateExpression(newRootSpec, results[j]);\n\t\tif (typeof newRoot === 'object' && newRoot !== null && !Array.isArray(newRoot)) {\n\t\t\tmodified.push(newRoot);\n\t\t} else {\n\t\t\tthrow new QueryError('$replaceRoot expression must evaluate to an object', {\n\t\t\t\tcollection: this.name,\n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t});\n\t\t}\n\t}\n\tresults = modified;\n} else if (stageType === \"$sample\") {\n\t// Random sampling of documents\n\tconst size = stageSpec.size || 1;\n\tif (typeof size !== 'number' || size < 0) {\n\t\tthrow new QueryError('$sample size must be a non-negative number', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Shuffle using Fisher-Yates algorithm and take first 'size' elements\n\tconst shuffled = [...results];\n\tfor (let j = shuffled.length - 1; j > 0; j--) {\n\t\tconst k = Math.floor(Math.random() * (j + 1));\n\t\t[shuffled[j], shuffled[k]] = [shuffled[k], shuffled[j]];\n\t}\n\tresults = shuffled.slice(0, Math.min(size, shuffled.length));\n} else if (stageType === \"$bucket\") {\n\t// Categorize documents into buckets based on boundaries\n\tif (!stageSpec.groupBy || !stageSpec.boundaries) {\n\t\tthrow new QueryError('$bucket requires groupBy and boundaries', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst boundaries = stageSpec.boundaries;\n\tconst defaultBucket = stageSpec.default;\n\tconst output = stageSpec.output || { count: { $sum: 1 } };\n\t\n\t// Initialize buckets\n\tconst buckets = {};\n\tfor (let j = 0; j < boundaries.length - 1; j++) {\n\t\tconst key = JSON.stringify(boundaries[j]);\n\t\tbuckets[key] = {\n\t\t\t_id: boundaries[j],\n\t\t\tdocs: []\n\t\t};\n\t}\n\tif (defaultBucket !== undefined) {\n\t\tbuckets['default'] = {\n\t\t\t_id: defaultBucket,\n\t\t\tdocs: []\n\t\t};\n\t}\n\t\n\t// Categorize documents into buckets\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst value = evaluateExpression(stageSpec.groupBy, doc);\n\t\t\n\t\tlet placed = false;\n\t\tfor (let k = 0; k < boundaries.length - 1; k++) {\n\t\t\tif (value >= boundaries[k] && value < boundaries[k + 1]) {\n\t\t\t\tconst key = JSON.stringify(boundaries[k]);\n\t\t\t\tbuckets[key].docs.push(doc);\n\t\t\t\tplaced = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!placed && defaultBucket !== undefined) {\n\t\t\tbuckets['default'].docs.push(doc);\n\t\t}\n\t}\n\t\n\t// Apply output accumulators\n\tconst bucketed = [];\n\tfor (const bucketKey in buckets) {\n\t\tconst bucket = buckets[bucketKey];\n\t\tif (bucket.docs.length === 0) continue; // Skip empty buckets\n\t\t\n\t\tconst result = { _id: bucket._id };\n\t\t\n\t\tfor (const field in output) {\n\t\t\tconst accumulator = output[field];\n\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\n\t\t\tconst accType = accKeys[0];\n\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\n\t\t\t// Apply accumulator (reuse $group logic)\n\t\t\tif (accType === '$sum') {\n\t\t\t\tlet sum = 0;\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\tsum += val;\n\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[field] = sum;\n\t\t\t} else if (accType === '$avg') {\n\t\t\t\tlet sum = 0;\n\t\t\t\tlet count = 0;\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t} else if (accType === '$push') {\n\t\t\t\tconst arr = [];\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tarr.push(val);\n\t\t\t\t}\n\t\t\t\tresult[field] = arr;\n\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\tconst set = {};\n\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t}\n\t\t\t\tresult[field] = Object.values(set);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbucketed.push(result);\n\t}\n\t\n\t// Sort by _id (bucket boundary)\n\tresults = bucketed.sort((a, b) => {\n\t\tif (a._id < b._id) return -1;\n\t\tif (a._id > b._id) return 1;\n\t\treturn 0;\n\t});\n} else if (stageType === \"$bucketAuto\") {\n\t// Auto-calculate bucket boundaries and categorize documents\n\tif (!stageSpec.groupBy || !stageSpec.buckets) {\n\t\tthrow new QueryError('$bucketAuto requires groupBy and buckets', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst numBuckets = stageSpec.buckets;\n\tconst output = stageSpec.output || { count: { $sum: 1 } };\n\t\n\tif (results.length === 0) {\n\t\tresults = [];\n\t} else {\n\t\t// Extract and sort values\n\t\tconst values = results.map(doc => ({\n\t\t\tvalue: evaluateExpression(stageSpec.groupBy, doc),\n\t\t\tdoc: doc\n\t\t})).sort((a, b) => {\n\t\t\tif (a.value < b.value) return -1;\n\t\t\tif (a.value > b.value) return 1;\n\t\t\treturn 0;\n\t\t});\n\t\t\n\t\t// Calculate bucket size\n\t\tconst bucketSize = Math.ceil(values.length / numBuckets);\n\t\tconst buckets = [];\n\t\t\n\t\tfor (let j = 0; j < numBuckets && j * bucketSize < values.length; j++) {\n\t\t\tconst startIdx = j * bucketSize;\n\t\t\tconst endIdx = Math.min((j + 1) * bucketSize, values.length);\n\t\t\tconst bucketDocs = values.slice(startIdx, endIdx);\n\t\t\t\n\t\t\tif (bucketDocs.length === 0) continue;\n\t\t\t\n\t\t\tconst bucket = {\n\t\t\t\t_id: {\n\t\t\t\t\tmin: bucketDocs[0].value,\n\t\t\t\t\tmax: endIdx < values.length ? bucketDocs[bucketDocs.length - 1].value : bucketDocs[bucketDocs.length - 1].value\n\t\t\t\t},\n\t\t\t\tdocs: bucketDocs.map(v => v.doc)\n\t\t\t};\n\t\t\tbuckets.push(bucket);\n\t\t}\n\t\t\n\t\t// Apply output accumulators\n\t\tconst bucketed = [];\n\t\tfor (let j = 0; j < buckets.length; j++) {\n\t\t\tconst bucket = buckets[j];\n\t\t\tconst result = { _id: bucket._id };\n\t\t\t\n\t\t\tfor (const field in output) {\n\t\t\t\tconst accumulator = output[field];\n\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\t\n\t\t\t\tconst accType = accKeys[0];\n\t\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\t\n\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = sum;\n\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\tconst arr = [];\n\t\t\t\t\tfor (let k = 0; k < bucket.docs.length; k++) {\n\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[k]);\n\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t}\n\t\t\t\t\tresult[field] = arr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbucketed.push(result);\n\t\t}\n\t\t\n\t\tresults = bucketed;\n\t}\n} else if (stageType === \"$out\") {\n\t// Output results to a collection (replaces existing collection)\n\tconst targetCollectionName = stageSpec;\n\t\n\tif (typeof targetCollectionName !== 'string') {\n\t\tthrow new QueryError('$out requires a string collection name', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Drop and recreate target collection\n\tif (this.db[targetCollectionName]) {\n\t\tthis.db.dropCollection(targetCollectionName);\n\t}\n\tthis.db.createCollection(targetCollectionName);\n\t\n\tconst targetCollection = this.db[targetCollectionName];\n\t\n\t// Insert all results into target collection\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst docId = doc._id;\n\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\ttargetCollection.storage.set(key, doc);\n\t}\n\t\n\t// $out returns empty results (MongoDB behavior)\n\tresults = [];\n} else if (stageType === \"$merge\") {\n\t// Merge results into a collection (MongoDB 4.2+)\n\tlet targetCollectionName;\n\tlet on = '_id';\n\tlet whenMatched = 'merge';\n\tlet whenNotMatched = 'insert';\n\t\n\tif (typeof stageSpec === 'string') {\n\t\ttargetCollectionName = stageSpec;\n\t} else if (typeof stageSpec === 'object') {\n\t\ttargetCollectionName = stageSpec.into;\n\t\ton = stageSpec.on || on;\n\t\twhenMatched = stageSpec.whenMatched || whenMatched;\n\t\twhenNotMatched = stageSpec.whenNotMatched || whenNotMatched;\n\t}\n\t\n\tif (!targetCollectionName) {\n\t\tthrow new QueryError('$merge requires a target collection', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Create target collection if it doesn't exist\n\tif (!this.db[targetCollectionName]) {\n\t\tthis.db.createCollection(targetCollectionName);\n\t}\n\t\n\tconst targetCollection = this.db[targetCollectionName];\n\t\n\t// Merge documents\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst matchField = typeof on === 'string' ? on : on[0];\n\t\tconst matchValue = getProp(doc, matchField);\n\t\t\n\t\t// Find existing document\n\t\tconst existingCursor = targetCollection.find({ [matchField]: matchValue });\n\t\tconst existing = existingCursor.hasNext() ? existingCursor.next() : null;\n\t\t\n\t\tif (existing) {\n\t\t\tif (whenMatched === 'replace') {\n\t\t\t\tconst docId = doc._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, doc);\n\t\t\t} else if (whenMatched === 'merge') {\n\t\t\t\tconst merged = Object.assign({}, existing, doc);\n\t\t\t\tconst docId = merged._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, merged);\n\t\t\t} else if (whenMatched === 'keepExisting') {\n\t\t\t\t// Do nothing\n\t\t\t} else if (whenMatched === 'fail') {\n\t\t\t\tthrow new QueryError('$merge failed: duplicate key', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.DUPLICATE_KEY\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (whenNotMatched === 'insert') {\n\t\t\t\tconst docId = doc._id;\n\t\t\t\tconst key = (typeof docId === 'object' && docId.toString) ? docId.toString() : String(docId);\n\t\t\t\ttargetCollection.storage.set(key, doc);\n\t\t\t} else if (whenNotMatched === 'discard') {\n\t\t\t\t// Do nothing\n\t\t\t} else if (whenNotMatched === 'fail') {\n\t\t\t\tthrow new QueryError('$merge failed: document not found', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// $merge returns empty results (MongoDB behavior)\n\tresults = [];\n} else if (stageType === \"$lookup\") {\n\t// Left outer join with another collection\n\tif (!stageSpec.from || !stageSpec.localField || !stageSpec.foreignField || !stageSpec.as) {\n\t\tthrow new QueryError('$lookup requires from, localField, foreignField, and as', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Check if collection exists without triggering auto-creation\n\tconst collectionNames = this.db.getCollectionNames();\n\tif (!collectionNames.includes(stageSpec.from)) {\n\t\tthrow new QueryError('$lookup: collection not found: ' + stageSpec.from, {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t}\n\t\n\tconst fromCollection = this.db[stageSpec.from];\n\t\n\tconst joined = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst localValue = getProp(doc, stageSpec.localField);\n\t\t\n\t\t// Find matching documents in foreign collection\n\t\tconst matches = [];\n\t\tconst foreignCursor = fromCollection.find({ [stageSpec.foreignField]: localValue });\n\t\twhile (foreignCursor.hasNext()) {\n\t\t\tmatches.push(foreignCursor.next());\n\t\t}\n\t\t\n\t\tdoc[stageSpec.as] = matches;\n\t\tjoined.push(doc);\n\t}\n\tresults = joined;\n} else if (stageType === \"$graphLookup\") {\n\t// Recursive graph lookup\n\tif (!stageSpec.from || !stageSpec.startWith || !stageSpec.connectFromField || \n\t    !stageSpec.connectToField || !stageSpec.as) {\n\t\tthrow new QueryError('$graphLookup requires from, startWith, connectFromField, connectToField, and as', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\t// Check if collection exists without triggering auto-creation\n\tconst collectionNames = this.db.getCollectionNames();\n\tif (!collectionNames.includes(stageSpec.from)) {\n\t\tthrow new QueryError('$graphLookup: collection not found: ' + stageSpec.from, {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.NAMESPACE_NOT_FOUND\n\t\t});\n\t}\n\t\n\tconst fromCollection = this.db[stageSpec.from];\n\t\n\tconst maxDepth = stageSpec.maxDepth !== undefined ? stageSpec.maxDepth : Number.MAX_SAFE_INTEGER;\n\tconst depthField = stageSpec.depthField;\n\tconst restrictSearchWithMatch = stageSpec.restrictSearchWithMatch;\n\t\n\tconst graphed = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst startValue = evaluateExpression(stageSpec.startWith, results[j]);\n\t\t\n\t\t// Recursive lookup\n\t\tconst visited = new Set();\n\t\tconst matches = [];\n\t\tconst queue = [{ value: startValue, depth: 0 }];\n\t\t\n\t\twhile (queue.length > 0) {\n\t\t\tconst { value, depth } = queue.shift();\n\t\t\tif (depth > maxDepth) continue;\n\t\t\t\n\t\t\tconst valueKey = JSON.stringify(value);\n\t\t\tif (visited.has(valueKey)) continue;\n\t\t\tvisited.add(valueKey);\n\t\t\t\n\t\t\t// Find matching documents\n\t\t\tlet query = { [stageSpec.connectToField]: value };\n\t\t\tif (restrictSearchWithMatch) {\n\t\t\t\tquery = { $and: [query, restrictSearchWithMatch] };\n\t\t\t}\n\t\t\t\n\t\t\tconst cursor = fromCollection.find(query);\n\t\t\twhile (cursor.hasNext()) {\n\t\t\t\tconst match = cursor.next();\n\t\t\t\tconst matchCopy = copy(match);\n\t\t\t\t\n\t\t\t\tif (depthField) {\n\t\t\t\t\tmatchCopy[depthField] = depth;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmatches.push(matchCopy);\n\t\t\t\t\n\t\t\t\t// Add connected value to queue for next iteration\n\t\t\t\tconst nextValue = getProp(match, stageSpec.connectFromField);\n\t\t\t\tif (nextValue !== undefined && nextValue !== null) {\n\t\t\t\t\tqueue.push({ value: nextValue, depth: depth + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdoc[stageSpec.as] = matches;\n\t\tgraphed.push(doc);\n\t}\n\tresults = graphed;\n} else if (stageType === \"$facet\") {\n\t// Multiple parallel pipelines\n\tif (typeof stageSpec !== 'object' || Array.isArray(stageSpec)) {\n\t\tthrow new QueryError('$facet requires an object with pipeline definitions', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst facetResult = {};\n\t\n\tfor (const facetName in stageSpec) {\n\t\tconst facetPipeline = stageSpec[facetName];\n\t\t\n\t\tif (!Array.isArray(facetPipeline)) {\n\t\t\tthrow new QueryError('$facet pipeline must be an array', {\n\t\t\t\tcollection: this.name,\n\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t});\n\t\t}\n\t\t\n\t\t// Execute the sub-pipeline on a copy of current results\n\t\tlet facetResults = results.map(r => copy(r));\n\t\t\n\t\tfor (let k = 0; k < facetPipeline.length; k++) {\n\t\t\tconst facetStage = facetPipeline[k];\n\t\t\tconst facetStageKeys = Object.keys(facetStage);\n\t\t\tif (facetStageKeys.length !== 1) {\n\t\t\t\tthrow new QueryError('Each pipeline stage must have exactly one key', {\n\t\t\t\t\tcollection: this.name,\n\t\t\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tconst facetStageType = facetStageKeys[0];\n\t\t\tconst facetStageSpec = facetStage[facetStageType];\n\t\t\t\n\t\t\t// Process facet stage (recursive call to aggregation logic)\n\t\t\t// We need to inline the stage processing here\n\t\t\tif (facetStageType === \"$match\") {\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tif (matches(facetResults[m], facetStageSpec)) {\n\t\t\t\t\t\tmatched.push(facetResults[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfacetResults = matched;\n\t\t\t} else if (facetStageType === \"$project\") {\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tprojected.push(applyProjectionWithExpressions(facetStageSpec, facetResults[m]));\n\t\t\t\t}\n\t\t\t\tfacetResults = projected;\n\t\t\t} else if (facetStageType === \"$limit\") {\n\t\t\t\tfacetResults = facetResults.slice(0, facetStageSpec);\n\t\t\t} else if (facetStageType === \"$skip\") {\n\t\t\t\tfacetResults = facetResults.slice(facetStageSpec);\n\t\t\t} else if (facetStageType === \"$sort\") {\n\t\t\t\tconst sortKeys = Object.keys(facetStageSpec);\n\t\t\t\tfacetResults.sort(function (a, b) {\n\t\t\t\t\tfor (let n = 0; n < sortKeys.length; n++) {\n\t\t\t\t\t\tconst key = sortKeys[n];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * facetStageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * facetStageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (facetStageType === \"$count\") {\n\t\t\t\tfacetResults = [{ [facetStageSpec]: facetResults.length }];\n\t\t\t} else if (facetStageType === \"$group\") {\n\t\t\t\t// Handle $group in facet sub-pipelines\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = facetStageSpec._id;\n\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = evaluateExpression(groupId, doc);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators (simplified version)\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\tfor (const field in facetStageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = facetStageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let n = 0; n < group.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, group.docs[n]);\n\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tfacetResults = grouped;\n\t\t\t} else if (facetStageType === \"$sortByCount\") {\n\t\t\t\t// Handle $sortByCount in facet sub-pipelines\n\t\t\t\tconst groups = {};\n\t\t\t\t\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tconst value = evaluateExpression(facetStageSpec, doc);\n\t\t\t\t\tconst key = JSON.stringify(value);\n\t\t\t\t\t\n\t\t\t\t\tif (!groups[key]) {\n\t\t\t\t\t\tgroups[key] = {\n\t\t\t\t\t\t\t_id: value,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tgroups[key].count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfacetResults = Object.values(groups).sort((a, b) => b.count - a.count);\n\t\t\t} else if (facetStageType === \"$sample\") {\n\t\t\t\t// Handle $sample in facet sub-pipelines\n\t\t\t\tconst size = facetStageSpec.size || 1;\n\t\t\t\tconst shuffled = [...facetResults];\n\t\t\t\tfor (let m = shuffled.length - 1; m > 0; m--) {\n\t\t\t\t\tconst k = Math.floor(Math.random() * (m + 1));\n\t\t\t\t\t[shuffled[m], shuffled[k]] = [shuffled[k], shuffled[m]];\n\t\t\t\t}\n\t\t\t\tfacetResults = shuffled.slice(0, Math.min(size, shuffled.length));\n\t\t\t} else if (facetStageType === \"$bucket\") {\n\t\t\t\t// Handle $bucket in facet sub-pipelines\n\t\t\t\tconst boundaries = facetStageSpec.boundaries;\n\t\t\t\tconst defaultBucket = facetStageSpec.default;\n\t\t\t\tconst output = facetStageSpec.output || { count: { $sum: 1 } };\n\t\t\t\t\n\t\t\t\tconst buckets = {};\n\t\t\t\tfor (let m = 0; m < boundaries.length - 1; m++) {\n\t\t\t\t\tconst key = JSON.stringify(boundaries[m]);\n\t\t\t\t\tbuckets[key] = {\n\t\t\t\t\t\t_id: boundaries[m],\n\t\t\t\t\t\tdocs: []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (defaultBucket !== undefined) {\n\t\t\t\t\tbuckets['default'] = {\n\t\t\t\t\t\t_id: defaultBucket,\n\t\t\t\t\t\tdocs: []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Categorize documents\n\t\t\t\tfor (let m = 0; m < facetResults.length; m++) {\n\t\t\t\t\tconst doc = facetResults[m];\n\t\t\t\t\tconst value = evaluateExpression(facetStageSpec.groupBy, doc);\n\t\t\t\t\t\n\t\t\t\t\tlet placed = false;\n\t\t\t\t\tfor (let n = 0; n < boundaries.length - 1; n++) {\n\t\t\t\t\t\tif (value >= boundaries[n] && value < boundaries[n + 1]) {\n\t\t\t\t\t\t\tconst key = JSON.stringify(boundaries[n]);\n\t\t\t\t\t\t\tbuckets[key].docs.push(doc);\n\t\t\t\t\t\t\tplaced = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!placed && defaultBucket !== undefined) {\n\t\t\t\t\t\tbuckets['default'].docs.push(doc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst bucketed = [];\n\t\t\t\tfor (const bucketKey in buckets) {\n\t\t\t\t\tconst bucket = buckets[bucketKey];\n\t\t\t\t\tif (bucket.docs.length === 0) continue;\n\t\t\t\t\t\n\t\t\t\t\tconst result = { _id: bucket._id };\n\t\t\t\t\t\n\t\t\t\t\tfor (const field in output) {\n\t\t\t\t\t\tconst accumulator = output[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let n = 0; n < bucket.docs.length; n++) {\n\t\t\t\t\t\t\t\tconst val = evaluateExpression(accExpr, bucket.docs[n]);\n\t\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t} else if (val !== null && val !== undefined) {\n\t\t\t\t\t\t\t\t\tsum += Number(val) || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbucketed.push(result);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfacetResults = bucketed.sort((a, b) => {\n\t\t\t\t\tif (a._id < b._id) return -1;\n\t\t\t\t\tif (a._id > b._id) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add more stage types as needed for facet sub-pipelines\n\t\t}\n\t\t\n\t\tfacetResult[facetName] = facetResults;\n\t}\n\t\n\tresults = [facetResult];\n} else if (stageType === \"$redact\") {\n\t// Conditionally filter or redact document content\n\tconst redacted = [];\n\t\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = results[j];\n\t\tconst decision = evaluateExpression(stageSpec, doc);\n\t\t\n\t\tif (decision === '$$DESCEND') {\n\t\t\t// Include document and recurse into subdocuments (simplified: just include)\n\t\t\tredacted.push(doc);\n\t\t} else if (decision === '$$PRUNE') {\n\t\t\t// Exclude this document\n\t\t\tcontinue;\n\t\t} else if (decision === '$$KEEP') {\n\t\t\t// Include this document\n\t\t\tredacted.push(doc);\n\t\t} else {\n\t\t\t// If result is a conditional expression, evaluate it\n\t\t\tif (decision) {\n\t\t\t\tredacted.push(doc);\n\t\t\t}\n\t\t}\n\t}\n\tresults = redacted;\n} else if (stageType === \"$geoNear\") {\n\t// Geospatial aggregation with distance calculation\n\tif (!stageSpec.near || !stageSpec.distanceField) {\n\t\tthrow new QueryError('$geoNear requires near and distanceField', {\n\t\t\tcollection: this.name,\n\t\t\tcode: ErrorCodes.FAILED_TO_PARSE\n\t\t});\n\t}\n\t\n\tconst near = stageSpec.near;\n\tconst distanceField = stageSpec.distanceField;\n\tconst maxDistance = stageSpec.maxDistance;\n\tconst minDistance = stageSpec.minDistance || 0;\n\tconst spherical = stageSpec.spherical !== false;\n\tconst key = stageSpec.key || 'location';\n\t\n\t// Calculate distance for each document\n\tconst withDistances = [];\n\tfor (let j = 0; j < results.length; j++) {\n\t\tconst doc = copy(results[j]);\n\t\tconst location = getProp(doc, key);\n\t\t\n\t\tif (!location || !Array.isArray(location) || location.length < 2) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Calculate distance (using Haversine formula for spherical or Euclidean for planar)\n\t\tlet distance;\n\t\tif (spherical) {\n\t\t\t// Haversine formula for great circle distance\n\t\t\tconst R = 6371000; // Earth radius in meters\n\t\t\tconst lat1 = near[1] * Math.PI / 180;\n\t\t\tconst lat2 = location[1] * Math.PI / 180;\n\t\t\tconst deltaLat = (location[1] - near[1]) * Math.PI / 180;\n\t\t\tconst deltaLon = (location[0] - near[0]) * Math.PI / 180;\n\t\t\t\n\t\t\tconst a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\n\t\t\t          Math.cos(lat1) * Math.cos(lat2) *\n\t\t\t          Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n\t\t\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\t\tdistance = R * c;\n\t\t} else {\n\t\t\t// Euclidean distance\n\t\t\tconst dx = location[0] - near[0];\n\t\t\tconst dy = location[1] - near[1];\n\t\t\tdistance = Math.sqrt(dx * dx + dy * dy);\n\t\t}\n\t\t\n\t\t// Filter by distance\n\t\tif (distance >= minDistance && (!maxDistance || distance <= maxDistance)) {\n\t\t\tdoc[distanceField] = distance;\n\t\t\twithDistances.push(doc);\n\t\t}\n\t}\n\t\n\t// Sort by distance (nearest first)\n\twithDistances.sort((a, b) => a[distanceField] - b[distanceField]);\n\t\n\t// Apply limit if specified\n\tif (stageSpec.limit) {\n\t\tresults = withDistances.slice(0, stageSpec.limit);\n\t} else {\n\t\tresults = withDistances;\n\t}\n} else {\n\tthrow new QueryError('Unsupported aggregation stage: ' + stageType, { \n\t\tcollection: this.name, \n\t\tcode: ErrorCodes.FAILED_TO_PARSE \n\t});\n}\n}\n\nreturn results;\n}\tbulkWrite() { throw new NotImplementedError('bulkWrite', { collection: this.name }); }\n\n\tasync count() {\n\t\treturn this.storage.size();\n\t}\n\n\tasync copyTo(destCollectionName) {\n\t\tif (!this.db[destCollectionName]) {\n\t\t\tthis.db.createCollection(destCollectionName);\n\t\t}\n\t\tconst destCol = this.db[destCollectionName];\n\t\tlet numCopied = 0;\n\t\tconst c = this.find({});\n\t\twhile (c.hasNext()) {\n\t\t\tawait destCol.insertOne(c.next());\n\t\t\tnumCopied++;\n\t\t}\n\t\treturn numCopied;\n\t}\n\n\tasync createIndex(keys, options) {\n\t\t// MongoDB-compliant createIndex\n\t\t// keys: { fieldName: 1 } for ascending, { fieldName: -1 } for descending, { fieldName: 'text' } for text\n\t\t// options: { name: \"indexName\", unique: true, ... }\n\n\t\tif (!keys || typeof keys !== 'object' || Array.isArray(keys)) {\n\t\t\tthrow new BadValueError('keys', keys, 'createIndex requires a key specification object', { \n\t\t\t\tcollection: this.name \n\t\t\t});\n\t\t}\n\n\t\tconst indexName = (options && options.name) ? options.name : this.generateIndexName(keys);\n\n\t\t// Check if index already exists\n\t\tif (this.indexes.has(indexName)) {\n\t\t\t// MongoDB checks for key specification conflicts\n\t\t\tconst existingIndex = this.indexes.get(indexName);\n\t\t\tconst existingKeys = JSON.stringify(existingIndex.keys);\n\t\t\tconst newKeys = JSON.stringify(keys);\n\t\t\tif (existingKeys !== newKeys) {\n\t\t\t\tthrow new IndexError(\n\t\t\t\t\t\"Index with name '\" + indexName + \"' already exists with a different key specification\", \n\t\t\t\t\t{ \n\t\t\t\t\t\tcode: ErrorCodes.INDEX_OPTIONS_CONFLICT,\n\t\t\t\t\t\tindex: indexName, \n\t\t\t\t\t\tcollection: this.name \n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Same index, return without error\n\t\t\treturn indexName;\n\t\t}\n\n\t\t// Build the index\n\t\tthis.buildIndex(indexName, keys, options);\n\n\t\treturn indexName;\n\t}\n\n\tdataSize() { throw new NotImplementedError('dataSize', { collection: this.name }); }\n\n\tasync deleteOne(query) {\n\t\tconst doc = await this.findOne(query);\n\t\tif (doc) {\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id.toString());\n\t\t\tthis.emit('delete', { _id: doc._id });\n\t\t\treturn { deletedCount: 1 };\n\t\t} else {\n\t\t\treturn { deletedCount: 0 };\n\t\t}\n\t}\n\n\tasync deleteMany(query) {\n\t\tconst c = this.find(query);\n\t\tconst ids = [];\n\t\tconst docs = [];\n\t\twhile (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tids.push(doc._id);\n\t\t\tdocs.push(doc);\n\t\t}\n\t\tconst deletedCount = ids.length;\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tthis.updateIndexesOnDelete(docs[i]);\n\t\t\tthis.storage.remove(ids[i].toString());\n\t\t\tthis.emit('delete', { _id: ids[i] });\n\t\t}\n\t\treturn { deletedCount: deletedCount };\n\t}\n\n\tasync distinct(field, query) {\n\t\tconst vals = {};\n\t\tconst c = this.find(query);\n\t\twhile (c.hasNext()) {\n\t\t\tconst d = c.next();\n\t\t\tif (d[field]) {\n\t\t\t\tvals[d[field]] = true;\n\t\t\t}\n\t\t}\n\t\treturn Object.keys(vals);\n\t}\n\n\tdrop() {\n\t\t// Clear all indexes\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tindex.clear();\n\t\t}\n\t\tthis.storage.clear();\n\t}\n\n\tdropIndex(indexName) {\n\t\tif (!this.indexes.has(indexName)) {\n\t\t\tthrow new IndexNotFoundError(indexName, { collection: this.name });\n\t\t}\n\t\tthis.indexes.get(indexName).clear();\n\t\tthis.indexes.delete(indexName);\n\t\treturn { nIndexesWas: this.indexes.size + 1, ok: 1 };\n\t}\n\n\tdropIndexes() {\n\t\tconst count = this.indexes.size;\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tindex.clear();\n\t\t}\n\t\tthis.indexes.clear();\n\t\treturn { nIndexesWas: count, msg: \"non-_id indexes dropped\", ok: 1 };\n\t}\n\tensureIndex() { throw new NotImplementedError('ensureIndex', { collection: this.name }); }\n\texplain() { throw new NotImplementedError('explain', { collection: this.name }); }\n\n\tfind(query, projection) {\n\t\tconst normalizedQuery = query == undefined ? {} : query;\n\t\t\n\t\t// Get query plan\n\t\tconst queryPlan = this.planQuery(normalizedQuery);\n\t\tconst documents = [];\n\t\tconst seen = {}; // Track which docs we've seen to avoid duplicates\n\t\t\n\t\t// If using index, get documents by ID\n\t\tif (queryPlan.useIndex && queryPlan.docIds) {\n\t\t\tfor (const docId of queryPlan.docIds) {\n\t\t\t\tconst doc = this.storage.get(docId.toString());\n\t\t\t\tif (doc && matches(doc, normalizedQuery)) {\n\t\t\t\t\tseen[doc._id] = true;\n\t\t\t\t\tdocuments.push(doc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If not index-only query, do full scan for remaining documents\n\t\t// This handles complex queries where index only partially matches\n\t\tif (!queryPlan.indexOnly) {\n\t\t\tconst allDocs = this.storage.getAllDocuments();\n\t\t\tfor (const doc of allDocs) {\n\t\t\t\tif (!seen[doc._id] && matches(doc, normalizedQuery)) {\n\t\t\t\t\tseen[doc._id] = true;\n\t\t\t\t\tdocuments.push(doc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new Cursor(\n\t\t\tthis,\n\t\t\tnormalizedQuery,\n\t\t\tprojection,\n\t\t\tdocuments,\n\t\t\tSortedCursor\n\t\t);\n\t}\n\n\tfindAndModify() { throw new NotImplementedError('findAndModify', { collection: this.name }); }\n\n\tasync findOne(query, projection) {\n\t\tconst cursor = this.find(query, projection);\n\t\tif (cursor.hasNext()) {\n\t\t\treturn cursor.next();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync findOneAndDelete(filter, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tthis.storage.remove(doc._id.toString());\n\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\telse return doc;\n\t}\n\n\tasync findOneAndReplace(filter, replacement, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\treplacement._id = doc._id;\n\t\tthis.storage.set(doc._id.toString(), replacement);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, replacement);\n\t\t\telse return replacement;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tasync findOneAndUpdate(filter, update, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tconst clone = Object.assign({}, doc);\n\t\t\n\t\t// Get array filter information for positional operator support\n\t\tconst matchInfo = matchWithArrayIndices(doc, filter);\n\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\n\t\tapplyUpdates(update, clone, false, positionalMatchInfo, userArrayFilters);\n\t\tthis.storage.set(doc._id.toString(), clone);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, clone);\n\t\t\telse return clone;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tgetIndexes() {\n\t\t// Return array of index specifications\n\t\tconst result = [];\n\t\tfor (const [indexName, index] of this.indexes) {\n\t\t\tresult.push(index.getSpec());\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetShardDistribution() { throw new NotImplementedError('getShardDistribution', { collection: this.name }); }\n\tgetShardVersion() { throw new NotImplementedError('getShardVersion', { collection: this.name }); }\n\n\t// non-mongo\n\tgetStore() {\n\t\treturn this.storage.getStore();\n\t}\n\n\tgroup() { throw new NotImplementedError('group', { collection: this.name }); }\n\n\tasync insert(doc) {\n\t\tif (Array == doc.constructor) {\n\t\t\treturn await this.insertMany(doc);\n\t\t} else {\n\t\t\treturn await this.insertOne(doc);\n\t\t}\n\t}\n\n\tasync insertOne(doc) {\n\t\tif (doc._id == undefined) doc._id = this.idGenerator();\n\t\tthis.storage.set(doc._id.toString(), doc);\n\t\tthis.updateIndexesOnInsert(doc);\n\t\tthis.emit('insert', doc);\n\t\treturn { insertedId: doc._id };\n\t}\n\n\tasync insertMany(docs) {\n\t\tconst insertedIds = [];\n\t\tfor (let i = 0; i < docs.length; i++) {\n\t\t\tconst result = await this.insertOne(docs[i]);\n\t\t\tinsertedIds.push(result.insertedId);\n\t\t}\n\t\treturn { insertedIds: insertedIds };\n\t}\n\n\tisCapped() { throw new NotImplementedError('isCapped', { collection: this.name }); }\n\tmapReduce() { throw new NotImplementedError('mapReduce', { collection: this.name }); }\n\treIndex() { throw new NotImplementedError('reIndex', { collection: this.name }); }\n\n\tasync replaceOne(query, replacement, options) { // only replace\n\t\t// first\n\t\tconst result = {};\n\t\tconst c = this.find(query);\n\t\tresult.matchedCount = c.count();\n\t\tif (result.matchedCount == 0) {\n\t\t\tresult.modifiedCount = 0;\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = replacement;\n\t\t\t\tnewDoc._id = this.idGenerator();\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t\tresult.upsertedId = newDoc._id;\n\t\t\t}\n\t\t} else {\n\t\t\tresult.modifiedCount = 1;\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\treplacement._id = doc._id;\n\t\t\tthis.storage.set(doc._id.toString(), replacement);\n\t\t\tthis.updateIndexesOnInsert(replacement);\n\t\t\tthis.emit('replace', replacement);\n\t\t}\n\t\treturn result;\n\t}\n\n\tremove(query, options) {\n\t\tconst c = this.find(query);\n\t\tif (!c.hasNext()) return;\n\t\tif (options === true || (options && options.justOne)) {\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id.toString());\n\t\t} else {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tthis.storage.remove(doc._id.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\trenameCollection() { throw new NotImplementedError('renameCollection', { collection: this.name }); }\n\tsave() { throw new NotImplementedError('save', { collection: this.name }); }\n\tstats() { throw new NotImplementedError('stats', { collection: this.name }); }\n\tstorageSize() { throw new NotImplementedError('storageSize', { collection: this.name }); }\n\ttotalSize() { throw new NotImplementedError('totalSize', { collection: this.name }); }\n\ttotalIndexSize() { throw new NotImplementedError('totalIndexSize', { collection: this.name }); }\n\n\tupdate(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tif (options && options.multi) {\n\t\t\t\twhile (c.hasNext()) {\n\t\t\t\t\tconst doc = c.next();\n\t\t\t\t\t\n\t\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\t\n\t\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst doc = c.next();\n\t\t\t\t\n\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateOne(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tconst originalDoc = JSON.parse(JSON.stringify(doc));\n\t\t\t\n\t\t\t// Get array filter information for positional operator support\n\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\tconst updateDescription = this._getUpdateDescription(originalDoc, doc);\n\t\t\tthis.emit('update', doc, updateDescription);\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateMany(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tconst originalDoc = JSON.parse(JSON.stringify(doc));\n\t\t\t\t\n\t\t\t\t// Get array filter information for positional operator support\n\t\t\t\tconst matchInfo = matchWithArrayIndices(doc, query);\n\t\t\t\tconst positionalMatchInfo = matchInfo.arrayFilters;\n\t\t\t\tconst userArrayFilters = options && options.arrayFilters;\n\t\t\t\t\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc, false, positionalMatchInfo, userArrayFilters);\n\t\t\t\tthis.storage.set(doc._id.toString(), doc);\n\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t\tconst updateDescription = this._getUpdateDescription(originalDoc, doc);\n\t\t\t\tthis.emit('update', doc, updateDescription);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id.toString(), newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t\tthis.emit('insert', newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidate() { throw new NotImplementedError('validate', { collection: this.name }); }\n\n\t/**\n\t * Generate updateDescription for change events\n\t * Compares original and updated documents to track changes\n\t */\n\t_getUpdateDescription(originalDoc, updatedDoc) {\n\t\tconst updatedFields = {};\n\t\tconst removedFields = [];\n\n\t\t// Find updated and new fields\n\t\tfor (const key in updatedDoc) {\n\t\t\tif (key === '_id') continue;\n\t\t\tif (JSON.stringify(originalDoc[key]) !== JSON.stringify(updatedDoc[key])) {\n\t\t\t\tupdatedFields[key] = updatedDoc[key];\n\t\t\t}\n\t\t}\n\n\t\t// Find removed fields\n\t\tfor (const key in originalDoc) {\n\t\t\tif (key === '_id') continue;\n\t\t\tif (!(key in updatedDoc)) {\n\t\t\t\tremovedFields.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tupdatedFields,\n\t\t\tremovedFields,\n\t\t\ttruncatedArrays: [] // Not implemented in micro-mongo\n\t\t};\n\t}\n\n\t/**\n\t * Watch for changes to this collection\n\t * @param {Array} pipeline - Aggregation pipeline to filter changes\n\t * @param {Object} options - Watch options (fullDocument, etc.)\n\t * @returns {ChangeStream} A change stream instance\n\t */\n\twatch(pipeline = [], options = {}) {\n\t\treturn new ChangeStream(this, pipeline, options);\n\t}\n\n}\n\n/**\n * Apply projection with expression support\n * Enhanced version of applyProjection that supports computed expressions\n */\nfunction applyProjectionWithExpressions(projection, doc) {\n\tconst result = {};\n\tconst keys = Object.keys(projection);\n\t\n\t// Check if this is an inclusion or exclusion projection\n\tlet isInclusion = false;\n\tlet isExclusion = false;\n\tlet hasComputedFields = false;\n\t\n\tfor (const key of keys) {\n\t\tif (key === '_id') continue;\n\t\tconst value = projection[key];\n\t\t\n\t\tif (value === 1 || value === true) {\n\t\t\tisInclusion = true;\n\t\t} else if (value === 0 || value === false) {\n\t\t\tisExclusion = true;\n\t\t} else {\n\t\t\t// Computed field (expression)\n\t\t\thasComputedFields = true;\n\t\t}\n\t}\n\t\n\t// Handle computed fields - they imply inclusion mode\n\tif (hasComputedFields || isInclusion) {\n\t\t// Inclusion mode: only include specified fields\n\t\t// Always include _id unless explicitly excluded\n\t\tif (projection._id !== 0 && projection._id !== false) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tconst value = projection[key];\n\t\t\t\n\t\t\tif (key === '_id') {\n\t\t\t\tif (value === 0 || value === false) {\n\t\t\t\t\tdelete result._id;\n\t\t\t\t}\n\t\t\t} else if (value === 1 || value === true) {\n\t\t\t\t// Simple field inclusion\n\t\t\t\tresult[key] = getProp(doc, key);\n\t\t\t} else {\n\t\t\t\t// Computed field (expression)\n\t\t\t\tresult[key] = evaluateExpression(value, doc);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Exclusion mode: include all fields except specified ones\n\t\tfor (const key in doc) {\n\t\t\tif (doc.hasOwnProperty(key)) {\n\t\t\t\tresult[key] = doc[key];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tif (projection[key] === 0 || projection[key] === false) {\n\t\t\t\tdelete result[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\n","/**\n * DocumentStore - In-memory document storage for collections\n * Simple key-value store using a plain JavaScript object\n */\nexport class DocumentStore {\n\tconstructor() {\n\t\tthis.data = new Map();\n\t}\n\n\tclear() {\n\t\tthis.data = new Map();\n\t}\n\n  keys() {\n    return this.data.keys();\n  }\n\n\tget(index) {\n\t\treturn this.data.get(index);\n\t}\n\n\tremove(key) {\n\t\tthis.data.delete(key);\n\t}\n\n\tset(key, value) {\n\t\tthis.data.set(key, value);\n\t}\n\n\tsize() {\n\t\treturn this.data.size;\n\t}\n}\n","import { DocumentStore } from './DocumentStore.js';\nimport { IndexStore } from './IndexStore.js';\n\n/**\n * CollectionStore - Unified storage for collection documents and indexes\n * \n * Provides:\n * - Document storage (via DocumentStore)\n * - Index data storage (plain objects for each index)\n * - Unified interface for Collection to manage all its data\n */\nexport class CollectionStore {\n\tconstructor() {\n\n\t\t// Document storage - uses DocumentStore for document CRUD operations\n\t\tthis.documents = new DocumentStore();\n\t\t\n\t\t// Index storage - plain object to store index data\n\t\t// Structure: { indexName: indexDataObject }\n\t\tthis.indexes = new Map();\n\t}\n\n\t/**\n\t * Clear all documents and indexes\n\t */\n\tclear() {\n\t\tthis.documents.clear();\n    this.indexes.clear();\n\t}\n\n  /**\n   * Get all document keys\n   * @returns {[string]} Array of document keys\n   */\n  documentKeys() {\n    return this.documents.keys();\n  }\n\n\t/**\n\t * Get all documents as an array\n\t * @returns {Array} Array of all documents\n\t */\n\tgetAllDocuments() {\n\t\treturn Array.from(this.documents.data.values());\n\t}\n\n\t/**\n\t * Get document by ID\n\t * @param {string} docId - Document ID\n\t * @returns {Object|undefined} Document or undefined\n\t */\n\tget(key) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n\t\treturn this.documents.get(key);\n\t}\n\n\t/**\n\t * \n\t */\n\tset(key, value) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n    this.documents.set(key, value);\n\t}\n\n\t/**\n\t * \n\t */\n\tremove(key) {\n    if (typeof key !== 'string') throw new Error(\"Document key must be a string\");\n\t\tthis.documents.remove(key);\n\t}\n\n\t/**\n\t *\n\t */\n\tsize() {\n\t\treturn this.documents.size();\n\t}\n\n\t/**\n\t * Get entire document store (for export/save)\n\t * @returns {Object} Document store object\n\t */\n\tgetStore() {\n\t\tconst store = {};\n\t\tfor (const key of this.documents.keys()) {\n\t\t\tstore[key] = this.documents.get(key);\n\t\t}\n\t\treturn store;\n\t}\n\n\t// ==========================================\n\t// Index Storage Interface\n\t// ==========================================\n\n  indexesCount() {\n    return this.indexes.size;\n  }\n\n  indexKeys() {\n    return this.indexes.keys();\n  }\n\n\t/**\n\t * Get index data for a specific index\n\t * @param {string} indexName - Name of the index\n\t * @returns {Object} Index data object (or creates empty one if doesn't exist)\n\t */\n\tcreateIndexStore(name,meta) {\n\t\tif (!this.indexes.has(name)) {\n\t\t\tthis.indexes.set(name, new IndexStore(meta));\n\t\t}\n\t\treturn this.indexes.get(name);\n\t}\n\n}\n","import { CollectionStore } from './CollectionStore.js';\n\n/**\n * In-memory storage engine (default)\n */\nexport class StorageEngine {\n\tconstructor() {\n\t\tthis.collections = new Map();\n\t}\n\n  collectionsCount() {\n    return this.collections.size;\n  }\n  \n  /**\n   * \n   * @returns {[string]} list of collection names\n   */\n  collectionStoreKeys() {\n    return this.collections.keys();\n  }\n\n  /**\n   * \n   * @param {*} collectionName \n   * @returns \n   */\n  getCollectionStore(collectionName) {\n    return this.collections.get(collectionName);\n  }\n\n\t/**\n\t * Create a collection's state\n\t * @param {string} collectionName - The collection name\n\t * @returns {CollectionStore} The collection store\n\t */\n\tcreateCollectionStore(collectionName) {\n    if (this.collections.has(collectionName)) {\n      return this.collections.get(collectionName);\n    }\n    const collectionStore = new CollectionStore();\n    this.collections.set(collectionName, collectionStore);\n    return collectionStore;\n  }\n\n\t/**\n\t * Delete a collection\n\t * @param {string} collectionName - The collection name\n\t */\n\tremoveCollectionStore(collectionName) {\n    this.collections.delete(collectionName);\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @returns {Promise<void>}\n\t */\n\tsave() {\n\t\t// In-memory storage does not persist data\n\t}\n\n}\n","import { Collection } from './Collection.js';\nimport { StorageEngine } from './StorageEngine.js';\nimport { ObjectId } from 'bjson';\nimport { ChangeStream } from './ChangeStream.js';\nimport { NotImplementedError } from './errors.js';\n\n/**\n * DB class\n */\nexport class DB {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t\tthis.dbName = this.options.dbName || 'default';\n\t\t\t\n\t\t// StorageEngine\n\t\tthis.storageEngine = this.options.storageEngine || new StorageEngine();\n\n\t\t// Load existing collections from storage engine\n\t\tthis._loadExistingCollections();\n\n\t\t// Return a Proxy to enable dynamic collection creation\n\t\treturn new Proxy(this, {\n\t\t\tget(target, property, receiver) {\n\t\t\t\t// If property exists on target (including undefined values), return it\n\t\t\t\tif (property in target) {\n\t\t\t\t\treturn Reflect.get(target, property, receiver);\n\t\t\t\t}\n\n\t\t\t\t// If property is a symbol or special property, return undefined\n\t\t\t\tif (typeof property === 'symbol' || property.startsWith('_')) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n        // For collection names, create the collection if it doesn't exist\n        // Only auto-create if it's a valid collection name and doesn't already exist\n        if (typeof property === 'string') {\n          // Don't auto-create if property was explicitly deleted\n          if (Object.prototype.hasOwnProperty.call(target, property)) {\n            return target[property];\n          }\n          // Auto-create the collection\n          target.createCollection(property);\n          return target[property];\n        }\n        return undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Log function\n\t */\n\t_log(msg) {\n\t\tif (this.options && this.options.print) this.options.print(msg);\n\t\telse console.log(msg);\n\t}\n\n\t/**\n\t * ID generator function\n\t */\n\t_id() {\n\t\tif (this.options && this.options.id) return this.options.id();\n\t\telse return new ObjectId();\n\t}\n\n\t/**\n\t * Load existing collections from storage engine\n\t * @private\n\t */\n\t_loadExistingCollections() {\n\t\t// Iterate through all collection stores in the storage engine\n\t\tfor (const collectionName of this.storageEngine.collectionStoreKeys()) {\n\t\t\tconst collectionStore = this.storageEngine.getCollectionStore(collectionName);\n\t\t\t// Create Collection instance for each existing collection\n\t\t\tthis[collectionName] = new Collection(\n\t\t\t\tthis,\n\t\t\t\tcollectionName,\n\t\t\t\tcollectionStore,\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\t// DB Methods\n\tcloneCollection() { throw new NotImplementedError('cloneCollection', { database: this.dbName }); }\n\tcloneDatabase() { throw new NotImplementedError('cloneDatabase', { database: this.dbName }); }\n\tcommandHelp() { throw new NotImplementedError('commandHelp', { database: this.dbName }); }\n\tcopyDatabase() { throw new NotImplementedError('copyDatabase', { database: this.dbName }); }\n\n\tcreateCollection(name) {\n\t\tif (!name) return;\n\t\tthis[name] = new Collection(\n\t\t\tthis,\n      name,\n\t\t\tthis.storageEngine.createCollectionStore(name),\n\t\t\tthis._id.bind(this)\n\t\t);\n\t}\n\n\t/**\n\t * Get or create a collection by name (MongoDB-compatible method)\n\t * @param {string} name - Collection name\n\t * @returns {Collection} The collection instance\n\t */\n\tcollection(name) {\n\t\tif (!name) throw new Error('Collection name is required');\n\t\t\n\t\t// Return existing collection if it exists\n\t\tif (this[name] && this[name].isCollection) {\n\t\t\treturn this[name];\n\t\t}\n\t\t\n\t\t// Create and return new collection\n\t\tthis.createCollection(name);\n\t\treturn this[name];\n\t}\n\n\tcurrentOp() { throw new NotImplementedError('currentOp', { database: this.dbName }); }\n\n\tdropCollection(collectionName) {\n\t\tif (this[collectionName]) {\n\t\t\t// Remove from storage engine\n\t\t\tthis.storageEngine.removeCollectionStore(collectionName);\n\t\t\t// Delete the collection property from DB\n\t\t\tdelete this[collectionName];\n\t\t}\n\t}\n\n\tdropDatabase() {\n\t\t// Get all collection names\n\t\tconst collectionNames = this.getCollectionNames();\n\t\t\n\t\t// Drop each collection\n\t\tfor (const name of collectionNames) {\n\t\t\t// Remove from storage engine\n\t\t\tthis.storageEngine.removeCollectionStore(name);\n\t\t\t// Delete the collection property from DB\n\t\t\tdelete this[name];\n\t\t}\n\t}\n\n\teval() { throw new NotImplementedError('eval', { database: this.dbName }); }\n\tfsyncLock() { throw new NotImplementedError('fsyncLock', { database: this.dbName }); }\n\tfsyncUnlock() { throw new NotImplementedError('fsyncUnlock', { database: this.dbName }); }\n\tgetCollection() { throw new NotImplementedError('getCollection', { database: this.dbName }); }\n\tgetCollectionInfos() { throw new NotImplementedError('getCollectionInfos', { database: this.dbName }); }\n\n\tgetCollectionNames() {\n\t\tconst names = [];\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tnames.push(key);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tgetLastError() { throw new NotImplementedError('getLastError', { database: this.dbName }); }\n\tgetLastErrorObj() { throw new NotImplementedError('getLastErrorObj', { database: this.dbName }); }\n\tgetLogComponents() { throw new NotImplementedError('getLogComponents', { database: this.dbName }); }\n\tgetMongo() { throw new NotImplementedError('getMongo', { database: this.dbName }); }\n\tgetName() { throw new NotImplementedError('getName', { database: this.dbName }); }\n\tgetPrevError() { throw new NotImplementedError('getPrevError', { database: this.dbName }); }\n\tgetProfilingLevel() { throw new NotImplementedError('getProfilingLevel', { database: this.dbName }); }\n\tgetProfilingStatus() { throw new NotImplementedError('getProfilingStatus', { database: this.dbName }); }\n\tgetReplicationInfo() { throw new NotImplementedError('getReplicationInfo', { database: this.dbName }); }\n\tgetSiblingDB() { throw new NotImplementedError('getSiblingDB', { database: this.dbName }); }\n\n\thelp() {\n\t\tthis._log(\"        help mr                      mapreduce\");\n\t\tthis._log(\"        db.foo.find()                list objects in collection foo\");\n\t\tthis._log(\"        db.foo.find( { a : 1 } )     list objects in foo where a == 1\");\n\t\tthis._log(\"        it                           result of the last line evaluated; use to further iterate\");\n\t}\n\n\thostInfo() { throw new NotImplementedError('hostInfo', { database: this.dbName }); }\n\tisMaster() { throw new NotImplementedError('isMaster', { database: this.dbName }); }\n\tkillOp() { throw new NotImplementedError('killOp', { database: this.dbName }); }\n\tlistCommands() { throw new NotImplementedError('listCommands', { database: this.dbName }); }\n\tloadServerScripts() { throw new NotImplementedError('loadServerScripts', { database: this.dbName }); }\n\tlogout() { throw new NotImplementedError('logout', { database: this.dbName }); }\n\tprintCollectionStats() { throw new NotImplementedError('printCollectionStats', { database: this.dbName }); }\n\tprintReplicationInfo() { throw new NotImplementedError('printReplicationInfo', { database: this.dbName }); }\n\tprintShardingStatus() { throw new NotImplementedError('printShardingStatus', { database: this.dbName }); }\n\tprintSlaveReplicationInfo() { throw new NotImplementedError('printSlaveReplicationInfo', { database: this.dbName }); }\n\trepairDatabase() { throw new NotImplementedError('repairDatabase', { database: this.dbName }); }\n\tresetError() { throw new NotImplementedError('resetError', { database: this.dbName }); }\n\trunCommand() { throw new NotImplementedError('runCommand', { database: this.dbName }); }\n\tserverBuildInfo() { throw new NotImplementedError('serverBuildInfo', { database: this.dbName }); }\n\tserverCmdLineOpts() { throw new NotImplementedError('serverCmdLineOpts', { database: this.dbName }); }\n\tserverStatus() { throw new NotImplementedError('serverStatus', { database: this.dbName }); }\n\tsetLogLevel() { throw new NotImplementedError('setLogLevel', { database: this.dbName }); }\n\tsetProfilingLevel() { throw new NotImplementedError('setProfilingLevel', { database: this.dbName }); }\n\tshutdownServer() { throw new NotImplementedError('shutdownServer', { database: this.dbName }); }\n\tstats() { throw new NotImplementedError('stats', { database: this.dbName }); }\n\tversion() { throw new NotImplementedError('version', { database: this.dbName }); }\n\tupgradeCheck() { throw new NotImplementedError('upgradeCheck', { database: this.dbName }); }\n\tupgradeCheckAllDBs() { throw new NotImplementedError('upgradeCheckAllDBs', { database: this.dbName }); }\n\n\t/**\n\t * Watch for changes across all collections in this database\n\t * @param {Array} pipeline - Aggregation pipeline to filter changes\n\t * @param {Object} options - Watch options\n\t * @returns {ChangeStream} A change stream instance\n\t */\n\twatch(pipeline = [], options = {}) {\n\t\treturn new ChangeStream(this, pipeline, options);\n\t}\n}\n","import { EventEmitter } from 'events';\r\nimport { DB } from './DB.js';\r\nimport { ChangeStream } from './ChangeStream.js';\r\n\r\nexport class MongoClient extends EventEmitter {\r\n  constructor(uri = 'mongodb://localhost:27017', options = {}) {\r\n    super();\r\n    this.uri = uri;\r\n    this.options = Object.freeze({ ...options }); // Make immutable\r\n    this._isConnected = false;\r\n    this._defaultDb = this._parseDefaultDbName(uri);\r\n  }\r\n\r\n  static async connect(uri, options = {}) {\r\n    const client = new MongoClient(uri, options);\r\n    await client.connect();\r\n    return client;\r\n  }\r\n\r\n  async connect() {\r\n    if (this._isConnected) return this;\r\n    \r\n    this._isConnected = true;\r\n    this.emit('open', this);\r\n    return this;\r\n  }\r\n\r\n  db(name, opts = {}) {\r\n    // Use default from URI if no name provided\r\n    const dbName = name || this._defaultDb;\r\n    if (!dbName) {\r\n      throw new Error('No database name provided and no default in connection string');\r\n    }\r\n    \r\n    const dbOptions = { ...this.options, ...opts, dbName };\r\n    return new DB(dbOptions);\r\n  }\r\n\r\n  async close(force = false) {\r\n    if (!this._isConnected) return;\r\n    \r\n    this._isConnected = false;\r\n    this.emit('close');\r\n  }\r\n\r\n  // Session management stubs\r\n  startSession(options = {}) {\r\n    // Return minimal session object for compatibility\r\n    return {\r\n      id: crypto.randomUUID(),\r\n      endSession: () => {},\r\n      withTransaction: async (fn) => await fn(this)\r\n    };\r\n  }\r\n\r\n  async withSession(optionsOrExecutor, executor) {\r\n    const session = this.startSession(\r\n      typeof optionsOrExecutor === 'function' ? {} : optionsOrExecutor\r\n    );\r\n    const fn = typeof optionsOrExecutor === 'function' ? optionsOrExecutor : executor;\r\n    \r\n    try {\r\n      return await fn(session);\r\n    } finally {\r\n      session.endSession();\r\n    }\r\n  }\r\n\r\n  // Configuration getters\r\n  get readConcern() { return this.options.readConcern; }\r\n  get writeConcern() { return this.options.writeConcern; }\r\n  get readPreference() { return this.options.readPreference; }\r\n\r\n  /**\r\n   * Watch for changes across all databases and collections\r\n   * @param {Array} pipeline - Aggregation pipeline to filter changes\r\n   * @param {Object} options - Watch options\r\n   * @returns {ChangeStream} A change stream instance\r\n   */\r\n  watch(pipeline = [], options = {}) {\r\n    return new ChangeStream(this, pipeline, options);\r\n  }\r\n\r\n  _parseDefaultDbName(uri) {\r\n    // Parse mongodb://host:port/dbname format\r\n    const match = uri.match(/\\/([^/?]+)/);\r\n    return match ? match[1] : null;\r\n  }\r\n}","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * IndexedDB-based storage engine for persistent storage\n * Stores each collection separately in IndexedDB\n */\nexport class IndexedDbStorageEngine extends StorageEngine {\n\tconstructor(dbName = 'micro-mongo') {\n\t\tsuper();\n\t\tthis.dbName = dbName;\n\t\tthis.db = null;\n\t\tthis.indexedDBName = `micro-mongo-${dbName}`;\n\t}\n\n\t/**\n\t * Initialize the IndexedDB connection\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open(this.indexedDBName, 1);\n\n\t\t\trequest.onerror = () => {\n\t\t\t\treject(new Error('Failed to open IndexedDB: ' + request.error));\n\t\t\t};\n\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tthis.db = request.result;\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = event.target.result;\n\t\t\t\t\n\t\t\t\t// Create object stores for collections and metadata\n\t\t\t\tif (!db.objectStoreNames.contains('collections')) {\n\t\t\t\t\tdb.createObjectStore('collections', { keyPath: 'name' });\n\t\t\t\t}\n\t\t\t\tif (!db.objectStoreNames.contains('metadata')) {\n\t\t\t\t\tdb.createObjectStore('metadata', { keyPath: 'key' });\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\t// Save metadata\n\t\tconst transaction = this.db.transaction(['metadata'], 'readwrite');\n\t\tconst metadataStore = transaction.objectStore('metadata');\n\t\t\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst request = metadataStore.put({\n\t\t\t\tkey: 'dbName',\n\t\t\t\tvalue: dbState.name\n\t\t\t});\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\n\t\t// Save each collection\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tawait this.saveCollection(dbState.name, collectionName, dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.getAll();\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst collections = {};\n\t\t\t\tfor (const collectionData of request.result) {\n\t\t\t\t\tcollections[collectionData.name] = {\n\t\t\t\t\t\tdocuments: collectionData.documents || [],\n\t\t\t\t\t\tindexes: collectionData.indexes || []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolve({\n\t\t\t\t\tname: dbName,\n\t\t\t\t\tcollections: collections\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.put({\n\t\t\t\tname: collectionName,\n\t\t\t\tdocuments: collectionState.documents || [],\n\t\t\t\tindexes: collectionState.indexes || []\n\t\t\t});\n\t\t\t\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.get(collectionName);\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tif (request.result) {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tdocuments: request.result.documents || [],\n\t\t\t\t\t\tindexes: request.result.indexes || []\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.delete(collectionName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.deleteDatabase(this.indexedDBName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\t}\n}\n"],"names":["ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","eventsModule","exports","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","ObjectId","constructor","id","generate","isValid","toLowerCase","Uint8Array","from","map","b","toString","padStart","join","toHexString","getTimestamp","timestamp","parseInt","substring","Date","equals","other","compare","localeCompare","toJSON","inspect","toBytes","bytes","test","createFromTime","tsHex","Math","floor","ts","now","rand","crypto","getRandomValues","tail","random","padEnd","valuesEqual","a","o","out","v","isArray","getProp","obj","path","split","result","pathSegment","numericIndex","getFieldValues","results","newResults","j","current","k","filter","setProp","indexOf","remainingPath","nextSegment","nextNumeric","setPropWithAllPositional","lastSegment","lastNumericIndex","toArray","hasOwnProperty","el","isIn","val","values","arrayMatches","x","y","objectMatches","p","applyProjection","projection","doc","hasInclusion","hasExclusion","$err","code","_id","fieldPath","pathParts","parent","ErrorCodes","OK","INTERNAL_ERROR","BAD_VALUE","NO_SUCH_KEY","GRAPH_CONTAINS_CYCLE","HOST_UNREACHABLE","HOST_NOT_FOUND","UNKNOWN_ERROR","FAILED_TO_PARSE","CANNOT_MUTATE_OBJECT","USER_NOT_FOUND","UNSUPPORTED_FORMAT","UNAUTHORIZED","TYPE_MISMATCH","OVERFLOW","INVALID_LENGTH","PROTOCOL_ERROR","AUTHENTICATION_FAILED","ILLEGAL_OPERATION","NAMESPACE_NOT_FOUND","INDEX_NOT_FOUND","PATH_NOT_VIABLE","CANNOT_CREATE_INDEX","INDEX_ALREADY_EXISTS","INDEX_EXISTS","COMMAND_NOT_FOUND","NAMESPACE_EXISTS","INVALID_NAMESPACE","INDEX_OPTIONS_CONFLICT","INVALID_INDEX_SPECIFICATION_OPTION","WRITE_CONFLICT","DUPLICATE_KEY","DUPLICATE_KEY_UPDATE","DOCUMENT_VALIDATION_FAILURE","BAD_QUERY","CANNOT_INDEX_PARALLEL_ARRAYS","CURSOR_NOT_FOUND","COLLECTION_IS_EMPTY","NOT_IMPLEMENTED","OPERATION_NOT_SUPPORTED","MongoError","options","super","codeName","_getCodeName","collection","database","operation","query","document","field","captureStackTrace","json","indexName","namespace","cursorId","feature","keyPattern","keyValue","writeErrors","MongoServerError","MongoDriverError","WriteError","DuplicateKeyError","keyStr","JSON","stringify","ValidationError","validationErrors","IndexError","IndexExistsError","IndexNotFoundError","CannotCreateIndexError","reason","QueryError","TypeMismatchError","expectedType","actualType","NamespaceError","NamespaceNotFoundError","InvalidNamespaceError","CursorError","CursorNotFoundError","NotImplementedError","OperationNotSupportedError","BadValueError","BulkWriteError","MongoNetworkError","Cursor","documents","SortedCursor","pos","_limit","_skip","_closed","batchSize","size","_batchSize","close","comment","commentString","_comment","explain","verbosity","queryPlanner","plannerVersion","db","indexFilterSet","parsedQuery","winningPlan","stage","direction","executionStats","executionSuccess","nReturned","executionTimeMillis","totalKeysExamined","totalDocsExamined","ok","forEach","fn","hasNext","next","effectiveMax","min","hint","_hint","itcount","limit","_max","maxScan","_maxScan","maxTimeMS","ms","_maxTimeMS","max","indexBounds","_maxIndexBounds","_minIndexBounds","noCursorTimeout","_noCursorTimeout","objsLeftInBatch","pretty","_pretty","readConcern","level","_readConcern","readPref","mode","tagSet","_readPref","returnKey","enabled","_returnKey","showRecordId","_showRecordId","remaining","maxPos","skip","num","isClosed","snapshot","sort","s","allowDiskUse","_allowDiskUse","collation","collationDocument","_collation","tailable","Symbol","asyncIterator","cursor","sortSpec","items","sortKeys","step2list","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3list","icate","ative","alize","iciti","ical","ful","ness","vowel","consonants","vowels","gt0","RegExp","eq1","gt1","vowelInStem","consonantLike","sfxLl","sfxE","sfxY","sfxIon","sfxEdOrIng","sfxAtOrBlOrIz","sfxEED","sfxS","sfxSsesOrIes","sfxMultiConsonantLike","step2","step3","step4","stemmer","match","firstCharacterWasLowerCaseY","codePointAt","exec","IndexStore","meta","_meta","Map","_data","entries","setMeta","hasMeta","has","getMeta","hasDataMap","getDataMap","STOPWORDS","Set","TextIndex","storage","documentTerms","documentLengths","_tokenize","text","word","add","docId","words","termFrequency","stem","frequency","remove","term","delete","queryText","scored","requireAll","stemmedTerms","uniqueTerms","docSets","termDocs","intersection","totalDocs","idf","docsWithTerm","log","docScores","termFreq","tfIdf","score","docTerms","coverage","r","getTermCount","getDocumentCount","clear","evaluateExpression","expr","startsWith","charAt","item","operator","operand","operands","sum","getTime","evalAdd","val1","val2","evalSubtract","product","evalMultiply","evalDivide","evalMod","base","exponent","pow","evalPow","sqrt","evalSqrt","abs","evalAbs","ceil","evalCeil","evalFloor","trunc","evalTrunc","place","multiplier","round","evalRound","evalConcat","str","start","substr","evalSubstr","evalToLower","toUpperCase","evalToUpper","input","chars","charsRegex","escapeRegex","replace","trim","evalTrim","evalLtrim","evalRtrim","delimiter","evalSplit","evalStrLenCP","str1","str2","evalStrcasecmp","end","evalIndexOfCP","find","replacement","evalReplaceOne","evalReplaceAll","evalCmp","evalEq","evalNe","evalGt","evalGte","evalLt","evalLte","evalAnd","evalOr","evalNot","ifExpr","thenExpr","elseExpr","if","then","else","condition","evalCond","evalIfNull","branches","branch","case","default","evalSwitch","date","getUTCFullYear","evalYear","getUTCMonth","evalMonth","getUTCDate","evalDayOfMonth","getUTCDay","evalDayOfWeek","UTC","diff","oneDay","evalDayOfYear","getUTCHours","evalHour","getUTCMinutes","evalMinute","getUTCSeconds","evalSecond","getUTCMilliseconds","evalMillisecond","onejan","evalWeek","valueOf","dayNr","setUTCDate","firstThursday","setUTCMonth","evalIsoWeek","evalIsoWeekYear","format","evalDateToString","evalToDate","idx","evalArrayElemAt","evalConcatArrays","asVar","as","cond","itemDoc","evalFilter","includes","evalIn","search","evalIndexOfArray","evalIsArray","inExpr","in","evalMap","initialValue","evalReduce","evalSize","evalSlice","reverse","evalReverseArray","inputs","useLongestLength","defaults","arrays","every","maxLength","tuple","evalZip","isInteger","evalType","to","onError","onNull","parseFloat","Boolean","e","evalConvert","evalToBool","evalToDecimal","evalToDouble","evalToInt","evalToLong","evalToString","evalObjectToArray","evalArrayToObject","assign","evalMergeObjects","evaluateOperator","BSON_TYPES","TYPE_ALIASES","reduce","acc","matchesType","typeSpec","typeCode","typeName","toBitMask","positions","mask","matchesBitsAllSet","matchesBitsAllClear","matchesBitsAnySet","matchesBitsAnyClear","validateJsonSchema","schema","docType","required","properties","propSchema","minimum","maximum","minLength","pattern","enum","compareValues","aVal","bVal","fieldValueMatches","fieldValue","checkFn","prop","textIndex","geoWithin","minLon","maxLat","maxLon","isGeometryWithinBBox","geoJson","minLat","features","geometry","coordinates","lng","lat","ring","coord","where","tlMatches","opMatches","and","els","or","not","nor","rawValue","$options","regex","arrayFieldValue","found","element","matchesPrimitive","opKeys","op","opValue","matches","sizeFieldValue","matchWithArrayIndices","arrayFilters","matched","andWithTracking","tlMatchesWithTracking","baseField","trackMatchingIndex","opMatchesWithTracking","orWithTracking","norWithTracking","Timestamp","low","high","$timestamp","t","getHighBits","getLowBits","toDate","fromDate","seconds","parseFieldPath","segment","identifier","extractFilteredPositionalIdentifier","isFilteredPositional","applyToFilteredArrayElements","parsedPath","traverse","pathIndex","filterContext","pathInfo","isLastSegment","f","some","nextPath","applyOperationToValue","shouldUpdate","transformedFilter","hasDirectMatch","container","hasFilteredPositionalOperator","hasAllPositional","applyToAllPositional","updateFn","newValue","replacePositionalOperator","parts","dollarIndex","pathBeforeDollar","matchedIndex","filterPath","applyUpdates","updates","setOnInsert","positionalMatchInfo","userArrayFilters","fields","amount","currentValue","$type","addValue","currentArray","popValue","src","notRemoved","shouldRemove","__temp","toRemove","removed","l","pushValue","$each","$position","$slice","$sort","valuesToPush","splice","sortKey","sortDir","sliceValue","createDocFromUpdate","idGenerator","newDoc","onlyFields","updateKeys","queryKeys","Index","update","oldDoc","getSpec","serialize","deserialize","data","isNumericString","isFinite","BPlusTreeNode","isLeaf","indexStore","nodeCache","children","childId","childData","childNode","nextData","self","Proxy","property","child","BPlusTree","order","minKeys","_buildTreeFromStorage","root","rootData","_searchNode","node","newRoot","_splitChild","_insertNonFull","fullChild","newChild","midIndex","promotedKey","deleteValue","deleted","_deleteValue","_delete","valueIndex","_rebalanceAfterDelete","_borrowFromLeft","_borrowFromRight","_merge","leftSibling","rightSibling","leftChild","rightChild","_getFirstLeaf","isEmpty","rangeSearch","minKey","maxKey","getHeight","height","RegularCollectionIndex","extractIndexKey","keyFields","keyParts","indexKey","indexFields","queryValue","_queryWithOperators","operators","ops","hasGt","hasLt","Infinity","rangeResults","allEntries","idArray","excludeKey","TextCollectionIndex","indexedFields","_extractText","textParts","searchText","textIndexVersion","weights","_getWeights","haversineDistance","lat1","lng1","lat2","lng2","dLat","PI","dLng","sin","cos","atan2","intersects","bbox1","bbox2","maxLng","minLng","area","bbox","union","enlargement","RTreeNode","childTarget","childProp","childValue","updateBBox","RTree","maxEntries","minEntries","_size","insert","entry","_insert","_split","_chooseSubtree","splitNode","minEnlargement","minArea","targetNode","enl","ar","maxDist","seed1Idx","seed2Idx","waste","node1","node2","enl1","enl2","searchBBox","_searchBBox","searchRadius","radiusKm","latDelta","lngDelta","radiusToBoundingBox","candidates","_remove","indexInParent","getAll","_getAll","GeospatialCollectionIndex","rtree","geoField","_extractCoordinates","sumLat","sumLng","geoValue","coords","geoQuery","$geoWithin","$near","nearQuery","$geometry","maxDistanceKm","$maxDistance","withDistances","dist","_haversineDistance","distance","$nearSphere","$geoIntersects","intersectsQuery","epsilon","_pointInPolygon","inside","xi","yi","xj","yj","QueryPlan","indexes","indexScans","estimatedCost","indexOnly","QueryPlanner","plan","analysis","_analyzeQuery","hasTextSearch","textPlan","_planTextSearch","hasGeoQuery","geoPlan","_planGeoQuery","andPlan","_planAndQuery","orPlan","_planOrQuery","simplePlan","_planSimpleQuery","conditions","$and","subAnalysis","$or","textQuery","_extractTextQuery","$text","$search","indexableConditions","conditionPlan","scan","_canIndexHandleQuery","_executeIndexScan","docIds","execute","sorted","currentSet","ChangeStream","pipeline","closed","_changeCounter","_startWatching","collections","_getCollectionsToWatch","_watchCollection","_interceptDBCollectionCreation","_interceptClientDBCreation","_monitorClient","collectionNames","getCollectionNames","isCollection","_monitorDB","handlers","_emitChange","updateDescription","operationType","changeEvent","_createChangeEvent","_matchesPipeline","event","Buffer","clusterTime","ns","dbName","coll","documentKey","fullDocument","updatedFields","removedFields","truncatedArrays","$match","_getNestedValue","part","client","originalDb","_watchedDBs","opts","colName","col","_interceptDBCollectionCreationForClient","_originalClientMethods","originalCollection","originalCreateCollection","createCollection","_originalDBMethods","queue","resolveNext","streamClosed","onChange","change","done","onClose","cleanup","Collection","generateIndexName","isTextIndex","isGeospatialIndex","buildIndex","createIndexStore","allDocs","getAllDocuments","updateIndexesOnInsert","updateIndexesOnDelete","planQuery","useIndex","planType","indexNames","getTextIndex","aggregate","stageKeys","stageType","stageSpec","projected","applyProjectionWithExpressions","modified","fieldsToRemove","groups","groupId","docs","accumulators","grouped","groupKey","group","accumulator","accKeys","accType","accExpr","valKey","mean","variance","merged","unwound","unwoundDoc","newRootSpec","shuffled","groupBy","boundaries","defaultBucket","output","$sum","buckets","placed","bucketed","bucketKey","bucket","numBuckets","bucketSize","startIdx","endIdx","bucketDocs","targetCollectionName","dropCollection","targetCollection","whenMatched","whenNotMatched","into","matchField","matchValue","existingCursor","localField","foreignField","fromCollection","joined","localValue","foreignCursor","startWith","connectFromField","connectToField","maxDepth","MAX_SAFE_INTEGER","depthField","restrictSearchWithMatch","graphed","startValue","visited","depth","valueKey","matchCopy","nextValue","facetResult","facetName","facetPipeline","facetResults","facetStage","facetStageKeys","facetStageType","facetStageSpec","redacted","decision","near","distanceField","maxDistance","minDistance","spherical","location","deltaLat","deltaLon","dx","dy","bulkWrite","copyTo","destCollectionName","destCol","numCopied","c","insertOne","createIndex","existingIndex","dataSize","deleteOne","findOne","deletedCount","deleteMany","ids","distinct","vals","d","drop","dropIndex","nIndexesWas","dropIndexes","msg","ensureIndex","normalizedQuery","queryPlan","seen","findAndModify","findOneAndDelete","findOneAndReplace","returnNewDocument","findOneAndUpdate","clone","getIndexes","getShardDistribution","getShardVersion","getStore","insertMany","insertedId","insertedIds","isCapped","mapReduce","reIndex","replaceOne","matchedCount","modifiedCount","upsert","upsertedId","justOne","renameCollection","save","stats","storageSize","totalSize","totalIndexSize","multi","updateOne","originalDoc","parse","_getUpdateDescription","updateMany","validate","updatedDoc","watch","isInclusion","hasComputedFields","DocumentStore","CollectionStore","documentKeys","store","indexesCount","indexKeys","StorageEngine","collectionsCount","collectionStoreKeys","getCollectionStore","collectionName","createCollectionStore","collectionStore","removeCollectionStore","DB","storageEngine","_loadExistingCollections","_log","print","cloneCollection","cloneDatabase","commandHelp","copyDatabase","currentOp","dropDatabase","eval","fsyncLock","fsyncUnlock","getCollection","getCollectionInfos","names","getLastError","getLastErrorObj","getLogComponents","getMongo","getName","getPrevError","getProfilingLevel","getProfilingStatus","getReplicationInfo","getSiblingDB","help","hostInfo","isMaster","killOp","listCommands","loadServerScripts","logout","printCollectionStats","printReplicationInfo","printShardingStatus","printSlaveReplicationInfo","repairDatabase","resetError","runCommand","serverBuildInfo","serverCmdLineOpts","serverStatus","setLogLevel","setProfilingLevel","shutdownServer","version","upgradeCheck","upgradeCheckAllDBs","MongoClient","uri","freeze","_isConnected","_defaultDb","_parseDefaultDbName","connect","dbOptions","force","startSession","randomUUID","endSession","withTransaction","async","withSession","optionsOrExecutor","executor","session","writeConcern","readPreference","IndexedDbStorageEngine","indexedDBName","initialize","request","indexedDB","open","onerror","onsuccess","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","saveDatabase","dbState","metadataStore","transaction","objectStore","put","saveCollection","loadDatabase","collectionsStore","collectionData","collectionState","loadCollection","deleteCollection","deleteDatabase"],"mappings":"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","x_google_ignoreList":[0,1,6]}