class e{constructor(t){if(null==t)this.id=e.generate();else if("string"==typeof t){if(!e.isValid(t))throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${t}`);this.id=t.toLowerCase()}else{if(!(t instanceof e))throw new Error("Argument passed in must be a string of 24 hex characters or an ObjectId");this.id=t.id}}toString(){return this.id}toHexString(){return this.id}getTimestamp(){const e=parseInt(this.id.substring(0,8),16);return new Date(1e3*e)}equals(t){return!!t&&(t instanceof e?this.id===t.id:"string"==typeof t?this.id===t.toLowerCase():!!t.id&&this.id===t.id)}toJSON(){return this.id}inspect(){return`ObjectId("${this.id}")`}static isValid(e){return!!e&&("string"==typeof e&&(24===e.length&&/^[0-9a-fA-F]{24}$/.test(e)))}static createFromTime(t){const n=("00000000"+Math.floor(t/1e3).toString(16)).slice(-8);return new e(n+"0000000000000000")}static generate(){const e=Math.floor(Date.now()/1e3),t="undefined"!=typeof crypto&&crypto.getRandomValues?new Uint8Array(8):null;let n="";if(t){crypto.getRandomValues(t);for(let e=0;e<t.length;e++)n+=("0"+t[e].toString(16)).slice(-2)}else n=Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8)+Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8);return(("00000000"+e.toString(16)).slice(-8)+n).slice(0,24)}}function t(t,n){return t instanceof e||n instanceof e?t instanceof e&&n instanceof e||t instanceof e&&"string"==typeof n?t.equals(n):n instanceof e&&"string"==typeof t&&n.equals(t):t==n}function n(t){if(t instanceof e)return new e(t.id);var s,i,r;for(r in s=Array.isArray(t)?[]:{},t)i=t[r],s[r]="object"==typeof i&&null!==i?n(i):i;return s}function s(e,t){for(var n=t.split("."),s=e[n[0]],i=1;i<n.length;i++){if(null==s||null==s)return s;s=s[n[i]]}return s}function i(e){return Array==e.constructor}function r(e,n){for(var s=0;s<n.length;s++)if(t(n[s],e))return!0;return!1}function o(e,n){if(e.length!=n.length)return!1;for(var s=0;s<e.length;s++)if(!t(e[s],n[s])){if(typeof e[s]!=typeof n[s])return!1;if("object"==typeof e[s]&&null!==e[s]){if(i(e[s])){if(!o(e[s],n[s]))return!1}else if(!h(e[s],n[s]))return!1}else if(!t(e[s],n[s]))return!1}return!0}function h(e,n){for(var s in e)if(e.hasOwnProperty(s)){if(!n.hasOwnProperty(s))return!1;if(!t(e[s],n[s])){if(typeof e[s]!=typeof n[s])return!1;if("object"==typeof e[s]&&null!==e[s]){if(i(e[s])){if(!o(e[s],n[s]))return!1}else if(!h(e[s],n[s]))return!1}else if(!t(e[s],n[s]))return!1}}for(var s in n)if(n.hasOwnProperty(s)&&!e.hasOwnProperty(s))return!1;return!0}function l(e,t){var n={},s=Object.keys(e);if(0==s.length)return t;for(var i=!1,r=!1,o=0;o<s.length;o++)"_id"!==s[o]&&(e[s[o]]?i=!0:r=!0);if(i&&r)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287};if(e[s[0]]||i){0!==e._id&&(n._id=t._id);for(o=0;o<s.length;o++)"_id"!==s[o]&&e[s[o]]&&(n[s[o]]=t[s[o]])}else{for(var h in t)n[h]=t[h];for(o=0;o<s.length;o++)e[s[o]]||delete n[s[o]]}return n}class a{constructor(e,t,n,s,i,r,o,h){if(this.collection=e,this.query=t,this.projection=n,this.matches=s,this.storage=i,this.indexes=r,this.planQuery=o,this.SortedCursor=h,n&&Object.keys(n).length>0){const e=Object.keys(n);let t=!1,s=!1;for(let i=0;i<e.length;i++)"_id"!==e[i]&&(n[e[i]]?t=!0:s=!0);if(t&&s)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287}}this.pos=0,this.max=0,this._next=!1;const l=this.planQuery(this.query);this.indexDocIds=null,this.indexPos=0,this.fullScanDocIds={},l&&l.useIndex&&(this.indexDocIds=l.docIds?l.docIds.slice():[]),this._findNext()}_findNext(){for(;null!==this.indexDocIds&&this.indexPos<this.indexDocIds.length;){const e=this.indexDocIds[this.indexPos++],t=this.storage.getStore()[e];if(t&&this.matches(t,this.query))return this.fullScanDocIds[t._id]=!0,void(this._next=t)}for(;this.pos<this.storage.size()&&(0==this.max||this.pos<this.max);){const e=this.storage.get(this.pos++);if(e&&!this.fullScanDocIds[e._id]&&this.matches(e,this.query))return this.fullScanDocIds[e._id]=!0,void(this._next=e)}this._next=null}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){let e=0;const t=new a(this.collection,this.query,null,this.matches,this.storage,this.indexes,this.planQuery,this.SortedCursor);for(;t.hasNext();)e++,t.next();return e}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return!1===this._next&&this._findNext(),null!=this._next}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.max=e,this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){if(null==this._next)throw"Error: error hasNext: false";const e=this._next;return this._findNext(),this.projection?l(this.projection,e):e}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new this.SortedCursor(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}class c{constructor(e,t,n,s){for(this.collection=e,this.query=t,this.sortSpec=s,this.pos=0,this.items=[];n.hasNext();)this.items.push(n.next());const i=Object.keys(s);this.items.sort(function(e,t){for(let n=0;n<i.length;n++){if(null==e[i[n]]&&null!=t[i[n]])return-1*s[i[n]];if(null!=e[i[n]]&&null==t[i[n]])return 1*s[i[n]];if(e[i[n]]<t[i[n]])return-1*s[i[n]];if(e[i[n]]>t[i[n]])return 1*s[i[n]]}return 0})}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){return this.items.length}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return this.pos<this.items.length}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.items=this.items.slice(0,e),this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){return this.items[this.pos++]}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new c(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}const d={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},u={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},f="[aeiouy]",m="([^aeiou][^aeiouy]*)",p="("+f+"[aeiou]*)",g=new RegExp("^"+m+"?"+p+m),x=new RegExp("^"+m+"?"+p+m+p+"?$"),y=new RegExp("^"+m+"?("+p+m+"){2,}"),w=new RegExp("^"+m+"?"+f),I=new RegExp("^"+m+f+"[^aeiouwxy]$"),b=/ll$/,N=/^(.+?)e$/,_=/^(.+?)y$/,v=/^(.+?(s|t))(ion)$/,O=/^(.+?)(ed|ing)$/,$=/(at|bl|iz)$/,S=/^(.+?)eed$/,k=/^.+?[^s]s$/,j=/^.+?(ss|i)es$/,L=/([^aeiouylsz])\1$/,C=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,M=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,B=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;function A(e){let t=String(e).toLowerCase();if(t.length<3)return t;let n,s=!1;return 121===t.codePointAt(0)&&(s=!0,t="Y"+t.slice(1)),j.test(t)?t=t.slice(0,-2):k.test(t)&&(t=t.slice(0,-1)),(n=S.exec(t))?g.test(n[1])&&(t=t.slice(0,-1)):(n=O.exec(t))&&w.test(n[1])&&(t=n[1],$.test(t)?t+="e":L.test(t)?t=t.slice(0,-1):I.test(t)&&(t+="e")),(n=_.exec(t))&&w.test(n[1])&&(t=n[1]+"i"),(n=C.exec(t))&&g.test(n[1])&&(t=n[1]+d[n[2]]),(n=M.exec(t))&&g.test(n[1])&&(t=n[1]+u[n[2]]),(n=B.exec(t))?y.test(n[1])&&(t=n[1]):(n=v.exec(t))&&y.test(n[1])&&(t=n[1]),(n=N.exec(t))&&(y.test(n[1])||x.test(n[1])&&!I.test(n[1]))&&(t=n[1]),b.test(t)&&y.test(t)&&(t=t.slice(0,-1)),s&&(t="y"+t.slice(1)),t}const E=/* @__PURE__ */new Set(["a","about","after","all","also","am","an","and","another","any","are","around","as","at","be","because","been","before","being","between","both","but","by","came","can","come","could","did","do","each","for","from","get","got","has","had","he","have","her","here","him","himself","his","how","i","if","in","into","is","it","like","make","many","me","might","more","most","much","must","my","never","now","of","on","only","or","other","our","out","over","said","same","see","should","since","some","still","such","take","than","that","the","their","them","then","there","these","they","this","those","through","to","too","under","up","very","was","way","we","well","were","what","where","which","while","who","with","would","you","your"]);class z{constructor(e={}){this.index=/* @__PURE__ */new Map,this.documentTerms=/* @__PURE__ */new Map,this.documentLengths=/* @__PURE__ */new Map,this.useStopWords=!1!==e.useStopWords,this.stopWords=e.stopWords||new Set(E)}_tokenize(e){if("string"!=typeof e)return[];const t=e.toLowerCase().split(/\W+/).filter(e=>e.length>0);return this.useStopWords?t.filter(e=>!this.stopWords.has(e)):t}add(e,t){if(!e)throw new Error("Document ID is required");const n=this._tokenize(t),s=/* @__PURE__ */new Map;n.forEach(e=>{const t=A(e);s.set(t,(s.get(t)||0)+1)}),s.forEach((t,n)=>{this.index.has(n)||this.index.set(n,/* @__PURE__ */new Map),this.index.get(n).set(e,t)}),this.documentTerms.set(e,s),this.documentLengths.set(e,n.length)}remove(e){if(!this.documentTerms.has(e))return!1;return this.documentTerms.get(e).forEach((t,n)=>{this.index.has(n)&&(this.index.get(n).delete(e),0===this.index.get(n).size&&this.index.delete(n))}),this.documentTerms.delete(e),this.documentLengths.delete(e),!0}query(e,t={scored:!0,requireAll:!1}){const n=this._tokenize(e);if(0===n.length)return[];const s=n.map(e=>A(e)),i=[...new Set(s)];if(t.requireAll){const e=i.map(e=>{const t=this.index.get(e);return t?new Set(t.keys()):/* @__PURE__ */new Set});if(0===e.length)return[];const t=new Set(e[0]);for(let n=1;n<e.length;n++)for(const s of t)e[n].has(s)||t.delete(s);return Array.from(t)}const r=this.documentLengths.size,o=/* @__PURE__ */new Map;i.forEach(e=>{const t=this.index.get(e)?.size||0;t>0&&o.set(e,Math.log(r/t))});const h=/* @__PURE__ */new Map;i.forEach(e=>{const t=this.index.get(e);t&&t.forEach((t,n)=>{h.has(n)||h.set(n,0);const s=t/(this.documentLengths.get(n)||1)*(o.get(e)||0);h.set(n,h.get(n)+s)})}),h.forEach((e,t)=>{const n=this.documentTerms.get(t);if(n){const s=i.filter(e=>n.has(e)).length/i.length;h.set(t,e*(1+s))}});const l=Array.from(h.entries()).map(([e,t])=>({id:e,score:t})).sort((e,t)=>t.score-e.score);return!1===t.scored?l.map(e=>e.id):l}getTermCount(){return this.index.size}getDocumentCount(){return this.documentTerms.size}clear(){this.index.clear(),this.documentTerms.clear(),this.documentLengths.clear()}addStopWords(...e){return e.forEach(e=>this.stopWords.add(e.toLowerCase())),this}removeStopWords(...e){return e.forEach(e=>this.stopWords.delete(e.toLowerCase())),this}setStopWordFiltering(e){return this.useStopWords=e,this}}function D(t,n){return t instanceof e||n instanceof e?t instanceof e&&n instanceof e||t instanceof e&&"string"==typeof n?t.equals(n):n instanceof e&&"string"==typeof t&&n.equals(t):t==n}function P(t,n,s){let i=t,r=n;switch(t instanceof e&&(i=t.toString()),n instanceof e&&(r=n.toString()),s){case">":return i>r;case">=":return i>=r;case"<":return i<r;case"<=":return i<=r;default:return!1}}function q(e,t){const n=new z;n.add("id",e);return 1===n.query(t,{scored:!1}).length}function T(e,t){try{if(!Array.isArray(t)||2!==t.length)return!1;const n=t[0][0],s=t[0][1],i=t[1][0];return W(e,n,i,t[1][1],s)}catch(n){return!1}}function W(e,t,n,s,i){if(!e)return!1;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){for(const r of e.features)if(r.geometry&&!W(r.geometry,t,n,s,i))return!1;return!0}if("Feature"===e.type&&e.geometry)return W(e.geometry,t,n,s,i);if("Point"===e.type&&e.coordinates){const[r,o]=e.coordinates;if("number"==typeof r&&"number"==typeof o)return r>=t&&r<=n&&o>=s&&o<=i}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){for(const r of e.coordinates)for(const e of r){const r=e[0],o=e[1];if(r<t||r>n||o<s||o>i)return!1}return!0}return!1}function F(e,t){var n=Object.keys(t)[0],s=t[n];if("$"==n.charAt(0)){if("$and"==n)return J(e,s);if("$or"==n)return function(e,t){for(var n=0;n<t.length;n++)if(F(e,t[n]))return!0;return!1}(e,s);if("$not"==n)return function(e,t){return!F(e,t)}(e,s);if("$nor"==n)return function(e,t){for(var n=0;n<t.length;n++)if(F(e,t[n]))return!1;return!0}(e,s);if("$where"==n)return function(e,t){if("function"==typeof t)try{return t.call(e)}catch(n){return!1}else if("string"==typeof t)try{return new Function("return "+t).call(e)}catch(n){return!1}return!1}(e,s);throw{$err:"Can't canonicalize query: BadValue unknown top level operator: "+n,code:17287}}return R(e,n,s)}function R(t,n,l){if("string"==typeof l)return D(s(t,n),l);if("number"==typeof l)return D(s(t,n),l);if("boolean"==typeof l)return D(s(t,n),l);if(l instanceof e)return D(s(t,n),l);if("object"==typeof l){if(l instanceof RegExp)return s(t,n)&&s(t,n).match(l);if(i(l))return s(t,n)&&o(s(t,n),l);var a=Object.keys(l);if("$"==a[0].charAt(0)){for(var c=0;c<a.length;c++){var d=Object.keys(l)[c],u=l[d];if("$eq"==d){if(null==s(t,n)||!D(s(t,n),u))return!1}else if("$gt"==d){if(null==s(t,n)||!P(s(t,n),u,">"))return!1}else if("$gte"==d){if(null==s(t,n)||!P(s(t,n),u,">="))return!1}else if("$lt"==d){if(null==s(t,n)||!P(s(t,n),u,"<"))return!1}else if("$lte"==d){if(null==s(t,n)||!P(s(t,n),u,"<="))return!1}else if("$ne"==d){if(null==s(t,n)||D(s(t,n),u))return!1}else if("$in"==d){if(null==s(t,n)||!r(s(t,n),u))return!1}else if("$nin"==d){if(null==s(t,n)||r(s(t,n),u))return!1}else if("$exists"==d){if(u?null==s(t,n):null!=s(t,n))return!1}else if("$type"==d){if(typeof s(t,n)!=u)return!1}else if("$mod"==d){if(2!=u.length)throw{$err:"Can't canonicalize query: BadValue malformed mod, not enough elements",code:17287};if(null==s(t,n)||s(t,n)%u[0]!=u[1])return!1}else if("$regex"==d){if(null==s(t,n)||!s(t,n).match(u))return!1}else if("$text"==d){if(null==s(t,n)||!q(s(t,n),u))return!1}else if("$geoWithin"==d){if(null==s(t,n)||!T(s(t,n),u))return!1}else if("$not"==d){if(R(t,n,u))return!1}else if("$all"==d){if(null==(b=s(t,n))||!i(b))return!1;for(var f=0;f<u.length;f++)if(!r(u[f],b))return!1}else if("$elemMatch"==d){if(null==(b=s(t,n))||!i(b))return!1;var m=!1;for(f=0;f<b.length;f++){var p=b[f];if("object"!=typeof p||i(p)){for(var g=!0,x=Object.keys(u),y=0;y<x.length;y++){var w=x[y],I=u[w];("$gte"!=w||p>=I)&&("$gt"!=w||p>I)&&("$lte"!=w||p<=I)&&("$lt"!=w||p<I)?"$eq"==w&&p!=I||"$ne"==w&&p==I?g=!1:"$in"!=w||r(p,I)?"$nin"==w&&r(p,I)&&(g=!1):g=!1:g=!1}if(g){m=!0;break}}else if(V(p,u)){m=!0;break}}if(!m)return!1}else{if("$size"!=d)throw{$err:"Can't canonicalize query: BadValue unknown operator: "+d,code:17287};var b;if(null==(b=s(t,n))||!i(b))return!1;if(b.length!=u)return!1}}return!0}return s(t,n)&&h(s(t,n),l)}}function J(e,t){for(var n=0;n<t.length;n++)if(!F(e,t[n]))return!1;return!0}function V(e,t){return J(e,function(e){var t=[];for(var n in e)if(e.hasOwnProperty(n)){var s={};s[n]=e[n],t.push(s)}return t}(t))}function G(e,t,n){for(var s=Object.keys(e),i=0;i<s.length;i++){var r=s[i],o=e[r];if("$inc"==r)for(var h=Object.keys(o),l=0;l<h.length;l++){var a=o[x=h[l]];t[x]=t[x]+a}else if("$mul"==r)for(h=Object.keys(o),l=0;l<h.length;l++){a=o[x=h[l]];t[x]=t[x]*a}else if("$rename"==r)for(h=Object.keys(o),l=0;l<h.length;l++){t[o[x=h[l]]]=t[x],delete t[x]}else if("$setOnInsert"==r&&n)for(h=Object.keys(o),l=0;l<h.length;l++)t[h[l]]=o[h[l]];else if("$set"==r)for(h=Object.keys(o),l=0;l<h.length;l++)t[h[l]]=o[h[l]];else if("$unset"==r)for(h=Object.keys(o),l=0;l<h.length;l++)delete t[h[l]];else if("$min"==r)for(h=Object.keys(o),l=0;l<h.length;l++){a=o[x=h[l]];t[x]=Math.min(t[x],a)}else if("$max"==r)for(h=Object.keys(o),l=0;l<h.length;l++){a=o[x=h[l]];t[x]=Math.max(t[x],a)}else if("$currentDate"==r)for(h=Object.keys(o),l=0;l<h.length;l++)t[h[l]]=/* @__PURE__ */new Date;else if("$addToSet"==r)for(h=Object.keys(o),l=0;l<h.length;l++){o=o[x=h[l]];t[x].push(o)}else if("$pop"==r)for(h=Object.keys(o),l=0;l<h.length;l++){1==(o=o[x=h[l]])?t[x].pop():-1==o&&t[x].shift()}else if("$pullAll"==r)for(h=Object.keys(o),l=0;l<h.length;l++){for(var c=t[h[l]],d=o[h[l]],u=[],f=0;f<c.length;f++){for(var m=!1,p=0;p<d.length;p++)if(c[f]==d[p]){m=!0;break}m||u.push(c[f])}t[h[l]]=u}else if("$pushAll"==r)for(h=Object.keys(o),l=0;l<h.length;l++){var g=o[x=h[l]];for(f=0;f<g.length;f++)t[x].push(g[f])}else if("$push"==r)for(h=Object.keys(o),l=0;l<h.length;l++){t[x=h[l]].push(o[x])}else{if("$bit"!=r)throw"unknown update operator: "+r;var x,y=o[x=Object.keys(o)[0]],w=Object.keys(y)[0],I=y[w];if("and"==w)t[x]=t[x]&I;else if("or"==w)t[x]=t[x]|I;else{if("xor"!=w)throw"unknown $bit operator: "+w;t[x]=t[x]^I}}}}function K(e,t,n){for(var s={_id:n()},i=!0,r=Object.keys(t),o=0;o<r.length;o++)if("$"==r[o].charAt(0)){i=!1;break}if(i)for(o=0;o<r.length;o++)s[r[o]]=t[r[o]];else{var h=Object.keys(e);for(o=0;o<h.length;o++)s[h[o]]=e[h[o]];G(t,s,!0)}return s}class Q{constructor(e,t={}){this.keys=e,this.options=t,this.name=t.name||this.generateIndexName(e)}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}add(e){throw new Error("add() must be implemented by subclass")}remove(e){throw new Error("remove() must be implemented by subclass")}update(e,t){this.remove(e),this.add(t)}query(e){throw new Error("query() must be implemented by subclass")}clear(){throw new Error("clear() must be implemented by subclass")}getSpec(){return{name:this.name,key:this.keys}}}class U extends Q{constructor(e,t={}){super(e,t),this.data={}}extractIndexKey(e){const t=Object.keys(this.keys);if(0===t.length)return null;if(1===t.length){const n=s(e,t[0]);return void 0===n?null:JSON.stringify({t:typeof n,v:n})}const n=[];for(let i=0;i<t.length;i++){const r=s(e,t[i]);if(void 0===r)return null;n.push(JSON.stringify(r))}return n.join("\0")}add(e){const t=this.extractIndexKey(e);null!==t&&(this.data[t]||(this.data[t]=[]),this.data[t].push(e._id))}remove(e){const t=this.extractIndexKey(e);if(null!==t&&this.data[t]){const n=this.data[t],s=n.indexOf(e._id);-1!==s&&n.splice(s,1),0===n.length&&delete this.data[t]}}query(e){const t=Object.keys(e),n=Object.keys(this.keys);if(1===n.length){const s=n[0];if(-1!==t.indexOf(s)){const t=e[s];if("object"!=typeof t||null===t){const e=JSON.stringify({t:typeof t,v:t});return this.data[e]||[]}}}return null}clear(){this.data={}}}class H extends Q{constructor(e,t={}){super(e,t),this.textIndex=new z(t),this.indexedFields=[];for(const n in e)"text"===e[n]&&this.indexedFields.push(n);if(0===this.indexedFields.length)throw new Error('Text index must have at least one field with type "text"')}_extractText(e){const t=[];for(const n of this.indexedFields){const i=s(e,n);null!=i&&t.push(String(i))}return t.join(" ")}add(e){if(!e._id)throw new Error("Document must have an _id field");const t=this._extractText(e);t&&this.textIndex.add(String(e._id),t)}remove(e){e._id&&this.textIndex.remove(String(e._id))}query(e){return null}search(e,t={}){return this.textIndex.query(e,{scored:!1,...t})}clear(){this.textIndex.clear()}getSpec(){return{name:this.name,key:this.keys,textIndexVersion:3,weights:this._getWeights()}}_getWeights(){const e={};for(const t of this.indexedFields)e[t]=1;return e}}function Y(e,t,n,s){const i=(n-e)*Math.PI/180,r=(s-t)*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(r/2)*Math.sin(r/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}function X(e,t){return!(e.maxLat<t.minLat||e.minLat>t.maxLat||e.maxLng<t.minLng||e.minLng>t.maxLng)}function Z(e){return(e.maxLat-e.minLat)*(e.maxLng-e.minLng)}function ee(e,t){return{minLat:Math.min(e.minLat,t.minLat),maxLat:Math.max(e.maxLat,t.maxLat),minLng:Math.min(e.minLng,t.minLng),maxLng:Math.max(e.maxLng,t.maxLng)}}function te(e,t){return Z(ee(e,t))-Z(e)}class ne{constructor(e=!1){this.isLeaf=e,this.children=[],this.bbox=null}updateBBox(){if(0===this.children.length)return void(this.bbox=null);let e=1/0,t=-1/0,n=1/0,s=-1/0;for(const i of this.children){const r=i.bbox;e=Math.min(e,r.minLat),t=Math.max(t,r.maxLat),n=Math.min(n,r.minLng),s=Math.max(s,r.maxLng)}this.bbox={minLat:e,maxLat:t,minLng:n,maxLng:s}}}class se{constructor(e=9){this.maxEntries=e,this.minEntries=Math.max(2,Math.ceil(e/2)),this.root=new ne(!0),this._size=0}insert(e,t,n){const s={bbox:{minLat:e,maxLat:e,minLng:t,maxLng:t},lat:e,lng:t,data:n};this._insert(s,this.root,1),this._size++}_insert(e,t,n){if(t.isLeaf){if(t.children.push(e),t.updateBBox(),t.children.length>this.maxEntries)return this._split(t)}else{const s=this._chooseSubtree(e.bbox,t),i=this._insert(e,s,n+1);if(i){if(t.children.push(i),t.updateBBox(),t.children.length>this.maxEntries)return this._split(t)}else t.updateBBox()}return null}_chooseSubtree(e,t){let n=1/0,s=1/0,i=null;for(const r of t.children){const t=te(r.bbox,e),o=Z(r.bbox);(t<n||t===n&&o<s)&&(n=t,s=o,i=r)}return i}_split(e){const t=e.children,n=e.isLeaf;let s=-1/0,i=0,r=1;for(let l=0;l<t.length;l++)for(let e=l+1;e<t.length;e++){const n=t[l].bbox,o=t[e].bbox,h=Z(ee(n,o))-Z(n)-Z(o);h>s&&(s=h,i=l,r=e)}const o=new ne(n),h=new ne(n);o.children.push(t[i]),h.children.push(t[r]);for(let l=0;l<t.length;l++){if(l===i||l===r)continue;const e=t[l],n=e.bbox,s=0===o.children.length?1/0:te(o.bbox||n,n),a=0===h.children.length?1/0:te(h.bbox||n,n);if(o.children.length<this.minEntries&&t.length-l+o.children.length<=this.minEntries)o.children.push(e);else if(h.children.length<this.minEntries&&t.length-l+h.children.length<=this.minEntries)h.children.push(e);else if(s<a)o.children.push(e);else if(a<s)h.children.push(e);else{(o.bbox?Z(o.bbox):0)<(h.bbox?Z(h.bbox):0)?o.children.push(e):h.children.push(e)}o.updateBBox(),h.updateBBox()}if(e.children=o.children,e.updateBBox(),e===this.root){const e=new ne(!1);return e.children=[o,h],e.updateBBox(),this.root=e,null}return h}searchBBox(e){const t=[];return this._searchBBox(e,this.root,t),t}_searchBBox(e,t,n){if(t.bbox&&X(e,t.bbox))if(t.isLeaf)for(const s of t.children)X(e,s.bbox)&&n.push(s);else for(const s of t.children)this._searchBBox(e,s,n)}searchRadius(e,t,n){const s=function(e,t,n){const s=n/111,i=n/(111*Math.cos(e*Math.PI/180));return{minLat:e-s,maxLat:e+s,minLng:t-i,maxLng:t+i}}(e,t,n),i=this.searchBBox(s),r=[];for(const o of i){Y(e,t,o.lat,o.lng)<=n&&r.push(o)}return r}remove(e,t,n=null){const s={minLat:e,maxLat:e,minLng:t,maxLng:t},i=this._remove(s,n,this.root,null,-1);return i&&this._size--,1!==this.root.children.length||this.root.isLeaf||(this.root=this.root.children[0]),i}_remove(e,t,n,s,i){if(!n.bbox||!X(e,n.bbox))return!1;if(n.isLeaf)for(let r=0;r<n.children.length;r++){const o=n.children[r];if(o.lat===e.minLat&&o.lng===e.minLng){if(null===t||JSON.stringify(o.data)===JSON.stringify(t)){if(n.children.splice(r,1),n.updateBBox(),n.children.length<this.minEntries&&n!==this.root){const e=n.children.slice();n.children=[],n.updateBBox(),s&&(s.children.splice(i,1),s.updateBBox());for(const t of e)this._insert(t,this.root,1)}return!0}}}else for(let r=0;r<n.children.length;r++){const s=n.children[r];if(this._remove(e,t,s,n,r))return n.updateBBox(),!0}return!1}getAll(){const e=[];return this._getAll(this.root,e),e}_getAll(e,t){if(e.isLeaf)t.push(...e.children);else for(const n of e.children)this._getAll(n,t)}size(){return this._size}clear(){this.root=new ne(!0),this._size=0}}class ie extends Q{constructor(e,t={}){super(e,t),this.rtree=new se,this.geoField=null;for(const n in e)if("2dsphere"===e[n]||"2d"===e[n]){this.geoField=n;break}if(!this.geoField)throw new Error('Geospatial index must have at least one field with type "2dsphere" or "2d"')}_extractCoordinates(e){if(!e)return null;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){const t=e.features[0];if(t.geometry)return this._extractCoordinates(t.geometry)}if("Feature"===e.type&&e.geometry)return this._extractCoordinates(e.geometry);if("Point"===e.type&&e.coordinates){const[t,n]=e.coordinates;if("number"==typeof t&&"number"==typeof n)return{lat:n,lng:t}}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){const t=e.coordinates[0];if(t.length>0){let e=0,n=0;for(const s of t)n+=s[0],e+=s[1];return{lat:e/t.length,lng:n/t.length}}}return null}add(e){if(!e._id)throw new Error("Document must have an _id field");const t=s(e,this.geoField),n=this._extractCoordinates(t);n&&this.rtree.insert(n.lat,n.lng,{_id:e._id,geoJson:t})}remove(e){if(!e._id)return;const t=s(e,this.geoField),n=this._extractCoordinates(t);n&&this.rtree.remove(n.lat,n.lng,{_id:e._id,geoJson:t})}query(e){if(!e[this.geoField])return null;const t=e[this.geoField];if(t.$geoWithin){const e=t.$geoWithin;if(Array.isArray(e)&&2===e.length){const t=e[0][0],n=e[0][1],s=e[1][0],i=e[1][1];return this.rtree.searchBBox({minLat:i,maxLat:n,minLng:t,maxLng:s}).map(e=>e.data._id)}}return null}clear(){this.rtree.clear()}getSpec(){return{name:this.name,key:this.keys,"2dsphereIndexVersion":3}}}class re{constructor(e,t,n){this.db=e,this.storage=t,this.idGenerator=n,this.indexes={},this.isCollection=!0}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}isTextIndex(e){for(const t in e)if("text"===e[t])return!0;return!1}isGeospatialIndex(e){for(const t in e)if("2dsphere"===e[t]||"2d"===e[t])return!0;return!1}buildIndex(e,t,n={}){let s;s=this.isTextIndex(t)?new H(t,{...n,name:e}):this.isGeospatialIndex(t)?new ie(t,{...n,name:e}):new U(t,{...n,name:e});for(let i=0;i<this.storage.size();i++){const e=this.storage.get(i);e&&s.add(e)}return this.indexes[e]=s,s}updateIndexesOnInsert(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){this.indexes[t].add(e)}}updateIndexesOnDelete(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){this.indexes[t].remove(e)}}planQuery(e){const t=Object.keys(e);for(const n in this.indexes)if(this.indexes.hasOwnProperty(n)){const s=this.indexes[n];if(s instanceof H)continue;if(s instanceof ie){const t=s.query(e);if(null!==t)return{useIndex:!0,indexName:n,docIds:t};continue}const i=Object.keys(s.keys);if(1===i.length){const r=i[0];if(-1!==t.indexOf(r)){const t=e[r];if("object"!=typeof t||null===t){const t=s.query(e);if(null!==t)return{useIndex:!0,indexName:n,docIds:t}}}}}return null}getTextIndex(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){const n=this.indexes[t];if(n instanceof H&&n.indexedFields.includes(e))return n}return null}aggregate(e){if(!e||!i(e))throw{$err:"Pipeline must be an array",code:17287};let t=[];const r=this.find({});for(;r.hasNext();)t.push(r.next());for(let o=0;o<e.length;o++){const r=e[o],h=Object.keys(r);if(1!==h.length)throw{$err:"Each pipeline stage must have exactly one key",code:17287};const a=h[0],c=r[a];if("$match"===a){const e=[];for(let n=0;n<t.length;n++)V(t[n],c)&&e.push(t[n]);t=e}else if("$project"===a){const e=[];for(let n=0;n<t.length;n++)e.push(l(c,t[n]));t=e}else if("$sort"===a){const e=Object.keys(c);t.sort(function(t,n){for(let s=0;s<e.length;s++){const i=e[s];if(void 0===t[i]&&void 0!==n[i])return-1*c[i];if(void 0!==t[i]&&void 0===n[i])return 1*c[i];if(t[i]<n[i])return-1*c[i];if(t[i]>n[i])return 1*c[i]}return 0})}else if("$limit"===a)t=t.slice(0,c);else if("$skip"===a)t=t.slice(c);else if("$group"===a){const e={},n=c._id;for(let r=0;r<t.length;r++){const i=t[r];let o;o=null==n?null:"string"==typeof n&&"$"===n.charAt(0)?s(i,n.substring(1)):"object"==typeof n?JSON.stringify(n):n;const h=JSON.stringify(o);e[h]||(e[h]={_id:o,docs:[],accumulators:{}}),e[h].docs.push(i)}const i=[];for(const t in e){const n=e[t],r={_id:n._id};for(const e in c){if("_id"===e)continue;const t=c[e],i=Object.keys(t);if(1!==i.length)continue;const o=i[0],h=t[o];if("$sum"===o){let t=0;for(let e=0;e<n.docs.length;e++)if("number"==typeof h)t+=h;else if("string"==typeof h&&"$"===h.charAt(0)){t+=s(n.docs[e],h.substring(1))||0}r[e]=t}else if("$avg"===o){let t=0,i=0;for(let e=0;e<n.docs.length;e++)if("string"==typeof h&&"$"===h.charAt(0)){const r=s(n.docs[e],h.substring(1));null!=r&&(t+=r,i++)}r[e]=i>0?t/i:0}else if("$min"===o){let t;for(let e=0;e<n.docs.length;e++)if("string"==typeof h&&"$"===h.charAt(0)){const i=s(n.docs[e],h.substring(1));void 0!==i&&(void 0===t||i<t)&&(t=i)}r[e]=t}else if("$max"===o){let t;for(let e=0;e<n.docs.length;e++)if("string"==typeof h&&"$"===h.charAt(0)){const i=s(n.docs[e],h.substring(1));void 0!==i&&(void 0===t||i>t)&&(t=i)}r[e]=t}else if("$push"===o){const t=[];for(let e=0;e<n.docs.length;e++)if("string"==typeof h&&"$"===h.charAt(0)){const i=s(n.docs[e],h.substring(1));t.push(i)}r[e]=t}else if("$addToSet"===o){const t={};for(let e=0;e<n.docs.length;e++)if("string"==typeof h&&"$"===h.charAt(0)){const i=s(n.docs[e],h.substring(1));t[JSON.stringify(i)]=i}const i=[];for(const e in t)i.push(t[e]);r[e]=i}else"$first"===o?n.docs.length>0&&"string"==typeof h&&"$"===h.charAt(0)&&(r[e]=s(n.docs[0],h.substring(1))):"$last"===o&&n.docs.length>0&&"string"==typeof h&&"$"===h.charAt(0)&&(r[e]=s(n.docs[n.docs.length-1],h.substring(1)))}i.push(r)}t=i}else if("$count"===a)t=[{[c]:t.length}];else{if("$unwind"!==a)throw{$err:"Unsupported aggregation stage: "+a,code:17287};{const e=[];let r=c;"string"==typeof r&&"$"===r.charAt(0)&&(r=r.substring(1));for(let o=0;o<t.length;o++){const h=t[o],l=s(h,r);if(l&&i(l)&&l.length>0)for(let t=0;t<l.length;t++){const s=n(h),i=r.split(".");let o=s;for(let e=0;e<i.length-1;e++)o[i[e]]||(o[i[e]]={}),o=o[i[e]];o[i[i.length-1]]=l[t],e.push(s)}}t=e}}}return t}bulkWrite(){throw"Not Implemented"}async count(){return this.storage.size()}async copyTo(e){this.db[e]||this.db.createCollection(e);const t=this.db[e];let n=0;const s=this.find({});for(;s.hasNext();)await t.insertOne(s.next()),n++;return n}async createIndex(e,t){if(!e||"object"!=typeof e||Array.isArray(e))throw{$err:"createIndex requires a key specification object",code:2};const n=t&&t.name?t.name:this.generateIndexName(e);if(this.indexes[n]){const t=this.indexes[n];if(JSON.stringify(t.keys)!==JSON.stringify(e))throw{$err:"Index with name '"+n+"' already exists with a different key specification",code:85};return n}return this.buildIndex(n,e,t),n}dataSize(){throw"Not Implemented"}async deleteOne(e){const t=await this.findOne(e);return t?(this.updateIndexesOnDelete(t),this.storage.remove(t._id),{deletedCount:1}):{deletedCount:0}}async deleteMany(e){const t=this.find(e),n=[],s=[];for(;t.hasNext();){const e=t.next();n.push(e._id),s.push(e)}const i=n.length;for(let r=0;r<n.length;r++)this.updateIndexesOnDelete(s[r]),this.storage.remove(n[r]);return{deletedCount:i}}async distinct(e,t){const n={},s=this.find(t);for(;s.hasNext();){const t=s.next();t[e]&&(n[t[e]]=!0)}return Object.keys(n)}drop(){this.storage.clear();for(const e in this.indexes)this.indexes.hasOwnProperty(e)&&this.indexes[e].clear()}dropIndex(e){if(!this.indexes[e])throw{$err:"Index not found with name: "+e,code:27};return this.indexes[e].clear(),delete this.indexes[e],{nIndexesWas:Object.keys(this.indexes).length+1,ok:1}}dropIndexes(){const e=Object.keys(this.indexes).length;for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&this.indexes[t].clear();return this.indexes={},{nIndexesWas:e,msg:"non-_id indexes dropped",ok:1}}ensureIndex(){throw"Not Implemented"}explain(){throw"Not Implemented"}find(e,t){return new a(this,null==e?{}:e,t,V,this.storage,this.indexes,this.planQuery.bind(this),c)}findAndModify(){throw"Not Implemented"}async findOne(e,t){const n=this.find(e,t);return n.hasNext()?n.next():null}async findOneAndDelete(e,t){let n=this.find(e);if(t&&t.sort&&(n=n.sort(t.sort)),!n.hasNext())return null;const s=n.next();return this.storage.remove(s._id),t&&t.projection?l(t.projection,s):s}async findOneAndReplace(e,t,n){let s=this.find(e);if(n&&n.sort&&(s=s.sort(n.sort)),!s.hasNext())return null;const i=s.next();return t._id=i._id,this.storage.set(i._id,t),n&&n.returnNewDocument?n&&n.projection?l(n.projection,t):t:n&&n.projection?l(n.projection,i):i}async findOneAndUpdate(e,t,n){let s=this.find(e);if(n&&n.sort&&(s=s.sort(n.sort)),!s.hasNext())return null;const i=s.next(),r=Object.assign({},i);return G(t,r),this.storage.set(i._id,r),n&&n.returnNewDocument?n&&n.projection?l(n.projection,r):r:n&&n.projection?l(n.projection,i):i}getIndexes(){const e=[];for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&e.push(this.indexes[t].getSpec());return e}getShardDistribution(){throw"Not Implemented"}getShardVersion(){throw"Not Implemented"}getStore(){return this.storage.getStore()}group(){throw"Not Implemented"}async insert(e){return Array==e.constructor?await this.insertMany(e):await this.insertOne(e)}async insertOne(e){return null==e._id&&(e._id=this.idGenerator()),this.storage.set(e._id,e),this.updateIndexesOnInsert(e),{insertedId:e._id}}async insertMany(e){const t=[];for(let n=0;n<e.length;n++){const s=await this.insertOne(e[n]);t.push(s.insertedId)}return{insertedIds:t}}isCapped(){throw"Not Implemented"}mapReduce(){throw"Not Implemented"}reIndex(){throw"Not Implemented"}async replaceOne(e,t,n){const s={},i=this.find(e);if(s.matchedCount=i.count(),0==s.matchedCount){if(s.modifiedCount=0,n&&n.upsert){const e=t;e._id=this.idGenerator(),this.storage.set(e._id,e),s.upsertedId=e._id}}else{s.modifiedCount=1;const e=i.next();this.updateIndexesOnDelete(e),t._id=e._id,this.storage.set(e._id,t),this.updateIndexesOnInsert(t)}return s}remove(e,t){const n=this.find(e);if(n.hasNext())if(!0===t||t&&t.justOne){const e=n.next();this.updateIndexesOnDelete(e),this.storage.remove(e._id)}else for(;n.hasNext();){const e=n.next();this.updateIndexesOnDelete(e),this.storage.remove(e._id)}}renameCollection(){throw"Not Implemented"}save(){throw"Not Implemented"}stats(){throw"Not Implemented"}storageSize(){throw"Not Implemented"}totalSize(){throw"Not Implemented"}totalIndexSize(){throw"Not Implemented"}update(e,t,n){const s=this.find(e);if(s.hasNext())if(n&&n.multi)for(;s.hasNext();){const e=s.next();this.updateIndexesOnDelete(e),G(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else{const e=s.next();this.updateIndexesOnDelete(e),G(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=K(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}async updateOne(e,t,n){const s=this.find(e);if(s.hasNext()){const e=s.next();this.updateIndexesOnDelete(e),G(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=K(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}async updateMany(e,t,n){const s=this.find(e);if(s.hasNext())for(;s.hasNext();){const e=s.next();this.updateIndexesOnDelete(e),G(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=K(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}validate(){throw"Not Implemented"}}class oe{constructor(e){return this.options=e||{},"undefined"!=typeof localStorage?this.localStorage=new re(this,this.options.localStorage?this.options.localStorage:le,this._id.bind(this)):this.localStorage=null,new Proxy(this,{get:(e,t,n)=>t in e?Reflect.get(e,t,n):"symbol"==typeof t||t.startsWith("_")?void 0:"string"==typeof t&&"localStorage"!==t?(Object.prototype.hasOwnProperty.call(e,t)||e.createCollection(t),e[t]):void 0})}_log(e){this.options&&this.options.print?this.options.print(e):console.log(e)}_id(){return this.options&&this.options.id?this.options.id():new e}cloneCollection(){throw"Not Implemented"}cloneDatabase(){throw"Not Implemented"}commandHelp(){throw"Not Implemented"}copyDatabase(){throw"Not Implemented"}createCollection(e){e&&("localStorage"==e?this.localStorage=new re(this,this.options.localStorage?this.options.localStorage:le,this._id.bind(this)):this[e]=new re(this,this.options&&this.options.storage?new this.options.storage:new ae,this._id.bind(this)))}currentOp(){throw"Not Implemented"}dropDatabase(){for(const e in this)null!=this[e]&&this[e].isCollection&&(this[e].drop(),delete this[e])}eval(){throw"Not Implemented"}fsyncLock(){throw"Not Implemented"}fsyncUnlock(){throw"Not Implemented"}getCollection(){throw"Not Implemented"}getCollectionInfos(){throw"Not Implemented"}getCollectionNames(){const e=[];for(const t in this)null!=this[t]&&this[t].isCollection&&e.push(t);return e}getLastError(){throw"Not Implemented"}getLastErrorObj(){throw"Not Implemented"}getLogComponents(){throw"Not Implemented"}getMongo(){throw"Not Implemented"}getName(){throw"Not Implemented"}getPrevError(){throw"Not Implemented"}getProfilingLevel(){throw"Not Implemented"}getProfilingStatus(){throw"Not Implemented"}getReplicationInfo(){throw"Not Implemented"}getSiblingDB(){throw"Not Implemented"}help(){this._log("        help mr                      mapreduce"),this._log("        db.foo.find()                list objects in collection foo"),this._log("        db.foo.find( { a : 1 } )     list objects in foo where a == 1"),this._log("        it                           result of the last line evaluated; use to further iterate")}hostInfo(){throw"Not Implemented"}isMaster(){throw"Not Implemented"}killOp(){throw"Not Implemented"}listCommands(){throw"Not Implemented"}loadServerScripts(){throw"Not Implemented"}logout(){throw"Not Implemented"}printCollectionStats(){throw"Not Implemented"}printReplicationInfo(){throw"Not Implemented"}printShardingStatus(){throw"Not Implemented"}printSlaveReplicationInfo(){throw"Not Implemented"}repairDatabase(){throw"Not Implemented"}resetError(){throw"Not Implemented"}runCommand(){throw"Not Implemented"}serverBuildInfo(){throw"Not Implemented"}serverCmdLineOpts(){throw"Not Implemented"}serverStatus(){throw"Not Implemented"}setLogLevel(){throw"Not Implemented"}setProfilingLevel(){throw"Not Implemented"}shutdownServer(){throw"Not Implemented"}stats(){throw"Not Implemented"}version(){throw"Not Implemented"}upgradeCheck(){throw"Not Implemented"}upgradeCheckAllDBs(){throw"Not Implemented"}}class he{constructor(e,t={}){this.uri=e,this.options=t}static async connect(e,t={}){return new he(e,t)}db(e,t={}){const n={...this.options,...t};return new oe(n)}async close(){}}const le=/* @__PURE__ */function(){return{clear:function(){localStorage.clear()},get:function(e){return JSON.parse(localStorage.getItem(localStorage.key(e)))},getStore:function(){return localStorage},remove:function(e){localStorage.removeItem(e)},set:async function(e,t){localStorage.setItem(e,JSON.stringify(t))},size:function(){return localStorage.length}}}(),ae=function(){var e={};return{clear:function(){e={}},get:function(t){return e[Object.keys(e)[t]]},getStore:function(){return e},remove:function(t){delete e[t]},set:function(t,n){e[t]=n},size:function(){return Object.keys(e).length}}};export{le as LocalStorageStore,he as MongoClient,e as ObjectId,ae as ObjectStore};
//# sourceMappingURL=micro-mongo-1.1.3.min.js.map
