!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MicroMongo={})}(this,function(e){"use strict";class t{constructor(e){if(null==e)this.id=t.generate();else if("string"==typeof e){if(!t.isValid(e))throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${e}`);this.id=e.toLowerCase()}else{if(!(e instanceof t))throw new Error("Argument passed in must be a string of 24 hex characters or an ObjectId");this.id=e.id}}toString(){return this.id}toHexString(){return this.id}getTimestamp(){const e=parseInt(this.id.substring(0,8),16);return new Date(1e3*e)}equals(e){return!!e&&(e instanceof t?this.id===e.id:"string"==typeof e?this.id===e.toLowerCase():!!e.id&&this.id===e.id)}toJSON(){return this.id}inspect(){return`ObjectId("${this.id}")`}static isValid(e){return!!e&&("string"==typeof e&&(24===e.length&&/^[0-9a-fA-F]{24}$/.test(e)))}static createFromTime(e){const n=("00000000"+Math.floor(e/1e3).toString(16)).slice(-8);return new t(n+"0000000000000000")}static generate(){const e=Math.floor(Date.now()/1e3),t="undefined"!=typeof crypto&&crypto.getRandomValues?new Uint8Array(8):null;let n="";if(t){crypto.getRandomValues(t);for(let e=0;e<t.length;e++)n+=("0"+t[e].toString(16)).slice(-2)}else n=Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8)+Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8);return(("00000000"+e.toString(16)).slice(-8)+n).slice(0,24)}}function n(e,n){return e instanceof t||n instanceof t?e instanceof t&&n instanceof t||e instanceof t&&"string"==typeof n?e.equals(n):n instanceof t&&"string"==typeof e&&n.equals(e):e==n}function s(e){if(e instanceof t)return new t(e.id);var n,i,o;for(o in n=Array.isArray(e)?[]:{},e)i=e[o],n[o]="object"==typeof i&&null!==i?s(i):i;return n}function i(e,t){for(var n=t.split("."),s=e[n[0]],i=1;i<n.length;i++){if(null==s||null==s)return s;s=s[n[i]]}return s}function o(e){return Array==e.constructor}function r(e,t){for(var s=0;s<t.length;s++)if(n(t[s],e))return!0;return!1}function a(e,t){if(e.length!=t.length)return!1;for(var s=0;s<e.length;s++)if(!n(e[s],t[s])){if(typeof e[s]!=typeof t[s])return!1;if("object"==typeof e[s]&&null!==e[s]){if(o(e[s])){if(!a(e[s],t[s]))return!1}else if(!l(e[s],t[s]))return!1}else if(!n(e[s],t[s]))return!1}return!0}function l(e,t){for(var s in e)if(e.hasOwnProperty(s)){if(!t.hasOwnProperty(s))return!1;if(!n(e[s],t[s])){if(typeof e[s]!=typeof t[s])return!1;if("object"==typeof e[s]&&null!==e[s]){if(o(e[s])){if(!a(e[s],t[s]))return!1}else if(!l(e[s],t[s]))return!1}else if(!n(e[s],t[s]))return!1}}for(var s in t)if(t.hasOwnProperty(s)&&!e.hasOwnProperty(s))return!1;return!0}function h(e,t){var n={},s=Object.keys(e);if(0==s.length)return t;for(var i=!1,o=!1,r=0;r<s.length;r++)"_id"!==s[r]&&(e[s[r]]?i=!0:o=!0);if(i&&o)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287};if(e[s[0]]||i){0!==e._id&&(n._id=t._id);for(r=0;r<s.length;r++)"_id"!==s[r]&&e[s[r]]&&(n[s[r]]=t[s[r]])}else{for(var a in t)n[a]=t[a];for(r=0;r<s.length;r++)e[s[r]]||delete n[s[r]]}return n}class c{constructor(e,t,n,s,i,o,r,a){if(this.collection=e,this.query=t,this.projection=n,this.matches=s,this.storage=i,this.indexes=o,this.planQuery=r,this.SortedCursor=a,n&&Object.keys(n).length>0){const e=Object.keys(n);let t=!1,s=!1;for(let i=0;i<e.length;i++)"_id"!==e[i]&&(n[e[i]]?t=!0:s=!0);if(t&&s)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287}}this.pos=0,this.max=0,this._next=!1;const l=this.planQuery(this.query);this.indexDocIds=null,this.indexPos=0,this.fullScanDocIds={},l&&l.useIndex&&(this.indexDocIds=l.docIds?l.docIds.slice():[]),this._findNext()}_findNext(){for(;null!==this.indexDocIds&&this.indexPos<this.indexDocIds.length;){const e=this.indexDocIds[this.indexPos++],t=this.storage.getStore()[e];if(t&&this.matches(t,this.query))return this.fullScanDocIds[t._id]=!0,void(this._next=t)}for(;this.pos<this.storage.size()&&(0==this.max||this.pos<this.max);){const e=this.storage.get(this.pos++);if(e&&!this.fullScanDocIds[e._id]&&this.matches(e,this.query))return this.fullScanDocIds[e._id]=!0,void(this._next=e)}this._next=null}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){let e=0;const t=new c(this.collection,this.query,null,this.matches,this.storage,this.indexes,this.planQuery,this.SortedCursor);for(;t.hasNext();)e++,t.next();return e}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return!1===this._next&&this._findNext(),null!=this._next}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.max=e,this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){if(null==this._next)throw"Error: error hasNext: false";const e=this._next;return this._findNext(),this.projection?h(this.projection,e):e}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new this.SortedCursor(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}class d{constructor(e,t,n,s){for(this.collection=e,this.query=t,this.sortSpec=s,this.pos=0,this.items=[];n.hasNext();)this.items.push(n.next());const i=Object.keys(s);this.items.sort(function(e,t){for(let n=0;n<i.length;n++){if(null==e[i[n]]&&null!=t[i[n]])return-1*s[i[n]];if(null!=e[i[n]]&&null==t[i[n]])return 1*s[i[n]];if(e[i[n]]<t[i[n]])return-1*s[i[n]];if(e[i[n]]>t[i[n]])return 1*s[i[n]]}return 0})}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){return this.items.length}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return this.pos<this.items.length}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.items=this.items.slice(0,e),this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){return this.items[this.pos++]}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new d(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}const u={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},f={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},m="[aeiouy]",p="([^aeiou][^aeiouy]*)",g="("+m+"[aeiou]*)",x=new RegExp("^"+p+"?"+g+p),y=new RegExp("^"+p+"?"+g+p+g+"?$"),w=new RegExp("^"+p+"?("+g+p+"){2,}"),b=new RegExp("^"+p+"?"+m),I=new RegExp("^"+p+m+"[^aeiouwxy]$"),N=/ll$/,S=/^(.+?)e$/,O=/^(.+?)y$/,v=/^(.+?(s|t))(ion)$/,_=/^(.+?)(ed|ing)$/,$=/(at|bl|iz)$/,E=/^(.+?)eed$/,k=/^.+?[^s]s$/,j=/^.+?(ss|i)es$/,z=/([^aeiouylsz])\1$/,L=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,C=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;function M(e){let t=String(e).toLowerCase();if(t.length<3)return t;let n,s=!1;return 121===t.codePointAt(0)&&(s=!0,t="Y"+t.slice(1)),j.test(t)?t=t.slice(0,-2):k.test(t)&&(t=t.slice(0,-1)),(n=E.exec(t))?x.test(n[1])&&(t=t.slice(0,-1)):(n=_.exec(t))&&b.test(n[1])&&(t=n[1],$.test(t)?t+="e":z.test(t)?t=t.slice(0,-1):I.test(t)&&(t+="e")),(n=O.exec(t))&&b.test(n[1])&&(t=n[1]+"i"),(n=L.exec(t))&&x.test(n[1])&&(t=n[1]+u[n[2]]),(n=C.exec(t))&&x.test(n[1])&&(t=n[1]+f[n[2]]),(n=D.exec(t))?w.test(n[1])&&(t=n[1]):(n=v.exec(t))&&w.test(n[1])&&(t=n[1]),(n=S.exec(t))&&(w.test(n[1])||y.test(n[1])&&!I.test(n[1]))&&(t=n[1]),N.test(t)&&w.test(t)&&(t=t.slice(0,-1)),s&&(t="y"+t.slice(1)),t}const B=new Set(["a","about","after","all","also","am","an","and","another","any","are","around","as","at","be","because","been","before","being","between","both","but","by","came","can","come","could","did","do","each","for","from","get","got","has","had","he","have","her","here","him","himself","his","how","i","if","in","into","is","it","like","make","many","me","might","more","most","much","must","my","never","now","of","on","only","or","other","our","out","over","said","same","see","should","since","some","still","such","take","than","that","the","their","them","then","there","these","they","this","those","through","to","too","under","up","very","was","way","we","well","were","what","where","which","while","who","with","would","you","your"]);class P{constructor(e={}){this.index=new Map,this.documentTerms=new Map,this.documentLengths=new Map,this.useStopWords=!1!==e.useStopWords,this.stopWords=e.stopWords||new Set(B)}_tokenize(e){if("string"!=typeof e)return[];const t=e.toLowerCase().split(/\W+/).filter(e=>e.length>0);return this.useStopWords?t.filter(e=>!this.stopWords.has(e)):t}add(e,t){if(!e)throw new Error("Document ID is required");const n=this._tokenize(t),s=new Map;n.forEach(e=>{const t=M(e);s.set(t,(s.get(t)||0)+1)}),s.forEach((t,n)=>{this.index.has(n)||this.index.set(n,new Map),this.index.get(n).set(e,t)}),this.documentTerms.set(e,s),this.documentLengths.set(e,n.length)}remove(e){if(!this.documentTerms.has(e))return!1;return this.documentTerms.get(e).forEach((t,n)=>{this.index.has(n)&&(this.index.get(n).delete(e),0===this.index.get(n).size&&this.index.delete(n))}),this.documentTerms.delete(e),this.documentLengths.delete(e),!0}query(e,t={scored:!0,requireAll:!1}){const n=this._tokenize(e);if(0===n.length)return[];const s=n.map(e=>M(e)),i=[...new Set(s)];if(t.requireAll){const e=i.map(e=>{const t=this.index.get(e);return t?new Set(t.keys()):new Set});if(0===e.length)return[];const t=new Set(e[0]);for(let n=1;n<e.length;n++)for(const s of t)e[n].has(s)||t.delete(s);return Array.from(t)}const o=this.documentLengths.size,r=new Map;i.forEach(e=>{const t=this.index.get(e)?.size||0;t>0&&r.set(e,Math.log(o/t))});const a=new Map;i.forEach(e=>{const t=this.index.get(e);t&&t.forEach((t,n)=>{a.has(n)||a.set(n,0);const s=t/(this.documentLengths.get(n)||1)*(r.get(e)||0);a.set(n,a.get(n)+s)})}),a.forEach((e,t)=>{const n=this.documentTerms.get(t);if(n){const s=i.filter(e=>n.has(e)).length/i.length;a.set(t,e*(1+s))}});const l=Array.from(a.entries()).map(([e,t])=>({id:e,score:t})).sort((e,t)=>t.score-e.score);return!1===t.scored?l.map(e=>e.id):l}getTermCount(){return this.index.size}getDocumentCount(){return this.documentTerms.size}clear(){this.index.clear(),this.documentTerms.clear(),this.documentLengths.clear()}addStopWords(...e){return e.forEach(e=>this.stopWords.add(e.toLowerCase())),this}removeStopWords(...e){return e.forEach(e=>this.stopWords.delete(e.toLowerCase())),this}setStopWordFiltering(e){return this.useStopWords=e,this}serialize(){const e={};this.index.forEach((t,n)=>{const s={};t.forEach((e,t)=>{s[t]=e}),e[n]=s});const t={};this.documentTerms.forEach((e,n)=>{const s={};e.forEach((e,t)=>{s[t]=e}),t[n]=s});const n={};return this.documentLengths.forEach((e,t)=>{n[t]=e}),{index:e,documentTerms:t,documentLengths:n,useStopWords:this.useStopWords,stopWords:Array.from(this.stopWords)}}deserialize(e){this.index=new Map;for(const t in e.index){const n=new Map;for(const s in e.index[t])n.set(s,e.index[t][s]);this.index.set(t,n)}this.documentTerms=new Map;for(const t in e.documentTerms){const n=new Map;for(const s in e.documentTerms[t])n.set(s,e.documentTerms[t][s]);this.documentTerms.set(t,n)}this.documentLengths=new Map;for(const t in e.documentLengths)this.documentLengths.set(t,e.documentLengths[t]);this.useStopWords=!1!==e.useStopWords,e.stopWords&&(this.stopWords=new Set(e.stopWords))}}function A(e,n){return e instanceof t||n instanceof t?e instanceof t&&n instanceof t||e instanceof t&&"string"==typeof n?e.equals(n):n instanceof t&&"string"==typeof e&&n.equals(e):e==n}function q(e,n,s){let i=e,o=n;switch(e instanceof t&&(i=e.toString()),n instanceof t&&(o=n.toString()),s){case">":return i>o;case">=":return i>=o;case"<":return i<o;case"<=":return i<=o;default:return!1}}function T(e,t){const n=new P;n.add("id",e);return 1===n.query(t,{scored:!1}).length}function F(e,t){try{if(!Array.isArray(t)||2!==t.length)return!1;const n=t[0][0],s=t[0][1],i=t[1][0];return W(e,n,i,t[1][1],s)}catch(n){return!1}}function W(e,t,n,s,i){if(!e)return!1;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){for(const o of e.features)if(o.geometry&&!W(o.geometry,t,n,s,i))return!1;return!0}if("Feature"===e.type&&e.geometry)return W(e.geometry,t,n,s,i);if("Point"===e.type&&e.coordinates){const[o,r]=e.coordinates;if("number"==typeof o&&"number"==typeof r)return o>=t&&o<=n&&r>=s&&r<=i}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){for(const o of e.coordinates)for(const e of o){const o=e[0],r=e[1];if(o<t||o>n||r<s||r>i)return!1}return!0}return!1}function J(e,t){var n=Object.keys(t)[0],s=t[n];if("$"==n.charAt(0)){if("$and"==n)return V(e,s);if("$or"==n)return function(e,t){for(var n=0;n<t.length;n++)if(J(e,t[n]))return!0;return!1}(e,s);if("$not"==n)return function(e,t){return!J(e,t)}(e,s);if("$nor"==n)return function(e,t){for(var n=0;n<t.length;n++)if(J(e,t[n]))return!1;return!0}(e,s);if("$where"==n)return function(e,t){if("function"==typeof t)try{return t.call(e)}catch(n){return!1}else if("string"==typeof t)try{return new Function("return "+t).call(e)}catch(n){return!1}return!1}(e,s);throw{$err:"Can't canonicalize query: BadValue unknown top level operator: "+n,code:17287}}return R(e,n,s)}function R(e,n,s){if("string"==typeof s)return A(i(e,n),s);if("number"==typeof s)return A(i(e,n),s);if("boolean"==typeof s)return A(i(e,n),s);if(s instanceof t)return A(i(e,n),s);if("object"==typeof s){if(s instanceof RegExp)return i(e,n)&&i(e,n).match(s);if(o(s))return i(e,n)&&a(i(e,n),s);var h=Object.keys(s);if("$"==h[0].charAt(0)){for(var c=0;c<h.length;c++){var d=Object.keys(s)[c],u=s[d];if("$eq"==d){if(null==i(e,n)||!A(i(e,n),u))return!1}else if("$gt"==d){if(null==i(e,n)||!q(i(e,n),u,">"))return!1}else if("$gte"==d){if(null==i(e,n)||!q(i(e,n),u,">="))return!1}else if("$lt"==d){if(null==i(e,n)||!q(i(e,n),u,"<"))return!1}else if("$lte"==d){if(null==i(e,n)||!q(i(e,n),u,"<="))return!1}else if("$ne"==d){if(null==i(e,n)||A(i(e,n),u))return!1}else if("$in"==d){if(null==i(e,n)||!r(i(e,n),u))return!1}else if("$nin"==d){if(null==i(e,n)||r(i(e,n),u))return!1}else if("$exists"==d){if(u?null==i(e,n):null!=i(e,n))return!1}else if("$type"==d){if(typeof i(e,n)!=u)return!1}else if("$mod"==d){if(2!=u.length)throw{$err:"Can't canonicalize query: BadValue malformed mod, not enough elements",code:17287};if(null==i(e,n)||i(e,n)%u[0]!=u[1])return!1}else if("$regex"==d){if(null==i(e,n)||!i(e,n).match(u))return!1}else if("$text"==d){if(null==i(e,n)||!T(i(e,n),u))return!1}else if("$geoWithin"==d){if(null==i(e,n)||!F(i(e,n),u))return!1}else if("$not"==d){if(R(e,n,u))return!1}else if("$all"==d){if(null==(I=i(e,n))||!o(I))return!1;for(var f=0;f<u.length;f++)if(!r(u[f],I))return!1}else if("$elemMatch"==d){if(null==(I=i(e,n))||!o(I))return!1;var m=!1;for(f=0;f<I.length;f++){var p=I[f];if("object"!=typeof p||o(p)){for(var g=!0,x=Object.keys(u),y=0;y<x.length;y++){var w=x[y],b=u[w];("$gte"!=w||p>=b)&&("$gt"!=w||p>b)&&("$lte"!=w||p<=b)&&("$lt"!=w||p<b)?"$eq"==w&&p!=b||"$ne"==w&&p==b?g=!1:"$in"!=w||r(p,b)?"$nin"==w&&r(p,b)&&(g=!1):g=!1:g=!1}if(g){m=!0;break}}else if(G(p,u)){m=!0;break}}if(!m)return!1}else{if("$size"!=d)throw{$err:"Can't canonicalize query: BadValue unknown operator: "+d,code:17287};var I;if(null==(I=i(e,n))||!o(I))return!1;if(I.length!=u)return!1}}return!0}return i(e,n)&&l(i(e,n),s)}}function V(e,t){for(var n=0;n<t.length;n++)if(!J(e,t[n]))return!1;return!0}function G(e,t){return V(e,function(e){var t=[];for(var n in e)if(e.hasOwnProperty(n)){var s={};s[n]=e[n],t.push(s)}return t}(t))}function K(e,t,n){for(var s=Object.keys(e),i=0;i<s.length;i++){var o=s[i],r=e[o];if("$inc"==o)for(var a=Object.keys(r),l=0;l<a.length;l++){var h=r[x=a[l]];t[x]=t[x]+h}else if("$mul"==o)for(a=Object.keys(r),l=0;l<a.length;l++){h=r[x=a[l]];t[x]=t[x]*h}else if("$rename"==o)for(a=Object.keys(r),l=0;l<a.length;l++){t[r[x=a[l]]]=t[x],delete t[x]}else if("$setOnInsert"==o&&n)for(a=Object.keys(r),l=0;l<a.length;l++)t[a[l]]=r[a[l]];else if("$set"==o)for(a=Object.keys(r),l=0;l<a.length;l++)t[a[l]]=r[a[l]];else if("$unset"==o)for(a=Object.keys(r),l=0;l<a.length;l++)delete t[a[l]];else if("$min"==o)for(a=Object.keys(r),l=0;l<a.length;l++){h=r[x=a[l]];t[x]=Math.min(t[x],h)}else if("$max"==o)for(a=Object.keys(r),l=0;l<a.length;l++){h=r[x=a[l]];t[x]=Math.max(t[x],h)}else if("$currentDate"==o)for(a=Object.keys(r),l=0;l<a.length;l++)t[a[l]]=new Date;else if("$addToSet"==o)for(a=Object.keys(r),l=0;l<a.length;l++){r=r[x=a[l]];t[x].push(r)}else if("$pop"==o)for(a=Object.keys(r),l=0;l<a.length;l++){1==(r=r[x=a[l]])?t[x].pop():-1==r&&t[x].shift()}else if("$pullAll"==o)for(a=Object.keys(r),l=0;l<a.length;l++){for(var c=t[a[l]],d=r[a[l]],u=[],f=0;f<c.length;f++){for(var m=!1,p=0;p<d.length;p++)if(c[f]==d[p]){m=!0;break}m||u.push(c[f])}t[a[l]]=u}else if("$pushAll"==o)for(a=Object.keys(r),l=0;l<a.length;l++){var g=r[x=a[l]];for(f=0;f<g.length;f++)t[x].push(g[f])}else if("$push"==o)for(a=Object.keys(r),l=0;l<a.length;l++){t[x=a[l]].push(r[x])}else{if("$bit"!=o)throw"unknown update operator: "+o;var x,y=r[x=Object.keys(r)[0]],w=Object.keys(y)[0],b=y[w];if("and"==w)t[x]=t[x]&b;else if("or"==w)t[x]=t[x]|b;else{if("xor"!=w)throw"unknown $bit operator: "+w;t[x]=t[x]^b}}}}function Q(e,t,n){for(var s={_id:n()},i=!0,o=Object.keys(t),r=0;r<o.length;r++)if("$"==o[r].charAt(0)){i=!1;break}if(i)for(r=0;r<o.length;r++)s[o[r]]=t[o[r]];else{var a=Object.keys(e);for(r=0;r<a.length;r++)s[a[r]]=e[a[r]];K(t,s,!0)}return s}class U{constructor(e,t={}){this.keys=e,this.options=t,this.name=t.name||this.generateIndexName(e)}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}add(e){throw new Error("add() must be implemented by subclass")}remove(e){throw new Error("remove() must be implemented by subclass")}update(e,t){this.remove(e),this.add(t)}query(e){throw new Error("query() must be implemented by subclass")}clear(){throw new Error("clear() must be implemented by subclass")}getSpec(){return{name:this.name,key:this.keys}}serialize(){throw new Error("serialize() must be implemented by subclass")}deserialize(e){throw new Error("deserialize() must be implemented by subclass")}}class H extends U{constructor(e,t={}){super(e,t),this.data={}}extractIndexKey(e){const t=Object.keys(this.keys);if(0===t.length)return null;if(1===t.length){const n=i(e,t[0]);return void 0===n?null:JSON.stringify({t:typeof n,v:n})}const n=[];for(let s=0;s<t.length;s++){const o=i(e,t[s]);if(void 0===o)return null;n.push(JSON.stringify(o))}return n.join("\0")}add(e){const t=this.extractIndexKey(e);null!==t&&(this.data[t]||(this.data[t]=[]),this.data[t].push(e._id))}remove(e){const t=this.extractIndexKey(e);if(null!==t&&this.data[t]){const n=this.data[t],s=n.indexOf(e._id);-1!==s&&n.splice(s,1),0===n.length&&delete this.data[t]}}query(e){const t=Object.keys(e),n=Object.keys(this.keys);if(1===n.length){const s=n[0];if(-1!==t.indexOf(s)){const t=e[s];if("object"!=typeof t||null===t){const e=JSON.stringify({t:typeof t,v:t});return this.data[e]||[]}}}return null}clear(){this.data={}}serialize(){return{type:"regular",keys:this.keys,options:this.options,data:this.data}}deserialize(e){this.data=e.data||{}}}class Y extends U{constructor(e,t={}){super(e,t),this.textIndex=new P(t),this.indexedFields=[];for(const n in e)"text"===e[n]&&this.indexedFields.push(n);if(0===this.indexedFields.length)throw new Error('Text index must have at least one field with type "text"')}_extractText(e){const t=[];for(const n of this.indexedFields){const s=i(e,n);null!=s&&t.push(String(s))}return t.join(" ")}add(e){if(!e._id)throw new Error("Document must have an _id field");const t=this._extractText(e);t&&this.textIndex.add(String(e._id),t)}remove(e){e._id&&this.textIndex.remove(String(e._id))}query(e){return null}search(e,t={}){return this.textIndex.query(e,{scored:!1,...t})}clear(){this.textIndex.clear()}getSpec(){return{name:this.name,key:this.keys,textIndexVersion:3,weights:this._getWeights()}}_getWeights(){const e={};for(const t of this.indexedFields)e[t]=1;return e}serialize(){return{type:"text",keys:this.keys,options:this.options,indexedFields:this.indexedFields,textIndexState:this.textIndex.serialize()}}deserialize(e){this.indexedFields=e.indexedFields||[],e.textIndexState&&this.textIndex.deserialize(e.textIndexState)}}function X(e,t,n,s){const i=(n-e)*Math.PI/180,o=(s-t)*Math.PI/180,r=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(o/2)*Math.sin(o/2);return 6371*(2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)))}function Z(e,t){return!(e.maxLat<t.minLat||e.minLat>t.maxLat||e.maxLng<t.minLng||e.minLng>t.maxLng)}function ee(e){return(e.maxLat-e.minLat)*(e.maxLng-e.minLng)}function te(e,t){return{minLat:Math.min(e.minLat,t.minLat),maxLat:Math.max(e.maxLat,t.maxLat),minLng:Math.min(e.minLng,t.minLng),maxLng:Math.max(e.maxLng,t.maxLng)}}function ne(e,t){return ee(te(e,t))-ee(e)}class se{constructor(e=!1){this.isLeaf=e,this.children=[],this.bbox=null}updateBBox(){if(0===this.children.length)return void(this.bbox=null);let e=1/0,t=-1/0,n=1/0,s=-1/0;for(const i of this.children){const o=i.bbox;e=Math.min(e,o.minLat),t=Math.max(t,o.maxLat),n=Math.min(n,o.minLng),s=Math.max(s,o.maxLng)}this.bbox={minLat:e,maxLat:t,minLng:n,maxLng:s}}}class ie{constructor(e=9){this.maxEntries=e,this.minEntries=Math.max(2,Math.ceil(e/2)),this.root=new se(!0),this._size=0}insert(e,t,n){const s={bbox:{minLat:e,maxLat:e,minLng:t,maxLng:t},lat:e,lng:t,data:n};this._insert(s,this.root,1),this._size++}_insert(e,t,n){if(t.isLeaf){if(t.children.push(e),t.updateBBox(),t.children.length>this.maxEntries)return this._split(t)}else{const s=this._chooseSubtree(e.bbox,t),i=this._insert(e,s,n+1);if(i){if(t.children.push(i),t.updateBBox(),t.children.length>this.maxEntries)return this._split(t)}else t.updateBBox()}return null}_chooseSubtree(e,t){let n=1/0,s=1/0,i=null;for(const o of t.children){const t=ne(o.bbox,e),r=ee(o.bbox);(t<n||t===n&&r<s)&&(n=t,s=r,i=o)}return i}_split(e){const t=e.children,n=e.isLeaf;let s=-1/0,i=0,o=1;for(let l=0;l<t.length;l++)for(let e=l+1;e<t.length;e++){const n=t[l].bbox,r=t[e].bbox,a=ee(te(n,r))-ee(n)-ee(r);a>s&&(s=a,i=l,o=e)}const r=new se(n),a=new se(n);r.children.push(t[i]),a.children.push(t[o]);for(let l=0;l<t.length;l++){if(l===i||l===o)continue;const e=t[l],n=e.bbox,s=0===r.children.length?1/0:ne(r.bbox||n,n),h=0===a.children.length?1/0:ne(a.bbox||n,n);if(r.children.length<this.minEntries&&t.length-l+r.children.length<=this.minEntries)r.children.push(e);else if(a.children.length<this.minEntries&&t.length-l+a.children.length<=this.minEntries)a.children.push(e);else if(s<h)r.children.push(e);else if(h<s)a.children.push(e);else{(r.bbox?ee(r.bbox):0)<(a.bbox?ee(a.bbox):0)?r.children.push(e):a.children.push(e)}r.updateBBox(),a.updateBBox()}if(e.children=r.children,e.updateBBox(),e===this.root){const e=new se(!1);return e.children=[r,a],e.updateBBox(),this.root=e,null}return a}searchBBox(e){const t=[];return this._searchBBox(e,this.root,t),t}_searchBBox(e,t,n){if(t.bbox&&Z(e,t.bbox))if(t.isLeaf)for(const s of t.children)Z(e,s.bbox)&&n.push(s);else for(const s of t.children)this._searchBBox(e,s,n)}searchRadius(e,t,n){const s=function(e,t,n){const s=n/111,i=n/(111*Math.cos(e*Math.PI/180));return{minLat:e-s,maxLat:e+s,minLng:t-i,maxLng:t+i}}(e,t,n),i=this.searchBBox(s),o=[];for(const r of i){X(e,t,r.lat,r.lng)<=n&&o.push(r)}return o}remove(e,t,n=null){const s={minLat:e,maxLat:e,minLng:t,maxLng:t},i=this._remove(s,n,this.root,null,-1);return i&&this._size--,1!==this.root.children.length||this.root.isLeaf||(this.root=this.root.children[0]),i}_remove(e,t,n,s,i){if(!n.bbox||!Z(e,n.bbox))return!1;if(n.isLeaf)for(let o=0;o<n.children.length;o++){const r=n.children[o];if(r.lat===e.minLat&&r.lng===e.minLng){if(null===t||JSON.stringify(r.data)===JSON.stringify(t)){if(n.children.splice(o,1),n.updateBBox(),n.children.length<this.minEntries&&n!==this.root){const e=n.children.slice();n.children=[],n.updateBBox(),s&&(s.children.splice(i,1),s.updateBBox());for(const t of e)this._insert(t,this.root,1)}return!0}}}else for(let o=0;o<n.children.length;o++){const s=n.children[o];if(this._remove(e,t,s,n,o))return n.updateBBox(),!0}return!1}getAll(){const e=[];return this._getAll(this.root,e),e}_getAll(e,t){if(e.isLeaf)t.push(...e.children);else for(const n of e.children)this._getAll(n,t)}size(){return this._size}clear(){this.root=new se(!0),this._size=0}serialize(){return{maxEntries:this.maxEntries,minEntries:this.minEntries,size:this._size,root:this._serializeNode(this.root)}}_serializeNode(e){const t={isLeaf:e.isLeaf,bbox:e.bbox,children:[]};return e.isLeaf?t.children=e.children.map(e=>({bbox:e.bbox,lat:e.lat,lng:e.lng,data:e.data})):t.children=e.children.map(e=>this._serializeNode(e)),t}deserialize(e){this.maxEntries=e.maxEntries||9,this.minEntries=e.minEntries||Math.ceil(this.maxEntries/2),this._size=e.size||0,this.root=this._deserializeNode(e.root)}_deserializeNode(e){const t=new se(e.isLeaf);return t.bbox=e.bbox,e.isLeaf?t.children=e.children.map(e=>({bbox:e.bbox,lat:e.lat,lng:e.lng,data:e.data})):t.children=e.children.map(e=>this._deserializeNode(e)),t}}class oe extends U{constructor(e,t={}){super(e,t),this.rtree=new ie,this.geoField=null;for(const n in e)if("2dsphere"===e[n]||"2d"===e[n]){this.geoField=n;break}if(!this.geoField)throw new Error('Geospatial index must have at least one field with type "2dsphere" or "2d"')}_extractCoordinates(e){if(!e)return null;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){const t=e.features[0];if(t.geometry)return this._extractCoordinates(t.geometry)}if("Feature"===e.type&&e.geometry)return this._extractCoordinates(e.geometry);if("Point"===e.type&&e.coordinates){const[t,n]=e.coordinates;if("number"==typeof t&&"number"==typeof n)return{lat:n,lng:t}}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){const t=e.coordinates[0];if(t.length>0){let e=0,n=0;for(const s of t)n+=s[0],e+=s[1];return{lat:e/t.length,lng:n/t.length}}}return null}add(e){if(!e._id)throw new Error("Document must have an _id field");const t=i(e,this.geoField),n=this._extractCoordinates(t);n&&this.rtree.insert(n.lat,n.lng,{_id:e._id,geoJson:t})}remove(e){if(!e._id)return;const t=i(e,this.geoField),n=this._extractCoordinates(t);n&&this.rtree.remove(n.lat,n.lng,{_id:e._id,geoJson:t})}query(e){if(!e[this.geoField])return null;const t=e[this.geoField];if(t.$geoWithin){const e=t.$geoWithin;if(Array.isArray(e)&&2===e.length){const t=e[0][0],n=e[0][1],s=e[1][0],i=e[1][1];return this.rtree.searchBBox({minLat:i,maxLat:n,minLng:t,maxLng:s}).map(e=>e.data._id)}}return null}clear(){this.rtree.clear()}getSpec(){return{name:this.name,key:this.keys,"2dsphereIndexVersion":3}}serialize(){return{type:"geospatial",keys:this.keys,options:this.options,geoField:this.geoField,rtreeState:this.rtree.serialize()}}deserialize(e){this.geoField=e.geoField,e.rtreeState&&this.rtree.deserialize(e.rtreeState)}}class re{constructor(e,t,n){this.db=e,this.storage=t,this.idGenerator=n,this.indexes={},this.isCollection=!0}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}isTextIndex(e){for(const t in e)if("text"===e[t])return!0;return!1}isGeospatialIndex(e){for(const t in e)if("2dsphere"===e[t]||"2d"===e[t])return!0;return!1}buildIndex(e,t,n={}){let s;s=this.isTextIndex(t)?new Y(t,{...n,name:e}):this.isGeospatialIndex(t)?new oe(t,{...n,name:e}):new H(t,{...n,name:e});for(let i=0;i<this.storage.size();i++){const e=this.storage.get(i);e&&s.add(e)}return this.indexes[e]=s,s}updateIndexesOnInsert(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){this.indexes[t].add(e)}}updateIndexesOnDelete(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){this.indexes[t].remove(e)}}planQuery(e){const t=Object.keys(e);for(const n in this.indexes)if(this.indexes.hasOwnProperty(n)){const s=this.indexes[n];if(s instanceof Y)continue;if(s instanceof oe){const t=s.query(e);if(null!==t)return{useIndex:!0,indexName:n,docIds:t};continue}const i=Object.keys(s.keys);if(1===i.length){const o=i[0];if(-1!==t.indexOf(o)){const t=e[o];if("object"!=typeof t||null===t){const t=s.query(e);if(null!==t)return{useIndex:!0,indexName:n,docIds:t}}}}}return null}getTextIndex(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){const n=this.indexes[t];if(n instanceof Y&&n.indexedFields.includes(e))return n}return null}aggregate(e){if(!e||!o(e))throw{$err:"Pipeline must be an array",code:17287};let t=[];const n=this.find({});for(;n.hasNext();)t.push(n.next());for(let r=0;r<e.length;r++){const n=e[r],a=Object.keys(n);if(1!==a.length)throw{$err:"Each pipeline stage must have exactly one key",code:17287};const l=a[0],c=n[l];if("$match"===l){const e=[];for(let n=0;n<t.length;n++)G(t[n],c)&&e.push(t[n]);t=e}else if("$project"===l){const e=[];for(let n=0;n<t.length;n++)e.push(h(c,t[n]));t=e}else if("$sort"===l){const e=Object.keys(c);t.sort(function(t,n){for(let s=0;s<e.length;s++){const i=e[s];if(void 0===t[i]&&void 0!==n[i])return-1*c[i];if(void 0!==t[i]&&void 0===n[i])return 1*c[i];if(t[i]<n[i])return-1*c[i];if(t[i]>n[i])return 1*c[i]}return 0})}else if("$limit"===l)t=t.slice(0,c);else if("$skip"===l)t=t.slice(c);else if("$group"===l){const e={},n=c._id;for(let o=0;o<t.length;o++){const s=t[o];let r;r=null==n?null:"string"==typeof n&&"$"===n.charAt(0)?i(s,n.substring(1)):"object"==typeof n?JSON.stringify(n):n;const a=JSON.stringify(r);e[a]||(e[a]={_id:r,docs:[],accumulators:{}}),e[a].docs.push(s)}const s=[];for(const t in e){const n=e[t],o={_id:n._id};for(const e in c){if("_id"===e)continue;const t=c[e],s=Object.keys(t);if(1!==s.length)continue;const r=s[0],a=t[r];if("$sum"===r){let t=0;for(let e=0;e<n.docs.length;e++)if("number"==typeof a)t+=a;else if("string"==typeof a&&"$"===a.charAt(0)){t+=i(n.docs[e],a.substring(1))||0}o[e]=t}else if("$avg"===r){let t=0,s=0;for(let e=0;e<n.docs.length;e++)if("string"==typeof a&&"$"===a.charAt(0)){const o=i(n.docs[e],a.substring(1));null!=o&&(t+=o,s++)}o[e]=s>0?t/s:0}else if("$min"===r){let t;for(let e=0;e<n.docs.length;e++)if("string"==typeof a&&"$"===a.charAt(0)){const s=i(n.docs[e],a.substring(1));void 0!==s&&(void 0===t||s<t)&&(t=s)}o[e]=t}else if("$max"===r){let t;for(let e=0;e<n.docs.length;e++)if("string"==typeof a&&"$"===a.charAt(0)){const s=i(n.docs[e],a.substring(1));void 0!==s&&(void 0===t||s>t)&&(t=s)}o[e]=t}else if("$push"===r){const t=[];for(let e=0;e<n.docs.length;e++)if("string"==typeof a&&"$"===a.charAt(0)){const s=i(n.docs[e],a.substring(1));t.push(s)}o[e]=t}else if("$addToSet"===r){const t={};for(let e=0;e<n.docs.length;e++)if("string"==typeof a&&"$"===a.charAt(0)){const s=i(n.docs[e],a.substring(1));t[JSON.stringify(s)]=s}const s=[];for(const e in t)s.push(t[e]);o[e]=s}else"$first"===r?n.docs.length>0&&"string"==typeof a&&"$"===a.charAt(0)&&(o[e]=i(n.docs[0],a.substring(1))):"$last"===r&&n.docs.length>0&&"string"==typeof a&&"$"===a.charAt(0)&&(o[e]=i(n.docs[n.docs.length-1],a.substring(1)))}s.push(o)}t=s}else if("$count"===l)t=[{[c]:t.length}];else{if("$unwind"!==l)throw{$err:"Unsupported aggregation stage: "+l,code:17287};{const e=[];let n=c;"string"==typeof n&&"$"===n.charAt(0)&&(n=n.substring(1));for(let r=0;r<t.length;r++){const a=t[r],l=i(a,n);if(l&&o(l)&&l.length>0)for(let t=0;t<l.length;t++){const i=s(a),o=n.split(".");let r=i;for(let e=0;e<o.length-1;e++)r[o[e]]||(r[o[e]]={}),r=r[o[e]];r[o[o.length-1]]=l[t],e.push(i)}}t=e}}}return t}bulkWrite(){throw"Not Implemented"}async count(){return this.storage.size()}async copyTo(e){this.db[e]||this.db.createCollection(e);const t=this.db[e];let n=0;const s=this.find({});for(;s.hasNext();)await t.insertOne(s.next()),n++;return n}async createIndex(e,t){if(!e||"object"!=typeof e||Array.isArray(e))throw{$err:"createIndex requires a key specification object",code:2};const n=t&&t.name?t.name:this.generateIndexName(e);if(this.indexes[n]){const t=this.indexes[n];if(JSON.stringify(t.keys)!==JSON.stringify(e))throw{$err:"Index with name '"+n+"' already exists with a different key specification",code:85};return n}return this.buildIndex(n,e,t),n}dataSize(){throw"Not Implemented"}async deleteOne(e){const t=await this.findOne(e);return t?(this.updateIndexesOnDelete(t),this.storage.remove(t._id),{deletedCount:1}):{deletedCount:0}}async deleteMany(e){const t=this.find(e),n=[],s=[];for(;t.hasNext();){const e=t.next();n.push(e._id),s.push(e)}const i=n.length;for(let o=0;o<n.length;o++)this.updateIndexesOnDelete(s[o]),this.storage.remove(n[o]);return{deletedCount:i}}async distinct(e,t){const n={},s=this.find(t);for(;s.hasNext();){const t=s.next();t[e]&&(n[t[e]]=!0)}return Object.keys(n)}drop(){this.storage.clear();for(const e in this.indexes)this.indexes.hasOwnProperty(e)&&this.indexes[e].clear()}dropIndex(e){if(!this.indexes[e])throw{$err:"Index not found with name: "+e,code:27};return this.indexes[e].clear(),delete this.indexes[e],{nIndexesWas:Object.keys(this.indexes).length+1,ok:1}}dropIndexes(){const e=Object.keys(this.indexes).length;for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&this.indexes[t].clear();return this.indexes={},{nIndexesWas:e,msg:"non-_id indexes dropped",ok:1}}ensureIndex(){throw"Not Implemented"}explain(){throw"Not Implemented"}find(e,t){return new c(this,null==e?{}:e,t,G,this.storage,this.indexes,this.planQuery.bind(this),d)}findAndModify(){throw"Not Implemented"}async findOne(e,t){const n=this.find(e,t);return n.hasNext()?n.next():null}async findOneAndDelete(e,t){let n=this.find(e);if(t&&t.sort&&(n=n.sort(t.sort)),!n.hasNext())return null;const s=n.next();return this.storage.remove(s._id),t&&t.projection?h(t.projection,s):s}async findOneAndReplace(e,t,n){let s=this.find(e);if(n&&n.sort&&(s=s.sort(n.sort)),!s.hasNext())return null;const i=s.next();return t._id=i._id,this.storage.set(i._id,t),n&&n.returnNewDocument?n&&n.projection?h(n.projection,t):t:n&&n.projection?h(n.projection,i):i}async findOneAndUpdate(e,t,n){let s=this.find(e);if(n&&n.sort&&(s=s.sort(n.sort)),!s.hasNext())return null;const i=s.next(),o=Object.assign({},i);return K(t,o),this.storage.set(i._id,o),n&&n.returnNewDocument?n&&n.projection?h(n.projection,o):o:n&&n.projection?h(n.projection,i):i}getIndexes(){const e=[];for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&e.push(this.indexes[t].getSpec());return e}getShardDistribution(){throw"Not Implemented"}getShardVersion(){throw"Not Implemented"}getStore(){return this.storage.getStore()}group(){throw"Not Implemented"}async insert(e){return Array==e.constructor?await this.insertMany(e):await this.insertOne(e)}async insertOne(e){return null==e._id&&(e._id=this.idGenerator()),this.storage.set(e._id,e),this.updateIndexesOnInsert(e),{insertedId:e._id}}async insertMany(e){const t=[];for(let n=0;n<e.length;n++){const s=await this.insertOne(e[n]);t.push(s.insertedId)}return{insertedIds:t}}isCapped(){throw"Not Implemented"}mapReduce(){throw"Not Implemented"}reIndex(){throw"Not Implemented"}async replaceOne(e,t,n){const s={},i=this.find(e);if(s.matchedCount=i.count(),0==s.matchedCount){if(s.modifiedCount=0,n&&n.upsert){const e=t;e._id=this.idGenerator(),this.storage.set(e._id,e),s.upsertedId=e._id}}else{s.modifiedCount=1;const e=i.next();this.updateIndexesOnDelete(e),t._id=e._id,this.storage.set(e._id,t),this.updateIndexesOnInsert(t)}return s}remove(e,t){const n=this.find(e);if(n.hasNext())if(!0===t||t&&t.justOne){const e=n.next();this.updateIndexesOnDelete(e),this.storage.remove(e._id)}else for(;n.hasNext();){const e=n.next();this.updateIndexesOnDelete(e),this.storage.remove(e._id)}}renameCollection(){throw"Not Implemented"}save(){throw"Not Implemented"}stats(){throw"Not Implemented"}storageSize(){throw"Not Implemented"}totalSize(){throw"Not Implemented"}totalIndexSize(){throw"Not Implemented"}update(e,t,n){const s=this.find(e);if(s.hasNext())if(n&&n.multi)for(;s.hasNext();){const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else{const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=Q(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}async updateOne(e,t,n){const s=this.find(e);if(s.hasNext()){const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=Q(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}async updateMany(e,t,n){const s=this.find(e);if(s.hasNext())for(;s.hasNext();){const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=Q(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}validate(){throw"Not Implemented"}exportState(){const e=[];for(let n=0;n<this.storage.size();n++){const t=this.storage.get(n);t&&e.push(t)}const t=[];for(const n in this.indexes)if(this.indexes.hasOwnProperty(n)){const e=this.indexes[n];t.push(e.serialize())}return{documents:e,indexes:t}}async importState(e){this.storage.clear();for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&this.indexes[t].clear();if(this.indexes={},e.documents&&Array.isArray(e.documents))for(const t of e.documents)this.storage.set(t._id,t);if(e.indexes&&Array.isArray(e.indexes))for(const t of e.indexes){let e;"text"===t.type?(e=new Y(t.keys,t.options),e.deserialize(t)):"geospatial"===t.type?(e=new oe(t.keys,t.options),e.deserialize(t)):(e=new H(t.keys,t.options),e.deserialize(t)),this.indexes[e.name]=e}}}class ae{constructor(){if(new.target===ae)throw new TypeError("Cannot construct StorageEngine instances directly")}async initialize(){throw new Error("initialize() must be implemented by subclass")}async saveDatabase(e){throw new Error("saveDatabase() must be implemented by subclass")}async loadDatabase(e){throw new Error("loadDatabase() must be implemented by subclass")}async saveCollection(e,t,n){throw new Error("saveCollection() must be implemented by subclass")}async loadCollection(e,t){throw new Error("loadCollection() must be implemented by subclass")}async deleteCollection(e,t){throw new Error("deleteCollection() must be implemented by subclass")}async deleteDatabase(e){throw new Error("deleteDatabase() must be implemented by subclass")}async close(){throw new Error("close() must be implemented by subclass")}}class le{constructor(e){return this.options=e||{},this.dbName=this.options.dbName||"default",this.storageEngine=this.options.storageEngine||null,"undefined"!=typeof localStorage?this.localStorage=new re(this,this.options.localStorage?this.options.localStorage:ce,this._id.bind(this)):this.localStorage=null,new Proxy(this,{get:(e,t,n)=>t in e?Reflect.get(e,t,n):"symbol"==typeof t||t.startsWith("_")?void 0:"string"==typeof t&&"localStorage"!==t?(Object.prototype.hasOwnProperty.call(e,t)||e.createCollection(t),e[t]):void 0})}_log(e){this.options&&this.options.print?this.options.print(e):console.log(e)}_id(){return this.options&&this.options.id?this.options.id():new t}cloneCollection(){throw"Not Implemented"}cloneDatabase(){throw"Not Implemented"}commandHelp(){throw"Not Implemented"}copyDatabase(){throw"Not Implemented"}createCollection(e){e&&("localStorage"==e?this.localStorage=new re(this,this.options.localStorage?this.options.localStorage:ce,this._id.bind(this)):this[e]=new re(this,this.options&&this.options.storage?new this.options.storage:new de,this._id.bind(this)))}currentOp(){throw"Not Implemented"}dropDatabase(){for(const e in this)null!=this[e]&&this[e].isCollection&&(this[e].drop(),delete this[e])}eval(){throw"Not Implemented"}fsyncLock(){throw"Not Implemented"}fsyncUnlock(){throw"Not Implemented"}getCollection(){throw"Not Implemented"}getCollectionInfos(){throw"Not Implemented"}getCollectionNames(){const e=[];for(const t in this)null!=this[t]&&this[t].isCollection&&e.push(t);return e}getLastError(){throw"Not Implemented"}getLastErrorObj(){throw"Not Implemented"}getLogComponents(){throw"Not Implemented"}getMongo(){throw"Not Implemented"}getName(){throw"Not Implemented"}getPrevError(){throw"Not Implemented"}getProfilingLevel(){throw"Not Implemented"}getProfilingStatus(){throw"Not Implemented"}getReplicationInfo(){throw"Not Implemented"}getSiblingDB(){throw"Not Implemented"}help(){this._log("        help mr                      mapreduce"),this._log("        db.foo.find()                list objects in collection foo"),this._log("        db.foo.find( { a : 1 } )     list objects in foo where a == 1"),this._log("        it                           result of the last line evaluated; use to further iterate")}hostInfo(){throw"Not Implemented"}isMaster(){throw"Not Implemented"}killOp(){throw"Not Implemented"}listCommands(){throw"Not Implemented"}loadServerScripts(){throw"Not Implemented"}logout(){throw"Not Implemented"}printCollectionStats(){throw"Not Implemented"}printReplicationInfo(){throw"Not Implemented"}printShardingStatus(){throw"Not Implemented"}printSlaveReplicationInfo(){throw"Not Implemented"}repairDatabase(){throw"Not Implemented"}resetError(){throw"Not Implemented"}runCommand(){throw"Not Implemented"}serverBuildInfo(){throw"Not Implemented"}serverCmdLineOpts(){throw"Not Implemented"}serverStatus(){throw"Not Implemented"}setLogLevel(){throw"Not Implemented"}setProfilingLevel(){throw"Not Implemented"}shutdownServer(){throw"Not Implemented"}stats(){throw"Not Implemented"}version(){throw"Not Implemented"}upgradeCheck(){throw"Not Implemented"}upgradeCheckAllDBs(){throw"Not Implemented"}async saveToStorage(){if(!this.storageEngine)throw new Error("No storage engine configured. Pass a storageEngine option when creating the DB.");this.storageEngine.initialize&&await this.storageEngine.initialize();const e={};for(const t in this)null!=this[t]&&this[t].isCollection&&(e[t]=this[t].exportState());await this.storageEngine.saveDatabase({name:this.dbName,collections:e})}async loadFromStorage(){if(!this.storageEngine)throw new Error("No storage engine configured. Pass a storageEngine option when creating the DB.");this.storageEngine.initialize&&await this.storageEngine.initialize();const e=await this.storageEngine.loadDatabase(this.dbName);if(e&&e.collections){this.dropDatabase();for(const t in e.collections)e.collections.hasOwnProperty(t)&&(this.createCollection(t),await this[t].importState(e.collections[t]))}}async saveCollection(e){if(!this.storageEngine)throw new Error("No storage engine configured. Pass a storageEngine option when creating the DB.");if(!this[e]||!this[e].isCollection)throw new Error(`Collection '${e}' does not exist`);this.storageEngine.initialize&&await this.storageEngine.initialize();const t=this[e].exportState();await this.storageEngine.saveCollection(this.dbName,e,t)}async loadCollection(e){if(!this.storageEngine)throw new Error("No storage engine configured. Pass a storageEngine option when creating the DB.");this.storageEngine.initialize&&await this.storageEngine.initialize();const t=await this.storageEngine.loadCollection(this.dbName,e);t&&(this[e]||this.createCollection(e),await this[e].importState(t))}}class he{constructor(e,t={}){this.uri=e,this.options=t}static async connect(e,t={}){return new he(e,t)}db(e,t={}){const n={...this.options,...t,dbName:e};return new le(n)}async close(){}}const ce=function(){return{clear:function(){localStorage.clear()},get:function(e){return JSON.parse(localStorage.getItem(localStorage.key(e)))},getStore:function(){return localStorage},remove:function(e){localStorage.removeItem(e)},set:async function(e,t){localStorage.setItem(e,JSON.stringify(t))},size:function(){return localStorage.length}}}(),de=function(){var e={};return{clear:function(){e={}},get:function(t){return e[Object.keys(e)[t]]},getStore:function(){return e},remove:function(t){delete e[t]},set:function(t,n){e[t]=n},size:function(){return Object.keys(e).length}}};e.IndexedDbStorageEngine=class extends ae{constructor(e="micro-mongo"){super(),this.dbName=e,this.db=null,this.indexedDBName=`micro-mongo-${e}`}async initialize(){return new Promise((e,t)=>{const n=indexedDB.open(this.indexedDBName,1);n.onerror=()=>{t(new Error("Failed to open IndexedDB: "+n.error))},n.onsuccess=()=>{this.db=n.result,e()},n.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains("collections")||t.createObjectStore("collections",{keyPath:"name"}),t.objectStoreNames.contains("metadata")||t.createObjectStore("metadata",{keyPath:"key"})}})}async saveDatabase(e){this.db||await this.initialize();const t=this.db.transaction(["metadata"],"readwrite").objectStore("metadata");await new Promise((n,s)=>{const i=t.put({key:"dbName",value:e.name});i.onsuccess=()=>n(),i.onerror=()=>s(i.error)});for(const n in e.collections)e.collections.hasOwnProperty(n)&&await this.saveCollection(e.name,n,e.collections[n])}async loadDatabase(e){this.db||await this.initialize();const t=this.db.transaction(["collections"],"readonly").objectStore("collections");return new Promise((n,s)=>{const i=t.getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.name]={documents:e.documents||[],indexes:e.indexes||[]};n({name:e,collections:t})},i.onerror=()=>s(i.error)})}async saveCollection(e,t,n){this.db||await this.initialize();const s=this.db.transaction(["collections"],"readwrite").objectStore("collections");return new Promise((e,i)=>{const o=s.put({name:t,documents:n.documents||[],indexes:n.indexes||[]});o.onsuccess=()=>e(),o.onerror=()=>i(o.error)})}async loadCollection(e,t){this.db||await this.initialize();const n=this.db.transaction(["collections"],"readonly").objectStore("collections");return new Promise((e,s)=>{const i=n.get(t);i.onsuccess=()=>{i.result?e({documents:i.result.documents||[],indexes:i.result.indexes||[]}):e(null)},i.onerror=()=>s(i.error)})}async deleteCollection(e,t){this.db||await this.initialize();const n=this.db.transaction(["collections"],"readwrite").objectStore("collections");return new Promise((e,s)=>{const i=n.delete(t);i.onsuccess=()=>e(),i.onerror=()=>s(i.error)})}async deleteDatabase(e){return this.db&&(this.db.close(),this.db=null),new Promise((e,t)=>{const n=indexedDB.deleteDatabase(this.indexedDBName);n.onsuccess=()=>e(),n.onerror=()=>t(n.error)})}async close(){this.db&&(this.db.close(),this.db=null)}},e.LocalStorageStore=ce,e.MongoClient=he,e.ObjectId=t,e.ObjectStorageEngine=class extends ae{constructor(){super(),this.databases={}}async initialize(){}async saveDatabase(e){this.databases[e.name]=JSON.parse(JSON.stringify(e))}async loadDatabase(e){return this.databases[e]?JSON.parse(JSON.stringify(this.databases[e])):null}async saveCollection(e,t,n){this.databases[e]||(this.databases[e]={name:e,collections:{}}),this.databases[e].collections[t]=JSON.parse(JSON.stringify(n))}async loadCollection(e,t){return this.databases[e]&&this.databases[e].collections[t]?JSON.parse(JSON.stringify(this.databases[e].collections[t])):null}async deleteCollection(e,t){this.databases[e]&&this.databases[e].collections&&delete this.databases[e].collections[t]}async deleteDatabase(e){delete this.databases[e]}async close(){}},e.ObjectStore=de,e.StorageEngine=ae,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=micro-mongo-1.1.3.min.umd.js.map
