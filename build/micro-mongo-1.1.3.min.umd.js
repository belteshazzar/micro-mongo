!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MicroMongo={})}(this,function(e){"use strict";class t{constructor(e){if(null==e)this.id=t.generate();else if("string"==typeof e){if(!t.isValid(e))throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${e}`);this.id=e.toLowerCase()}else{if(!(e instanceof t))throw new Error("Argument passed in must be a string of 24 hex characters or an ObjectId");this.id=e.id}}toString(){return this.id}toHexString(){return this.id}getTimestamp(){const e=parseInt(this.id.substring(0,8),16);return new Date(1e3*e)}equals(e){return!!e&&(e instanceof t?this.id===e.id:"string"==typeof e?this.id===e.toLowerCase():!!e.id&&this.id===e.id)}toJSON(){return this.id}inspect(){return`ObjectId("${this.id}")`}static isValid(e){return!!e&&("string"==typeof e&&(24===e.length&&/^[0-9a-fA-F]{24}$/.test(e)))}static createFromTime(e){const n=("00000000"+Math.floor(e/1e3).toString(16)).slice(-8);return new t(n+"0000000000000000")}static generate(){const e=Math.floor(Date.now()/1e3),t="undefined"!=typeof crypto&&crypto.getRandomValues?new Uint8Array(8):null;let n="";if(t){crypto.getRandomValues(t);for(let e=0;e<t.length;e++)n+=("0"+t[e].toString(16)).slice(-2)}else n=Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8)+Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8);return(("00000000"+e.toString(16)).slice(-8)+n).slice(0,24)}}function n(e,n){return e instanceof t||n instanceof t?e instanceof t&&n instanceof t||e instanceof t&&"string"==typeof n?e.equals(n):n instanceof t&&"string"==typeof e&&n.equals(e):e==n}function s(e){if(e instanceof t)return new t(e.id);var n,i,r;for(r in n=Array.isArray(e)?[]:{},e)i=e[r],n[r]="object"==typeof i&&null!==i?s(i):i;return n}function i(e,t){for(var n=t.split("."),s=e[n[0]],i=1;i<n.length;i++){if(null==s||null==s)return s;s=s[n[i]]}return s}function r(e){return Array==e.constructor}function o(e,t){for(var s=0;s<t.length;s++)if(n(t[s],e))return!0;return!1}function l(e,t){if(e.length!=t.length)return!1;for(var s=0;s<e.length;s++)if(!n(e[s],t[s])){if(typeof e[s]!=typeof t[s])return!1;if("object"==typeof e[s]&&null!==e[s]){if(r(e[s])){if(!l(e[s],t[s]))return!1}else if(!h(e[s],t[s]))return!1}else if(!n(e[s],t[s]))return!1}return!0}function h(e,t){for(var s in e)if(e.hasOwnProperty(s)){if(!t.hasOwnProperty(s))return!1;if(!n(e[s],t[s])){if(typeof e[s]!=typeof t[s])return!1;if("object"==typeof e[s]&&null!==e[s]){if(r(e[s])){if(!l(e[s],t[s]))return!1}else if(!h(e[s],t[s]))return!1}else if(!n(e[s],t[s]))return!1}}for(var s in t)if(t.hasOwnProperty(s)&&!e.hasOwnProperty(s))return!1;return!0}function a(e,t){var n={},s=Object.keys(e);if(0==s.length)return t;for(var i=!1,r=!1,o=0;o<s.length;o++)"_id"!==s[o]&&(e[s[o]]?i=!0:r=!0);if(i&&r)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287};if(e[s[0]]||i){0!==e._id&&(n._id=t._id);for(o=0;o<s.length;o++)"_id"!==s[o]&&e[s[o]]&&(n[s[o]]=t[s[o]])}else{for(var l in t)n[l]=t[l];for(o=0;o<s.length;o++)e[s[o]]||delete n[s[o]]}return n}class c{constructor(e,t,n,s,i,r,o,l){if(this.collection=e,this.query=t,this.projection=n,this.matches=s,this.storage=i,this.indexes=r,this.planQuery=o,this.SortedCursor=l,n&&Object.keys(n).length>0){const e=Object.keys(n);let t=!1,s=!1;for(let i=0;i<e.length;i++)"_id"!==e[i]&&(n[e[i]]?t=!0:s=!0);if(t&&s)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287}}this.pos=0,this.max=0,this._next=!1;const h=this.planQuery(this.query);this.indexDocIds=null,this.indexPos=0,this.fullScanDocIds={},h&&h.useIndex&&(this.indexDocIds=h.docIds?h.docIds.slice():[]),this._findNext()}_findNext(){for(;null!==this.indexDocIds&&this.indexPos<this.indexDocIds.length;){const e=this.indexDocIds[this.indexPos++],t=this.storage.getStore()[e];if(t&&this.matches(t,this.query))return this.fullScanDocIds[t._id]=!0,void(this._next=t)}for(;this.pos<this.storage.size()&&(0==this.max||this.pos<this.max);){const e=this.storage.get(this.pos++);if(e&&!this.fullScanDocIds[e._id]&&this.matches(e,this.query))return this.fullScanDocIds[e._id]=!0,void(this._next=e)}this._next=null}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){let e=0;const t=new c(this.collection,this.query,null,this.matches,this.storage,this.indexes,this.planQuery,this.SortedCursor);for(;t.hasNext();)e++,t.next();return e}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return!1===this._next&&this._findNext(),null!=this._next}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.max=e,this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){if(null==this._next)throw"Error: error hasNext: false";const e=this._next;return this._findNext(),this.projection?a(this.projection,e):e}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new this.SortedCursor(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}class d{constructor(e,t,n,s){for(this.collection=e,this.query=t,this.sortSpec=s,this.pos=0,this.items=[];n.hasNext();)this.items.push(n.next());const i=Object.keys(s);this.items.sort(function(e,t){for(let n=0;n<i.length;n++){if(null==e[i[n]]&&null!=t[i[n]])return-1*s[i[n]];if(null!=e[i[n]]&&null==t[i[n]])return 1*s[i[n]];if(e[i[n]]<t[i[n]])return-1*s[i[n]];if(e[i[n]]>t[i[n]])return 1*s[i[n]]}return 0})}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){return this.items.length}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return this.pos<this.items.length}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.items=this.items.slice(0,e),this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){return this.items[this.pos++]}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new d(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}const u={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},f={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},m="[aeiouy]",p="([^aeiou][^aeiouy]*)",g="("+m+"[aeiou]*)",x=new RegExp("^"+p+"?"+g+p),y=new RegExp("^"+p+"?"+g+p+g+"?$"),w=new RegExp("^"+p+"?("+g+p+"){2,}"),I=new RegExp("^"+p+"?"+m),b=new RegExp("^"+p+m+"[^aeiouwxy]$"),N=/ll$/,_=/^(.+?)e$/,O=/^(.+?)y$/,v=/^(.+?(s|t))(ion)$/,$=/^(.+?)(ed|ing)$/,S=/(at|bl|iz)$/,j=/^(.+?)eed$/,k=/^.+?[^s]s$/,L=/^.+?(ss|i)es$/,C=/([^aeiouylsz])\1$/,M=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,B=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,A=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;function E(e){let t=String(e).toLowerCase();if(t.length<3)return t;let n,s=!1;return 121===t.codePointAt(0)&&(s=!0,t="Y"+t.slice(1)),L.test(t)?t=t.slice(0,-2):k.test(t)&&(t=t.slice(0,-1)),(n=j.exec(t))?x.test(n[1])&&(t=t.slice(0,-1)):(n=$.exec(t))&&I.test(n[1])&&(t=n[1],S.test(t)?t+="e":C.test(t)?t=t.slice(0,-1):b.test(t)&&(t+="e")),(n=O.exec(t))&&I.test(n[1])&&(t=n[1]+"i"),(n=M.exec(t))&&x.test(n[1])&&(t=n[1]+u[n[2]]),(n=B.exec(t))&&x.test(n[1])&&(t=n[1]+f[n[2]]),(n=A.exec(t))?w.test(n[1])&&(t=n[1]):(n=v.exec(t))&&w.test(n[1])&&(t=n[1]),(n=_.exec(t))&&(w.test(n[1])||y.test(n[1])&&!b.test(n[1]))&&(t=n[1]),N.test(t)&&w.test(t)&&(t=t.slice(0,-1)),s&&(t="y"+t.slice(1)),t}const z=new Set(["a","about","after","all","also","am","an","and","another","any","are","around","as","at","be","because","been","before","being","between","both","but","by","came","can","come","could","did","do","each","for","from","get","got","has","had","he","have","her","here","him","himself","his","how","i","if","in","into","is","it","like","make","many","me","might","more","most","much","must","my","never","now","of","on","only","or","other","our","out","over","said","same","see","should","since","some","still","such","take","than","that","the","their","them","then","there","these","they","this","those","through","to","too","under","up","very","was","way","we","well","were","what","where","which","while","who","with","would","you","your"]);class P{constructor(e={}){this.index=new Map,this.documentTerms=new Map,this.documentLengths=new Map,this.useStopWords=!1!==e.useStopWords,this.stopWords=e.stopWords||new Set(z)}_tokenize(e){if("string"!=typeof e)return[];const t=e.toLowerCase().split(/\W+/).filter(e=>e.length>0);return this.useStopWords?t.filter(e=>!this.stopWords.has(e)):t}add(e,t){if(!e)throw new Error("Document ID is required");const n=this._tokenize(t),s=new Map;n.forEach(e=>{const t=E(e);s.set(t,(s.get(t)||0)+1)}),s.forEach((t,n)=>{this.index.has(n)||this.index.set(n,new Map),this.index.get(n).set(e,t)}),this.documentTerms.set(e,s),this.documentLengths.set(e,n.length)}remove(e){if(!this.documentTerms.has(e))return!1;return this.documentTerms.get(e).forEach((t,n)=>{this.index.has(n)&&(this.index.get(n).delete(e),0===this.index.get(n).size&&this.index.delete(n))}),this.documentTerms.delete(e),this.documentLengths.delete(e),!0}query(e,t={scored:!0,requireAll:!1}){const n=this._tokenize(e);if(0===n.length)return[];const s=n.map(e=>E(e)),i=[...new Set(s)];if(t.requireAll){const e=i.map(e=>{const t=this.index.get(e);return t?new Set(t.keys()):new Set});if(0===e.length)return[];const t=new Set(e[0]);for(let n=1;n<e.length;n++)for(const s of t)e[n].has(s)||t.delete(s);return Array.from(t)}const r=this.documentLengths.size,o=new Map;i.forEach(e=>{const t=this.index.get(e)?.size||0;t>0&&o.set(e,Math.log(r/t))});const l=new Map;i.forEach(e=>{const t=this.index.get(e);t&&t.forEach((t,n)=>{l.has(n)||l.set(n,0);const s=t/(this.documentLengths.get(n)||1)*(o.get(e)||0);l.set(n,l.get(n)+s)})}),l.forEach((e,t)=>{const n=this.documentTerms.get(t);if(n){const s=i.filter(e=>n.has(e)).length/i.length;l.set(t,e*(1+s))}});const h=Array.from(l.entries()).map(([e,t])=>({id:e,score:t})).sort((e,t)=>t.score-e.score);return!1===t.scored?h.map(e=>e.id):h}getTermCount(){return this.index.size}getDocumentCount(){return this.documentTerms.size}clear(){this.index.clear(),this.documentTerms.clear(),this.documentLengths.clear()}addStopWords(...e){return e.forEach(e=>this.stopWords.add(e.toLowerCase())),this}removeStopWords(...e){return e.forEach(e=>this.stopWords.delete(e.toLowerCase())),this}setStopWordFiltering(e){return this.useStopWords=e,this}}function D(e,n){return e instanceof t||n instanceof t?e instanceof t&&n instanceof t||e instanceof t&&"string"==typeof n?e.equals(n):n instanceof t&&"string"==typeof e&&n.equals(e):e==n}function q(e,n,s){let i=e,r=n;switch(e instanceof t&&(i=e.toString()),n instanceof t&&(r=n.toString()),s){case">":return i>r;case">=":return i>=r;case"<":return i<r;case"<=":return i<=r;default:return!1}}function T(e,t){const n=new P;n.add("id",e);return 1===n.query(t,{scored:!1}).length}function W(e,t){try{if(!Array.isArray(t)||2!==t.length)return!1;const n=t[0][0],s=t[0][1],i=t[1][0];return F(e,n,i,t[1][1],s)}catch(n){return!1}}function F(e,t,n,s,i){if(!e)return!1;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){for(const r of e.features)if(r.geometry&&!F(r.geometry,t,n,s,i))return!1;return!0}if("Feature"===e.type&&e.geometry)return F(e.geometry,t,n,s,i);if("Point"===e.type&&e.coordinates){const[r,o]=e.coordinates;if("number"==typeof r&&"number"==typeof o)return r>=t&&r<=n&&o>=s&&o<=i}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){for(const r of e.coordinates)for(const e of r){const r=e[0],o=e[1];if(r<t||r>n||o<s||o>i)return!1}return!0}return!1}function R(e,t){var n=Object.keys(t)[0],s=t[n];if("$"==n.charAt(0)){if("$and"==n)return V(e,s);if("$or"==n)return function(e,t){for(var n=0;n<t.length;n++)if(R(e,t[n]))return!0;return!1}(e,s);if("$not"==n)return function(e,t){return!R(e,t)}(e,s);if("$nor"==n)return function(e,t){for(var n=0;n<t.length;n++)if(R(e,t[n]))return!1;return!0}(e,s);if("$where"==n)return function(e,t){if("function"==typeof t)try{return t.call(e)}catch(n){return!1}else if("string"==typeof t)try{return new Function("return "+t).call(e)}catch(n){return!1}return!1}(e,s);throw{$err:"Can't canonicalize query: BadValue unknown top level operator: "+n,code:17287}}return J(e,n,s)}function J(e,n,s){if("string"==typeof s)return D(i(e,n),s);if("number"==typeof s)return D(i(e,n),s);if("boolean"==typeof s)return D(i(e,n),s);if(s instanceof t)return D(i(e,n),s);if("object"==typeof s){if(s instanceof RegExp)return i(e,n)&&i(e,n).match(s);if(r(s))return i(e,n)&&l(i(e,n),s);var a=Object.keys(s);if("$"==a[0].charAt(0)){for(var c=0;c<a.length;c++){var d=Object.keys(s)[c],u=s[d];if("$eq"==d){if(null==i(e,n)||!D(i(e,n),u))return!1}else if("$gt"==d){if(null==i(e,n)||!q(i(e,n),u,">"))return!1}else if("$gte"==d){if(null==i(e,n)||!q(i(e,n),u,">="))return!1}else if("$lt"==d){if(null==i(e,n)||!q(i(e,n),u,"<"))return!1}else if("$lte"==d){if(null==i(e,n)||!q(i(e,n),u,"<="))return!1}else if("$ne"==d){if(null==i(e,n)||D(i(e,n),u))return!1}else if("$in"==d){if(null==i(e,n)||!o(i(e,n),u))return!1}else if("$nin"==d){if(null==i(e,n)||o(i(e,n),u))return!1}else if("$exists"==d){if(u?null==i(e,n):null!=i(e,n))return!1}else if("$type"==d){if(typeof i(e,n)!=u)return!1}else if("$mod"==d){if(2!=u.length)throw{$err:"Can't canonicalize query: BadValue malformed mod, not enough elements",code:17287};if(null==i(e,n)||i(e,n)%u[0]!=u[1])return!1}else if("$regex"==d){if(null==i(e,n)||!i(e,n).match(u))return!1}else if("$text"==d){if(null==i(e,n)||!T(i(e,n),u))return!1}else if("$geoWithin"==d){if(null==i(e,n)||!W(i(e,n),u))return!1}else if("$not"==d){if(J(e,n,u))return!1}else if("$all"==d){if(null==(b=i(e,n))||!r(b))return!1;for(var f=0;f<u.length;f++)if(!o(u[f],b))return!1}else if("$elemMatch"==d){if(null==(b=i(e,n))||!r(b))return!1;var m=!1;for(f=0;f<b.length;f++){var p=b[f];if("object"!=typeof p||r(p)){for(var g=!0,x=Object.keys(u),y=0;y<x.length;y++){var w=x[y],I=u[w];("$gte"!=w||p>=I)&&("$gt"!=w||p>I)&&("$lte"!=w||p<=I)&&("$lt"!=w||p<I)?"$eq"==w&&p!=I||"$ne"==w&&p==I?g=!1:"$in"!=w||o(p,I)?"$nin"==w&&o(p,I)&&(g=!1):g=!1:g=!1}if(g){m=!0;break}}else if(G(p,u)){m=!0;break}}if(!m)return!1}else{if("$size"!=d)throw{$err:"Can't canonicalize query: BadValue unknown operator: "+d,code:17287};var b;if(null==(b=i(e,n))||!r(b))return!1;if(b.length!=u)return!1}}return!0}return i(e,n)&&h(i(e,n),s)}}function V(e,t){for(var n=0;n<t.length;n++)if(!R(e,t[n]))return!1;return!0}function G(e,t){return V(e,function(e){var t=[];for(var n in e)if(e.hasOwnProperty(n)){var s={};s[n]=e[n],t.push(s)}return t}(t))}function K(e,t,n){for(var s=Object.keys(e),i=0;i<s.length;i++){var r=s[i],o=e[r];if("$inc"==r)for(var l=Object.keys(o),h=0;h<l.length;h++){var a=o[x=l[h]];t[x]=t[x]+a}else if("$mul"==r)for(l=Object.keys(o),h=0;h<l.length;h++){a=o[x=l[h]];t[x]=t[x]*a}else if("$rename"==r)for(l=Object.keys(o),h=0;h<l.length;h++){t[o[x=l[h]]]=t[x],delete t[x]}else if("$setOnInsert"==r&&n)for(l=Object.keys(o),h=0;h<l.length;h++)t[l[h]]=o[l[h]];else if("$set"==r)for(l=Object.keys(o),h=0;h<l.length;h++)t[l[h]]=o[l[h]];else if("$unset"==r)for(l=Object.keys(o),h=0;h<l.length;h++)delete t[l[h]];else if("$min"==r)for(l=Object.keys(o),h=0;h<l.length;h++){a=o[x=l[h]];t[x]=Math.min(t[x],a)}else if("$max"==r)for(l=Object.keys(o),h=0;h<l.length;h++){a=o[x=l[h]];t[x]=Math.max(t[x],a)}else if("$currentDate"==r)for(l=Object.keys(o),h=0;h<l.length;h++)t[l[h]]=new Date;else if("$addToSet"==r)for(l=Object.keys(o),h=0;h<l.length;h++){o=o[x=l[h]];t[x].push(o)}else if("$pop"==r)for(l=Object.keys(o),h=0;h<l.length;h++){1==(o=o[x=l[h]])?t[x].pop():-1==o&&t[x].shift()}else if("$pullAll"==r)for(l=Object.keys(o),h=0;h<l.length;h++){for(var c=t[l[h]],d=o[l[h]],u=[],f=0;f<c.length;f++){for(var m=!1,p=0;p<d.length;p++)if(c[f]==d[p]){m=!0;break}m||u.push(c[f])}t[l[h]]=u}else if("$pushAll"==r)for(l=Object.keys(o),h=0;h<l.length;h++){var g=o[x=l[h]];for(f=0;f<g.length;f++)t[x].push(g[f])}else if("$push"==r)for(l=Object.keys(o),h=0;h<l.length;h++){t[x=l[h]].push(o[x])}else{if("$bit"!=r)throw"unknown update operator: "+r;var x,y=o[x=Object.keys(o)[0]],w=Object.keys(y)[0],I=y[w];if("and"==w)t[x]=t[x]&I;else if("or"==w)t[x]=t[x]|I;else{if("xor"!=w)throw"unknown $bit operator: "+w;t[x]=t[x]^I}}}}function Q(e,t,n){for(var s={_id:n()},i=!0,r=Object.keys(t),o=0;o<r.length;o++)if("$"==r[o].charAt(0)){i=!1;break}if(i)for(o=0;o<r.length;o++)s[r[o]]=t[r[o]];else{var l=Object.keys(e);for(o=0;o<l.length;o++)s[l[o]]=e[l[o]];K(t,s,!0)}return s}class U{constructor(e,t={}){this.keys=e,this.options=t,this.name=t.name||this.generateIndexName(e)}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}add(e){throw new Error("add() must be implemented by subclass")}remove(e){throw new Error("remove() must be implemented by subclass")}update(e,t){this.remove(e),this.add(t)}query(e){throw new Error("query() must be implemented by subclass")}clear(){throw new Error("clear() must be implemented by subclass")}getSpec(){return{name:this.name,key:this.keys}}}class H extends U{constructor(e,t={}){super(e,t),this.data={}}extractIndexKey(e){const t=Object.keys(this.keys);if(0===t.length)return null;if(1===t.length){const n=i(e,t[0]);return void 0===n?null:JSON.stringify({t:typeof n,v:n})}const n=[];for(let s=0;s<t.length;s++){const r=i(e,t[s]);if(void 0===r)return null;n.push(JSON.stringify(r))}return n.join("\0")}add(e){const t=this.extractIndexKey(e);null!==t&&(this.data[t]||(this.data[t]=[]),this.data[t].push(e._id))}remove(e){const t=this.extractIndexKey(e);if(null!==t&&this.data[t]){const n=this.data[t],s=n.indexOf(e._id);-1!==s&&n.splice(s,1),0===n.length&&delete this.data[t]}}query(e){const t=Object.keys(e),n=Object.keys(this.keys);if(1===n.length){const s=n[0];if(-1!==t.indexOf(s)){const t=e[s];if("object"!=typeof t||null===t){const e=JSON.stringify({t:typeof t,v:t});return this.data[e]||[]}}}return null}clear(){this.data={}}}class Y extends U{constructor(e,t={}){super(e,t),this.textIndex=new P(t),this.indexedFields=[];for(const n in e)"text"===e[n]&&this.indexedFields.push(n);if(0===this.indexedFields.length)throw new Error('Text index must have at least one field with type "text"')}_extractText(e){const t=[];for(const n of this.indexedFields){const s=i(e,n);null!=s&&t.push(String(s))}return t.join(" ")}add(e){if(!e._id)throw new Error("Document must have an _id field");const t=this._extractText(e);t&&this.textIndex.add(String(e._id),t)}remove(e){e._id&&this.textIndex.remove(String(e._id))}query(e){return null}search(e,t={}){return this.textIndex.query(e,{scored:!1,...t})}clear(){this.textIndex.clear()}getSpec(){return{name:this.name,key:this.keys,textIndexVersion:3,weights:this._getWeights()}}_getWeights(){const e={};for(const t of this.indexedFields)e[t]=1;return e}}function X(e,t,n,s){const i=(n-e)*Math.PI/180,r=(s-t)*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(r/2)*Math.sin(r/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}function Z(e,t){return!(e.maxLat<t.minLat||e.minLat>t.maxLat||e.maxLng<t.minLng||e.minLng>t.maxLng)}function ee(e){return(e.maxLat-e.minLat)*(e.maxLng-e.minLng)}function te(e,t){return{minLat:Math.min(e.minLat,t.minLat),maxLat:Math.max(e.maxLat,t.maxLat),minLng:Math.min(e.minLng,t.minLng),maxLng:Math.max(e.maxLng,t.maxLng)}}function ne(e,t){return ee(te(e,t))-ee(e)}class se{constructor(e=!1){this.isLeaf=e,this.children=[],this.bbox=null}updateBBox(){if(0===this.children.length)return void(this.bbox=null);let e=1/0,t=-1/0,n=1/0,s=-1/0;for(const i of this.children){const r=i.bbox;e=Math.min(e,r.minLat),t=Math.max(t,r.maxLat),n=Math.min(n,r.minLng),s=Math.max(s,r.maxLng)}this.bbox={minLat:e,maxLat:t,minLng:n,maxLng:s}}}class ie{constructor(e=9){this.maxEntries=e,this.minEntries=Math.max(2,Math.ceil(e/2)),this.root=new se(!0),this._size=0}insert(e,t,n){const s={bbox:{minLat:e,maxLat:e,minLng:t,maxLng:t},lat:e,lng:t,data:n};this._insert(s,this.root,1),this._size++}_insert(e,t,n){if(t.isLeaf){if(t.children.push(e),t.updateBBox(),t.children.length>this.maxEntries)return this._split(t)}else{const s=this._chooseSubtree(e.bbox,t),i=this._insert(e,s,n+1);if(i){if(t.children.push(i),t.updateBBox(),t.children.length>this.maxEntries)return this._split(t)}else t.updateBBox()}return null}_chooseSubtree(e,t){let n=1/0,s=1/0,i=null;for(const r of t.children){const t=ne(r.bbox,e),o=ee(r.bbox);(t<n||t===n&&o<s)&&(n=t,s=o,i=r)}return i}_split(e){const t=e.children,n=e.isLeaf;let s=-1/0,i=0,r=1;for(let h=0;h<t.length;h++)for(let e=h+1;e<t.length;e++){const n=t[h].bbox,o=t[e].bbox,l=ee(te(n,o))-ee(n)-ee(o);l>s&&(s=l,i=h,r=e)}const o=new se(n),l=new se(n);o.children.push(t[i]),l.children.push(t[r]);for(let h=0;h<t.length;h++){if(h===i||h===r)continue;const e=t[h],n=e.bbox,s=0===o.children.length?1/0:ne(o.bbox||n,n),a=0===l.children.length?1/0:ne(l.bbox||n,n);if(o.children.length<this.minEntries&&t.length-h+o.children.length<=this.minEntries)o.children.push(e);else if(l.children.length<this.minEntries&&t.length-h+l.children.length<=this.minEntries)l.children.push(e);else if(s<a)o.children.push(e);else if(a<s)l.children.push(e);else{(o.bbox?ee(o.bbox):0)<(l.bbox?ee(l.bbox):0)?o.children.push(e):l.children.push(e)}o.updateBBox(),l.updateBBox()}if(e.children=o.children,e.updateBBox(),e===this.root){const e=new se(!1);return e.children=[o,l],e.updateBBox(),this.root=e,null}return l}searchBBox(e){const t=[];return this._searchBBox(e,this.root,t),t}_searchBBox(e,t,n){if(t.bbox&&Z(e,t.bbox))if(t.isLeaf)for(const s of t.children)Z(e,s.bbox)&&n.push(s);else for(const s of t.children)this._searchBBox(e,s,n)}searchRadius(e,t,n){const s=function(e,t,n){const s=n/111,i=n/(111*Math.cos(e*Math.PI/180));return{minLat:e-s,maxLat:e+s,minLng:t-i,maxLng:t+i}}(e,t,n),i=this.searchBBox(s),r=[];for(const o of i){X(e,t,o.lat,o.lng)<=n&&r.push(o)}return r}remove(e,t,n=null){const s={minLat:e,maxLat:e,minLng:t,maxLng:t},i=this._remove(s,n,this.root,null,-1);return i&&this._size--,1!==this.root.children.length||this.root.isLeaf||(this.root=this.root.children[0]),i}_remove(e,t,n,s,i){if(!n.bbox||!Z(e,n.bbox))return!1;if(n.isLeaf)for(let r=0;r<n.children.length;r++){const o=n.children[r];if(o.lat===e.minLat&&o.lng===e.minLng){if(null===t||JSON.stringify(o.data)===JSON.stringify(t)){if(n.children.splice(r,1),n.updateBBox(),n.children.length<this.minEntries&&n!==this.root){const e=n.children.slice();n.children=[],n.updateBBox(),s&&(s.children.splice(i,1),s.updateBBox());for(const t of e)this._insert(t,this.root,1)}return!0}}}else for(let r=0;r<n.children.length;r++){const s=n.children[r];if(this._remove(e,t,s,n,r))return n.updateBBox(),!0}return!1}getAll(){const e=[];return this._getAll(this.root,e),e}_getAll(e,t){if(e.isLeaf)t.push(...e.children);else for(const n of e.children)this._getAll(n,t)}size(){return this._size}clear(){this.root=new se(!0),this._size=0}}class re extends U{constructor(e,t={}){super(e,t),this.rtree=new ie,this.geoField=null;for(const n in e)if("2dsphere"===e[n]||"2d"===e[n]){this.geoField=n;break}if(!this.geoField)throw new Error('Geospatial index must have at least one field with type "2dsphere" or "2d"')}_extractCoordinates(e){if(!e)return null;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){const t=e.features[0];if(t.geometry)return this._extractCoordinates(t.geometry)}if("Feature"===e.type&&e.geometry)return this._extractCoordinates(e.geometry);if("Point"===e.type&&e.coordinates){const[t,n]=e.coordinates;if("number"==typeof t&&"number"==typeof n)return{lat:n,lng:t}}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){const t=e.coordinates[0];if(t.length>0){let e=0,n=0;for(const s of t)n+=s[0],e+=s[1];return{lat:e/t.length,lng:n/t.length}}}return null}add(e){if(!e._id)throw new Error("Document must have an _id field");const t=i(e,this.geoField),n=this._extractCoordinates(t);n&&this.rtree.insert(n.lat,n.lng,{_id:e._id,geoJson:t})}remove(e){if(!e._id)return;const t=i(e,this.geoField),n=this._extractCoordinates(t);n&&this.rtree.remove(n.lat,n.lng,{_id:e._id,geoJson:t})}query(e){if(!e[this.geoField])return null;const t=e[this.geoField];if(t.$geoWithin){const e=t.$geoWithin;if(Array.isArray(e)&&2===e.length){const t=e[0][0],n=e[0][1],s=e[1][0],i=e[1][1];return this.rtree.searchBBox({minLat:i,maxLat:n,minLng:t,maxLng:s}).map(e=>e.data._id)}}return null}clear(){this.rtree.clear()}getSpec(){return{name:this.name,key:this.keys,"2dsphereIndexVersion":3}}}class oe{constructor(e,t,n){this.db=e,this.storage=t,this.idGenerator=n,this.indexes={},this.isCollection=!0}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}isTextIndex(e){for(const t in e)if("text"===e[t])return!0;return!1}isGeospatialIndex(e){for(const t in e)if("2dsphere"===e[t]||"2d"===e[t])return!0;return!1}buildIndex(e,t,n={}){let s;s=this.isTextIndex(t)?new Y(t,{...n,name:e}):this.isGeospatialIndex(t)?new re(t,{...n,name:e}):new H(t,{...n,name:e});for(let i=0;i<this.storage.size();i++){const e=this.storage.get(i);e&&s.add(e)}return this.indexes[e]=s,s}updateIndexesOnInsert(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){this.indexes[t].add(e)}}updateIndexesOnDelete(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){this.indexes[t].remove(e)}}planQuery(e){const t=Object.keys(e);for(const n in this.indexes)if(this.indexes.hasOwnProperty(n)){const s=this.indexes[n];if(s instanceof Y)continue;if(s instanceof re){const t=s.query(e);if(null!==t)return{useIndex:!0,indexName:n,docIds:t};continue}const i=Object.keys(s.keys);if(1===i.length){const r=i[0];if(-1!==t.indexOf(r)){const t=e[r];if("object"!=typeof t||null===t){const t=s.query(e);if(null!==t)return{useIndex:!0,indexName:n,docIds:t}}}}}return null}getTextIndex(e){for(const t in this.indexes)if(this.indexes.hasOwnProperty(t)){const n=this.indexes[t];if(n instanceof Y&&n.indexedFields.includes(e))return n}return null}aggregate(e){if(!e||!r(e))throw{$err:"Pipeline must be an array",code:17287};let t=[];const n=this.find({});for(;n.hasNext();)t.push(n.next());for(let o=0;o<e.length;o++){const n=e[o],l=Object.keys(n);if(1!==l.length)throw{$err:"Each pipeline stage must have exactly one key",code:17287};const h=l[0],c=n[h];if("$match"===h){const e=[];for(let n=0;n<t.length;n++)G(t[n],c)&&e.push(t[n]);t=e}else if("$project"===h){const e=[];for(let n=0;n<t.length;n++)e.push(a(c,t[n]));t=e}else if("$sort"===h){const e=Object.keys(c);t.sort(function(t,n){for(let s=0;s<e.length;s++){const i=e[s];if(void 0===t[i]&&void 0!==n[i])return-1*c[i];if(void 0!==t[i]&&void 0===n[i])return 1*c[i];if(t[i]<n[i])return-1*c[i];if(t[i]>n[i])return 1*c[i]}return 0})}else if("$limit"===h)t=t.slice(0,c);else if("$skip"===h)t=t.slice(c);else if("$group"===h){const e={},n=c._id;for(let r=0;r<t.length;r++){const s=t[r];let o;o=null==n?null:"string"==typeof n&&"$"===n.charAt(0)?i(s,n.substring(1)):"object"==typeof n?JSON.stringify(n):n;const l=JSON.stringify(o);e[l]||(e[l]={_id:o,docs:[],accumulators:{}}),e[l].docs.push(s)}const s=[];for(const t in e){const n=e[t],r={_id:n._id};for(const e in c){if("_id"===e)continue;const t=c[e],s=Object.keys(t);if(1!==s.length)continue;const o=s[0],l=t[o];if("$sum"===o){let t=0;for(let e=0;e<n.docs.length;e++)if("number"==typeof l)t+=l;else if("string"==typeof l&&"$"===l.charAt(0)){t+=i(n.docs[e],l.substring(1))||0}r[e]=t}else if("$avg"===o){let t=0,s=0;for(let e=0;e<n.docs.length;e++)if("string"==typeof l&&"$"===l.charAt(0)){const r=i(n.docs[e],l.substring(1));null!=r&&(t+=r,s++)}r[e]=s>0?t/s:0}else if("$min"===o){let t;for(let e=0;e<n.docs.length;e++)if("string"==typeof l&&"$"===l.charAt(0)){const s=i(n.docs[e],l.substring(1));void 0!==s&&(void 0===t||s<t)&&(t=s)}r[e]=t}else if("$max"===o){let t;for(let e=0;e<n.docs.length;e++)if("string"==typeof l&&"$"===l.charAt(0)){const s=i(n.docs[e],l.substring(1));void 0!==s&&(void 0===t||s>t)&&(t=s)}r[e]=t}else if("$push"===o){const t=[];for(let e=0;e<n.docs.length;e++)if("string"==typeof l&&"$"===l.charAt(0)){const s=i(n.docs[e],l.substring(1));t.push(s)}r[e]=t}else if("$addToSet"===o){const t={};for(let e=0;e<n.docs.length;e++)if("string"==typeof l&&"$"===l.charAt(0)){const s=i(n.docs[e],l.substring(1));t[JSON.stringify(s)]=s}const s=[];for(const e in t)s.push(t[e]);r[e]=s}else"$first"===o?n.docs.length>0&&"string"==typeof l&&"$"===l.charAt(0)&&(r[e]=i(n.docs[0],l.substring(1))):"$last"===o&&n.docs.length>0&&"string"==typeof l&&"$"===l.charAt(0)&&(r[e]=i(n.docs[n.docs.length-1],l.substring(1)))}s.push(r)}t=s}else if("$count"===h)t=[{[c]:t.length}];else{if("$unwind"!==h)throw{$err:"Unsupported aggregation stage: "+h,code:17287};{const e=[];let n=c;"string"==typeof n&&"$"===n.charAt(0)&&(n=n.substring(1));for(let o=0;o<t.length;o++){const l=t[o],h=i(l,n);if(h&&r(h)&&h.length>0)for(let t=0;t<h.length;t++){const i=s(l),r=n.split(".");let o=i;for(let e=0;e<r.length-1;e++)o[r[e]]||(o[r[e]]={}),o=o[r[e]];o[r[r.length-1]]=h[t],e.push(i)}}t=e}}}return t}bulkWrite(){throw"Not Implemented"}async count(){return this.storage.size()}async copyTo(e){this.db[e]||this.db.createCollection(e);const t=this.db[e];let n=0;const s=this.find({});for(;s.hasNext();)await t.insertOne(s.next()),n++;return n}async createIndex(e,t){if(!e||"object"!=typeof e||Array.isArray(e))throw{$err:"createIndex requires a key specification object",code:2};const n=t&&t.name?t.name:this.generateIndexName(e);if(this.indexes[n]){const t=this.indexes[n];if(JSON.stringify(t.keys)!==JSON.stringify(e))throw{$err:"Index with name '"+n+"' already exists with a different key specification",code:85};return n}return this.buildIndex(n,e,t),n}dataSize(){throw"Not Implemented"}async deleteOne(e){const t=await this.findOne(e);return t?(this.updateIndexesOnDelete(t),this.storage.remove(t._id),{deletedCount:1}):{deletedCount:0}}async deleteMany(e){const t=this.find(e),n=[],s=[];for(;t.hasNext();){const e=t.next();n.push(e._id),s.push(e)}const i=n.length;for(let r=0;r<n.length;r++)this.updateIndexesOnDelete(s[r]),this.storage.remove(n[r]);return{deletedCount:i}}async distinct(e,t){const n={},s=this.find(t);for(;s.hasNext();){const t=s.next();t[e]&&(n[t[e]]=!0)}return Object.keys(n)}drop(){this.storage.clear();for(const e in this.indexes)this.indexes.hasOwnProperty(e)&&this.indexes[e].clear()}dropIndex(e){if(!this.indexes[e])throw{$err:"Index not found with name: "+e,code:27};return this.indexes[e].clear(),delete this.indexes[e],{nIndexesWas:Object.keys(this.indexes).length+1,ok:1}}dropIndexes(){const e=Object.keys(this.indexes).length;for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&this.indexes[t].clear();return this.indexes={},{nIndexesWas:e,msg:"non-_id indexes dropped",ok:1}}ensureIndex(){throw"Not Implemented"}explain(){throw"Not Implemented"}find(e,t){return new c(this,null==e?{}:e,t,G,this.storage,this.indexes,this.planQuery.bind(this),d)}findAndModify(){throw"Not Implemented"}async findOne(e,t){const n=this.find(e,t);return n.hasNext()?n.next():null}async findOneAndDelete(e,t){let n=this.find(e);if(t&&t.sort&&(n=n.sort(t.sort)),!n.hasNext())return null;const s=n.next();return this.storage.remove(s._id),t&&t.projection?a(t.projection,s):s}async findOneAndReplace(e,t,n){let s=this.find(e);if(n&&n.sort&&(s=s.sort(n.sort)),!s.hasNext())return null;const i=s.next();return t._id=i._id,this.storage.set(i._id,t),n&&n.returnNewDocument?n&&n.projection?a(n.projection,t):t:n&&n.projection?a(n.projection,i):i}async findOneAndUpdate(e,t,n){let s=this.find(e);if(n&&n.sort&&(s=s.sort(n.sort)),!s.hasNext())return null;const i=s.next(),r=Object.assign({},i);return K(t,r),this.storage.set(i._id,r),n&&n.returnNewDocument?n&&n.projection?a(n.projection,r):r:n&&n.projection?a(n.projection,i):i}getIndexes(){const e=[];for(const t in this.indexes)this.indexes.hasOwnProperty(t)&&e.push(this.indexes[t].getSpec());return e}getShardDistribution(){throw"Not Implemented"}getShardVersion(){throw"Not Implemented"}getStore(){return this.storage.getStore()}group(){throw"Not Implemented"}async insert(e){return Array==e.constructor?await this.insertMany(e):await this.insertOne(e)}async insertOne(e){return null==e._id&&(e._id=this.idGenerator()),this.storage.set(e._id,e),this.updateIndexesOnInsert(e),{insertedId:e._id}}async insertMany(e){const t=[];for(let n=0;n<e.length;n++){const s=await this.insertOne(e[n]);t.push(s.insertedId)}return{insertedIds:t}}isCapped(){throw"Not Implemented"}mapReduce(){throw"Not Implemented"}reIndex(){throw"Not Implemented"}async replaceOne(e,t,n){const s={},i=this.find(e);if(s.matchedCount=i.count(),0==s.matchedCount){if(s.modifiedCount=0,n&&n.upsert){const e=t;e._id=this.idGenerator(),this.storage.set(e._id,e),s.upsertedId=e._id}}else{s.modifiedCount=1;const e=i.next();this.updateIndexesOnDelete(e),t._id=e._id,this.storage.set(e._id,t),this.updateIndexesOnInsert(t)}return s}remove(e,t){const n=this.find(e);if(n.hasNext())if(!0===t||t&&t.justOne){const e=n.next();this.updateIndexesOnDelete(e),this.storage.remove(e._id)}else for(;n.hasNext();){const e=n.next();this.updateIndexesOnDelete(e),this.storage.remove(e._id)}}renameCollection(){throw"Not Implemented"}save(){throw"Not Implemented"}stats(){throw"Not Implemented"}storageSize(){throw"Not Implemented"}totalSize(){throw"Not Implemented"}totalIndexSize(){throw"Not Implemented"}update(e,t,n){const s=this.find(e);if(s.hasNext())if(n&&n.multi)for(;s.hasNext();){const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else{const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=Q(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}async updateOne(e,t,n){const s=this.find(e);if(s.hasNext()){const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=Q(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}async updateMany(e,t,n){const s=this.find(e);if(s.hasNext())for(;s.hasNext();){const e=s.next();this.updateIndexesOnDelete(e),K(t,e),this.storage.set(e._id,e),this.updateIndexesOnInsert(e)}else if(n&&n.upsert){const n=Q(e,t,this.idGenerator);this.storage.set(n._id,n),this.updateIndexesOnInsert(n)}}validate(){throw"Not Implemented"}}class le{constructor(e){return this.options=e||{},"undefined"!=typeof localStorage?this.localStorage=new oe(this,this.options.localStorage?this.options.localStorage:ae,this._id.bind(this)):this.localStorage=null,new Proxy(this,{get:(e,t,n)=>t in e?Reflect.get(e,t,n):"symbol"==typeof t||t.startsWith("_")?void 0:"string"==typeof t&&"localStorage"!==t?(Object.prototype.hasOwnProperty.call(e,t)||e.createCollection(t),e[t]):void 0})}_log(e){this.options&&this.options.print?this.options.print(e):console.log(e)}_id(){return this.options&&this.options.id?this.options.id():new t}cloneCollection(){throw"Not Implemented"}cloneDatabase(){throw"Not Implemented"}commandHelp(){throw"Not Implemented"}copyDatabase(){throw"Not Implemented"}createCollection(e){e&&("localStorage"==e?this.localStorage=new oe(this,this.options.localStorage?this.options.localStorage:ae,this._id.bind(this)):this[e]=new oe(this,this.options&&this.options.storage?new this.options.storage:new ce,this._id.bind(this)))}currentOp(){throw"Not Implemented"}dropDatabase(){for(const e in this)null!=this[e]&&this[e].isCollection&&(this[e].drop(),delete this[e])}eval(){throw"Not Implemented"}fsyncLock(){throw"Not Implemented"}fsyncUnlock(){throw"Not Implemented"}getCollection(){throw"Not Implemented"}getCollectionInfos(){throw"Not Implemented"}getCollectionNames(){const e=[];for(const t in this)null!=this[t]&&this[t].isCollection&&e.push(t);return e}getLastError(){throw"Not Implemented"}getLastErrorObj(){throw"Not Implemented"}getLogComponents(){throw"Not Implemented"}getMongo(){throw"Not Implemented"}getName(){throw"Not Implemented"}getPrevError(){throw"Not Implemented"}getProfilingLevel(){throw"Not Implemented"}getProfilingStatus(){throw"Not Implemented"}getReplicationInfo(){throw"Not Implemented"}getSiblingDB(){throw"Not Implemented"}help(){this._log("        help mr                      mapreduce"),this._log("        db.foo.find()                list objects in collection foo"),this._log("        db.foo.find( { a : 1 } )     list objects in foo where a == 1"),this._log("        it                           result of the last line evaluated; use to further iterate")}hostInfo(){throw"Not Implemented"}isMaster(){throw"Not Implemented"}killOp(){throw"Not Implemented"}listCommands(){throw"Not Implemented"}loadServerScripts(){throw"Not Implemented"}logout(){throw"Not Implemented"}printCollectionStats(){throw"Not Implemented"}printReplicationInfo(){throw"Not Implemented"}printShardingStatus(){throw"Not Implemented"}printSlaveReplicationInfo(){throw"Not Implemented"}repairDatabase(){throw"Not Implemented"}resetError(){throw"Not Implemented"}runCommand(){throw"Not Implemented"}serverBuildInfo(){throw"Not Implemented"}serverCmdLineOpts(){throw"Not Implemented"}serverStatus(){throw"Not Implemented"}setLogLevel(){throw"Not Implemented"}setProfilingLevel(){throw"Not Implemented"}shutdownServer(){throw"Not Implemented"}stats(){throw"Not Implemented"}version(){throw"Not Implemented"}upgradeCheck(){throw"Not Implemented"}upgradeCheckAllDBs(){throw"Not Implemented"}}class he{constructor(e,t={}){this.uri=e,this.options=t}static async connect(e,t={}){return new he(e,t)}db(e,t={}){const n={...this.options,...t};return new le(n)}async close(){}}const ae=function(){return{clear:function(){localStorage.clear()},get:function(e){return JSON.parse(localStorage.getItem(localStorage.key(e)))},getStore:function(){return localStorage},remove:function(e){localStorage.removeItem(e)},set:async function(e,t){localStorage.setItem(e,JSON.stringify(t))},size:function(){return localStorage.length}}}(),ce=function(){var e={};return{clear:function(){e={}},get:function(t){return e[Object.keys(e)[t]]},getStore:function(){return e},remove:function(t){delete e[t]},set:function(t,n){e[t]=n},size:function(){return Object.keys(e).length}}};e.LocalStorageStore=ae,e.MongoClient=he,e.ObjectId=t,e.ObjectStore=ce,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=micro-mongo-1.1.3.min.umd.js.map
