{"version":3,"file":"micro-mongo-1.1.3.min.umd.js","sources":["../src/ObjectId.js","../src/utils.js","../src/Cursor.js","../src/SortedCursor.js","../node_modules/stemmer/index.js","../src/TextIndex.js","../src/queryMatcher.js","../src/updates.js","../src/CollectionIndex.js","../src/RegularCollectionIndex.js","../src/TextCollectionIndex.js","../src/RTree.js","../src/GeospatialCollectionIndex.js","../src/Collection.js","../src/StorageEngine.js","../src/DB.js","../src/MongoClient.js","../main.js","../src/IndexedDbStorageEngine.js","../src/ObjectStorageEngine.js"],"sourcesContent":["/**\r\n * ObjectId class - MongoDB-compatible 24-character hex string identifier\r\n * Format: 8-char timestamp + 16-char random data\r\n */\r\nexport class ObjectId {\r\n  constructor(id) {\r\n    if (id === undefined || id === null) {\r\n      // Generate new ObjectId\r\n      this.id = ObjectId.generate();\r\n    } else if (typeof id === 'string') {\r\n      // Create from hex string\r\n      if (!ObjectId.isValid(id)) {\r\n        throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${id}`);\r\n      }\r\n      this.id = id.toLowerCase();\r\n    } else if (id instanceof ObjectId) {\r\n      // Copy constructor\r\n      this.id = id.id;\r\n    } else {\r\n      throw new Error(`Argument passed in must be a string of 24 hex characters or an ObjectId`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the ObjectId as a 24-character hex string\r\n   */\r\n  toString() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the ObjectId as a 24-character hex string (alias for toString)\r\n   */\r\n  toHexString() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the timestamp portion of the ObjectId as a Date\r\n   */\r\n  getTimestamp() {\r\n    const timestamp = parseInt(this.id.substring(0, 8), 16);\r\n    return new Date(timestamp * 1000);\r\n  }\r\n\r\n  /**\r\n   * Compares this ObjectId with another for equality\r\n   */\r\n  equals(other) {\r\n    if (!other) return false;\r\n    \r\n    if (other instanceof ObjectId) {\r\n      return this.id === other.id;\r\n    }\r\n    \r\n    if (typeof other === 'string') {\r\n      return this.id === other.toLowerCase();\r\n    }\r\n    \r\n    // Handle objects with id property\r\n    if (other.id) {\r\n      return this.id === other.id;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns the ObjectId in JSON format (as hex string)\r\n   */\r\n  toJSON() {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Custom inspect for Node.js console.log\r\n   */\r\n  inspect() {\r\n    return `ObjectId(\"${this.id}\")`;\r\n  }\r\n\r\n  /**\r\n   * Validates if a string is a valid ObjectId hex string\r\n   */\r\n  static isValid(id) {\r\n    if (!id) return false;\r\n    if (typeof id !== 'string') return false;\r\n    if (id.length !== 24) return false;\r\n    return /^[0-9a-fA-F]{24}$/.test(id);\r\n  }\r\n\r\n  /**\r\n   * Creates an ObjectId from a timestamp\r\n   */\r\n  static createFromTime(timestamp) {\r\n    const ts = Math.floor(timestamp / 1000);\r\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\r\n    const tail = '0000000000000000'; // Zero out the random portion\r\n    return new ObjectId(tsHex + tail);\r\n  }\r\n\r\n  /**\r\n   * Generates a new ObjectId hex string\r\n   * Format: 8-char timestamp (4 bytes) + 16-char random data (8 bytes)\r\n   */\r\n  static generate() {\r\n    const ts = Math.floor(Date.now() / 1000);\r\n    \r\n    // Generate 8 random bytes\r\n    const rand = typeof crypto !== 'undefined' && crypto.getRandomValues ? new Uint8Array(8) : null;\r\n    let tail = '';\r\n    \r\n    if (rand) {\r\n      crypto.getRandomValues(rand);\r\n      for (let i = 0; i < rand.length; i++) {\r\n        tail += ('0' + rand[i].toString(16)).slice(-2);\r\n      }\r\n    } else {\r\n      // Fallback for environments without crypto\r\n      // Generate two 8-character hex strings\r\n      tail = Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8) +\r\n             Math.random().toString(16).slice(2).padEnd(8, '0').slice(0, 8);\r\n    }\r\n    \r\n    const tsHex = ('00000000' + ts.toString(16)).slice(-8);\r\n    return (tsHex + tail).slice(0, 24);\r\n  }\r\n}","/**\n * Utility functions for MicroMongoDB\n */\n\nimport { ObjectId } from './ObjectId.js';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Deep copy an object or array\n */\nexport function copy(o) {\n\t// Handle ObjectId\n\tif (o instanceof ObjectId) {\n\t\treturn new ObjectId(o.id);\n\t}\n\t\n\tvar out, v, key;\n\tout = Array.isArray(o) ? [] : {};\n\tfor (key in o) {\n\t\tv = o[key];\n\t\tout[key] = (typeof v === \"object\" && v !== null) ? copy(v) : v;\n\t}\n\treturn out;\n}\n\n/**\n * Get a property from an object using dot notation\n */\nexport function getProp(obj, name) {\n\tvar path = name.split(\".\");\n\tvar result = obj[path[0]];\n\tfor (var i = 1; i < path.length; i++) {\n\t\tif (result == undefined || result == null) return result;\n\t\tresult = result[path[i]];\n\t}\n\treturn result;\n}\n\n/**\n * Check if value is an array\n */\nexport function isArray(o) {\n\treturn Array == o.constructor;\n}\n\n/**\n * Convert object to array of key-value pairs\n */\nexport function toArray(obj) {\n\tvar arr = [];\n\tfor (var key in obj) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar el = {};\n\t\t\tel[key] = obj[key];\n\t\t\tarr.push(el);\n\t\t}\n\t}\n\treturn arr;\n}\n\n/**\n * Check if a value is in an array\n */\nexport function isIn(val, values) {\n\tfor (var i = 0; i < values.length; i++) {\n\t\tif (valuesEqual(values[i], val)) return true;\n\t}\n\treturn false;\n}\n\n/**\n * Check if two arrays match\n */\nexport function arrayMatches(x, y) {\n\tif (x.length != y.length) return false;\n\tfor (var i = 0; i < x.length; i++) {\n\t\tif (valuesEqual(x[i], y[i])) continue;\n\t\tif (typeof (x[i]) != typeof (y[i])) return false;\n\t\tif (typeof (x[i]) == \"object\" && x[i] !== null) {\n\t\t\tif (isArray(x[i])) {\n\t\t\t\tif (!arrayMatches(x[i], y[i])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[i], y[i])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[i], y[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Check if two objects match\n */\nexport function objectMatches(x, y) {\n\tfor (var p in x) {\n\t\tif (!x.hasOwnProperty(p)) continue;\n\t\tif (!y.hasOwnProperty(p)) return false;\n\t\tif (valuesEqual(x[p], y[p])) continue;\n\t\tif (typeof (x[p]) != typeof (y[p])) return false;\n\t\tif (typeof (x[p]) == \"object\" && x[p] !== null) {\n\t\t\tif (isArray(x[p])) {\n\t\t\t\tif (!arrayMatches(x[p], y[p])) return false;\n\t\t\t} else {\n\t\t\t\tif (!objectMatches(x[p], y[p])) return false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!valuesEqual(x[p], y[p])) return false;\n\t\t}\n\t}\n\tfor (var p in y) {\n\t\tif (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Apply projection to a document\n */\nexport function applyProjection(projection, doc) {\n\tvar result = {};\n\tvar keys = Object.keys(projection);\n\tif (keys.length == 0) return doc;\n\t\n\t// Check for mixed inclusion/exclusion (except _id which can be excluded in inclusion projection)\n\tvar hasInclusion = false;\n\tvar hasExclusion = false;\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (keys[i] === '_id') continue; // _id is special\n\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\telse hasExclusion = true;\n\t}\n\t\n\tif (hasInclusion && hasExclusion) {\n\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t}\n\t\n\tif (projection[keys[0]] || hasInclusion) {\n\t\t// inclusion with _id (unless explicitly excluded)\n\t\tif (projection._id !== 0) {\n\t\t\tresult._id = doc._id;\n\t\t}\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (keys[i] === '_id') continue;\n\t\t\tif (!projection[keys[i]]) continue;\n\t\t\tresult[keys[i]] = doc[keys[i]];\n\t\t}\n\t} else {\n\t\t// exclusion\n\t\tfor (var key in doc) {\n\t\t\tresult[key] = doc[key];\n\t\t}\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (projection[keys[i]]) continue;\n\t\t\tdelete result[keys[i]];\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Convert bbox to GeoJSON\n */\nexport function bboxToGeojson(bbox) {\n\tconst minLon = bbox[0][0];\n\tconst maxLat = bbox[0][1];\n\tconst maxLon = bbox[1][0];\n\tconst minLat = bbox[1][1];\n\treturn {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: [{\n\t\t\ttype: 'Feature',\n\t\t\tproperties: {},\n\t\t\tgeometry: {\n\t\t\t\ttype: 'Polygon',\n\t\t\t\tcoordinates: [[\n\t\t\t\t\t[minLon, maxLat],\n\t\t\t\t\t[minLon, minLat],\n\t\t\t\t\t[maxLon, minLat],\n\t\t\t\t\t[maxLon, maxLat],\n\t\t\t\t\t[minLon, maxLat]\n\t\t\t\t]]\n\t\t\t}\n\t\t}]\n\t};\n}\n","import { applyProjection } from './utils.js';\n\n/**\n * Cursor class for iterating over query results\n */\nexport class Cursor {\n\tconstructor(collection, query, projection, matches, storage, indexes, planQuery, SortedCursor) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.projection = projection;\n\t\tthis.matches = matches;\n\t\tthis.storage = storage;\n\t\tthis.indexes = indexes;\n\t\tthis.planQuery = planQuery;\n\t\tthis.SortedCursor = SortedCursor;\n\t\t\n\t\t// Validate projection if provided\n\t\tif (projection && Object.keys(projection).length > 0) {\n\t\t\tconst keys = Object.keys(projection);\n\t\t\tlet hasInclusion = false;\n\t\t\tlet hasExclusion = false;\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tif (keys[i] === '_id') continue; // _id is special\n\t\t\t\tif (projection[keys[i]]) hasInclusion = true;\n\t\t\t\telse hasExclusion = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (hasInclusion && hasExclusion) {\n\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.\", code: 17287 };\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.pos = 0;\n\t\tthis.max = 0;\n\t\tthis._next = false; // false == unknown, null == no more, !null == next\n\t\t\n\t\t// Query planning - check if we can use an index\n\t\tconst queryPlan = this.planQuery(this.query);\n\t\tthis.indexDocIds = null;\n\t\tthis.indexPos = 0;\n\t\tthis.fullScanDocIds = {}; // Track which docs we've seen to avoid duplicates\n\n\t\t// If using index, get the document IDs from the index\n\t\tif (queryPlan && queryPlan.useIndex) {\n\t\t\tthis.indexDocIds = queryPlan.docIds ? queryPlan.docIds.slice() : [];\n\t\t}\n\t\t\n\t\t// Initialize by finding first document\n\t\tthis._findNext();\n\t}\n\n\t_findNext() {\n\t\t// First, try to get documents from index\n\t\twhile (this.indexDocIds !== null && this.indexPos < this.indexDocIds.length) {\n\t\t\tconst docId = this.indexDocIds[this.indexPos++];\n\t\t\tconst doc = this.storage.getStore()[docId];\n\t\t\tif (doc && this.matches(doc, this.query)) {\n\t\t\t\tthis.fullScanDocIds[doc._id] = true;\n\t\t\t\tthis._next = doc;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If doc doesn't match (shouldn't happen with good index), continue to next\n\t\t}\n\n\t\t// Then fall back to full scan for remaining documents\n\t\t// This handles complex queries where index only partially matches\n\t\twhile (this.pos < this.storage.size() && (this.max == 0 || this.pos < this.max)) {\n\t\t\tconst cur = this.storage.get(this.pos++);\n\t\t\t// Skip docs we already returned from index\n\t\t\tif (cur && !this.fullScanDocIds[cur._id] && this.matches(cur, this.query)) {\n\t\t\t\tthis.fullScanDocIds[cur._id] = true;\n\t\t\t\tthis._next = cur;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._next = null;\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\tlet num = 0;\n\t\tconst c = new Cursor(this.collection, this.query, null, this.matches, this.storage, this.indexes, this.planQuery, this.SortedCursor);\n\t\twhile (c.hasNext()) {\n\t\t\tnum++;\n\t\t\tc.next();\n\t\t}\n\t\treturn num;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\tif (this._next === false) this._findNext();\n\t\treturn this._next != null;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(_max) {\n\t\tthis.max = _max;\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\tif (this._next == null) throw \"Error: error hasNext: false\";\n\t\tconst result = this._next;\n\t\tthis._findNext();\n\t\tif (this.projection) return applyProjection(this.projection, result);\n\t\telse return result;\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new this.SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","/**\n * SortedCursor class for iterating over sorted query results\n */\nexport class SortedCursor {\n\tconstructor(collection, query, cursor, sort) {\n\t\tthis.collection = collection;\n\t\tthis.query = query;\n\t\tthis.sortSpec = sort;\n\t\tthis.pos = 0;\n\t\tthis.items = [];\n\t\t\n\t\t// Collect all items from the cursor\n\t\twhile (cursor.hasNext()) {\n\t\t\tthis.items.push(cursor.next());\n\t\t}\n\t\t\n\t\t// Sort the items\n\t\tconst sortKeys = Object.keys(sort);\n\t\tthis.items.sort(function(a, b) {\n\t\t\tfor (let i = 0; i < sortKeys.length; i++) {\n\t\t\t\tif (a[sortKeys[i]] == undefined && b[sortKeys[i]] != undefined) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] != undefined && b[sortKeys[i]] == undefined) return 1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] < b[sortKeys[i]]) return -1 * sort[sortKeys[i]];\n\t\t\t\tif (a[sortKeys[i]] > b[sortKeys[i]]) return 1 * sort[sortKeys[i]];\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\tbatchSize() { throw \"Not Implemented\"; }\n\tclose() { throw \"Not Implemented\"; }\n\tcomment() { throw \"Not Implemented\"; }\n\t\n\tcount() {\n\t\treturn this.items.length;\n\t}\n\t\n\texplain() { throw \"Not Implemented\"; }\n\t\n\tasync forEach(fn) {\n\t\twhile (this.hasNext()) {\n\t\t\tawait fn(this.next());\n\t\t}\n\t}\n\t\n\thasNext() {\n\t\treturn this.pos < this.items.length;\n\t}\n\t\n\thint() { throw \"Not Implemented\"; }\n\titcount() { throw \"Not Implemented\"; }\n\t\n\tlimit(max) {\n\t\tthis.items = this.items.slice(0, max);\n\t\treturn this;\n\t}\n\t\n\tmap(fn) {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(fn(this.next()));\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tmaxScan() { throw \"Not Implemented\"; }\n\tmaxTimeMS() { throw \"Not Implemented\"; }\n\tmax() { throw \"Not Implemented\"; }\n\tmin() { throw \"Not Implemented\"; }\n\t\n\tnext() {\n\t\treturn this.items[this.pos++];\n\t}\n\t\n\tnoCursorTimeout() { throw \"Not Implemented\"; }\n\tobjsLeftInBatch() { throw \"Not Implemented\"; }\n\tpretty() { throw \"Not Implemented\"; }\n\treadConcern() { throw \"Not Implemented\"; }\n\treadPref() { throw \"Not Implemented\"; }\n\treturnKey() { throw \"Not Implemented\"; }\n\tshowRecordId() { throw \"Not Implemented\"; }\n\tsize() { throw \"Not Implemented\"; }\n\t\n\tskip(num) {\n\t\twhile (num > 0) {\n\t\t\tthis.next();\n\t\t\tnum--;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tsnapshot() { throw \"Not Implemented\"; }\n\t\n\tsort(s) {\n\t\treturn new SortedCursor(this.collection, this.query, this, s);\n\t}\n\t\n\ttailable() { throw \"Not Implemented\"; }\n\t\n\tasync toArray() {\n\t\tconst results = [];\n\t\twhile (this.hasNext()) {\n\t\t\tresults.push(this.next());\n\t\t}\n\t\treturn results;\n\t}\n\t\n\t// Support for async iteration (for await...of)\n\tasync *[Symbol.asyncIterator]() {\n\t\twhile (this.hasNext()) {\n\t\t\tyield this.next();\n\t\t}\n\t}\n}\n","// Standard suffix manipulations.\n/** @type {Record<string, string>} */\nconst step2list = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant-vowel sequences.\nconst consonant = '[^aeiou]'\nconst vowel = '[aeiouy]'\nconst consonants = '(' + consonant + '[^aeiouy]*)'\nconst vowels = '(' + vowel + '[aeiou]*)'\n\nconst gt0 = new RegExp('^' + consonants + '?' + vowels + consonants)\nconst eq1 = new RegExp(\n  '^' + consonants + '?' + vowels + consonants + vowels + '?$'\n)\nconst gt1 = new RegExp('^' + consonants + '?(' + vowels + consonants + '){2,}')\nconst vowelInStem = new RegExp('^' + consonants + '?' + vowel)\nconst consonantLike = new RegExp('^' + consonants + vowel + '[^aeiouwxy]$')\n\n// Exception expressions.\nconst sfxLl = /ll$/\nconst sfxE = /^(.+?)e$/\nconst sfxY = /^(.+?)y$/\nconst sfxIon = /^(.+?(s|t))(ion)$/\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/\nconst sfxEED = /^(.+?)eed$/\nconst sfxS = /^.+?[^s]s$/\nconst sfxSsesOrIes = /^.+?(ss|i)es$/\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nexport function stemmer(value) {\n  let result = String(value).toLowerCase()\n\n  // Exit early.\n  if (result.length < 3) {\n    return result\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true\n    result = 'Y' + result.slice(1)\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2)\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1)\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1]\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += 'e'\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1)\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += 'e'\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + 'i'\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]]\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]]\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1]\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1]\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1]\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1)\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = 'y' + result.slice(1)\n  }\n\n  return result\n}\n","import { stemmer } from 'stemmer';\n\n// Common English stop words that don't add semantic value to searches\nconst STOPWORDS = new Set([\n  'a', 'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', \n  'around', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'between', 'both', \n  'but', 'by', 'came', 'can', 'come', 'could', 'did', 'do', 'each', 'for', 'from', \n  'get', 'got', 'has', 'had', 'he', 'have', 'her', 'here', 'him', 'himself', 'his', \n  'how', 'i', 'if', 'in', 'into', 'is', 'it', 'like', 'make', 'many', 'me', 'might', \n  'more', 'most', 'much', 'must', 'my', 'never', 'now', 'of', 'on', 'only', 'or', \n  'other', 'our', 'out', 'over', 'said', 'same', 'see', 'should', 'since', 'some', \n  'still', 'such', 'take', 'than', 'that', 'the', 'their', 'them', 'then', 'there', \n  'these', 'they', 'this', 'those', 'through', 'to', 'too', 'under', 'up', 'very', \n  'was', 'way', 'we', 'well', 'were', 'what', 'where', 'which', 'while', 'who', \n  'with', 'would', 'you', 'your'\n]);\n\n/**\n * TextIndex - A text index implementation using Porter stemmer algorithm\n * \n * This class provides full-text search capabilities by indexing terms\n * and associating them with document IDs. It uses the Porter stemmer\n * algorithm to normalize words to their root forms.\n */\nexport class TextIndex {\n  constructor(options = {}) {\n    // Map from stemmed term to Map of document IDs to term frequency\n    // Structure: term -> { docId: frequency }\n    this.index = new Map();\n    // Map from document ID to Map of stemmed terms to their frequency\n    // Structure: docId -> { term: frequency }\n    this.documentTerms = new Map();\n    // Map from document ID to total term count (for normalization)\n    this.documentLengths = new Map();\n    // Stop words configuration\n    this.useStopWords = options.useStopWords !== false; // default: true\n    // Create a copy of STOPWORDS to avoid mutating the global set\n    this.stopWords = options.stopWords || new Set(STOPWORDS);\n  }\n\n  /**\n   * Tokenize text into individual words\n   * @param {string} text - The text to tokenize\n   * @returns {string[]} Array of words\n   */\n  _tokenize(text) {\n    if (typeof text !== 'string') {\n      return [];\n    }\n    // Split on non-word characters and filter out empty strings\n    const words = text.toLowerCase()\n      .split(/\\W+/)\n      .filter(word => word.length > 0);\n    \n    // Filter stop words if enabled\n    if (this.useStopWords) {\n      return words.filter(word => !this.stopWords.has(word));\n    }\n    \n    return words;\n  }\n\n  /**\n   * Add terms from text to the index for a given document ID\n   * @param {string} docId - The document identifier\n   * @param {string} text - The text content to index\n   */\n  add(docId, text) {\n    if (!docId) {\n      throw new Error('Document ID is required');\n    }\n\n    const words = this._tokenize(text);\n    const termFrequency = new Map();\n\n    // Count term frequencies\n    words.forEach(word => {\n      const stem = stemmer(word);\n      termFrequency.set(stem, (termFrequency.get(stem) || 0) + 1);\n    });\n\n    // Add to index\n    termFrequency.forEach((frequency, stem) => {\n      if (!this.index.has(stem)) {\n        this.index.set(stem, new Map());\n      }\n      this.index.get(stem).set(docId, frequency);\n    });\n\n    // Track document terms and frequencies\n    this.documentTerms.set(docId, termFrequency);\n    this.documentLengths.set(docId, words.length);\n  }\n\n  /**\n   * Remove all indexed terms for a given document ID\n   * @param {string} docId - The document identifier to remove\n   * @returns {boolean} True if document was found and removed, false otherwise\n   */\n  remove(docId) {\n    if (!this.documentTerms.has(docId)) {\n      return false;\n    }\n\n    // Get all terms associated with this document\n    const terms = this.documentTerms.get(docId);\n\n    // Remove document ID from each term's posting list\n    terms.forEach((frequency, term) => {\n      if (this.index.has(term)) {\n        this.index.get(term).delete(docId);\n        // Clean up empty term entries\n        if (this.index.get(term).size === 0) {\n          this.index.delete(term);\n        }\n      }\n    });\n\n    // Remove document from tracking\n    this.documentTerms.delete(docId);\n    this.documentLengths.delete(docId);\n    return true;\n  }\n\n  /**\n   * Query the index for documents containing the given terms with relevance scoring\n   * @param {string} queryText - The search query text\n   * @param {Object} options - Query options\n   * @param {boolean} options.scored - If true, return scored results; if false, return just IDs (default: true)\n   * @param {boolean} options.requireAll - If true, require ALL terms; if false, rank by relevance (default: false)\n   * @returns {Array} Array of document IDs (if scored=false) or objects with {id, score} (if scored=true)\n   */\n  query(queryText, options = { scored: true, requireAll: false }) {\n    const words = this._tokenize(queryText);\n    if (words.length === 0) {\n      return [];\n    }\n\n    // Get stemmed versions of query terms\n    const stemmedTerms = words.map(word => stemmer(word));\n    const uniqueTerms = [...new Set(stemmedTerms)];\n\n    if (options.requireAll) {\n      // Strict AND logic - document must contain ALL terms\n      const docSets = uniqueTerms.map(term => {\n        const termDocs = this.index.get(term);\n        return termDocs ? new Set(termDocs.keys()) : new Set();\n      });\n\n      if (docSets.length === 0) {\n        return [];\n      }\n\n      // Compute intersection of all document sets\n      const intersection = new Set(docSets[0]);\n      for (let i = 1; i < docSets.length; i++) {\n        for (const docId of intersection) {\n          if (!docSets[i].has(docId)) {\n            intersection.delete(docId);\n          }\n        }\n      }\n\n      return Array.from(intersection);\n    }\n\n    // Relevance-based scoring (OR logic with ranking)\n    // Calculate IDF (Inverse Document Frequency) for each term\n    const totalDocs = this.documentLengths.size;\n    const idf = new Map();\n    \n    uniqueTerms.forEach(term => {\n      const docsWithTerm = this.index.get(term)?.size || 0;\n      if (docsWithTerm > 0) {\n        // IDF = log(totalDocs / docsWithTerm)\n        idf.set(term, Math.log(totalDocs / docsWithTerm));\n      }\n    });\n\n    // Collect all documents that contain at least one query term\n    const docScores = new Map();\n\n    uniqueTerms.forEach(term => {\n      const termDocs = this.index.get(term);\n      if (!termDocs) return;\n\n      termDocs.forEach((termFreq, docId) => {\n        if (!docScores.has(docId)) {\n          docScores.set(docId, 0);\n        }\n\n        // Calculate TF-IDF score\n        // TF = term frequency in document / total terms in document\n        const docLength = this.documentLengths.get(docId) || 1;\n        const tf = termFreq / docLength;\n        \n        // Add to document's total score\n        const termIdf = idf.get(term) || 0;\n        const tfIdf = tf * termIdf;\n        \n        docScores.set(docId, docScores.get(docId) + tfIdf);\n      });\n    });\n\n    // Bonus for documents containing multiple query terms\n    docScores.forEach((score, docId) => {\n      const docTerms = this.documentTerms.get(docId);\n      if (docTerms) {\n        const matchingTerms = uniqueTerms.filter(term => docTerms.has(term)).length;\n        // Boost score based on term coverage (what % of query terms are present)\n        const coverage = matchingTerms / uniqueTerms.length;\n        docScores.set(docId, score * (1 + coverage));\n      }\n    });\n\n    // Sort by score (highest first)\n    const results = Array.from(docScores.entries())\n      .map(([id, score]) => ({ id, score }))\n      .sort((a, b) => b.score - a.score);\n\n    // Return based on options\n    if (options.scored === false) {\n      return results.map(r => r.id);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Get the number of unique terms in the index\n   * @returns {number} Number of unique terms\n   */\n  getTermCount() {\n    return this.index.size;\n  }\n\n  /**\n   * Get the number of documents in the index\n   * @returns {number} Number of indexed documents\n   */\n  getDocumentCount() {\n    return this.documentTerms.size;\n  }\n\n  /**\n   * Clear all data from the index\n   */\n  clear() {\n    this.index.clear();\n    this.documentTerms.clear();\n    this.documentLengths.clear();\n  }\n\n  /**\n   * Add custom stop words\n   * @param {...string} words - Words to add to stop word list\n   * @returns {TextIndex} this for chaining\n   */\n  addStopWords(...words) {\n    words.forEach(word => this.stopWords.add(word.toLowerCase()));\n    return this;\n  }\n\n  /**\n   * Remove words from stop word list\n   * @param {...string} words - Words to remove from stop word list\n   * @returns {TextIndex} this for chaining\n   */\n  removeStopWords(...words) {\n    words.forEach(word => this.stopWords.delete(word.toLowerCase()));\n    return this;\n  }\n\n  /**\n   * Enable or disable stop word filtering\n   * @param {boolean} enabled - Whether to filter stop words\n   * @returns {TextIndex} this for chaining\n   */\n  setStopWordFiltering(enabled) {\n    this.useStopWords = enabled;\n    return this;\n  }\n\n  /**\n   * Serialize the text index state for storage\n   * @returns {Object} Serializable state\n   */\n  serialize() {\n    // Convert Maps to plain objects for JSON serialization\n    const indexObj = {};\n    this.index.forEach((docs, term) => {\n      const docsObj = {};\n      docs.forEach((freq, docId) => {\n        docsObj[docId] = freq;\n      });\n      indexObj[term] = docsObj;\n    });\n\n    const documentTermsObj = {};\n    this.documentTerms.forEach((terms, docId) => {\n      const termsObj = {};\n      terms.forEach((freq, term) => {\n        termsObj[term] = freq;\n      });\n      documentTermsObj[docId] = termsObj;\n    });\n\n    const documentLengthsObj = {};\n    this.documentLengths.forEach((length, docId) => {\n      documentLengthsObj[docId] = length;\n    });\n\n    return {\n      index: indexObj,\n      documentTerms: documentTermsObj,\n      documentLengths: documentLengthsObj,\n      useStopWords: this.useStopWords,\n      stopWords: Array.from(this.stopWords)\n    };\n  }\n\n  /**\n   * Restore the text index state from serialized data\n   * @param {Object} state - Serialized state\n   */\n  deserialize(state) {\n    // Restore index\n    this.index = new Map();\n    for (const term in state.index) {\n      const docs = new Map();\n      for (const docId in state.index[term]) {\n        docs.set(docId, state.index[term][docId]);\n      }\n      this.index.set(term, docs);\n    }\n\n    // Restore documentTerms\n    this.documentTerms = new Map();\n    for (const docId in state.documentTerms) {\n      const terms = new Map();\n      for (const term in state.documentTerms[docId]) {\n        terms.set(term, state.documentTerms[docId][term]);\n      }\n      this.documentTerms.set(docId, terms);\n    }\n\n    // Restore documentLengths\n    this.documentLengths = new Map();\n    for (const docId in state.documentLengths) {\n      this.documentLengths.set(docId, state.documentLengths[docId]);\n    }\n\n    // Restore settings\n    this.useStopWords = state.useStopWords !== false;\n    if (state.stopWords) {\n      this.stopWords = new Set(state.stopWords);\n    }\n  }\n}\n","import { getProp, isArray, arrayMatches, objectMatches, toArray, isIn, bboxToGeojson } from './utils.js';\nimport { TextIndex } from './TextIndex.js';\nimport { ObjectId } from './ObjectId.js';\n\n/**\n * Compare two values for equality, handling ObjectId instances\n */\nfunction valuesEqual(a, b) {\n\t// Handle ObjectId comparison\n\tif (a instanceof ObjectId || b instanceof ObjectId) {\n\t\tif (a instanceof ObjectId && b instanceof ObjectId) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (a instanceof ObjectId && typeof b === 'string') {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\tif (b instanceof ObjectId && typeof a === 'string') {\n\t\t\treturn b.equals(a);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t// Regular equality\n\treturn a == b;\n}\n\n/**\n * Compare two values with a comparison operator, handling ObjectId instances\n */\nfunction compareValues(a, b, operator) {\n\t// Convert ObjectIds to comparable values (use timestamp for ordering)\n\tlet aVal = a;\n\tlet bVal = b;\n\t\n\tif (a instanceof ObjectId) {\n\t\taVal = a.toString();\n\t}\n\tif (b instanceof ObjectId) {\n\t\tbVal = b.toString();\n\t}\n\t\n\tswitch(operator) {\n\t\tcase '>': return aVal > bVal;\n\t\tcase '>=': return aVal >= bVal;\n\t\tcase '<': return aVal < bVal;\n\t\tcase '<=': return aVal <= bVal;\n\t\tdefault: return false;\n\t}\n}\n\n/**\n * Text search helper\n * Creates a temporary TextIndex to check if the text matches the query\n */\nexport function text(prop, query) {\n\tconst textIndex = new TextIndex();\n\ttextIndex.add('id', prop);\n\tconst results = textIndex.query(query, { scored: false });\n\treturn results.length === 1;\n}\n\n/**\n * Geo within helper - using bounding box logic instead of de9im\n * This is a simpler implementation that doesn't require de9im dependency\n */\nexport function geoWithin(prop, query) {\n\ttry {\n\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\tif (!Array.isArray(query) || query.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst minLon = query[0][0];\n\t\tconst maxLat = query[0][1];\n\t\tconst maxLon = query[1][0];\n\t\tconst minLat = query[1][1];\n\n\t\t// Check if geometry is within bounding box\n\t\treturn isGeometryWithinBBox(prop, minLon, maxLon, minLat, maxLat);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if a GeoJSON geometry is within a bounding box\n * For Points: checks if the point is within the bbox\n * For Polygons: checks if ALL vertices are within the bbox\n */\nfunction isGeometryWithinBBox(geoJson, minLon, maxLon, minLat, maxLat) {\n\tif (!geoJson) return false;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t// All features must be within the bbox\n\t\tfor (const feature of geoJson.features) {\n\t\t\tif (feature.geometry) {\n\t\t\t\tif (!isGeometryWithinBBox(feature.geometry, minLon, maxLon, minLat, maxLat)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn isGeometryWithinBBox(geoJson.geometry, minLon, maxLon, minLat, maxLat);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn lng >= minLon && lng <= maxLon && lat >= minLat && lat <= maxLat;\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - ALL vertices must be within the bbox\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tfor (const ring of geoJson.coordinates) {\n\t\t\tfor (const coord of ring) {\n\t\t\t\tconst lng = coord[0];\n\t\t\t\tconst lat = coord[1];\n\t\t\t\tif (lng < minLon || lng > maxLon || lat < minLat || lat > maxLat) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Extract coordinates from a GeoJSON object for indexing purposes\n * This uses centroid for polygons to get a single point to index\n * @param {Object} geoJson - The GeoJSON object\n * @returns {Object|null} Object with lat and lng, or null if invalid\n */\nfunction extractCoordinatesFromGeoJSON(geoJson) {\n\tif (!geoJson) return null;\n\n\t// Handle GeoJSON FeatureCollection\n\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\tconst feature = geoJson.features[0];\n\t\tif (feature.geometry) {\n\t\t\treturn extractCoordinatesFromGeoJSON(feature.geometry);\n\t\t}\n\t}\n\n\t// Handle GeoJSON Feature\n\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\treturn extractCoordinatesFromGeoJSON(geoJson.geometry);\n\t}\n\n\t// Handle GeoJSON Point\n\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\tconst [lng, lat] = geoJson.coordinates;\n\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\treturn { lat, lng };\n\t\t}\n\t}\n\n\t// Handle GeoJSON Polygon - use centroid of first coordinate ring\n\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\tconst ring = geoJson.coordinates[0];\n\t\tif (ring.length > 0) {\n\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\tfor (const coord of ring) {\n\t\t\t\tsumLng += coord[0];\n\t\t\t\tsumLat += coord[1];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\tlng: sumLng / ring.length\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * $where operator implementation\n * SECURITY NOTE: This uses Function constructor which can execute arbitrary code.\n * This is acceptable for a local/in-memory database but should NOT be used\n * in environments where untrusted user input is processed.\n */\nexport function where(doc, value) {\n\tif (typeof value === 'function') {\n\t\ttry {\n\t\t\treturn value.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t} else if (typeof value === 'string') {\n\t\t// Evaluate the string as a function\n\t\ttry {\n\t\t\tvar fn = new Function('return ' + value);\n\t\t\treturn fn.call(doc);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Top-level match function\n */\nexport function tlMatches(doc, query) {\n\tvar key = Object.keys(query)[0];\n\tvar value = query[key];\n\tif (key.charAt(0) == \"$\") {\n\t\tif (key == \"$and\") return and(doc, value);\n\t\telse if (key == \"$or\") return or(doc, value);\n\t\telse if (key == \"$not\") return not(doc, value);\n\t\telse if (key == \"$nor\") return nor(doc, value);\n\t\telse if (key == \"$where\") return where(doc, value);\n\t\telse throw { $err: \"Can't canonicalize query: BadValue unknown top level operator: \" + key, code: 17287 };\n\t} else {\n\t\treturn opMatches(doc, key, value);\n\t}\n}\n\n/**\n * Operator match function\n */\nexport function opMatches(doc, key, value) {\n\tif (typeof (value) == \"string\") return valuesEqual(getProp(doc, key), value);\n\telse if (typeof (value) == \"number\") return valuesEqual(getProp(doc, key), value);\n\telse if (typeof (value) == \"boolean\") return valuesEqual(getProp(doc, key), value);\n\telse if (value instanceof ObjectId) return valuesEqual(getProp(doc, key), value);\n\telse if (typeof (value) == \"object\") {\n\t\tif (value instanceof RegExp) return getProp(doc, key) && getProp(doc, key).match(value);\n\t\telse if (isArray(value)) return getProp(doc, key) && arrayMatches(getProp(doc, key), value);\n\t\telse {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tif (keys[0].charAt(0) == \"$\") {\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar operator = Object.keys(value)[i];\n\t\t\t\t\tvar operand = value[operator];\n\t\t\t\t\tif (operator == \"$eq\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !valuesEqual(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$gt\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '>')) return false;\n\t\t\t\t\t} else if (operator == \"$gte\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '>=')) return false;\n\t\t\t\t\t} else if (operator == \"$lt\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '<')) return false;\n\t\t\t\t\t} else if (operator == \"$lte\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !compareValues(getProp(doc, key), operand, '<=')) return false;\n\t\t\t\t\t} else if (operator == \"$ne\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !(!valuesEqual(getProp(doc, key), operand))) return false;\n\t\t\t\t\t} else if (operator == \"$in\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !isIn(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$nin\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || isIn(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$exists\") {\n\t\t\t\t\t\tif (operand ? getProp(doc, key) == undefined : getProp(doc, key) != undefined) return false;\n\t\t\t\t\t} else if (operator == \"$type\") {\n\t\t\t\t\t\tif (typeof (getProp(doc, key)) != operand) return false;\n\t\t\t\t\t} else if (operator == \"$mod\") {\n\t\t\t\t\t\tif (operand.length != 2) throw { $err: \"Can't canonicalize query: BadValue malformed mod, not enough elements\", code: 17287 };\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || (getProp(doc, key) % operand[0] != operand[1])) return false;\n\t\t\t\t\t} else if (operator == \"$regex\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !getProp(doc, key).match(operand)) return false;\n\t\t\t\t\t} else if (operator == \"$text\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !text(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$geoWithin\") {\n\t\t\t\t\t\tif (getProp(doc, key) == undefined || !geoWithin(getProp(doc, key), operand)) return false;\n\t\t\t\t\t} else if (operator == \"$not\") {\n\t\t\t\t\t\tif (opMatches(doc, key, operand)) return false;\n\t\t\t\t\t} else if (operator == \"$all\") {\n\t\t\t\t\t\tvar fieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (fieldValue == undefined || !isArray(fieldValue)) return false;\n\t\t\t\t\t\tfor (var j = 0; j < operand.length; j++) {\n\t\t\t\t\t\t\tif (!isIn(operand[j], fieldValue)) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (operator == \"$elemMatch\") {\n\t\t\t\t\t\tvar fieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (fieldValue == undefined || !isArray(fieldValue)) return false;\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor (var j = 0; j < fieldValue.length; j++) {\n\t\t\t\t\t\t\tvar element = fieldValue[j];\n\t\t\t\t\t\t\t// Check if element matches the query\n\t\t\t\t\t\t\tif (typeof element === 'object' && !isArray(element)) {\n\t\t\t\t\t\t\t\t// For objects, use matches\n\t\t\t\t\t\t\t\tif (matches(element, operand)) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For primitive values, check operators directly\n\t\t\t\t\t\t\t\tvar matchesPrimitive = true;\n\t\t\t\t\t\t\t\tvar opKeys = Object.keys(operand);\n\t\t\t\t\t\t\t\tfor (var k = 0; k < opKeys.length; k++) {\n\t\t\t\t\t\t\t\t\tvar op = opKeys[k];\n\t\t\t\t\t\t\t\t\tvar opValue = operand[op];\n\t\t\t\t\t\t\t\t\tif (op == \"$gte\" && !(element >= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$gt\" && !(element > opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lte\" && !(element <= opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$lt\" && !(element < opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$eq\" && !(element == opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$ne\" && !(element != opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$in\" && !isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t\telse if (op == \"$nin\" && isIn(element, opValue)) matchesPrimitive = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (matchesPrimitive) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found) return false;\n\t\t\t\t\t} else if (operator == \"$size\") {\n\t\t\t\t\t\tvar fieldValue = getProp(doc, key);\n\t\t\t\t\t\tif (fieldValue == undefined || !isArray(fieldValue)) return false;\n\t\t\t\t\t\tif (fieldValue.length != operand) return false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow { $err: \"Can't canonicalize query: BadValue unknown operator: \" + operator, code: 17287 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn getProp(doc, key) && objectMatches(getProp(doc, key), value);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * $not operator\n */\nexport function not(doc, value) {\n\treturn !tlMatches(doc, value);\n}\n\n/**\n * $and operator\n */\nexport function and(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (!tlMatches(doc, els[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * $or operator\n */\nexport function or(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return true;\n\t}\n\treturn false;\n}\n\n/**\n * $nor operator\n */\nexport function nor(doc, els) {\n\tfor (var i = 0; i < els.length; i++) {\n\t\tif (tlMatches(doc, els[i])) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Main matches function - query structure: (top level operators ( \"age\" : (operators) ))\n * top, top level query, implicit $and\n */\nexport function matches(doc, query) {\n\treturn and(doc, toArray(query));\n}\n","/**\n * Update operations module\n */\n\n/**\n * Apply update operators to a document\n */\nexport function applyUpdates(updates, doc, setOnInsert) {\n\tvar keys = Object.keys(updates);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar value = updates[key];\n\t\tif (key == \"$inc\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = doc[field] + amount;\n\t\t\t}\n\t\t} else if (key == \"$mul\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = doc[field] * amount;\n\t\t\t}\n\t\t} else if (key == \"$rename\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar newName = value[field];\n\t\t\t\tdoc[newName] = doc[field];\n\t\t\t\tdelete doc[field];\n\t\t\t}\n\t\t} else if (key == \"$setOnInsert\" && setOnInsert) {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdoc[fields[j]] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$set\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdoc[fields[j]] = value[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$unset\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdelete doc[fields[j]];\n\t\t\t}\n\t\t} else if (key == \"$min\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = Math.min(doc[field], amount);\n\t\t\t}\n\t\t} else if (key == \"$max\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar amount = value[field];\n\t\t\t\tdoc[field] = Math.max(doc[field], amount);\n\t\t\t}\n\t\t} else if (key == \"$currentDate\") {  // TODO not the same as mongo\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tdoc[fields[j]] = new Date();\n\t\t\t}\n\t\t} else if (key == \"$addToSet\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar value = value[field];\n\t\t\t\tdoc[field].push(value);\n\t\t\t}\n\t\t} else if (key == \"$pop\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar value = value[field];\n\t\t\t\tif (value == 1) {\n\t\t\t\t\tdoc[field].pop();\n\t\t\t\t} else if (value == -1) {\n\t\t\t\t\tdoc[field].shift();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$pullAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar src = doc[fields[j]];\n\t\t\t\tvar toRemove = value[fields[j]];\n\t\t\t\tvar notRemoved = [];\n\t\t\t\tfor (var k = 0; k < src.length; k++) {\n\t\t\t\t\tvar removed = false;\n\t\t\t\t\tfor (var l = 0; l < toRemove.length; l++) {\n\t\t\t\t\t\tif (src[k] == toRemove[l]) {\n\t\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!removed) notRemoved.push(src[k]);\n\t\t\t\t}\n\t\t\t\tdoc[fields[j]] = notRemoved;\n\t\t\t}\n\t\t} else if (key == \"$pushAll\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tvar values = value[field];\n\t\t\t\tfor (var k = 0; k < values.length; k++) {\n\t\t\t\t\tdoc[field].push(values[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key == \"$push\") {\n\t\t\tvar fields = Object.keys(value);\n\t\t\tfor (var j = 0; j < fields.length; j++) {\n\t\t\t\tvar field = fields[j];\n\t\t\t\tdoc[field].push(value[field]);\n\t\t\t}\n\t\t} else if (key == \"$bit\") {\n\t\t\tvar field = Object.keys(value)[0];\n\t\t\tvar operation = value[field];\n\t\t\tvar operator = Object.keys(operation)[0];\n\t\t\tvar operand = operation[operator];\n\t\t\tif (operator == \"and\") {\n\t\t\t\tdoc[field] = doc[field] & operand;\n\t\t\t} else if (operator == \"or\") {\n\t\t\t\tdoc[field] = doc[field] | operand;\n\t\t\t} else if (operator == \"xor\") {\n\t\t\t\tdoc[field] = doc[field] ^ operand;\n\t\t\t} else {\n\t\t\t\tthrow \"unknown $bit operator: \" + operator;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow \"unknown update operator: \" + key;\n\t\t}\n\t}\n}\n\n/**\n * Create a new document from query and update operators for upsert\n */\nexport function createDocFromUpdate(query, updates, idGenerator) {\n\tvar newDoc = { _id: idGenerator() };\n\tvar onlyFields = true;\n\tvar updateKeys = Object.keys(updates);\n\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\tif (updateKeys[i].charAt(0) == \"$\") {\n\t\t\tonlyFields = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (onlyFields) {\n\t\tfor (var i = 0; i < updateKeys.length; i++) {\n\t\t\tnewDoc[updateKeys[i]] = updates[updateKeys[i]];\n\t\t}\n\t} else {\n\t\tvar queryKeys = Object.keys(query);\n\t\tfor (var i = 0; i < queryKeys.length; i++) {\n\t\t\tnewDoc[queryKeys[i]] = query[queryKeys[i]];\n\t\t}\n\t\tapplyUpdates(updates, newDoc, true);\n\t}\n\treturn newDoc;\n}\n","/**\n * Base class for collection indexes\n * Provides a common interface for different types of indexes (e.g., regular, text, geo)\n */\nexport class CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tthis.keys = keys;\n\t\tthis.options = options;\n\t\tthis.name = options.name || this.generateIndexName(keys);\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tthrow new Error('add() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tthrow new Error('remove() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Update a document in the index (remove old, add new)\n\t * @param {Object} oldDoc - The old document\n\t * @param {Object} newDoc - The new document\n\t */\n\tupdate(oldDoc, newDoc) {\n\t\tthis.remove(oldDoc);\n\t\tthis.add(newDoc);\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query to execute\n\t * @returns {Array} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tthrow new Error('query() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthrow new Error('clear() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Get index specification (for getIndexes())\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\tthrow new Error('serialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} data - Serialized index state\n\t */\n\tdeserialize(data) {\n\t\tthrow new Error('deserialize() must be implemented by subclass');\n\t}\n}\n","import { CollectionIndex } from './CollectionIndex.js';\nimport { getProp } from './utils.js';\n\n/**\n * Regular (B-tree style) index implementation\n * Supports equality queries on indexed fields\n */\nexport class RegularCollectionIndex extends CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tsuper(keys, options);\n\t\t// Map of key value to array of document _ids\n\t\tthis.data = {};\n\t}\n\n\t/**\n\t * Extract index key value from a document\n\t */\n\textractIndexKey(doc) {\n\t\tconst keyFields = Object.keys(this.keys);\n\t\tif (keyFields.length === 0) return null;\n\n\t\t// For simple single-field index\n\t\tif (keyFields.length === 1) {\n\t\t\tconst field = keyFields[0];\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value === undefined) return null;\n\t\t\t// Preserve type information in the key\n\t\t\treturn JSON.stringify({ t: typeof value, v: value });\n\t\t}\n\n\t\t// For compound index, concatenate values with type preservation\n\t\tconst keyParts = [];\n\t\tfor (let i = 0; i < keyFields.length; i++) {\n\t\t\tconst value = getProp(doc, keyFields[i]);\n\t\t\tif (value === undefined) return null;\n\t\t\tkeyParts.push(JSON.stringify(value));\n\t\t}\n\t\t// Use a separator that won't appear in JSON\n\t\treturn keyParts.join('\\x00');\n\t}\n\n\t/**\n\t * Add a document to the index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null) {\n\t\t\tif (!this.data[indexKey]) {\n\t\t\t\tthis.data[indexKey] = [];\n\t\t\t}\n\t\t\tthis.data[indexKey].push(doc._id);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tconst indexKey = this.extractIndexKey(doc);\n\t\tif (indexKey !== null && this.data[indexKey]) {\n\t\t\tconst arr = this.data[indexKey];\n\t\t\tconst idx = arr.indexOf(doc._id);\n\t\t\tif (idx !== -1) {\n\t\t\t\tarr.splice(idx, 1);\n\t\t\t}\n\t\t\tif (arr.length === 0) {\n\t\t\t\tdelete this.data[indexKey];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if index cannot satisfy query\n\t */\n\tquery(query) {\n\t\tconst queryKeys = Object.keys(query);\n\t\tconst indexFields = Object.keys(this.keys);\n\n\t\t// Check if query matches index (simple case: single field equality)\n\t\tif (indexFields.length === 1) {\n\t\t\tconst field = indexFields[0];\n\t\t\t// Check for simple equality\n\t\t\tif (queryKeys.indexOf(field) !== -1) {\n\t\t\t\tconst queryValue = query[field];\n\t\t\t\t// Only use index for simple equality (not operators like $gt, $lt, etc.)\n\t\t\t\tif (typeof queryValue !== 'object' || queryValue === null) {\n\t\t\t\t\tconst indexKey = JSON.stringify({ t: typeof queryValue, v: queryValue });\n\t\t\t\t\treturn this.data[indexKey] || [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.data = {};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\ttype: 'regular',\n\t\t\tkeys: this.keys,\n\t\t\toptions: this.options,\n\t\t\tdata: this.data\n\t\t};\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} state - Serialized index state\n\t */\n\tdeserialize(state) {\n\t\tthis.data = state.data || {};\n\t}\n}\n","import { CollectionIndex } from './CollectionIndex.js';\nimport { TextIndex } from './TextIndex.js';\nimport { getProp } from './utils.js';\n\n/**\n * Text index implementation using TextIndex\n * Supports full-text search on one or more fields\n */\nexport class TextCollectionIndex extends CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tsuper(keys, options);\n\t\t// Create the underlying TextIndex\n\t\tthis.textIndex = new TextIndex(options);\n\t\t// Track which fields are indexed\n\t\tthis.indexedFields = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\tthis.indexedFields.push(field);\n\t\t\t}\n\t\t}\n\t\tif (this.indexedFields.length === 0) {\n\t\t\tthrow new Error('Text index must have at least one field with type \"text\"');\n\t\t}\n\t}\n\n\t/**\n\t * Extract text content from a document for the indexed fields\n\t * @param {Object} doc - The document\n\t * @returns {string} Combined text from all indexed fields\n\t */\n\t_extractText(doc) {\n\t\tconst textParts = [];\n\t\tfor (const field of this.indexedFields) {\n\t\t\tconst value = getProp(doc, field);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\ttextParts.push(String(value));\n\t\t\t}\n\t\t}\n\t\treturn textParts.join(' ');\n\t}\n\n\t/**\n\t * Add a document to the text index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst text = this._extractText(doc);\n\t\tif (text) {\n\t\t\tthis.textIndex.add(String(doc._id), text);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the text index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tthis.textIndex.remove(String(doc._id));\n\t}\n\n\t/**\n\t * Query the text index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a text search\n\t */\n\tquery(query) {\n\t\t// This method is used for query planning\n\t\t// Text queries are handled separately in queryMatcher\n\t\treturn null;\n\t}\n\n\t/**\n\t * Search the text index\n\t * @param {string} searchText - The text to search for\n\t * @param {Object} options - Search options\n\t * @returns {Array} Array of document IDs\n\t */\n\tsearch(searchText, options = {}) {\n\t\tconst results = this.textIndex.query(searchText, { scored: false, ...options });\n\t\treturn results;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.textIndex.clear();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\ttextIndexVersion: 3,\n\t\t\tweights: this._getWeights()\n\t\t};\n\t}\n\n\t/**\n\t * Get field weights (all default to 1 for now)\n\t */\n\t_getWeights() {\n\t\tconst weights = {};\n\t\tfor (const field of this.indexedFields) {\n\t\t\tweights[field] = 1;\n\t\t}\n\t\treturn weights;\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\ttype: 'text',\n\t\t\tkeys: this.keys,\n\t\t\toptions: this.options,\n\t\t\tindexedFields: this.indexedFields,\n\t\t\ttextIndexState: this.textIndex.serialize()\n\t\t};\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} state - Serialized index state\n\t */\n\tdeserialize(state) {\n\t\tthis.indexedFields = state.indexedFields || [];\n\t\tif (state.textIndexState) {\n\t\t\tthis.textIndex.deserialize(state.textIndexState);\n\t\t}\n\t}\n}\n","/**\n * R-tree implementation for geospatial indexing\n * \n * This implementation supports:\n * - Adding points with lat/lng coordinates\n * - Removing points\n * - Bounding box queries\n * - Location + radius queries (converted to bounding box)\n */\n\n/**\n * Calculate distance between two points using Haversine formula\n * @param {number} lat1 - Latitude of first point\n * @param {number} lng1 - Longitude of first point\n * @param {number} lat2 - Latitude of second point\n * @param {number} lng2 - Longitude of second point\n * @returns {number} Distance in kilometers\n */\nfunction haversineDistance(lat1, lng1, lat2, lng2) {\n\tconst R = 6371; // Earth's radius in kilometers\n\tconst dLat = (lat2 - lat1) * Math.PI / 180;\n\tconst dLng = (lng2 - lng1) * Math.PI / 180;\n\tconst a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n\t\tMath.sin(dLng / 2) * Math.sin(dLng / 2);\n\tconst c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn R * c;\n}\n\n/**\n * Convert radius query to bounding box\n * Approximation: 1 degree latitude  111 km\n * @param {number} lat - Center latitude\n * @param {number} lng - Center longitude\n * @param {number} radiusKm - Radius in kilometers\n * @returns {Object} Bounding box {minLat, maxLat, minLng, maxLng}\n */\nfunction radiusToBoundingBox(lat, lng, radiusKm) {\n\tconst latDelta = radiusKm / 111; // degrees\n\tconst lngDelta = radiusKm / (111 * Math.cos(lat * Math.PI / 180)); // degrees\n\t\n\treturn {\n\t\tminLat: lat - latDelta,\n\t\tmaxLat: lat + latDelta,\n\t\tminLng: lng - lngDelta,\n\t\tmaxLng: lng + lngDelta\n\t};\n}\n\n/**\n * Check if two bounding boxes intersect\n */\nfunction intersects(bbox1, bbox2) {\n\treturn !(bbox1.maxLat < bbox2.minLat ||\n\t\tbbox1.minLat > bbox2.maxLat ||\n\t\tbbox1.maxLng < bbox2.minLng ||\n\t\tbbox1.minLng > bbox2.maxLng);\n}\n\n/**\n * Check if bbox1 contains bbox2\n */\nfunction contains(bbox1, bbox2) {\n\treturn bbox1.minLat <= bbox2.minLat &&\n\t\tbbox1.maxLat >= bbox2.maxLat &&\n\t\tbbox1.minLng <= bbox2.minLng &&\n\t\tbbox1.maxLng >= bbox2.maxLng;\n}\n\n/**\n * Calculate the area of a bounding box\n */\nfunction area(bbox) {\n\treturn (bbox.maxLat - bbox.minLat) * (bbox.maxLng - bbox.minLng);\n}\n\n/**\n * Calculate the bounding box that contains both input boxes\n */\nfunction union(bbox1, bbox2) {\n\treturn {\n\t\tminLat: Math.min(bbox1.minLat, bbox2.minLat),\n\t\tmaxLat: Math.max(bbox1.maxLat, bbox2.maxLat),\n\t\tminLng: Math.min(bbox1.minLng, bbox2.minLng),\n\t\tmaxLng: Math.max(bbox1.maxLng, bbox2.maxLng)\n\t};\n}\n\n/**\n * Calculate the enlargement needed to include bbox2 in bbox1\n */\nfunction enlargement(bbox1, bbox2) {\n\tconst unionBox = union(bbox1, bbox2);\n\treturn area(unionBox) - area(bbox1);\n}\n\n/**\n * R-tree Node class\n */\nclass RTreeNode {\n\tconstructor(isLeaf = false) {\n\t\tthis.isLeaf = isLeaf;\n\t\tthis.children = []; // For internal nodes: child nodes; For leaf nodes: data entries\n\t\tthis.bbox = null;\n\t}\n\n\t/**\n\t * Update the bounding box to contain all children\n\t */\n\tupdateBBox() {\n\t\tif (this.children.length === 0) {\n\t\t\tthis.bbox = null;\n\t\t\treturn;\n\t\t}\n\n\t\tlet minLat = Infinity, maxLat = -Infinity;\n\t\tlet minLng = Infinity, maxLng = -Infinity;\n\n\t\tfor (const child of this.children) {\n\t\t\tconst bbox = child.bbox;\n\t\t\tminLat = Math.min(minLat, bbox.minLat);\n\t\t\tmaxLat = Math.max(maxLat, bbox.maxLat);\n\t\t\tminLng = Math.min(minLng, bbox.minLng);\n\t\t\tmaxLng = Math.max(maxLng, bbox.maxLng);\n\t\t}\n\n\t\tthis.bbox = { minLat, maxLat, minLng, maxLng };\n\t}\n}\n\n/**\n * R-tree implementation\n */\nexport class RTree {\n\tconstructor(maxEntries = 9) {\n\t\tthis.maxEntries = maxEntries;\n\t\tthis.minEntries = Math.max(2, Math.ceil(maxEntries / 2));\n\t\tthis.root = new RTreeNode(true);\n\t\tthis._size = 0; // Track size for O(1) queries\n\t}\n\n\t/**\n\t * Insert a point into the R-tree\n\t * @param {number} lat - Latitude\n\t * @param {number} lng - Longitude\n\t * @param {*} data - Associated data\n\t */\n\tinsert(lat, lng, data) {\n\t\t// Create a point bounding box (bbox with zero area)\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst entry = { bbox, lat, lng, data };\n\t\tthis._insert(entry, this.root, 1);\n\t\tthis._size++;\n\t}\n\n\t/**\n\t * Internal insert method\n\t */\n\t_insert(entry, node, level) {\n\t\tif (node.isLeaf) {\n\t\t\tnode.children.push(entry);\n\t\t\tnode.updateBBox();\n\n\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\treturn this._split(node);\n\t\t\t}\n\t\t} else {\n\t\t\t// Choose subtree\n\t\t\tconst target = this._chooseSubtree(entry.bbox, node);\n\t\t\tconst splitNode = this._insert(entry, target, level + 1);\n\n\t\t\tif (splitNode) {\n\t\t\t\tnode.children.push(splitNode);\n\t\t\t\tnode.updateBBox();\n\n\t\t\t\tif (node.children.length > this.maxEntries) {\n\t\t\t\t\treturn this._split(node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.updateBBox();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Choose the best subtree to insert an entry\n\t */\n\t_chooseSubtree(bbox, node) {\n\t\tlet minEnlargement = Infinity;\n\t\tlet minArea = Infinity;\n\t\tlet targetNode = null;\n\n\t\tfor (const child of node.children) {\n\t\t\tconst enl = enlargement(child.bbox, bbox);\n\t\t\tconst ar = area(child.bbox);\n\n\t\t\tif (enl < minEnlargement || (enl === minEnlargement && ar < minArea)) {\n\t\t\t\tminEnlargement = enl;\n\t\t\t\tminArea = ar;\n\t\t\t\ttargetNode = child;\n\t\t\t}\n\t\t}\n\n\t\treturn targetNode;\n\t}\n\n\t/**\n\t * Split an overflowing node\n\t */\n\t_split(node) {\n\t\t// Simple linear split algorithm\n\t\tconst children = node.children;\n\t\tconst isLeaf = node.isLeaf;\n\n\t\t// Find two seeds (most distant entries)\n\t\tlet maxDist = -Infinity;\n\t\tlet seed1Idx = 0, seed2Idx = 1;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tfor (let j = i + 1; j < children.length; j++) {\n\t\t\t\tconst bbox1 = children[i].bbox;\n\t\t\t\tconst bbox2 = children[j].bbox;\n\t\t\t\tconst combinedBox = union(bbox1, bbox2);\n\t\t\t\tconst waste = area(combinedBox) - area(bbox1) - area(bbox2);\n\t\t\t\t\n\t\t\t\tif (waste > maxDist) {\n\t\t\t\t\tmaxDist = waste;\n\t\t\t\t\tseed1Idx = i;\n\t\t\t\t\tseed2Idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create two new nodes\n\t\tconst node1 = new RTreeNode(isLeaf);\n\t\tconst node2 = new RTreeNode(isLeaf);\n\n\t\tnode1.children.push(children[seed1Idx]);\n\t\tnode2.children.push(children[seed2Idx]);\n\n\t\t// Distribute remaining entries\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tif (i === seed1Idx || i === seed2Idx) continue;\n\n\t\t\tconst child = children[i];\n\t\t\tconst bbox = child.bbox;\n\t\t\t\n\t\t\tconst enl1 = node1.children.length === 0 ? Infinity : enlargement(node1.bbox || bbox, bbox);\n\t\t\tconst enl2 = node2.children.length === 0 ? Infinity : enlargement(node2.bbox || bbox, bbox);\n\n\t\t\tif (node1.children.length < this.minEntries && \n\t\t\t\tchildren.length - i + node1.children.length <= this.minEntries) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (node2.children.length < this.minEntries && \n\t\t\t\tchildren.length - i + node2.children.length <= this.minEntries) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else if (enl1 < enl2) {\n\t\t\t\tnode1.children.push(child);\n\t\t\t} else if (enl2 < enl1) {\n\t\t\t\tnode2.children.push(child);\n\t\t\t} else {\n\t\t\t\t// Equal enlargement, choose the one with smaller area\n\t\t\t\tconst area1 = node1.bbox ? area(node1.bbox) : 0;\n\t\t\t\tconst area2 = node2.bbox ? area(node2.bbox) : 0;\n\t\t\t\tif (area1 < area2) {\n\t\t\t\t\tnode1.children.push(child);\n\t\t\t\t} else {\n\t\t\t\t\tnode2.children.push(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode1.updateBBox();\n\t\t\tnode2.updateBBox();\n\t\t}\n\n\t\t// Update the original node with one group\n\t\tnode.children = node1.children;\n\t\tnode.updateBBox();\n\n\t\t// If this was the root, create a new root\n\t\tif (node === this.root) {\n\t\t\tconst newRoot = new RTreeNode(false);\n\t\t\tnewRoot.children = [node1, node2];\n\t\t\tnewRoot.updateBBox();\n\t\t\tthis.root = newRoot;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn node2;\n\t}\n\n\t/**\n\t * Search for points within a bounding box\n\t * @param {Object} bbox - Bounding box {minLat, maxLat, minLng, maxLng}\n\t * @returns {Array} Array of matching entries\n\t */\n\tsearchBBox(bbox) {\n\t\tconst results = [];\n\t\tthis._searchBBox(bbox, this.root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal bounding box search\n\t */\n\t_searchBBox(bbox, node, results) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (const entry of node.children) {\n\t\t\t\tif (intersects(bbox, entry.bbox)) {\n\t\t\t\t\tresults.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tthis._searchBBox(bbox, child, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search for points within a radius of a location\n\t * @param {number} lat - Center latitude\n\t * @param {number} lng - Center longitude\n\t * @param {number} radiusKm - Radius in kilometers\n\t * @returns {Array} Array of matching entries\n\t */\n\tsearchRadius(lat, lng, radiusKm) {\n\t\t// Convert radius to bounding box for initial filtering\n\t\tconst bbox = radiusToBoundingBox(lat, lng, radiusKm);\n\t\tconst candidates = this.searchBBox(bbox);\n\n\t\t// Filter by actual distance\n\t\tconst results = [];\n\t\tfor (const entry of candidates) {\n\t\t\tconst dist = haversineDistance(lat, lng, entry.lat, entry.lng);\n\t\t\tif (dist <= radiusKm) {\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Remove a point from the R-tree\n\t * @param {number} lat - Latitude\n\t * @param {number} lng - Longitude\n\t * @param {*} data - Associated data (optional, for exact match)\n\t * @returns {boolean} True if removed, false if not found\n\t */\n\tremove(lat, lng, data = null) {\n\t\tconst bbox = {\n\t\t\tminLat: lat,\n\t\t\tmaxLat: lat,\n\t\t\tminLng: lng,\n\t\t\tmaxLng: lng\n\t\t};\n\n\t\tconst removed = this._remove(bbox, data, this.root, null, -1);\n\t\t\n\t\tif (removed) {\n\t\t\tthis._size--;\n\t\t}\n\t\t\n\t\t// If root has only one child after removal, make that child the new root\n\t\tif (this.root.children.length === 1 && !this.root.isLeaf) {\n\t\t\tthis.root = this.root.children[0];\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Internal remove method\n\t */\n\t_remove(bbox, data, node, parent, indexInParent) {\n\t\tif (!node.bbox || !intersects(bbox, node.bbox)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.isLeaf) {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst entry = node.children[i];\n\t\t\t\tif (entry.lat === bbox.minLat && entry.lng === bbox.minLng) {\n\t\t\t\t\t// If data is specified, check for match\n\t\t\t\t\tconst dataMatches = data === null || \n\t\t\t\t\t\tJSON.stringify(entry.data) === JSON.stringify(data);\n\t\t\t\t\t\n\t\t\t\t\tif (dataMatches) {\n\t\t\t\t\t\tnode.children.splice(i, 1);\n\t\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Handle underflow\n\t\t\t\t\t\tif (node.children.length < this.minEntries && node !== this.root) {\n\t\t\t\t\t\t\t// Simple approach: reinsert all entries from this node\n\t\t\t\t\t\t\tconst entries = node.children.slice();\n\t\t\t\t\t\t\tnode.children = [];\n\t\t\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Remove this node from parent\n\t\t\t\t\t\t\tif (parent) {\n\t\t\t\t\t\t\t\tparent.children.splice(indexInParent, 1);\n\t\t\t\t\t\t\t\tparent.updateBBox();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Reinsert entries\n\t\t\t\t\t\t\tfor (const e of entries) {\n\t\t\t\t\t\t\t\tthis._insert(e, this.root, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\t\t\t\tif (this._remove(bbox, data, child, node, i)) {\n\t\t\t\t\tnode.updateBBox();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get all entries in the tree\n\t * @returns {Array} All entries\n\t */\n\tgetAll() {\n\t\tconst results = [];\n\t\tthis._getAll(this.root, results);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Internal method to get all entries\n\t */\n\t_getAll(node, results) {\n\t\tif (node.isLeaf) {\n\t\t\tresults.push(...node.children);\n\t\t} else {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tthis._getAll(child, results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the number of entries in the tree\n\t * @returns {number} Number of entries\n\t */\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Clear all entries from the tree\n\t */\n\tclear() {\n\t\tthis.root = new RTreeNode(true);\n\t\tthis._size = 0;\n\t}\n\n\t/**\n\t * Serialize the R-tree state for storage\n\t * @returns {Object} Serializable state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\tmaxEntries: this.maxEntries,\n\t\t\tminEntries: this.minEntries,\n\t\t\tsize: this._size,\n\t\t\troot: this._serializeNode(this.root)\n\t\t};\n\t}\n\n\t/**\n\t * Serialize a node recursively\n\t */\n\t_serializeNode(node) {\n\t\tconst serialized = {\n\t\t\tisLeaf: node.isLeaf,\n\t\t\tbbox: node.bbox,\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (node.isLeaf) {\n\t\t\t// Leaf nodes contain entries\n\t\t\tserialized.children = node.children.map(entry => ({\n\t\t\t\tbbox: entry.bbox,\n\t\t\t\tlat: entry.lat,\n\t\t\t\tlng: entry.lng,\n\t\t\t\tdata: entry.data\n\t\t\t}));\n\t\t} else {\n\t\t\t// Internal nodes contain child nodes\n\t\t\tserialized.children = node.children.map(child => this._serializeNode(child));\n\t\t}\n\n\t\treturn serialized;\n\t}\n\n\t/**\n\t * Restore the R-tree state from serialized data\n\t * @param {Object} state - Serialized state\n\t */\n\tdeserialize(state) {\n\t\tthis.maxEntries = state.maxEntries || 9;\n\t\tthis.minEntries = state.minEntries || Math.ceil(this.maxEntries / 2);\n\t\tthis._size = state.size || 0;\n\t\tthis.root = this._deserializeNode(state.root);\n\t}\n\n\t/**\n\t * Deserialize a node recursively\n\t */\n\t_deserializeNode(serialized) {\n\t\tconst node = new RTreeNode(serialized.isLeaf);\n\t\tnode.bbox = serialized.bbox;\n\n\t\tif (serialized.isLeaf) {\n\t\t\t// Restore leaf entries\n\t\t\tnode.children = serialized.children.map(entry => ({\n\t\t\t\tbbox: entry.bbox,\n\t\t\t\tlat: entry.lat,\n\t\t\t\tlng: entry.lng,\n\t\t\t\tdata: entry.data\n\t\t\t}));\n\t\t} else {\n\t\t\t// Restore child nodes\n\t\t\tnode.children = serialized.children.map(child => this._deserializeNode(child));\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\nexport default RTree;\n","import { CollectionIndex } from './CollectionIndex.js';\nimport { RTree } from './RTree.js';\nimport { getProp } from './utils.js';\n\n/**\n * Geospatial index implementation using RTree\n * Supports geospatial queries on GeoJSON fields\n */\nexport class GeospatialCollectionIndex extends CollectionIndex {\n\tconstructor(keys, options = {}) {\n\t\tsuper(keys, options);\n\t\t// Create the underlying RTree\n\t\tthis.rtree = new RTree();\n\t\t// Track which field is the geospatial field\n\t\tthis.geoField = null;\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\tthis.geoField = field;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!this.geoField) {\n\t\t\tthrow new Error('Geospatial index must have at least one field with type \"2dsphere\" or \"2d\"');\n\t\t}\n\t}\n\n\t/**\n\t * Extract coordinates from a GeoJSON object\n\t * @param {Object} geoJson - The GeoJSON object\n\t * @returns {Object|null} Object with lat and lng, or null if invalid\n\t */\n\t_extractCoordinates(geoJson) {\n\t\tif (!geoJson) return null;\n\n\t\t// Handle GeoJSON FeatureCollection\n\t\tif (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {\n\t\t\tconst feature = geoJson.features[0];\n\t\t\tif (feature.geometry) {\n\t\t\t\treturn this._extractCoordinates(feature.geometry);\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Feature\n\t\tif (geoJson.type === 'Feature' && geoJson.geometry) {\n\t\t\treturn this._extractCoordinates(geoJson.geometry);\n\t\t}\n\n\t\t// Handle GeoJSON Point\n\t\tif (geoJson.type === 'Point' && geoJson.coordinates) {\n\t\t\tconst [lng, lat] = geoJson.coordinates;\n\t\t\tif (typeof lng === 'number' && typeof lat === 'number') {\n\t\t\t\treturn { lat, lng };\n\t\t\t}\n\t\t}\n\n\t\t// Handle GeoJSON Polygon - use centroid of first coordinate\n\t\tif (geoJson.type === 'Polygon' && geoJson.coordinates && geoJson.coordinates.length > 0) {\n\t\t\tconst ring = geoJson.coordinates[0];\n\t\t\tif (ring.length > 0) {\n\t\t\t\tlet sumLat = 0, sumLng = 0;\n\t\t\t\tfor (const coord of ring) {\n\t\t\t\t\tsumLng += coord[0];\n\t\t\t\t\tsumLat += coord[1];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tlat: sumLat / ring.length,\n\t\t\t\t\tlng: sumLng / ring.length\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add a document to the geospatial index\n\t * @param {Object} doc - The document to index\n\t */\n\tadd(doc) {\n\t\tif (!doc._id) {\n\t\t\tthrow new Error('Document must have an _id field');\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\tthis.rtree.insert(coords.lat, coords.lng, { \n\t\t\t\t_id: doc._id, \n\t\t\t\tgeoJson: geoValue \n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Remove a document from the geospatial index\n\t * @param {Object} doc - The document to remove\n\t */\n\tremove(doc) {\n\t\tif (!doc._id) {\n\t\t\treturn;\n\t\t}\n\t\tconst geoValue = getProp(doc, this.geoField);\n\t\tconst coords = this._extractCoordinates(geoValue);\n\t\tif (coords) {\n\t\t\tthis.rtree.remove(coords.lat, coords.lng, { \n\t\t\t\t_id: doc._id, \n\t\t\t\tgeoJson: geoValue \n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Query the geospatial index\n\t * @param {*} query - The query object\n\t * @returns {Array|null} Array of document IDs or null if query is not a geospatial query\n\t */\n\tquery(query) {\n\t\t// Check if this is a geospatial query on our indexed field\n\t\tif (!query[this.geoField]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst geoQuery = query[this.geoField];\n\n\t\t// Handle $geoWithin with bounding box\n\t\tif (geoQuery.$geoWithin) {\n\t\t\tconst bbox = geoQuery.$geoWithin;\n\t\t\t// bbox format: [[minLon, maxLat], [maxLon, minLat]]\n\t\t\tif (Array.isArray(bbox) && bbox.length === 2) {\n\t\t\t\tconst minLon = bbox[0][0];\n\t\t\t\tconst maxLat = bbox[0][1];\n\t\t\t\tconst maxLon = bbox[1][0];\n\t\t\t\tconst minLat = bbox[1][1];\n\n\t\t\t\tconst results = this.rtree.searchBBox({\n\t\t\t\t\tminLat: minLat,\n\t\t\t\t\tmaxLat: maxLat,\n\t\t\t\t\tminLng: minLon,\n\t\t\t\t\tmaxLng: maxLon\n\t\t\t\t});\n\n\t\t\t\t// Extract document IDs\n\t\t\t\treturn results.map(entry => entry.data._id);\n\t\t\t}\n\t\t}\n\n\t\t// Handle $near with radius (future enhancement)\n\t\t// if (geoQuery.$near) {\n\t\t//   const center = geoQuery.$near;\n\t\t//   const maxDistance = geoQuery.$maxDistance || 1000; // default 1000km\n\t\t//   // Implementation would use rtree.searchRadius\n\t\t// }\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clear all data from the index\n\t */\n\tclear() {\n\t\tthis.rtree.clear();\n\t}\n\n\t/**\n\t * Get index specification\n\t */\n\tgetSpec() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tkey: this.keys,\n\t\t\t'2dsphereIndexVersion': 3\n\t\t};\n\t}\n\n\t/**\n\t * Serialize index state for storage\n\t * @returns {Object} Serializable index state\n\t */\n\tserialize() {\n\t\treturn {\n\t\t\ttype: 'geospatial',\n\t\t\tkeys: this.keys,\n\t\t\toptions: this.options,\n\t\t\tgeoField: this.geoField,\n\t\t\trtreeState: this.rtree.serialize()\n\t\t};\n\t}\n\n\t/**\n\t * Restore index state from serialized data\n\t * @param {Object} state - Serialized index state\n\t */\n\tdeserialize(state) {\n\t\tthis.geoField = state.geoField;\n\t\tif (state.rtreeState) {\n\t\t\tthis.rtree.deserialize(state.rtreeState);\n\t\t}\n\t}\n}\n","import { Cursor } from './Cursor.js';\nimport { SortedCursor } from './SortedCursor.js';\nimport { isArray, getProp, applyProjection, copy } from './utils.js';\nimport { matches } from './queryMatcher.js';\nimport { applyUpdates, createDocFromUpdate } from './updates.js';\nimport { RegularCollectionIndex } from './RegularCollectionIndex.js';\nimport { TextCollectionIndex } from './TextCollectionIndex.js';\nimport { GeospatialCollectionIndex } from './GeospatialCollectionIndex.js';\n\n/**\n * Collection class\n */\nexport class Collection {\n\tconstructor(db, storage, idGenerator) {\n\t\tthis.db = db;\n\t\tthis.storage = storage;\n\t\tthis.idGenerator = idGenerator;\n\t\tthis.indexes = {}; // Index storage - map of index name to index structure\n\t\tthis.isCollection = true; // TODO used by dropDatabase, ugly\n\t}\n\n\t/**\n\t * Generate index name from keys\n\t */\n\tgenerateIndexName(keys) {\n\t\tconst parts = [];\n\t\tfor (const field in keys) {\n\t\t\tif (keys.hasOwnProperty(field)) {\n\t\t\t\tparts.push(field + '_' + keys[field]);\n\t\t\t}\n\t\t}\n\t\treturn parts.join('_');\n\t}\n\n\t/**\n\t * Determine if keys specify a text index\n\t */\n\tisTextIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === 'text') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine if keys specify a geospatial index\n\t */\n\tisGeospatialIndex(keys) {\n\t\tfor (const field in keys) {\n\t\t\tif (keys[field] === '2dsphere' || keys[field] === '2d') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build/rebuild an index\n\t */\n\tbuildIndex(indexName, keys, options = {}) {\n\t\tlet index;\n\t\t\n\t\t// Create appropriate index type\n\t\tif (this.isTextIndex(keys)) {\n\t\t\tindex = new TextCollectionIndex(keys, { ...options, name: indexName });\n\t\t} else if (this.isGeospatialIndex(keys)) {\n\t\t\tindex = new GeospatialCollectionIndex(keys, { ...options, name: indexName });\n\t\t} else {\n\t\t\tindex = new RegularCollectionIndex(keys, { ...options, name: indexName });\n\t\t}\n\n\t\t// Build index by scanning all documents\n\t\tfor (let i = 0; i < this.storage.size(); i++) {\n\t\t\tconst doc = this.storage.get(i);\n\t\t\tif (doc) {\n\t\t\t\tindex.add(doc);\n\t\t\t}\n\t\t}\n\n\t\tthis.indexes[indexName] = index;\n\t\treturn index;\n\t}\n\n\t/**\n\t * Update indexes when a document is inserted\n\t */\n\tupdateIndexesOnInsert(doc) {\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tindex.add(doc);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Update indexes when a document is deleted\n\t */\n\tupdateIndexesOnDelete(doc) {\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tindex.remove(doc);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query planner - analyze query and determine if an index can be used\n\t */\n\tplanQuery(query) {\n\t\t// Simple query planner - look for equality queries on indexed fields\n\t\tconst queryKeys = Object.keys(query);\n\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\t\n\t\t\t\t// Skip text indexes - they are handled separately\n\t\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Try geospatial indexes\n\t\t\t\tif (index instanceof GeospatialCollectionIndex) {\n\t\t\t\t\tconst docIds = index.query(query);\n\t\t\t\t\tif (docIds !== null) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuseIndex: true,\n\t\t\t\t\t\t\tindexName: indexName,\n\t\t\t\t\t\t\tdocIds: docIds\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst indexFields = Object.keys(index.keys);\n\n\t\t\t\t// Check if query matches index (simple case: single field equality)\n\t\t\t\t// Note: Compound indexes are created but only single-field equality queries use them\n\t\t\t\tif (indexFields.length === 1) {\n\t\t\t\t\tconst field = indexFields[0];\n\t\t\t\t\t// Check for simple equality\n\t\t\t\t\tif (queryKeys.indexOf(field) !== -1) {\n\t\t\t\t\t\tconst queryValue = query[field];\n\t\t\t\t\t\t// Only use index for simple equality (not operators like $gt, $lt, etc.)\n\t\t\t\t\t\tif (typeof queryValue !== 'object' || queryValue === null) {\n\t\t\t\t\t\t\tconst docIds = index.query(query);\n\t\t\t\t\t\t\tif (docIds !== null) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tuseIndex: true,\n\t\t\t\t\t\t\t\t\tindexName: indexName,\n\t\t\t\t\t\t\t\t\tdocIds: docIds\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get a text index for the given field\n\t * @param {string} field - The field name\n\t * @returns {TextCollectionIndex|null} The text index or null if not found\n\t */\n\tgetTextIndex(field) {\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tif (index instanceof TextCollectionIndex) {\n\t\t\t\t\t// Check if this field is indexed\n\t\t\t\t\tif (index.indexedFields.includes(field)) {\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Collection methods\n\taggregate(pipeline) {\n\t\tif (!pipeline || !isArray(pipeline)) {\n\t\t\tthrow { $err: \"Pipeline must be an array\", code: 17287 };\n\t\t}\n\n\t\t// Start with all documents\n\t\tlet results = [];\n\t\tconst cursor = this.find({});\n\t\twhile (cursor.hasNext()) {\n\t\t\tresults.push(cursor.next());\n\t\t}\n\n\t\t// Process each stage in the pipeline\n\t\tfor (let i = 0; i < pipeline.length; i++) {\n\t\t\tconst stage = pipeline[i];\n\t\t\tconst stageKeys = Object.keys(stage);\n\t\t\tif (stageKeys.length !== 1) {\n\t\t\t\tthrow { $err: \"Each pipeline stage must have exactly one key\", code: 17287 };\n\t\t\t}\n\t\t\tconst stageType = stageKeys[0];\n\t\t\tconst stageSpec = stage[stageType];\n\n\t\t\tif (stageType === \"$match\") {\n\t\t\t\t// Filter documents based on query\n\t\t\t\tconst matched = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tif (matches(results[j], stageSpec)) {\n\t\t\t\t\t\tmatched.push(results[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults = matched;\n\t\t\t} else if (stageType === \"$project\") {\n\t\t\t\t// Reshape documents\n\t\t\t\tconst projected = [];\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tprojected.push(applyProjection(stageSpec, results[j]));\n\t\t\t\t}\n\t\t\t\tresults = projected;\n\t\t\t} else if (stageType === \"$sort\") {\n\t\t\t\t// Sort documents\n\t\t\t\tconst sortKeys = Object.keys(stageSpec);\n\t\t\t\tresults.sort(function (a, b) {\n\t\t\t\t\tfor (let k = 0; k < sortKeys.length; k++) {\n\t\t\t\t\t\tconst key = sortKeys[k];\n\t\t\t\t\t\tif (a[key] === undefined && b[key] !== undefined) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] !== undefined && b[key] === undefined) return 1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] < b[key]) return -1 * stageSpec[key];\n\t\t\t\t\t\tif (a[key] > b[key]) return 1 * stageSpec[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else if (stageType === \"$limit\") {\n\t\t\t\t// Limit number of documents\n\t\t\t\tresults = results.slice(0, stageSpec);\n\t\t\t} else if (stageType === \"$skip\") {\n\t\t\t\t// Skip documents\n\t\t\t\tresults = results.slice(stageSpec);\n\t\t\t} else if (stageType === \"$group\") {\n\t\t\t\t// Group documents\n\t\t\t\tconst groups = {};\n\t\t\t\tconst groupId = stageSpec._id;\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tlet key;\n\n\t\t\t\t\t// Compute group key\n\t\t\t\t\tif (groupId === null || groupId === undefined) {\n\t\t\t\t\t\tkey = null;\n\t\t\t\t\t} else if (typeof groupId === 'string' && groupId.charAt(0) === '$') {\n\t\t\t\t\t\t// Field reference\n\t\t\t\t\t\tkey = getProp(doc, groupId.substring(1));\n\t\t\t\t\t} else if (typeof groupId === 'object') {\n\t\t\t\t\t\t// Computed key\n\t\t\t\t\t\tkey = JSON.stringify(groupId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkey = groupId;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst keyStr = JSON.stringify(key);\n\n\t\t\t\t\t// Initialize group\n\t\t\t\t\tif (!groups[keyStr]) {\n\t\t\t\t\t\tgroups[keyStr] = {\n\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\tdocs: [],\n\t\t\t\t\t\t\taccumulators: {}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tgroups[keyStr].docs.push(doc);\n\t\t\t\t}\n\n\t\t\t\t// Apply accumulators\n\t\t\t\tconst grouped = [];\n\t\t\t\tfor (const groupKey in groups) {\n\t\t\t\t\tconst group = groups[groupKey];\n\t\t\t\t\tconst result = { _id: group._id };\n\n\t\t\t\t\t// Process each accumulator field\n\t\t\t\t\tfor (const field in stageSpec) {\n\t\t\t\t\t\tif (field === '_id') continue;\n\n\t\t\t\t\t\tconst accumulator = stageSpec[field];\n\t\t\t\t\t\tconst accKeys = Object.keys(accumulator);\n\t\t\t\t\t\tif (accKeys.length !== 1) continue;\n\n\t\t\t\t\t\tconst accType = accKeys[0];\n\t\t\t\t\t\tconst accExpr = accumulator[accType];\n\n\t\t\t\t\t\tif (accType === '$sum') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'number') {\n\t\t\t\t\t\t\t\t\tsum += accExpr;\n\t\t\t\t\t\t\t\t} else if (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tsum += val || 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = sum;\n\t\t\t\t\t\t} else if (accType === '$avg') {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tif (val !== undefined && val !== null) {\n\t\t\t\t\t\t\t\t\t\tsum += val;\n\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = count > 0 ? sum / count : 0;\n\t\t\t\t\t\t} else if (accType === '$min') {\n\t\t\t\t\t\t\tlet min = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tif (val !== undefined && (min === undefined || val < min)) {\n\t\t\t\t\t\t\t\t\t\tmin = val;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = min;\n\t\t\t\t\t\t} else if (accType === '$max') {\n\t\t\t\t\t\t\tlet max = undefined;\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tif (val !== undefined && (max === undefined || val > max)) {\n\t\t\t\t\t\t\t\t\t\tmax = val;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = max;\n\t\t\t\t\t\t} else if (accType === '$push') {\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tarr.push(val);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$addToSet') {\n\t\t\t\t\t\t\tconst set = {};\n\t\t\t\t\t\t\tfor (let k = 0; k < group.docs.length; k++) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tconst val = getProp(group.docs[k], accExpr.substring(1));\n\t\t\t\t\t\t\t\t\tset[JSON.stringify(val)] = val;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst arr = [];\n\t\t\t\t\t\t\tfor (const valKey in set) {\n\t\t\t\t\t\t\t\tarr.push(set[valKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult[field] = arr;\n\t\t\t\t\t\t} else if (accType === '$first') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tresult[field] = getProp(group.docs[0], accExpr.substring(1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (accType === '$last') {\n\t\t\t\t\t\t\tif (group.docs.length > 0) {\n\t\t\t\t\t\t\t\tif (typeof accExpr === 'string' && accExpr.charAt(0) === '$') {\n\t\t\t\t\t\t\t\t\tresult[field] = getProp(group.docs[group.docs.length - 1], accExpr.substring(1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgrouped.push(result);\n\t\t\t\t}\n\t\t\t\tresults = grouped;\n\t\t\t} else if (stageType === \"$count\") {\n\t\t\t\t// Count documents and return single document with count\n\t\t\t\tresults = [{ [stageSpec]: results.length }];\n\t\t\t} else if (stageType === \"$unwind\") {\n\t\t\t\t// Unwind array field\n\t\t\t\tconst unwound = [];\n\t\t\t\tlet fieldPath = stageSpec;\n\t\t\t\tif (typeof fieldPath === 'string' && fieldPath.charAt(0) === '$') {\n\t\t\t\t\tfieldPath = fieldPath.substring(1);\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < results.length; j++) {\n\t\t\t\t\tconst doc = results[j];\n\t\t\t\t\tconst arr = getProp(doc, fieldPath);\n\n\t\t\t\t\tif (arr && isArray(arr) && arr.length > 0) {\n\t\t\t\t\t\tfor (let k = 0; k < arr.length; k++) {\n\t\t\t\t\t\t\tconst unwoundDoc = copy(doc);\n\t\t\t\t\t\t\t// Set the unwound value\n\t\t\t\t\t\t\tconst parts = fieldPath.split('.');\n\t\t\t\t\t\t\tlet target = unwoundDoc;\n\t\t\t\t\t\t\tfor (let l = 0; l < parts.length - 1; l++) {\n\t\t\t\t\t\t\t\tif (!target[parts[l]]) {\n\t\t\t\t\t\t\t\t\ttarget[parts[l]] = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget = target[parts[l]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[parts[parts.length - 1]] = arr[k];\n\t\t\t\t\t\t\tunwound.push(unwoundDoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// MongoDB's default behavior: skip documents where field is missing, null, empty array, or not an array\n\t\t\t\t}\n\t\t\t\tresults = unwound;\n\t\t\t} else {\n\t\t\t\tthrow { $err: \"Unsupported aggregation stage: \" + stageType, code: 17287 };\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tbulkWrite() { throw \"Not Implemented\"; }\n\n\tasync count() {\n\t\treturn this.storage.size();\n\t}\n\n\tasync copyTo(destCollectionName) {\n\t\tif (!this.db[destCollectionName]) {\n\t\t\tthis.db.createCollection(destCollectionName);\n\t\t}\n\t\tconst destCol = this.db[destCollectionName];\n\t\tlet numCopied = 0;\n\t\tconst c = this.find({});\n\t\twhile (c.hasNext()) {\n\t\t\tawait destCol.insertOne(c.next());\n\t\t\tnumCopied++;\n\t\t}\n\t\treturn numCopied;\n\t}\n\n\tasync createIndex(keys, options) {\n\t\t// MongoDB-compliant createIndex\n\t\t// keys: { fieldName: 1 } for ascending, { fieldName: -1 } for descending, { fieldName: 'text' } for text\n\t\t// options: { name: \"indexName\", unique: true, ... }\n\n\t\tif (!keys || typeof keys !== 'object' || Array.isArray(keys)) {\n\t\t\tthrow { $err: \"createIndex requires a key specification object\", code: 2 };\n\t\t}\n\n\t\tconst indexName = (options && options.name) ? options.name : this.generateIndexName(keys);\n\n\t\t// Check if index already exists\n\t\tif (this.indexes[indexName]) {\n\t\t\t// MongoDB checks for key specification conflicts\n\t\t\tconst existingIndex = this.indexes[indexName];\n\t\t\tconst existingKeys = JSON.stringify(existingIndex.keys);\n\t\t\tconst newKeys = JSON.stringify(keys);\n\t\t\tif (existingKeys !== newKeys) {\n\t\t\t\tthrow { $err: \"Index with name '\" + indexName + \"' already exists with a different key specification\", code: 85 };\n\t\t\t}\n\t\t\t// Same index, return without error\n\t\t\treturn indexName;\n\t\t}\n\n\t\t// Build the index\n\t\tthis.buildIndex(indexName, keys, options);\n\n\t\treturn indexName;\n\t}\n\n\tdataSize() { throw \"Not Implemented\"; }\n\n\tasync deleteOne(query) {\n\t\tconst doc = await this.findOne(query);\n\t\tif (doc) {\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id);\n\t\t\treturn { deletedCount: 1 };\n\t\t} else {\n\t\t\treturn { deletedCount: 0 };\n\t\t}\n\t}\n\n\tasync deleteMany(query) {\n\t\tconst c = this.find(query);\n\t\tconst ids = [];\n\t\tconst docs = [];\n\t\twhile (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tids.push(doc._id);\n\t\t\tdocs.push(doc);\n\t\t}\n\t\tconst deletedCount = ids.length;\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tthis.updateIndexesOnDelete(docs[i]);\n\t\t\tthis.storage.remove(ids[i]);\n\t\t}\n\t\treturn { deletedCount: deletedCount };\n\t}\n\n\tasync distinct(field, query) {\n\t\tconst vals = {};\n\t\tconst c = this.find(query);\n\t\twhile (c.hasNext()) {\n\t\t\tconst d = c.next();\n\t\t\tif (d[field]) {\n\t\t\t\tvals[d[field]] = true;\n\t\t\t}\n\t\t}\n\t\treturn Object.keys(vals);\n\t}\n\n\tdrop() {\n\t\tthis.storage.clear();\n\t\t// Clear all indexes\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tthis.indexes[indexName].clear();\n\t\t\t}\n\t\t}\n\t}\n\n\tdropIndex(indexName) {\n\t\tif (!this.indexes[indexName]) {\n\t\t\tthrow { $err: \"Index not found with name: \" + indexName, code: 27 };\n\t\t}\n\t\tthis.indexes[indexName].clear();\n\t\tdelete this.indexes[indexName];\n\t\treturn { nIndexesWas: Object.keys(this.indexes).length + 1, ok: 1 };\n\t}\n\n\tdropIndexes() {\n\t\tconst count = Object.keys(this.indexes).length;\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tthis.indexes[indexName].clear();\n\t\t\t}\n\t\t}\n\t\tthis.indexes = {};\n\t\treturn { nIndexesWas: count, msg: \"non-_id indexes dropped\", ok: 1 };\n\t}\n\tensureIndex() { throw \"Not Implemented\"; }\n\texplain() { throw \"Not Implemented\"; }\n\n\tfind(query, projection) {\n\t\treturn new Cursor(\n\t\t\tthis,\n\t\t\t(query == undefined ? {} : query),\n\t\t\tprojection,\n\t\t\tmatches,\n\t\t\tthis.storage,\n\t\t\tthis.indexes,\n\t\t\tthis.planQuery.bind(this),\n\t\t\tSortedCursor\n\t\t);\n\t}\n\n\tfindAndModify() { throw \"Not Implemented\"; }\n\n\tasync findOne(query, projection) {\n\t\tconst cursor = this.find(query, projection);\n\t\tif (cursor.hasNext()) {\n\t\t\treturn cursor.next();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync findOneAndDelete(filter, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tthis.storage.remove(doc._id);\n\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\telse return doc;\n\t}\n\n\tasync findOneAndReplace(filter, replacement, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\treplacement._id = doc._id;\n\t\tthis.storage.set(doc._id, replacement);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, replacement);\n\t\t\telse return replacement;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tasync findOneAndUpdate(filter, update, options) {\n\t\tlet c = this.find(filter);\n\t\tif (options && options.sort) c = c.sort(options.sort);\n\t\tif (!c.hasNext()) return null;\n\t\tconst doc = c.next();\n\t\tconst clone = Object.assign({}, doc);\n\t\tapplyUpdates(update, clone);\n\t\tthis.storage.set(doc._id, clone);\n\t\tif (options && options.returnNewDocument) {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, clone);\n\t\t\telse return clone;\n\t\t} else {\n\t\t\tif (options && options.projection) return applyProjection(options.projection, doc);\n\t\t\telse return doc;\n\t\t}\n\t}\n\n\tgetIndexes() {\n\t\t// Return array of index specifications\n\t\tconst result = [];\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tresult.push(this.indexes[indexName].getSpec());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetShardDistribution() { throw \"Not Implemented\"; }\n\tgetShardVersion() { throw \"Not Implemented\"; }\n\n\t// non-mongo\n\tgetStore() {\n\t\treturn this.storage.getStore();\n\t}\n\n\tgroup() { throw \"Not Implemented\"; }\n\n\tasync insert(doc) {\n\t\tif (Array == doc.constructor) {\n\t\t\treturn await this.insertMany(doc);\n\t\t} else {\n\t\t\treturn await this.insertOne(doc);\n\t\t}\n\t}\n\n\tasync insertOne(doc) {\n\t\tif (doc._id == undefined) doc._id = this.idGenerator();\n\t\tthis.storage.set(doc._id, doc);\n\t\tthis.updateIndexesOnInsert(doc);\n\t\treturn { insertedId: doc._id };\n\t}\n\n\tasync insertMany(docs) {\n\t\tconst insertedIds = [];\n\t\tfor (let i = 0; i < docs.length; i++) {\n\t\t\tconst result = await this.insertOne(docs[i]);\n\t\t\tinsertedIds.push(result.insertedId);\n\t\t}\n\t\treturn { insertedIds: insertedIds };\n\t}\n\n\tisCapped() { throw \"Not Implemented\"; }\n\tmapReduce() { throw \"Not Implemented\"; }\n\treIndex() { throw \"Not Implemented\"; }\n\n\tasync replaceOne(query, replacement, options) { // only replace\n\t\t// first\n\t\tconst result = {};\n\t\tconst c = this.find(query);\n\t\tresult.matchedCount = c.count();\n\t\tif (result.matchedCount == 0) {\n\t\t\tresult.modifiedCount = 0;\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = replacement;\n\t\t\t\tnewDoc._id = this.idGenerator();\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tresult.upsertedId = newDoc._id;\n\t\t\t}\n\t\t} else {\n\t\t\tresult.modifiedCount = 1;\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\treplacement._id = doc._id;\n\t\t\tthis.storage.set(doc._id, replacement);\n\t\t\tthis.updateIndexesOnInsert(replacement);\n\t\t}\n\t\treturn result;\n\t}\n\n\tremove(query, options) {\n\t\tconst c = this.find(query);\n\t\tif (!c.hasNext()) return;\n\t\tif (options === true || (options && options.justOne)) {\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tthis.storage.remove(doc._id);\n\t\t} else {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tthis.storage.remove(doc._id);\n\t\t\t}\n\t\t}\n\t}\n\n\trenameCollection() { throw \"Not Implemented\"; }\n\tsave() { throw \"Not Implemented\"; }\n\tstats() { throw \"Not Implemented\"; }\n\tstorageSize() { throw \"Not Implemented\"; }\n\ttotalSize() { throw \"Not Implemented\"; }\n\ttotalIndexSize() { throw \"Not Implemented\"; }\n\n\tupdate(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tif (options && options.multi) {\n\t\t\t\twhile (c.hasNext()) {\n\t\t\t\t\tconst doc = c.next();\n\t\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\t\tapplyUpdates(updates, doc);\n\t\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc);\n\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateOne(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\tconst doc = c.next();\n\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\tapplyUpdates(updates, doc);\n\t\t\tthis.storage.set(doc._id, doc);\n\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateMany(query, updates, options) {\n\t\tconst c = this.find(query);\n\t\tif (c.hasNext()) {\n\t\t\twhile (c.hasNext()) {\n\t\t\t\tconst doc = c.next();\n\t\t\t\tthis.updateIndexesOnDelete(doc);\n\t\t\t\tapplyUpdates(updates, doc);\n\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t\tthis.updateIndexesOnInsert(doc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (options && options.upsert) {\n\t\t\t\tconst newDoc = createDocFromUpdate(query, updates, this.idGenerator);\n\t\t\t\tthis.storage.set(newDoc._id, newDoc);\n\t\t\t\tthis.updateIndexesOnInsert(newDoc);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidate() { throw \"Not Implemented\"; }\n\n\t/**\n\t * Export collection state for storage\n\t * @returns {Object} Collection state including documents and indexes\n\t */\n\texportState() {\n\t\t// Export all documents\n\t\tconst documents = [];\n\t\tfor (let i = 0; i < this.storage.size(); i++) {\n\t\t\tconst doc = this.storage.get(i);\n\t\t\tif (doc) {\n\t\t\t\tdocuments.push(doc);\n\t\t\t}\n\t\t}\n\n\t\t// Export all indexes\n\t\tconst indexes = [];\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tconst index = this.indexes[indexName];\n\t\t\t\tindexes.push(index.serialize());\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdocuments: documents,\n\t\t\tindexes: indexes\n\t\t};\n\t}\n\n\t/**\n\t * Import collection state from storage\n\t * @param {Object} state - Collection state including documents and indexes\n\t */\n\tasync importState(state) {\n\t\t// Clear existing data\n\t\tthis.storage.clear();\n\t\tfor (const indexName in this.indexes) {\n\t\t\tif (this.indexes.hasOwnProperty(indexName)) {\n\t\t\t\tthis.indexes[indexName].clear();\n\t\t\t}\n\t\t}\n\t\tthis.indexes = {};\n\n\t\t// Import documents\n\t\tif (state.documents && Array.isArray(state.documents)) {\n\t\t\tfor (const doc of state.documents) {\n\t\t\t\tthis.storage.set(doc._id, doc);\n\t\t\t}\n\t\t}\n\n\t\t// Import indexes\n\t\tif (state.indexes && Array.isArray(state.indexes)) {\n\t\t\tfor (const indexState of state.indexes) {\n\t\t\t\t// Recreate the index based on its type\n\t\t\t\tlet index;\n\t\t\t\tif (indexState.type === 'text') {\n\t\t\t\t\tindex = new TextCollectionIndex(indexState.keys, indexState.options);\n\t\t\t\t\tindex.deserialize(indexState);\n\t\t\t\t} else if (indexState.type === 'geospatial') {\n\t\t\t\t\tindex = new GeospatialCollectionIndex(indexState.keys, indexState.options);\n\t\t\t\t\tindex.deserialize(indexState);\n\t\t\t\t} else {\n\t\t\t\t\t// Default to regular index\n\t\t\t\t\tindex = new RegularCollectionIndex(indexState.keys, indexState.options);\n\t\t\t\t\tindex.deserialize(indexState);\n\t\t\t\t}\n\t\t\t\tthis.indexes[index.name] = index;\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Abstract base class for storage engines\n * Defines the interface for storing and retrieving database state\n */\nexport class StorageEngine {\n\tconstructor() {\n\t\tif (new.target === StorageEngine) {\n\t\t\tthrow new TypeError(\"Cannot construct StorageEngine instances directly\");\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\tthrow new Error('initialize() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @param {string} dbState.name - The database name\n\t * @param {Object} dbState.collections - Map of collection names to collection data\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tthrow new Error('saveDatabase() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tthrow new Error('loadDatabase() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @param {Array} collectionState.documents - The documents in the collection\n\t * @param {Array} collectionState.indexes - The indexes in the collection\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tthrow new Error('saveCollection() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tthrow new Error('loadCollection() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tthrow new Error('deleteCollection() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tthrow new Error('deleteDatabase() must be implemented by subclass');\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tthrow new Error('close() must be implemented by subclass');\n\t}\n}\n","import { Collection } from './Collection.js';\nimport { LocalStorageStore, ObjectStore } from '../main.js';\nimport { ObjectId } from './ObjectId.js';\nimport { ObjectStorageEngine } from './ObjectStorageEngine.js';\n\n/**\n * DB class\n */\nexport class DB {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t\tthis.dbName = this.options.dbName || 'default';\n\t\t\n\t\t// Initialize storage engine if provided\n\t\tthis.storageEngine = this.options.storageEngine || null;\n\t\t\n\t\t// Initialize localStorage collection if available\n\t\tif (typeof localStorage !== \"undefined\") {\n\t\t\tthis.localStorage = new Collection(\n\t\t\t\tthis,\n\t\t\t\t(this.options.localStorage ? this.options.localStorage : LocalStorageStore),\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t} else {\n\t\t\tthis.localStorage = null;\n\t\t}\n\n\t\t// Return a Proxy to enable dynamic collection creation\n\t\treturn new Proxy(this, {\n\t\t\tget(target, property, receiver) {\n\t\t\t\t// If property exists on target (including undefined values), return it\n\t\t\t\tif (property in target) {\n\t\t\t\t\treturn Reflect.get(target, property, receiver);\n\t\t\t\t}\n\n\t\t\t\t// If property is a symbol or special property, return undefined\n\t\t\t\tif (typeof property === 'symbol' || property.startsWith('_')) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// For collection names, create the collection if it doesn't exist\n\t\t\t\t// Only auto-create if it's a valid collection name and doesn't already exist\n\t\t\t\tif (typeof property === 'string' && property !== 'localStorage') {\n\t\t\t\t\t// Don't auto-create if property was explicitly deleted\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(target, property)) {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t\t// Auto-create the collection\n\t\t\t\t\ttarget.createCollection(property);\n\t\t\t\t\treturn target[property];\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Log function\n\t */\n\t_log(msg) {\n\t\tif (this.options && this.options.print) this.options.print(msg);\n\t\telse console.log(msg);\n\t}\n\n\t/**\n\t * ID generator function\n\t */\n\t_id() {\n\t\tif (this.options && this.options.id) return this.options.id();\n\t\telse return new ObjectId();\n\t}\n\n\t// DB Methods\n\tcloneCollection() { throw \"Not Implemented\"; }\n\tcloneDatabase() { throw \"Not Implemented\"; }\n\tcommandHelp() { throw \"Not Implemented\"; }\n\tcopyDatabase() { throw \"Not Implemented\"; }\n\n\tcreateCollection(name) {\n\t\tif (!name) return;\n\t\tif (name == \"localStorage\") {\n\t\t\tthis.localStorage = new Collection(\n\t\t\t\tthis,\n\t\t\t\t(this.options.localStorage ? this.options.localStorage : LocalStorageStore),\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t} else {\n\t\t\tthis[name] = new Collection(\n\t\t\t\tthis,\n\t\t\t\t(this.options && this.options.storage ? new this.options.storage() : new ObjectStore()),\n\t\t\t\tthis._id.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\tcurrentOp() { throw \"Not Implemented\"; }\n\n\tdropDatabase() {\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tthis[key].drop(); // drop the contents\n\t\t\t\tdelete this[key];\n\t\t\t}\n\t\t}\n\t}\n\n\teval() { throw \"Not Implemented\"; }\n\tfsyncLock() { throw \"Not Implemented\"; }\n\tfsyncUnlock() { throw \"Not Implemented\"; }\n\tgetCollection() { throw \"Not Implemented\"; }\n\tgetCollectionInfos() { throw \"Not Implemented\"; }\n\n\tgetCollectionNames() {\n\t\tconst names = [];\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tnames.push(key);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tgetLastError() { throw \"Not Implemented\"; }\n\tgetLastErrorObj() { throw \"Not Implemented\"; }\n\tgetLogComponents() { throw \"Not Implemented\"; }\n\tgetMongo() { throw \"Not Implemented\"; }\n\tgetName() { throw \"Not Implemented\"; }\n\tgetPrevError() { throw \"Not Implemented\"; }\n\tgetProfilingLevel() { throw \"Not Implemented\"; }\n\tgetProfilingStatus() { throw \"Not Implemented\"; }\n\tgetReplicationInfo() { throw \"Not Implemented\"; }\n\tgetSiblingDB() { throw \"Not Implemented\"; }\n\n\thelp() {\n\t\tthis._log(\"        help mr                      mapreduce\");\n\t\tthis._log(\"        db.foo.find()                list objects in collection foo\");\n\t\tthis._log(\"        db.foo.find( { a : 1 } )     list objects in foo where a == 1\");\n\t\tthis._log(\"        it                           result of the last line evaluated; use to further iterate\");\n\t}\n\n\thostInfo() { throw \"Not Implemented\"; }\n\tisMaster() { throw \"Not Implemented\"; }\n\tkillOp() { throw \"Not Implemented\"; }\n\tlistCommands() { throw \"Not Implemented\"; }\n\tloadServerScripts() { throw \"Not Implemented\"; }\n\tlogout() { throw \"Not Implemented\"; }\n\tprintCollectionStats() { throw \"Not Implemented\"; }\n\tprintReplicationInfo() { throw \"Not Implemented\"; }\n\tprintShardingStatus() { throw \"Not Implemented\"; }\n\tprintSlaveReplicationInfo() { throw \"Not Implemented\"; }\n\trepairDatabase() { throw \"Not Implemented\"; }\n\tresetError() { throw \"Not Implemented\"; }\n\trunCommand() { throw \"Not Implemented\"; }\n\tserverBuildInfo() { throw \"Not Implemented\"; }\n\tserverCmdLineOpts() { throw \"Not Implemented\"; }\n\tserverStatus() { throw \"Not Implemented\"; }\n\tsetLogLevel() { throw \"Not Implemented\"; }\n\tsetProfilingLevel() { throw \"Not Implemented\"; }\n\tshutdownServer() { throw \"Not Implemented\"; }\n\tstats() { throw \"Not Implemented\"; }\n\tversion() { throw \"Not Implemented\"; }\n\tupgradeCheck() { throw \"Not Implemented\"; }\n\tupgradeCheckAllDBs() { throw \"Not Implemented\"; }\n\n\t/**\n\t * Save database state to storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync saveToStorage() {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\t// Collect all collections and their states\n\t\tconst collections = {};\n\t\tfor (const key in this) {\n\t\t\tif (this[key] != null && this[key].isCollection) {\n\t\t\t\tcollections[key] = this[key].exportState();\n\t\t\t}\n\t\t}\n\n\t\t// Save to storage engine\n\t\tawait this.storageEngine.saveDatabase({\n\t\t\tname: this.dbName,\n\t\t\tcollections: collections\n\t\t});\n\t}\n\n\t/**\n\t * Load database state from storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync loadFromStorage() {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\t// Load from storage engine\n\t\tconst dbState = await this.storageEngine.loadDatabase(this.dbName);\n\t\t\n\t\tif (!dbState || !dbState.collections) {\n\t\t\treturn; // No saved state\n\t\t}\n\n\t\t// Drop existing collections\n\t\tthis.dropDatabase();\n\n\t\t// Restore collections\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tthis.createCollection(collectionName);\n\t\t\t\tawait this[collectionName].importState(dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Save a specific collection to storage engine\n\t * @param {string} collectionName - Name of the collection to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(collectionName) {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\tif (!this[collectionName] || !this[collectionName].isCollection) {\n\t\t\tthrow new Error(`Collection '${collectionName}' does not exist`);\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\tconst collectionState = this[collectionName].exportState();\n\t\tawait this.storageEngine.saveCollection(this.dbName, collectionName, collectionState);\n\t}\n\n\t/**\n\t * Load a specific collection from storage engine\n\t * @param {string} collectionName - Name of the collection to load\n\t * @returns {Promise<void>}\n\t */\n\tasync loadCollection(collectionName) {\n\t\tif (!this.storageEngine) {\n\t\t\tthrow new Error('No storage engine configured. Pass a storageEngine option when creating the DB.');\n\t\t}\n\n\t\t// Initialize storage engine if needed\n\t\tif (this.storageEngine.initialize) {\n\t\t\tawait this.storageEngine.initialize();\n\t\t}\n\n\t\tconst collectionState = await this.storageEngine.loadCollection(this.dbName, collectionName);\n\t\t\n\t\tif (!collectionState) {\n\t\t\treturn; // No saved state for this collection\n\t\t}\n\n\t\t// Create or recreate the collection\n\t\tif (!this[collectionName]) {\n\t\t\tthis.createCollection(collectionName);\n\t\t}\n\n\t\tawait this[collectionName].importState(collectionState);\n\t}\n}\n","\r\nimport { DB } from './DB.js'\r\n// https://mongodb.github.io/node-mongodb-native/6.20/classes/MongoClient.html\r\nexport class MongoClient {\r\n\r\n  constructor(uri, options = {}) {\r\n    this.uri = uri;\r\n    this.options = options;\r\n  }\r\n\r\n  static async connect(uri, options = {}) {\r\n    return new MongoClient(uri, options);\r\n  }\r\n\r\n  db(name, opts = {}) {\r\n    // Merge client options with db-specific options\r\n    const dbOptions = { ...this.options, ...opts, dbName: name };\r\n    return new DB(dbOptions);\r\n  }\r\n\r\n  async close() {\r\n    /* no-op for in-memory */ \r\n  }\r\n}","/**\n * MicroMongoDB - Lightweight MongoDB-compatible database\n * Refactored into separate class files\n */\n\n/**\n * MicroMongoDB.LocalStorageStore\n * \n * Singleton\n */\nexport const LocalStorageStore = (function() {\n\n\treturn {\n\t\tclear : function() {\n\t\t\tlocalStorage.clear();\n\t\t},\n\t\tget : function(i) {\n\t\t\treturn JSON.parse(localStorage.getItem(localStorage.key(i)));\n\t\t},\n\t\tgetStore : function() {\n\t\t\treturn localStorage;\n\t\t},\n\t\tremove : function(key) {\n\t\t\tlocalStorage.removeItem(key);\n\t\t},\n\t\tset : async function(key,val) {\n\t\t\tlocalStorage.setItem(key,JSON.stringify(val));\n\t\t},\n\t\tsize : function() {\n\t\t\treturn localStorage.length;\n\t\t}\n\t};\n\n})(); // MicroMongoDB.LocalStorageStore\n\n/**\n * MicroMongoDB.ObjectStore\n * \n * Public Constructor Function\n */\nexport const ObjectStore = function() {\n\n\tvar objs = {};\n\n\treturn {\n\t\tclear : function() {\n\t\t\tobjs = {};\n\t\t},\n\t\tget : function(i) {\n\t\t\treturn objs[Object.keys(objs)[i]];\n\t\t},\n\t\tgetStore : function() {\n\t\t\treturn objs;\n\t\t},\n\t\tremove : function(key) {\n\t\t\tdelete objs[key];\n\t\t},\n\t\tset : function(key,val) {\n\t\t\tobjs[key] = val;\n\t\t},\n\t\tsize : function() {\n\t\t\treturn Object.keys(objs).length;\n\t\t}\n\t}; // MicroMongoDB.ObjectStore return\n}; // MicroMongoDB.ObjectStore\n\n// Export refactored classes\nexport { MongoClient } from './src/MongoClient.js';\nexport { ObjectId } from './src/ObjectId.js';\nexport { StorageEngine } from './src/StorageEngine.js';\nexport { IndexedDbStorageEngine } from './src/IndexedDbStorageEngine.js';\nexport { ObjectStorageEngine } from './src/ObjectStorageEngine.js';\n","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * IndexedDB-based storage engine for persistent storage\n * Stores each collection separately in IndexedDB\n */\nexport class IndexedDbStorageEngine extends StorageEngine {\n\tconstructor(dbName = 'micro-mongo') {\n\t\tsuper();\n\t\tthis.dbName = dbName;\n\t\tthis.db = null;\n\t\tthis.indexedDBName = `micro-mongo-${dbName}`;\n\t}\n\n\t/**\n\t * Initialize the IndexedDB connection\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.open(this.indexedDBName, 1);\n\n\t\t\trequest.onerror = () => {\n\t\t\t\treject(new Error('Failed to open IndexedDB: ' + request.error));\n\t\t\t};\n\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tthis.db = request.result;\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tconst db = event.target.result;\n\t\t\t\t\n\t\t\t\t// Create object stores for collections and metadata\n\t\t\t\tif (!db.objectStoreNames.contains('collections')) {\n\t\t\t\t\tdb.createObjectStore('collections', { keyPath: 'name' });\n\t\t\t\t}\n\t\t\t\tif (!db.objectStoreNames.contains('metadata')) {\n\t\t\t\t\tdb.createObjectStore('metadata', { keyPath: 'key' });\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\t// Save metadata\n\t\tconst transaction = this.db.transaction(['metadata'], 'readwrite');\n\t\tconst metadataStore = transaction.objectStore('metadata');\n\t\t\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst request = metadataStore.put({\n\t\t\t\tkey: 'dbName',\n\t\t\t\tvalue: dbState.name\n\t\t\t});\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\n\t\t// Save each collection\n\t\tfor (const collectionName in dbState.collections) {\n\t\t\tif (dbState.collections.hasOwnProperty(collectionName)) {\n\t\t\t\tawait this.saveCollection(dbState.name, collectionName, dbState.collections[collectionName]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.getAll();\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst collections = {};\n\t\t\t\tfor (const collectionData of request.result) {\n\t\t\t\t\tcollections[collectionData.name] = {\n\t\t\t\t\t\tdocuments: collectionData.documents || [],\n\t\t\t\t\t\tindexes: collectionData.indexes || []\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolve({\n\t\t\t\t\tname: dbName,\n\t\t\t\t\tcollections: collections\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.put({\n\t\t\t\tname: collectionName,\n\t\t\t\tdocuments: collectionState.documents || [],\n\t\t\t\tindexes: collectionState.indexes || []\n\t\t\t});\n\t\t\t\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readonly');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.get(collectionName);\n\t\t\t\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tif (request.result) {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tdocuments: request.result.documents || [],\n\t\t\t\t\t\tindexes: request.result.indexes || []\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (!this.db) {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst transaction = this.db.transaction(['collections'], 'readwrite');\n\t\tconst collectionsStore = transaction.objectStore('collections');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = collectionsStore.delete(collectionName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = indexedDB.deleteDatabase(this.indexedDBName);\n\t\t\trequest.onsuccess = () => resolve();\n\t\t\trequest.onerror = () => reject(request.error);\n\t\t});\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\tif (this.db) {\n\t\t\tthis.db.close();\n\t\t\tthis.db = null;\n\t\t}\n\t}\n}\n","import { StorageEngine } from './StorageEngine.js';\n\n/**\n * In-memory storage engine (default)\n * Does not persist data between sessions\n */\nexport class ObjectStorageEngine extends StorageEngine {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.databases = {};\n\t}\n\n\t/**\n\t * Initialize the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync initialize() {\n\t\t// No initialization needed for in-memory storage\n\t}\n\n\t/**\n\t * Save the entire database state\n\t * @param {Object} dbState - The database state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveDatabase(dbState) {\n\t\tthis.databases[dbState.name] = JSON.parse(JSON.stringify(dbState));\n\t}\n\n\t/**\n\t * Load the entire database state\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<Object|null>} The database state or null if not found\n\t */\n\tasync loadDatabase(dbName) {\n\t\tif (this.databases[dbName]) {\n\t\t\treturn JSON.parse(JSON.stringify(this.databases[dbName]));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Save a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @param {Object} collectionState - The collection state to save\n\t * @returns {Promise<void>}\n\t */\n\tasync saveCollection(dbName, collectionName, collectionState) {\n\t\tif (!this.databases[dbName]) {\n\t\t\tthis.databases[dbName] = {\n\t\t\t\tname: dbName,\n\t\t\t\tcollections: {}\n\t\t\t};\n\t\t}\n\t\tthis.databases[dbName].collections[collectionName] = JSON.parse(JSON.stringify(collectionState));\n\t}\n\n\t/**\n\t * Load a single collection's state\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<Object|null>} The collection state or null if not found\n\t */\n\tasync loadCollection(dbName, collectionName) {\n\t\tif (this.databases[dbName] && this.databases[dbName].collections[collectionName]) {\n\t\t\treturn JSON.parse(JSON.stringify(this.databases[dbName].collections[collectionName]));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Delete a collection\n\t * @param {string} dbName - The database name\n\t * @param {string} collectionName - The collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteCollection(dbName, collectionName) {\n\t\tif (this.databases[dbName] && this.databases[dbName].collections) {\n\t\t\tdelete this.databases[dbName].collections[collectionName];\n\t\t}\n\t}\n\n\t/**\n\t * Delete the entire database\n\t * @param {string} dbName - The database name\n\t * @returns {Promise<void>}\n\t */\n\tasync deleteDatabase(dbName) {\n\t\tdelete this.databases[dbName];\n\t}\n\n\t/**\n\t * Close/cleanup the storage engine\n\t * @returns {Promise<void>}\n\t */\n\tasync close() {\n\t\t// No cleanup needed for in-memory storage\n\t}\n}\n"],"names":["ObjectId","constructor","id","this","generate","isValid","Error","toLowerCase","toString","toHexString","getTimestamp","timestamp","parseInt","substring","Date","equals","other","toJSON","inspect","length","test","createFromTime","tsHex","Math","floor","slice","ts","now","rand","crypto","getRandomValues","Uint8Array","tail","i","random","padEnd","valuesEqual","a","b","copy","o","out","v","key","Array","isArray","getProp","obj","name","path","split","result","isIn","val","values","arrayMatches","x","y","objectMatches","p","hasOwnProperty","applyProjection","projection","doc","keys","Object","hasInclusion","hasExclusion","$err","code","_id","Cursor","collection","query","matches","storage","indexes","planQuery","SortedCursor","pos","max","_next","queryPlan","indexDocIds","indexPos","fullScanDocIds","useIndex","docIds","_findNext","docId","getStore","size","cur","get","batchSize","close","comment","count","num","c","hasNext","next","explain","forEach","fn","hint","itcount","limit","_max","map","results","push","maxScan","maxTimeMS","min","noCursorTimeout","objsLeftInBatch","pretty","readConcern","readPref","returnKey","showRecordId","skip","snapshot","sort","s","tailable","toArray","Symbol","asyncIterator","cursor","sortSpec","items","sortKeys","step2list","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3list","icate","ative","alize","iciti","ical","ful","ness","vowel","consonants","vowels","gt0","RegExp","eq1","gt1","vowelInStem","consonantLike","sfxLl","sfxE","sfxY","sfxIon","sfxEdOrIng","sfxAtOrBlOrIz","sfxEED","sfxS","sfxSsesOrIes","sfxMultiConsonantLike","step2","step3","step4","stemmer","value","String","match","firstCharacterWasLowerCaseY","codePointAt","exec","STOPWORDS","Set","TextIndex","options","index","Map","documentTerms","documentLengths","useStopWords","stopWords","_tokenize","text","words","filter","word","has","add","termFrequency","stem","set","frequency","remove","term","delete","queryText","scored","requireAll","stemmedTerms","uniqueTerms","docSets","termDocs","intersection","from","totalDocs","idf","docsWithTerm","log","docScores","termFreq","tfIdf","score","docTerms","coverage","entries","r","getTermCount","getDocumentCount","clear","addStopWords","removeStopWords","setStopWordFiltering","enabled","serialize","indexObj","docs","docsObj","freq","documentTermsObj","terms","termsObj","documentLengthsObj","deserialize","state","compareValues","operator","aVal","bVal","prop","textIndex","geoWithin","minLon","maxLat","maxLon","isGeometryWithinBBox","e","geoJson","minLat","type","features","feature","geometry","coordinates","lng","lat","ring","coord","tlMatches","charAt","and","els","or","not","nor","call","Function","where","opMatches","operand","fieldValue","j","found","element","matchesPrimitive","opKeys","k","op","opValue","arr","el","applyUpdates","updates","setOnInsert","fields","amount","field","pop","shift","src","toRemove","notRemoved","removed","l","operation","createDocFromUpdate","idGenerator","newDoc","onlyFields","updateKeys","queryKeys","CollectionIndex","generateIndexName","parts","join","update","oldDoc","getSpec","data","RegularCollectionIndex","super","extractIndexKey","keyFields","JSON","stringify","t","keyParts","indexKey","idx","indexOf","splice","indexFields","queryValue","TextCollectionIndex","indexedFields","_extractText","textParts","search","searchText","textIndexVersion","weights","_getWeights","textIndexState","haversineDistance","lat1","lng1","lat2","lng2","dLat","PI","dLng","sin","cos","atan2","sqrt","intersects","bbox1","bbox2","maxLng","minLng","area","bbox","union","enlargement","RTreeNode","isLeaf","children","updateBBox","Infinity","child","RTree","maxEntries","minEntries","ceil","root","_size","insert","entry","_insert","node","level","_split","target","_chooseSubtree","splitNode","minEnlargement","minArea","targetNode","enl","ar","maxDist","seed1Idx","seed2Idx","waste","node1","node2","enl1","enl2","newRoot","searchBBox","_searchBBox","searchRadius","radiusKm","latDelta","lngDelta","radiusToBoundingBox","candidates","_remove","parent","indexInParent","getAll","_getAll","_serializeNode","serialized","_deserializeNode","GeospatialCollectionIndex","rtree","geoField","_extractCoordinates","sumLat","sumLng","geoValue","coords","geoQuery","$geoWithin","rtreeState","Collection","db","isCollection","isTextIndex","isGeospatialIndex","buildIndex","indexName","updateIndexesOnInsert","updateIndexesOnDelete","getTextIndex","includes","aggregate","pipeline","find","stage","stageKeys","stageType","stageSpec","matched","projected","groups","groupId","keyStr","accumulators","grouped","groupKey","group","accumulator","accKeys","accType","accExpr","sum","valKey","unwound","fieldPath","unwoundDoc","bulkWrite","copyTo","destCollectionName","createCollection","destCol","numCopied","insertOne","createIndex","existingIndex","dataSize","deleteOne","findOne","deletedCount","deleteMany","ids","distinct","vals","d","drop","dropIndex","nIndexesWas","ok","dropIndexes","msg","ensureIndex","bind","findAndModify","findOneAndDelete","findOneAndReplace","replacement","returnNewDocument","findOneAndUpdate","clone","assign","getIndexes","getShardDistribution","getShardVersion","insertMany","insertedId","insertedIds","isCapped","mapReduce","reIndex","replaceOne","matchedCount","modifiedCount","upsert","upsertedId","justOne","renameCollection","save","stats","storageSize","totalSize","totalIndexSize","multi","updateOne","updateMany","validate","exportState","documents","importState","indexState","StorageEngine","TypeError","initialize","saveDatabase","dbState","loadDatabase","dbName","saveCollection","collectionName","collectionState","loadCollection","deleteCollection","deleteDatabase","DB","storageEngine","localStorage","LocalStorageStore","Proxy","property","receiver","Reflect","startsWith","prototype","_log","print","console","cloneCollection","cloneDatabase","commandHelp","copyDatabase","ObjectStore","currentOp","dropDatabase","eval","fsyncLock","fsyncUnlock","getCollection","getCollectionInfos","getCollectionNames","names","getLastError","getLastErrorObj","getLogComponents","getMongo","getName","getPrevError","getProfilingLevel","getProfilingStatus","getReplicationInfo","getSiblingDB","help","hostInfo","isMaster","killOp","listCommands","loadServerScripts","logout","printCollectionStats","printReplicationInfo","printShardingStatus","printSlaveReplicationInfo","repairDatabase","resetError","runCommand","serverBuildInfo","serverCmdLineOpts","serverStatus","setLogLevel","setProfilingLevel","shutdownServer","version","upgradeCheck","upgradeCheckAllDBs","saveToStorage","collections","loadFromStorage","MongoClient","uri","connect","opts","dbOptions","parse","getItem","removeItem","async","setItem","objs","indexedDBName","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","onupgradeneeded","event","objectStoreNames","contains","createObjectStore","keyPath","metadataStore","transaction","objectStore","put","collectionsStore","collectionData","databases"],"mappings":"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","x_google_ignoreList":[4]}