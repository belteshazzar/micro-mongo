!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MicroMongo={})}(this,function(e){"use strict";var t,n={exports:{}};var r=function(){if(t)return n.exports;t=1;var e,r="object"==typeof Reflect?Reflect:null,i=r&&"function"==typeof r.apply?r.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};e=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var s=Number.isNaN||function(e){return e!=e};function o(){o.init.call(this)}n.exports=o,n.exports.once=function(e,t){return new Promise(function(n,r){function i(n){e.removeListener(t,s),r(n)}function s(){"function"==typeof e.removeListener&&e.removeListener("error",i),n([].slice.call(arguments))}m(e,t,s,{once:!0}),"error"!==t&&function(e,t,n){"function"==typeof e.on&&m(e,"error",t,n)}(e,i,{once:!0})})},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var a=10;function c(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function l(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function u(e,t,n,r){var i,s,o,a;if(c(n),void 0===(s=e._events)?(s=e._events=Object.create(null),e._eventsCount=0):(void 0!==s.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),s=e._events),o=s[t]),void 0===o)o=s[t]=n,++e._eventsCount;else if("function"==typeof o?o=s[t]=r?[n,o]:[o,n]:r?o.unshift(n):o.push(n),(i=l(e))>0&&o.length>i&&!o.warned){o.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=e,u.type=t,u.count=o.length,a=u,console&&console.warn&&console.warn(a)}return e}function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function f(e,t,n){var r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=h.bind(r);return i.listener=n,r.wrapFn=i,i}function d(e,t,n){var r=e._events;if(void 0===r)return[];var i=r[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):g(i,i.length)}function p(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function g(e,t){for(var n=new Array(t),r=0;r<t;++r)n[r]=e[r];return n}function m(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,function i(s){r.once&&e.removeEventListener(t,i),n(s)})}}return Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return a},set:function(e){if("number"!=typeof e||e<0||s(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");a=e}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||s(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return l(this)},o.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var r="error"===e,s=this._events;if(void 0!==s)r=r&&void 0===s.error;else if(!r)return!1;if(r){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var c=s[e];if(void 0===c)return!1;if("function"==typeof c)i(c,this,t);else{var l=c.length,u=g(c,l);for(n=0;n<l;++n)i(u[n],this,t)}return!0},o.prototype.addListener=function(e,t){return u(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return u(this,e,t,!0)},o.prototype.once=function(e,t){return c(t),this.on(e,f(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){return c(t),this.prependListener(e,f(this,e,t)),this},o.prototype.removeListener=function(e,t){var n,r,i,s,o;if(c(t),void 0===(r=this._events))return this;if(void 0===(n=r[e]))return this;if(n===t||n.listener===t)0===--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(i=-1,s=n.length-1;s>=0;s--)if(n[s]===t||n[s].listener===t){o=n[s].listener,i=s;break}if(i<0)return this;0===i?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,i),1===n.length&&(r[e]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",e,o||t)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0===--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var i,s=Object.keys(n);for(r=0;r<s.length;++r)"removeListener"!==(i=s[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(r=t.length-1;r>=0;r--)this.removeListener(e,t[r]);return this},o.prototype.listeners=function(e){return d(this,e,!0)},o.prototype.rawListeners=function(e){return d(this,e,!1)},o.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},o.prototype.listenerCount=p,o.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]},n.exports}();const i=0,s=1,o=2,a=3,c=4,l=5,u=6,h=7,f=8,d=16,p=17;class g{constructor(e){if(null==e)this.id=g.generate();else if("string"==typeof e){if(!g.isValid(e))throw new Error(`Argument passed in must be a string of 24 hex characters, got: ${e}`);this.id=e.toLowerCase()}else if(e instanceof Uint8Array&&12===e.length)this.id=Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join("");else{if(!(e instanceof g))throw new Error("Argument passed in must be a string of 24 hex characters or an ObjectId");this.id=e.id}}toString(){return this.id}toHexString(){return this.id}getTimestamp(){const e=parseInt(this.id.substring(0,8),16);return new Date(1e3*e)}equals(e){if(!(e instanceof g))throw new Error("Can only compare with another ObjectId");return this.id===e.id}compare(e){if(!(e instanceof g))throw new Error("Can only compare with another ObjectId");return this.id.localeCompare(e.id)}toJSON(){return this.id}inspect(){return`ObjectId("${this.id}")`}toBytes(){const e=new Uint8Array(12);for(let t=0;t<12;t++)e[t]=parseInt(this.id.substring(2*t,2*t+2),16);return e}static isValid(e){return!!e&&("string"==typeof e&&(24===e.length&&/^[0-9a-fA-F]{24}$/.test(e)))}static createFromTime(e){const t=("00000000"+Math.floor(e/1e3).toString(16)).slice(-8);return new g(t+"0000000000000000")}static generate(){const e=Math.floor(Date.now()/1e3),t="undefined"!=typeof crypto&&crypto.getRandomValues?new Uint8Array(8):null;let n="";if(t){crypto.getRandomValues(t);for(let e=0;e<t.length;e++)n+=("0"+t[e].toString(16)).slice(-2)}else n=Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8)+Math.random().toString(16).slice(2).padEnd(8,"0").slice(0,8);return(("00000000"+e.toString(16)).slice(-8)+n).slice(0,24)}}class m{constructor(e){if(null==e)throw new Error("Pointer offset must be a number");if("number"!=typeof e)throw new Error("Pointer offset must be a number");if(!Number.isInteger(e))throw new Error("Pointer offset must be an integer");if(e<0)throw new Error("Pointer offset must be non-negative");if(e>Number.MAX_SAFE_INTEGER)throw new Error("Pointer offset exceeds maximum safe integer");this.offset=e}valueOf(){return this.offset}toString(){return this.offset.toString()}toJSON(){return this.offset}inspect(){return`Pointer(${this.offset})`}equals(e){return e instanceof m&&this.offset===e.offset}}function y(e){const t=[];!function e(n){if(null===n)t.push(new Uint8Array([i]));else if(!1===n)t.push(new Uint8Array([s]));else if(!0===n)t.push(new Uint8Array([o]));else if(n instanceof g)t.push(new Uint8Array([u])),t.push(n.toBytes());else if(n instanceof Date){t.push(new Uint8Array([h]));const e=new ArrayBuffer(8);new DataView(e).setBigInt64(0,BigInt(n.getTime()),!0),t.push(new Uint8Array(e))}else if(n instanceof m){t.push(new Uint8Array([f]));const e=new ArrayBuffer(8);new DataView(e).setBigUint64(0,BigInt(n.offset),!0),t.push(new Uint8Array(e))}else if("number"==typeof n)if(Number.isInteger(n)&&Number.isSafeInteger(n)){t.push(new Uint8Array([a]));const e=new ArrayBuffer(8);new DataView(e).setBigInt64(0,BigInt(n),!0),t.push(new Uint8Array(e))}else{t.push(new Uint8Array([c]));const e=new ArrayBuffer(8);new DataView(e).setFloat64(0,n,!0),t.push(new Uint8Array(e))}else if("string"==typeof n){t.push(new Uint8Array([l]));const e=(new TextEncoder).encode(n),r=new ArrayBuffer(4);new DataView(r).setUint32(0,e.length,!0),t.push(new Uint8Array(r)),t.push(e)}else if(Array.isArray(n)){const r=[],i=new ArrayBuffer(4);new DataView(i).setUint32(0,n.length,!0),r.push(new Uint8Array(i));const s=t.length;for(const t of n)e(t);const o=t.splice(s);r.push(...o);const a=r.reduce((e,t)=>e+t.length,0);t.push(new Uint8Array([d]));const c=new ArrayBuffer(4);new DataView(c).setUint32(0,a,!0),t.push(new Uint8Array(c)),t.push(...r)}else{if("object"!=typeof n)throw new Error("Unsupported type: "+typeof n);{const r=[],i=Object.keys(n),s=new ArrayBuffer(4);new DataView(s).setUint32(0,i.length,!0),r.push(new Uint8Array(s));const o=t.length;for(const u of i){const r=(new TextEncoder).encode(u),i=new ArrayBuffer(4);new DataView(i).setUint32(0,r.length,!0),t.push(new Uint8Array(i)),t.push(r),e(n[u])}const a=t.splice(o);r.push(...a);const c=r.reduce((e,t)=>e+t.length,0);t.push(new Uint8Array([p]));const l=new ArrayBuffer(4);new DataView(l).setUint32(0,c,!0),t.push(new Uint8Array(l)),t.push(...r)}}}(e);const n=t.reduce((e,t)=>e+t.length,0),r=new Uint8Array(n);let y=0;for(const i of t)r.set(i,y),y+=i.length;return r}function w(e){let t=0;return function n(){if(t>=e.length)throw new Error("Unexpected end of data");const r=e[t++];switch(r){case i:return null;case s:return!1;case o:return!0;case a:{if(t+4>e.length)throw new Error("Unexpected end of data for INT");const n=new DataView(e.buffer,e.byteOffset+t,8).getBigInt64(0,!0);if(t+=8,n<BigInt(Number.MIN_SAFE_INTEGER)||n>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Decoded integer exceeds safe range");return Number(n)}case c:{if(t+8>e.length)throw new Error("Unexpected end of data for FLOAT");const n=new DataView(e.buffer,e.byteOffset+t,8).getFloat64(0,!0);return t+=8,n}case l:{if(t+4>e.length)throw new Error("Unexpected end of data for STRING length");const n=new DataView(e.buffer,e.byteOffset+t,4).getUint32(0,!0);if(t+=4,t+n>e.length)throw new Error("Unexpected end of data for STRING content");const r=e.slice(t,t+n);return t+=n,(new TextDecoder).decode(r)}case u:{if(t+12>e.length)throw new Error("Unexpected end of data for OID");const n=e.slice(t,t+12);return t+=12,new g(n)}case h:{if(t+8>e.length)throw new Error("Unexpected end of data for DATE");const n=new DataView(e.buffer,e.byteOffset+t,8).getBigInt64(0,!0);return t+=8,new Date(Number(n))}case f:{if(t+8>e.length)throw new Error("Unexpected end of data for POINTER");const n=new DataView(e.buffer,e.byteOffset+t,8).getBigUint64(0,!0);if(t+=8,n>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Pointer offset out of valid range");return new m(Number(n))}case d:{if(t+4>e.length)throw new Error("Unexpected end of data for ARRAY size");const r=new DataView(e.buffer,e.byteOffset+t,4).getUint32(0,!0);if(t+=4,t+r>e.length)throw new Error("Unexpected end of data for ARRAY content");const i=new DataView(e.buffer,e.byteOffset+t,4).getUint32(0,!0);t+=4;const s=[];for(let e=0;e<i;e++)s.push(n());return s}case p:{if(t+4>e.length)throw new Error("Unexpected end of data for OBJECT size");const r=new DataView(e.buffer,e.byteOffset+t,4).getUint32(0,!0);if(t+=4,t+r>e.length)throw new Error("Unexpected end of data for OBJECT content");const i=new DataView(e.buffer,e.byteOffset+t,4).getUint32(0,!0);t+=4;const s={};for(let o=0;o<i;o++){if(t+4>e.length)throw new Error("Unexpected end of data for OBJECT key length");const r=new DataView(e.buffer,e.byteOffset+t,4).getUint32(0,!0);if(t+=4,t+r>e.length)throw new Error("Unexpected end of data for OBJECT key");const i=e.slice(t,t+r);t+=r;s[(new TextDecoder).decode(i)]=n()}return s}default:throw new Error(`Unknown type byte: 0x${r.toString(16)}`)}}()}class b{constructor(e){this.filename=e,this.root=null,this.fileHandle=null,this.file=null,this.mode=null,this.isOpen=!1}async open(e="r"){if(this.isOpen)throw new Error(`File is already open in ${this.mode} mode`);if("r"!==e&&"rw"!==e)throw new Error(`Invalid mode: ${e}. Use 'r' for read-only or 'rw' for read-write`);if(!navigator.storage||!navigator.storage.getDirectory)throw new Error("Origin Private File System (OPFS) is not supported in this browser");this.root=await navigator.storage.getDirectory(),this.mode=e;try{this.fileHandle="r"===e?await this.root.getFileHandle(this.filename):await this.root.getFileHandle(this.filename,{create:!0}),this.file=await this.fileHandle.getFile(),this.isOpen=!0}catch(t){if("NotFoundError"===t.name)throw new Error(`File not found: ${this.filename}`);throw t}}async close(){this.isOpen=!1,this.mode=null,this.fileHandle=null,this.file=null}ensureOpen(){if(!this.isOpen)throw new Error("File is not open. Call open('r') or open('rw') first")}ensureWritable(){if(this.ensureOpen(),"r"===this.mode)throw new Error("File is opened in read-only mode. Cannot write or append")}async refreshFile(){this.ensureOpen(),this.file=await this.fileHandle.getFile()}async#e(e,t){this.ensureOpen();const n=this.file.slice(e,e+t),r=await n.arrayBuffer();return new Uint8Array(r)}async getFileSize(){return this.ensureOpen(),this.file.size}async write(e){this.ensureWritable();const t=y(e),n=await this.fileHandle.createWritable();await n.write(t),await n.close(),await this.refreshFile()}async read(e=new m(0)){this.ensureOpen();const t=await this.getFileSize();if(0===t)throw new Error(`File is empty: ${this.filename}`);const n=e.valueOf();if(n<0||n>=t)throw new Error(`Pointer offset ${e} out of file bounds [0, ${t})`);return w(await this.#e(n,t-n))}async append(e){this.ensureWritable();const t=y(e),n=this.file.size,r=await this.fileHandle.createWritable({keepExistingData:!0});await r.seek(n),await r.write(t),await r.close(),await this.refreshFile()}async*scan(){this.ensureOpen();const e=await this.getFileSize();if(0===e)return;let t=0;for(;t<e;){const e=async e=>{let t=await this.#e(e,1);const n=t[0];switch(n){case i:case s:case o:return 1;case a:case c:case h:case f:return 9;case u:return 13;case l:t=await this.#e(e+1,4);return 5+new DataView(t.buffer,t.byteOffset,4).getUint32(0,!0);case d:t=await this.#e(e+1,4);return 5+new DataView(t.buffer,t.byteOffset,4).getUint32(0,!0);case p:t=await this.#e(e+1,4);return 5+new DataView(t.buffer,t.byteOffset,4).getUint32(0,!0);default:throw new Error(`Unknown type byte: 0x${n.toString(16)}`)}},n=await e(t),r=await this.#e(t,n);t+=n,yield w(r)}}async delete(){this.ensureWritable();try{await this.root.removeEntry(this.filename),await this.close()}catch(e){if("NotFoundError"===e.name)return;throw e}}async exists(){if(!navigator.storage||!navigator.storage.getDirectory)throw new Error("Origin Private File System (OPFS) is not supported in this browser");const e=await navigator.storage.getDirectory();try{return await e.getFileHandle(this.filename),!0}catch(t){if("NotFoundError"===t.name)return!1;throw t}}}function x(e,t){return e instanceof g||t instanceof g?e instanceof g&&t instanceof g||e instanceof g&&"string"==typeof t?e.equals(t):t instanceof g&&"string"==typeof e&&t.equals(e):e==t}function _(e){if(e instanceof g)return new g(e.id);var t,n,r;for(r in t=Array.isArray(e)?[]:{},e)n=e[r],t[r]="object"==typeof n&&null!==n?_(n):n;return t}function v(e,t){for(var n=t.split("."),r=e[n[0]],i=1;i<n.length;i++){if(null==r||null==r)return r;var s=n[i],o=parseInt(s,10);r=O(r)&&!isNaN(o)&&o>=0&&o<r.length?r[o]:r[s]}return r}function $(e,t){for(var n=t.split("."),r=[e],i=0;i<n.length;i++){for(var s=n[i],o=parseInt(s,10),a=[],c=0;c<r.length;c++){var l=r[c];if(null!=l&&null!=l)if(O(l)&&!isNaN(o)&&o>=0)o<l.length&&a.push(l[o]);else if(O(l))for(var u=0;u<l.length;u++)null!=l[u]&&null!=l[u]&&"object"==typeof l[u]&&a.push(l[u][s]);else"object"==typeof l&&a.push(l[s])}r=a}if(0!==(r=r.filter(function(e){return void 0!==e})).length)return 1===r.length?r[0]:r}function N(e,t,n){if(-1!==t.indexOf("$[]"))return function(e,t,n){for(var r=t.split("."),i=e,s=0;s<r.length;s++){var o=r[s];if("$[]"===o){if(!Array.isArray(i))throw new Error("The positional operator did not find the match needed from the query.");for(var a=r.slice(s+1).join("."),c=0;c<i.length;c++)a?N(i[c],a,n):i[c]=n;return}var l=parseInt(o,10);if(O(i)&&!isNaN(l)&&l>=0)i=i[l];else{if(null==i[o]||null==i[o]){var u=s+1<r.length?r[s+1]:null;if("$[]"===u)i[o]=[];else{var h=parseInt(u,10);!isNaN(h)&&h>=0?i[o]=[]:i[o]={}}}i=i[o]}}}(e,t,n);for(var r=t.split("."),i=e,s=0;s<r.length-1;s++){var o=r[s],a=parseInt(o,10);if(O(i)&&!isNaN(a)&&a>=0){for(;i.length<=a;)i.push(void 0);if(null==i[a]||null==i[a]){var c=r[s+1],l=parseInt(c,10);!isNaN(l)&&l>=0?i[a]=[]:i[a]={}}i=i[a]}else{if(null==i[o]||null==i[o]){c=r[s+1],l=parseInt(c,10);!isNaN(l)&&l>=0?i[o]=[]:i[o]={}}i=i[o]}}var u=r[r.length-1],h=parseInt(u,10);if(O(i)&&!isNaN(h)&&h>=0){for(;i.length<=h;)i.push(void 0);i[h]=n}else i[u]=n}function O(e){return Array==e.constructor}function E(e){var t=[];for(var n in e)if(e.hasOwnProperty(n)){var r={};r[n]=e[n],t.push(r)}return t}function A(e,t){for(var n=0;n<t.length;n++)if(x(t[n],e))return!0;return!1}function I(e,t){if(e.length!=t.length)return!1;for(var n=0;n<e.length;n++)if(!x(e[n],t[n])){if(typeof e[n]!=typeof t[n])return!1;if("object"==typeof e[n]&&null!==e[n]){if(O(e[n])){if(!I(e[n],t[n]))return!1}else if(!S(e[n],t[n]))return!1}else if(!x(e[n],t[n]))return!1}return!0}function S(e,t){for(var n in e)if(e.hasOwnProperty(n)){if(!t.hasOwnProperty(n))return!1;if(!x(e[n],t[n])){if(typeof e[n]!=typeof t[n])return!1;if("object"==typeof e[n]&&null!==e[n]){if(O(e[n])){if(!I(e[n],t[n]))return!1}else if(!S(e[n],t[n]))return!1}else if(!x(e[n],t[n]))return!1}}for(var n in t)if(t.hasOwnProperty(n)&&!e.hasOwnProperty(n))return!1;return!0}function C(e,t){var n={},r=Object.keys(e);if(0==r.length)return t;for(var i=!1,s=!1,o=0;o<r.length;o++)"_id"!==r[o]&&(e[r[o]]?i=!0:s=!0);if(i&&s)throw{$err:"Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",code:17287};if(e[r[0]]||i){0!==e._id&&(n._id=t._id);for(o=0;o<r.length;o++)if("_id"!==r[o]&&e[r[o]]){var a=v(t,u=r[o]);void 0!==a&&N(n,u,a)}}else{for(var c in t)if(t.hasOwnProperty(c)){var l=t[c];"object"!=typeof l||null===l||O(l)?O(l)?n[c]=l.slice():n[c]=l:n[c]=_(l)}for(o=0;o<r.length;o++)if(!e[r[o]]){var u,h=(u=r[o]).split(".");if(1===h.length)delete n[u];else{for(var f=n,d=0;d<h.length-1&&(null!=f&&null!=f);d++)f=f[h[d]];null!=f&&null!=f&&delete f[h[h.length-1]]}}}return n}const D={OK:0,INTERNAL_ERROR:1,BAD_VALUE:2,NO_SUCH_KEY:4,GRAPH_CONTAINS_CYCLE:5,HOST_UNREACHABLE:6,HOST_NOT_FOUND:7,UNKNOWN_ERROR:8,FAILED_TO_PARSE:17287,CANNOT_MUTATE_OBJECT:10,USER_NOT_FOUND:11,UNSUPPORTED_FORMAT:12,UNAUTHORIZED:13,TYPE_MISMATCH:14,OVERFLOW:15,INVALID_LENGTH:16,PROTOCOL_ERROR:17,AUTHENTICATION_FAILED:18,ILLEGAL_OPERATION:20,NAMESPACE_NOT_FOUND:26,INDEX_NOT_FOUND:27,PATH_NOT_VIABLE:28,CANNOT_CREATE_INDEX:67,INDEX_ALREADY_EXISTS:68,INDEX_EXISTS:68,COMMAND_NOT_FOUND:59,NAMESPACE_EXISTS:48,INVALID_NAMESPACE:73,INDEX_OPTIONS_CONFLICT:85,INVALID_INDEX_SPECIFICATION_OPTION:197,WRITE_CONFLICT:112,DUPLICATE_KEY:11e3,DUPLICATE_KEY_UPDATE:11001,DOCUMENT_VALIDATION_FAILURE:121,BAD_QUERY:2,CANNOT_INDEX_PARALLEL_ARRAYS:171,CURSOR_NOT_FOUND:43,COLLECTION_IS_EMPTY:26,NOT_IMPLEMENTED:999,OPERATION_NOT_SUPPORTED:998};class M extends Error{constructor(e,t={}){super(e),this.name="MongoError",this.code=t.code||D.UNKNOWN_ERROR,this.codeName=this._getCodeName(this.code),this.$err=e,t.collection&&(this.collection=t.collection),t.database&&(this.database=t.database),t.operation&&(this.operation=t.operation),t.query&&(this.query=t.query),t.document&&(this.document=t.document),t.field&&(this.field=t.field),t.index&&(this.index=t.index),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}_getCodeName(e){return{0:"OK",1:"InternalError",2:"BadValue",4:"NoSuchKey",5:"GraphContainsCycle",6:"HostUnreachable",7:"HostNotFound",8:"UnknownError",10:"CannotMutateObject",11:"UserNotFound",12:"UnsupportedFormat",13:"Unauthorized",14:"TypeMismatch",15:"Overflow",16:"InvalidLength",17:"ProtocolError",18:"AuthenticationFailed",20:"IllegalOperation",26:"NamespaceNotFound",27:"IndexNotFound",28:"PathNotViable",43:"CursorNotFound",48:"NamespaceExists",59:"CommandNotFound",67:"CannotCreateIndex",68:"IndexExists",73:"InvalidNamespace",85:"IndexOptionsConflict",112:"WriteConflict",121:"DocumentValidationFailure",171:"CannotIndexParallelArrays",197:"InvalidIndexSpecificationOption",998:"OperationNotSupported",999:"NotImplemented",11e3:"DuplicateKey",11001:"DuplicateKeyUpdate",17287:"FailedToParse"}[e]||"UnknownError"}toJSON(){const e={name:this.name,message:this.message,code:this.code,codeName:this.codeName};return this.collection&&(e.collection=this.collection),this.database&&(e.database=this.database),this.operation&&(e.operation=this.operation),this.index&&(e.index=this.index),this.indexName&&(e.indexName=this.indexName),this.field&&(e.field=this.field),this.query&&(e.query=this.query),this.document&&(e.document=this.document),this.namespace&&(e.namespace=this.namespace),this.cursorId&&(e.cursorId=this.cursorId),this.feature&&(e.feature=this.feature),this.keyPattern&&(e.keyPattern=this.keyPattern),this.keyValue&&(e.keyValue=this.keyValue),this.writeErrors&&(e.writeErrors=this.writeErrors),e}}class L extends M{constructor(e,t={}){super(e,t),this.name="WriteError",this.code=t.code||D.WRITE_CONFLICT}}class T extends M{constructor(e,t={}){super(e,t),this.name="IndexError"}}class j extends T{constructor(e,t={}){super(`Index '${e}' not found`,{...t,code:D.INDEX_NOT_FOUND,index:e}),this.name="IndexNotFoundError",this.indexName=e}}class k extends M{constructor(e,t={}){super(e,t),this.name="QueryError",this.code=t.code||D.BAD_QUERY}}class P extends M{constructor(e,t={}){super(e,t),this.name="NamespaceError"}}class F extends M{constructor(e,t={}){super(e,t),this.name="CursorError"}}class U extends M{constructor(e,t={}){super(`${e} is not implemented in micro-mongo`,{...t,code:D.NOT_IMPLEMENTED}),this.name="NotImplementedError",this.feature=e}}class B extends M{constructor(e,t,n,r={}){super(`Bad value for field '${e}': ${n}`,{...r,code:D.BAD_VALUE,field:e}),this.name="BadValueError",this.value=t}}class R{constructor(e,t,n,r,i){if(this.collection=e,this.query=t,this.projection=n,this.documents=r,this.SortedCursor=i,n&&Object.keys(n).length>0){const t=Object.keys(n);let r=!1,i=!1;for(let e=0;e<t.length;e++)"_id"!==t[e]&&(n[t[e]]?r=!0:i=!0);if(r&&i)throw new k("Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.",{code:D.FAILED_TO_PARSE,collection:e.name})}this.pos=0,this._limit=0,this._skip=0,this._closed=!1}batchSize(e){return this._batchSize=e,this}close(){this._closed=!0,this.pos=this.documents.length}comment(e){return this._comment=e,this}count(){return this.documents.length}explain(e="queryPlanner"){return{queryPlanner:{plannerVersion:1,namespace:`${this.collection.db?.name||"db"}.${this.collection.name}`,indexFilterSet:!1,parsedQuery:this.query,winningPlan:{stage:"COLLSCAN",filter:this.query,direction:"forward"}},executionStats:"executionStats"===e||"allPlansExecution"===e?{executionSuccess:!0,nReturned:this.documents.length,executionTimeMillis:0,totalKeysExamined:0,totalDocsExamined:this.documents.length}:void 0,ok:1}}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){if(this._closed)return!1;let e;return e=this._limit>0?Math.min(this._skip+this._limit,this.documents.length):this.documents.length,this.pos<e}hint(e){return this._hint=e,this}itcount(){let e=0;for(;this.hasNext();)this.next(),e++;return e}limit(e){return this._limit=e,this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(e){return this._maxScan=e,this}maxTimeMS(e){return this._maxTimeMS=e,this}max(e){return this._maxIndexBounds=e,this}min(e){return this._minIndexBounds=e,this}next(){if(!this.hasNext())throw new k("Error: error hasNext: false",{collection:this.collection.name});const e=this.documents[this.pos++];return this.projection?C(this.projection,e):e}noCursorTimeout(){return this._noCursorTimeout=!0,this}objsLeftInBatch(){return this.size()}pretty(){return this._pretty=!0,this}readConcern(e){return this._readConcern=e,this}readPref(e,t){return this._readPref={mode:e,tagSet:t},this}returnKey(e=!0){return this._returnKey=e,this}showRecordId(e=!0){return this._showRecordId=e,this}size(){const e=this.documents.length-this.pos;if(this._limit>0){const t=this._skip+this._limit;return Math.min(t-this.pos,e)}return e}skip(e){return this._skip=e,0===this.pos&&(this.pos=Math.min(e,this.documents.length)),this}isClosed(){return!0===this._closed}snapshot(){throw new U("snapshot")}sort(e){return new this.SortedCursor(this.collection,this.query,this,e)}allowDiskUse(e=!0){return this._allowDiskUse=e,this}collation(e){return this._collation=e,this}tailable(){throw new U("tailable")}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}class z{constructor(e,t,n,r){for(this.collection=e,this.query=t,this.sortSpec=r,this.pos=0,this.items=[];n.hasNext();)this.items.push(n.next());const i=Object.keys(r);this.items.sort(function(e,t){for(let n=0;n<i.length;n++){if(null==e[i[n]]&&null!=t[i[n]])return-1*r[i[n]];if(null!=e[i[n]]&&null==t[i[n]])return 1*r[i[n]];if(e[i[n]]<t[i[n]])return-1*r[i[n]];if(e[i[n]]>t[i[n]])return 1*r[i[n]]}return 0})}batchSize(){throw"Not Implemented"}close(){throw"Not Implemented"}comment(){throw"Not Implemented"}count(){return this.items.length}explain(){throw"Not Implemented"}async forEach(e){for(;this.hasNext();)await e(this.next())}hasNext(){return this.pos<this.items.length}hint(){throw"Not Implemented"}itcount(){throw"Not Implemented"}limit(e){return this.items=this.items.slice(0,e),this}map(e){const t=[];for(;this.hasNext();)t.push(e(this.next()));return t}maxScan(){throw"Not Implemented"}maxTimeMS(){throw"Not Implemented"}max(){throw"Not Implemented"}min(){throw"Not Implemented"}next(){return this.items[this.pos++]}noCursorTimeout(){throw"Not Implemented"}objsLeftInBatch(){throw"Not Implemented"}pretty(){throw"Not Implemented"}readConcern(){throw"Not Implemented"}readPref(){throw"Not Implemented"}returnKey(){throw"Not Implemented"}showRecordId(){throw"Not Implemented"}size(){throw"Not Implemented"}skip(e){for(;e>0;)this.next(),e--;return this}snapshot(){throw"Not Implemented"}sort(e){return new z(this.collection,this.query,this,e)}tailable(){throw"Not Implemented"}async toArray(){const e=[];for(;this.hasNext();)e.push(this.next());return e}async*[Symbol.asyncIterator](){for(;this.hasNext();)yield this.next()}}const q={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},V={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},W="[aeiouy]",K="([^aeiou][^aeiouy]*)",H="("+W+"[aeiou]*)",Q=new RegExp("^"+K+"?"+H+K),J=new RegExp("^"+K+"?"+H+K+H+"?$"),G=new RegExp("^"+K+"?("+H+K+"){2,}"),Y=new RegExp("^"+K+"?"+W),X=new RegExp("^"+K+W+"[^aeiouwxy]$"),Z=/ll$/,ee=/^(.+?)e$/,te=/^(.+?)y$/,ne=/^(.+?(s|t))(ion)$/,re=/^(.+?)(ed|ing)$/,ie=/(at|bl|iz)$/,se=/^(.+?)eed$/,oe=/^.+?[^s]s$/,ae=/^.+?(ss|i)es$/,ce=/([^aeiouylsz])\1$/,le=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,ue=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,he=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;function fe(e){let t=String(e).toLowerCase();if(t.length<3)return t;let n,r=!1;return 121===t.codePointAt(0)&&(r=!0,t="Y"+t.slice(1)),ae.test(t)?t=t.slice(0,-2):oe.test(t)&&(t=t.slice(0,-1)),(n=se.exec(t))?Q.test(n[1])&&(t=t.slice(0,-1)):(n=re.exec(t))&&Y.test(n[1])&&(t=n[1],ie.test(t)?t+="e":ce.test(t)?t=t.slice(0,-1):X.test(t)&&(t+="e")),(n=te.exec(t))&&Y.test(n[1])&&(t=n[1]+"i"),(n=le.exec(t))&&Q.test(n[1])&&(t=n[1]+q[n[2]]),(n=ue.exec(t))&&Q.test(n[1])&&(t=n[1]+V[n[2]]),(n=he.exec(t))?G.test(n[1])&&(t=n[1]):(n=ne.exec(t))&&G.test(n[1])&&(t=n[1]),(n=ee.exec(t))&&(G.test(n[1])||J.test(n[1])&&!X.test(n[1]))&&(t=n[1]),Z.test(t)&&G.test(t)&&(t=t.slice(0,-1)),r&&(t="y"+t.slice(1)),t}class de{constructor(e,t,n,r,i,s){this.id=e,this.isLeaf=t,this.keys=n,this.values=r,this.children=i;for(let o of i)if(!(o instanceof m))throw new Error("Children must be Pointer objects");this.next=s}}class pe{constructor(e,t=3){if(t<3)throw new Error("B+ tree order must be at least 3");this.filename=e,this.order=t,this.minKeys=Math.ceil(t/2)-1,this.file=new b(e),this.isOpen=!1,this.rootPointer=null,this.nextNodeId=0,this._size=0}async open(){if(this.isOpen)throw new Error("Tree file is already open");await this.file.exists()?(await this.file.open("rw"),await this._loadMetadata()):(await this.file.open("rw"),await this._initializeNewTree()),this.isOpen=!0}async close(){this.isOpen&&(await this._saveMetadata(),await this.file.close(),this.isOpen=!1)}async _initializeNewTree(){const e=new de(0,!0,[],[],[],null);this.nextNodeId=1,this._size=0;const t=await this._saveNode(e);this.rootPointer=t,await this._saveMetadata()}async _saveMetadata(){const e={version:1,maxEntries:this.order,minEntries:this.minKeys,size:this._size,rootPointer:this.rootPointer,nextId:this.nextNodeId};await this.file.append(e)}async _loadMetadata(){const e=await this.file.getFileSize();if(e<135)throw new Error("Invalid tree file");const t=e-135,n=await this.file.read(t);if(!n||void 0===n.maxEntries)throw new Error("Failed to read metadata: missing required fields");this.order=n.maxEntries,this.minKeys=n.minEntries,this._size=n.size,this.nextNodeId=n.nextId,this.rootPointer=n.rootPointer}async _saveNode(e){const t=await this.file.getFileSize();return await this.file.append(e),new m(t)}async _loadNode(e){if(!(e instanceof m))throw new Error("Expected Pointer object");const t=await this.file.read(e);return new de(t.id,t.isLeaf,t.keys,t.values,t.children,t.next)}async _loadRoot(){return await this._loadNode(this.rootPointer)}async search(e){const t=await this._loadRoot();return this._searchNode(t,e)}async _searchNode(e,t){if(!e.isLeaf){let n=0;for(;n<e.keys.length&&t>=e.keys[n];)n++;const r=await this._loadNode(e.children[n]);return this._searchNode(r,t)}for(let n=0;n<e.keys.length;n++)if(t===e.keys[n])return e.values[n]}async add(e,t){const n=await this._loadRoot(),r=await this._addToNode(n,e,t);let i;if(r.newNode)i=r.newNode;else{const e=await this._saveNode(r.left),t=await this._saveNode(r.right);i=new de(this.nextNodeId++,!1,[r.splitKey],[],[e,t],null)}const s=await this._saveNode(i);this.rootPointer=s,this._size++}async _addToNode(e,t,n){if(e.isLeaf){const r=[...e.keys],i=[...e.values],s=r.indexOf(t);if(-1!==s)return i[s]=n,{newNode:new de(e.id,!0,r,i,[],null)};let o=0;for(;o<r.length&&t>r[o];)o++;if(r.splice(o,0,t),i.splice(o,0,n),r.length<this.order)return{newNode:new de(e.id,!0,r,i,[],null)};{const t=Math.ceil(r.length/2),n=r.slice(0,t),s=i.slice(0,t),o=r.slice(t),a=i.slice(t),c=new de(this.nextNodeId++,!0,o,a,[],null);return{left:new de(e.id,!0,n,s,[],null),right:c,splitKey:o[0]}}}{const r=[...e.keys],i=[...e.children];let s=0;for(;s<r.length&&t>=r[s];)s++;const o=await this._loadNode(i[s]),a=await this._addToNode(o,t,n);if(a.newNode){const t=await this._saveNode(a.newNode);return i[s]=t,{newNode:new de(e.id,!1,r,[],i,null)}}{const t=await this._saveNode(a.left),n=await this._saveNode(a.right);if(r.splice(s,0,a.splitKey),i.splice(s,1,t,n),r.length<this.order)return{newNode:new de(e.id,!1,r,[],i,null)};{const t=Math.ceil(r.length/2)-1,n=r[t],s=r.slice(0,t),o=r.slice(t+1),a=i.slice(0,t+1),c=i.slice(t+1);return{left:new de(e.id,!1,s,[],a,null),right:new de(this.nextNodeId++,!1,o,[],c,null),splitKey:n}}}}}async delete(e){const t=await this._loadRoot(),n=await this._deleteFromNode(t,e);if(!n)return;let r=n;0===r.keys.length&&!r.isLeaf&&r.children.length>0&&(r=await this._loadNode(r.children[0]));const i=await this._saveNode(r);this.rootPointer=i,this._size--}async _deleteFromNode(e,t){if(e.isLeaf){const n=e.keys.indexOf(t);if(-1===n)return null;const r=[...e.keys],i=[...e.values];return r.splice(n,1),i.splice(n,1),new de(e.id,!0,r,i,[],e.next)}{let n=0;for(;n<e.keys.length&&t>=e.keys[n];)n++;const r=await this._loadNode(e.children[n]),i=await this._deleteFromNode(r,t);if(!i)return null;const s=[...e.children],o=await this._saveNode(i);return s[n]=o,new de(e.id,!1,[...e.keys],[],s,null)}}async toArray(){const e=[];return await this._collectAllEntries(await this._loadRoot(),e),e}async _collectAllEntries(e,t){if(e.isLeaf)for(let n=0;n<e.keys.length;n++)t.push({key:e.keys[n],value:e.values[n]});else for(const n of e.children){const e=await this._loadNode(n);await this._collectAllEntries(e,t)}}size(){return this._size}isEmpty(){return 0===this._size}async rangeSearch(e,t){const n=[];return await this._rangeSearchNode(await this._loadRoot(),e,t,n),n}async _rangeSearchNode(e,t,n,r){if(e.isLeaf)for(let i=0;i<e.keys.length;i++)e.keys[i]>=t&&e.keys[i]<=n&&r.push({key:e.keys[i],value:e.values[i]});else for(const i of e.children){const e=await this._loadNode(i);await this._rangeSearchNode(e,t,n,r)}}async getHeight(){let e=0,t=await this._loadRoot();for(;!t.isLeaf;)e++,t=await this._loadNode(t.children[0]);return e}async compact(e){if(!this.isOpen)throw new Error("Tree file is not open");if(!e)throw new Error("Destination filename is required for compaction");await this._saveMetadata();const t=await this.file.getFileSize(),n=await this.toArray(),r=new pe(e,this.order);await r.open();for(const o of n)await r.add(o.key,o.value);await r.close();const i=new b(e);await i.open("r");const s=await i.getFileSize();return await i.close(),{oldSize:t,newSize:s,bytesSaved:Math.max(0,t-s),newFilename:e}}}const ge=new Set(["a","about","after","all","also","am","an","and","another","any","are","around","as","at","be","because","been","before","being","between","both","but","by","came","can","come","could","did","do","each","for","from","get","got","has","had","he","have","her","here","him","himself","his","how","i","if","in","into","is","it","like","make","many","me","might","more","most","much","must","my","never","now","of","on","only","or","other","our","out","over","said","same","see","should","since","some","still","such","take","than","that","the","their","them","then","there","these","they","this","those","through","to","too","under","up","very","was","way","we","well","were","what","where","which","while","who","with","would","you","your"]);function me(e){if("string"!=typeof e)return[];return e.toLowerCase().split(/\W+/).filter(e=>e.length>0).filter(e=>!ge.has(e))}class ye{constructor(e={}){const{baseFilename:t=`text-index-${Date.now()}-${Math.random().toString(16).slice(2)}`,order:n=16,trees:r}=e;this.baseFilename=t,this.index=r?.index||new pe(`${t}-terms.bjson`,n),this.documentTerms=r?.documentTerms||new pe(`${t}-documents.bjson`,n),this.documentLengths=r?.documentLengths||new pe(`${t}-lengths.bjson`,n),this.isOpen=!1}async open(){if(this.isOpen)throw new Error("TextIndex is already open");await Promise.all([this.index.open(),this.documentTerms.open(),this.documentLengths.open()]),this.isOpen=!0}async close(){this.isOpen&&(await Promise.all([this.index.close(),this.documentTerms.close(),this.documentLengths.close()]),this.isOpen=!1)}_ensureOpen(){if(!this.isOpen)throw new Error("TextIndex is not open")}async add(e,t){if(this._ensureOpen(),!e)throw new Error("Document ID is required");const n=me(t),r=new Map;n.forEach(e=>{const t=fe(e);r.set(t,(r.get(t)||0)+1)});for(const[o,a]of r.entries()){const t=await this.index.search(o)||{};t[e]=a,await this.index.add(o,t)}const i={...await this.documentTerms.search(e)||{}};r.forEach((e,t)=>{i[t]=e});const s=Object.values(i).reduce((e,t)=>e+t,0);await this.documentTerms.add(e,i),await this.documentLengths.add(e,s)}async remove(e){this._ensureOpen();const t=await this.documentTerms.search(e);if(!t)return!1;for(const[n]of Object.entries(t)){const t=await this.index.search(n)||{};delete t[e],0===Object.keys(t).length?await this.index.delete(n):await this.index.add(n,t)}return await this.documentTerms.delete(e),await this.documentLengths.delete(e),!0}async query(e,t={scored:!0,requireAll:!1}){this._ensureOpen();const n=me(e);if(0===n.length)return[];const r=n.map(e=>fe(e)),i=[...new Set(r)];if(t.requireAll){const e=[];for(const n of i){const t=await this.index.search(n);e.push(new Set(Object.keys(t||{})))}if(0===e.length)return[];const t=new Set(e[0]);for(let n=1;n<e.length;n++)for(const r of[...t])e[n].has(r)||t.delete(r);return Array.from(t)}const s=await this.documentLengths.toArray(),o=new Map(s.map(({key:e,value:t})=>[String(e),t||1])),a=s.length,c=new Map;for(const h of i){const e=await this.index.search(h),t=e?Object.keys(e).length:0;t>0&&c.set(h,Math.log(a/t))}const l=new Map;for(const h of i){const e=await this.index.search(h);if(e)for(const[t,n]of Object.entries(e)){const e=n/(o.get(t)||1),r=c.get(h)||0,i=l.get(t)||0;l.set(t,i+e*r)}}for(const[h,f]of l.entries()){const e=await this.documentTerms.search(h)||{},t=i.filter(t=>!!e[t]).length/i.length;l.set(h,f*(1+t))}const u=Array.from(l.entries()).map(([e,t])=>({id:e,score:t})).sort((e,t)=>t.score-e.score);return!1===t.scored?u.map(e=>e.id):u}async getTermCount(){this._ensureOpen();return(await this.index.toArray()).length}async getDocumentCount(){this._ensureOpen();return(await this.documentTerms.toArray()).length}async clear(){this._ensureOpen();const[e,t,n]=await Promise.all([this.index.toArray(),this.documentTerms.toArray(),this.documentLengths.toArray()]);for(const r of e)await this.index.delete(r.key);for(const r of t)await this.documentTerms.delete(r.key);for(const r of n)await this.documentLengths.delete(r.key)}async compact(e=`${this.baseFilename}-compact-${Date.now()}`){if(this._ensureOpen(),!e)throw new Error("Destination base filename is required for compaction");const t=`${e}-terms.bjson`,n=`${e}-documents.bjson`,r=`${e}-lengths.bjson`,i=await Promise.all([this.index.compact(t),this.documentTerms.compact(n),this.documentLengths.compact(r)]),s=this.index.order,o=this.documentTerms.order,a=this.documentLengths.order;return await this.close(),this.baseFilename=e,this.index=new pe(t,s),this.documentTerms=new pe(n,o),this.documentLengths=new pe(r,a),await this.open(),{terms:i[0],documents:i[1],lengths:i[2]}}}function we(e,t){if(null==e)return e;if("boolean"==typeof e||"number"==typeof e)return e;if("string"==typeof e)return e.startsWith("$$")?"$$KEEP"===e||"$$PRUNE"===e||"$$DESCEND"===e?e:v(t,e.substring(2)):"$"===e.charAt(0)?v(t,e.substring(1)):e;if("object"==typeof e){if(Array.isArray(e))return e.map(e=>we(e,t));const n=Object.keys(e);if(0===n.length)return e;const r=n[0];if("$"===r.charAt(0)){return function(e,t,n){switch(e){case"$add":return function(e,t){if(!Array.isArray(e))return null;let n=0;for(const r of e){const e=we(r,t);e instanceof Date?n+=e.getTime():"number"==typeof e&&(n+=e)}return n}(t,n);case"$subtract":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);if(n instanceof Date&&r instanceof Date)return n.getTime()-r.getTime();if(n instanceof Date&&"number"==typeof r)return new Date(n.getTime()-r);if("number"==typeof n&&"number"==typeof r)return n-r;return null}(t,n);case"$multiply":return function(e,t){if(!Array.isArray(e))return null;let n=1;for(const r of e){const e=we(r,t);"number"==typeof e&&(n*=e)}return n}(t,n);case"$divide":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);if("number"==typeof n&&"number"==typeof r&&0!==r)return n/r;return null}(t,n);case"$mod":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);if("number"==typeof n&&"number"==typeof r&&0!==r)return n%r;return null}(t,n);case"$pow":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);if("number"==typeof n&&"number"==typeof r)return Math.pow(n,r);return null}(t,n);case"$sqrt":return function(e,t){const n=we(e,t);if("number"==typeof n&&n>=0)return Math.sqrt(n);return null}(t,n);case"$abs":return function(e,t){const n=we(e,t);if("number"==typeof n)return Math.abs(n);return null}(t,n);case"$ceil":return function(e,t){const n=we(e,t);if("number"==typeof n)return Math.ceil(n);return null}(t,n);case"$floor":return function(e,t){const n=we(e,t);if("number"==typeof n)return Math.floor(n);return null}(t,n);case"$trunc":return function(e,t){const n=we(e,t);if("number"==typeof n)return Math.trunc(n);return null}(t,n);case"$round":return function(e,t){const n=we(Array.isArray(e)?e[0]:e,t),r=Array.isArray(e)&&void 0!==e[1]?we(e[1],t):0;if("number"==typeof n&&"number"==typeof r){const e=Math.pow(10,r);return Math.round(n*e)/e}return null}(t,n);case"$concat":return function(e,t){if(!Array.isArray(e))return null;let n="";for(const r of e){const e=we(r,t);null!=e&&(n+=String(e))}return n}(t,n);case"$substr":return function(e,t){if(!Array.isArray(e)||e.length<3)return null;const n=String(we(e[0],t)||""),r=we(e[1],t),i=we(e[2],t);if("number"==typeof r&&"number"==typeof i)return n.substr(r,i);return null}(t,n);case"$toLower":return function(e,t){const n=we(e,t);return null!=n?String(n).toLowerCase():""}(t,n);case"$toUpper":return function(e,t){const n=we(e,t);return null!=n?String(n).toUpperCase():""}(t,n);case"$trim":return function(e,t){const n=we("object"==typeof e&&e.input?e.input:e,t),r=e.chars?we(e.chars,t):null;let i=null!=n?String(n):"";if(r){const e=new RegExp(`^[${be(r)}]+|[${be(r)}]+$`,"g");return i.replace(e,"")}return i.trim()}(t,n);case"$ltrim":return function(e,t){const n=we("object"==typeof e&&e.input?e.input:e,t),r=e.chars?we(e.chars,t):null;let i=null!=n?String(n):"";if(r){const e=new RegExp(`^[${be(r)}]+`,"g");return i.replace(e,"")}return i.replace(/^\s+/,"")}(t,n);case"$rtrim":return function(e,t){const n=we("object"==typeof e&&e.input?e.input:e,t),r=e.chars?we(e.chars,t):null;let i=null!=n?String(n):"";if(r){const e=new RegExp(`[${be(r)}]+$`,"g");return i.replace(e,"")}return i.replace(/\s+$/,"")}(t,n);case"$split":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=String(we(e[0],t)||""),r=String(we(e[1],t)||"");return n.split(r)}(t,n);case"$strLenCP":return function(e,t){const n=we(e,t);return null!=n?String(n).length:0}(t,n);case"$strcasecmp":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=String(we(e[0],t)||"").toLowerCase(),r=String(we(e[1],t)||"").toLowerCase();return n<r?-1:n>r?1:0}(t,n);case"$indexOfCP":return function(e,t){if(!Array.isArray(e)||e.length<2)return null;const n=String(we(e[0],t)||""),r=String(we(e[1],t)||""),i=void 0!==e[2]?we(e[2],t):0,s=void 0!==e[3]?we(e[3],t):n.length,o=n.substring(i,s).indexOf(r);return-1===o?-1:o+i}(t,n);case"$replaceOne":return function(e,t){const n=String(we(e.input,t)||""),r=String(we(e.find,t)||""),i=String(we(e.replacement,t)||"");return n.replace(r,i)}(t,n);case"$replaceAll":return function(e,t){const n=String(we(e.input,t)||""),r=String(we(e.find,t)||""),i=String(we(e.replacement,t)||"");return n.split(r).join(i)}(t,n);case"$cmp":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n<r?-1:n>r?1:0}(t,n);case"$eq":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n===r}(t,n);case"$ne":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n!==r}(t,n);case"$gt":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n>r}(t,n);case"$gte":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n>=r}(t,n);case"$lt":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n<r}(t,n);case"$lte":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return n<=r}(t,n);case"$and":return function(e,t){if(!Array.isArray(e))return null;for(const n of e){if(!we(n,t))return!1}return!0}(t,n);case"$or":return function(e,t){if(!Array.isArray(e))return null;for(const n of e){if(we(n,t))return!0}return!1}(t,n);case"$not":return function(e,t){const n=we(Array.isArray(e)?e[0]:e,t);return!n}(t,n);case"$cond":return function(e,t){let n,r,i;if(Array.isArray(e)){if(3!==e.length)return null;[n,r,i]=e}else{if("object"!=typeof e)return null;n=e.if,r=e.then,i=e.else}const s=we(n,t);return we(s?r:i,t)}(t,n);case"$ifNull":return function(e,t){if(!Array.isArray(e)||e.length<2)return null;for(let n=0;n<e.length;n++){const r=we(e[n],t);if(null!=r)return r}return null}(t,n);case"$switch":return function(e,t){if("object"!=typeof e||!Array.isArray(e.branches))return null;for(const n of e.branches){if(we(n.case,t))return we(n.then,t)}return void 0!==e.default?we(e.default,t):null}(t,n);case"$year":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCFullYear();return null}(t,n);case"$month":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCMonth()+1;return null}(t,n);case"$dayOfMonth":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCDate();return null}(t,n);case"$dayOfWeek":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCDay()+1;return null}(t,n);case"$dayOfYear":return function(e,t){const n=we(e,t);if(n instanceof Date){const e=new Date(Date.UTC(n.getUTCFullYear(),0,0)),t=n-e,r=864e5;return Math.floor(t/r)}return null}(t,n);case"$hour":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCHours();return null}(t,n);case"$minute":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCMinutes();return null}(t,n);case"$second":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCSeconds();return null}(t,n);case"$millisecond":return function(e,t){const n=we(e,t);if(n instanceof Date)return n.getUTCMilliseconds();return null}(t,n);case"$week":return function(e,t){const n=we(e,t);if(n instanceof Date){const e=new Date(Date.UTC(n.getUTCFullYear(),0,1));return Math.ceil(((n-e)/864e5+e.getUTCDay()+1)/7)-1}return null}(t,n);case"$isoWeek":return function(e,t){const n=we(e,t);if(n instanceof Date){const e=new Date(n.valueOf()),t=(n.getUTCDay()+6)%7;e.setUTCDate(e.getUTCDate()-t+3);const r=e.valueOf();return e.setUTCMonth(0,1),4!==e.getUTCDay()&&e.setUTCMonth(0,1+(4-e.getUTCDay()+7)%7),1+Math.ceil((r-e)/6048e5)}return null}(t,n);case"$isoWeekYear":return function(e,t){const n=we(e,t);if(n instanceof Date){const e=new Date(n.valueOf());return e.setUTCDate(e.getUTCDate()-(n.getUTCDay()+6)%7+3),e.getUTCFullYear()}return null}(t,n);case"$dateToString":return function(e,t){const n=e.format?we(e.format,t):"%Y-%m-%dT%H:%M:%S.%LZ",r=we(e.date,t);return r instanceof Date?n.replace("%Y",r.getUTCFullYear()).replace("%m",String(r.getUTCMonth()+1).padStart(2,"0")).replace("%d",String(r.getUTCDate()).padStart(2,"0")).replace("%H",String(r.getUTCHours()).padStart(2,"0")).replace("%M",String(r.getUTCMinutes()).padStart(2,"0")).replace("%S",String(r.getUTCSeconds()).padStart(2,"0")).replace("%L",String(r.getUTCMilliseconds()).padStart(3,"0")):null}(t,n);case"$toDate":return function(e,t){const n=we(e,t);if(n instanceof Date)return n;if("string"==typeof n||"number"==typeof n){const e=new Date(n);return isNaN(e.getTime())?null:e}return null}(t,n);case"$arrayElemAt":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);if(!Array.isArray(n)||"number"!=typeof r)return null;const i=r<0?n.length+r:r;return n[i]}(t,n);case"$concatArrays":return function(e,t){if(!Array.isArray(e))return null;const n=[];for(const r of e){const e=we(r,t);Array.isArray(e)&&n.push(...e)}return n}(t,n);case"$filter":return function(e,t){const n=we(e.input,t),r=e.as||"this",i=e.cond;return Array.isArray(n)?n.filter(e=>{const n={...t,[r]:e};return we(i,n)}):null}(t,n);case"$in":return function(e,t){if(!Array.isArray(e)||2!==e.length)return null;const n=we(e[0],t),r=we(e[1],t);return!!Array.isArray(r)&&r.includes(n)}(t,n);case"$indexOfArray":return function(e,t){if(!Array.isArray(e)||e.length<2)return null;const n=we(e[0],t),r=we(e[1],t),i=void 0!==e[2]?we(e[2],t):0,s=void 0!==e[3]?we(e[3],t):n.length;if(!Array.isArray(n))return null;for(let o=i;o<s&&o<n.length;o++)if(n[o]===r)return o;return-1}(t,n);case"$isArray":return function(e,t){const n=we(e,t);return Array.isArray(n)}(t,n);case"$map":return function(e,t){const n=we(e.input,t),r=e.as||"this",i=e.in;return Array.isArray(n)?n.map(e=>{const n={...t,[r]:e};return we(i,n)}):null}(t,n);case"$reduce":return function(e,t){const n=we(e.input,t),r=we(e.initialValue,t),i=e.in;if(!Array.isArray(n))return null;let s=r;for(const o of n){s=we(i,{...t,value:s,this:o})}return s}(t,n);case"$size":return function(e,t){const n=we(e,t);return Array.isArray(n)?n.length:null}(t,n);case"$slice":return function(e,t){if(!Array.isArray(e)||e.length<2)return null;const n=we(e[0],t);if(!Array.isArray(n))return null;if(2===e.length){const r=we(e[1],t);return r>=0?n.slice(0,r):n.slice(r)}{const r=we(e[1],t),i=we(e[2],t);return n.slice(r,r+i)}}(t,n);case"$reverseArray":return function(e,t){const n=we(e,t);return Array.isArray(n)?n.slice().reverse():null}(t,n);case"$zip":return function(e,t){const n=e.inputs?we(e.inputs,t):null,r=e.useLongestLength||!1,i=e.defaults;if(!Array.isArray(n))return null;const s=n.map(e=>we(e,t));if(!s.every(e=>Array.isArray(e)))return null;const o=Math.max(...s.map(e=>e.length)),a=r?o:Math.min(...s.map(e=>e.length)),c=[];for(let l=0;l<a;l++){const e=[];for(let t=0;t<s.length;t++)l<s[t].length?e.push(s[t][l]):i&&t<i.length?e.push(i[t]):e.push(null);c.push(e)}return c}(t,n);case"$type":return function(e,t){const n=we(e,t);return null===n?"null":void 0===n?"missing":"boolean"==typeof n?"bool":"number"==typeof n?Number.isInteger(n)?"int":"double":"string"==typeof n?"string":n instanceof Date?"date":Array.isArray(n)?"array":"object"==typeof n?"object":"unknown"}(t,n);case"$convert":return function(e,t){const n=we(e.input,t),r=e.to,i=e.onError,s=e.onNull;if(null===n)return void 0!==s?we(s,t):null;try{switch(r){case"double":case"decimal":return parseFloat(n);case"int":case"long":return parseInt(n);case"bool":return Boolean(n);case"string":return String(n);case"date":return new Date(n);default:return n}}catch(o){return void 0!==i?we(i,t):null}}(t,n);case"$toBool":return function(e,t){const n=we(e,t);return Boolean(n)}(t,n);case"$toDecimal":return function(e,t){const n=we(e,t);return parseFloat(n)}(t,n);case"$toDouble":return function(e,t){const n=we(e,t);return parseFloat(n)}(t,n);case"$toInt":return function(e,t){const n=we(e,t);return parseInt(n)}(t,n);case"$toLong":return function(e,t){const n=we(e,t);return parseInt(n)}(t,n);case"$toString":return function(e,t){const n=we(e,t);return null==n?null:String(n)}(t,n);case"$objectToArray":return function(e,t){const n=we(e,t);if("object"!=typeof n||null===n||Array.isArray(n))return null;return Object.keys(n).map(e=>({k:e,v:n[e]}))}(t,n);case"$arrayToObject":return function(e,t){const n=we(e,t);if(!Array.isArray(n))return null;const r={};for(const i of n)Array.isArray(i)&&2===i.length?r[i[0]]=i[1]:"object"==typeof i&&void 0!==i.k&&void 0!==i.v&&(r[i.k]=i.v);return r}(t,n);case"$mergeObjects":return function(e,t){if(!Array.isArray(e))return we(e,t);const n={};for(const r of e){const e=we(r,t);"object"!=typeof e||null===e||Array.isArray(e)||Object.assign(n,e)}return n}(t,n);case"$literal":return t;default:throw new Error(`Unsupported aggregation operator: ${e}`)}}(r,e[r],t)}{const r={};for(const i of n)r[i]=we(e[i],t);return r}}return e}function be(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const xe={1:"double",2:"string",3:"object",4:"array",5:"binData",6:"undefined",7:"objectId",8:"bool",9:"date",10:"null",11:"regex",13:"javascript",15:"javascriptWithScope",16:"int",17:"timestamp",18:"long",19:"decimal",127:"maxKey","-1":"minKey"},_e=Object.entries(xe).reduce((e,[t,n])=>(e[n]=parseInt(t),e),{});function ve(e,t){if(O(t)){for(let n=0;n<t.length;n++)if(ve(e,t[n]))return!0;return!1}const n="number"==typeof t?t:_e[t],r=xe[n]||t;return null===e?"null"===r||10===n:void 0===e?"undefined"===r||6===n:"number"==typeof e?Number.isInteger(e)?"int"===r||16===n:"double"===r||1===n:"string"==typeof e?"string"===r||2===n:"boolean"==typeof e?"bool"===r||8===n:e instanceof Date?"date"===r||9===n:e instanceof g?"objectId"===r||7===n:e instanceof RegExp?"regex"===r||11===n:O(e)?"array"===r||4===n:"object"==typeof e?"object"===r||3===n:typeof e===t}function $e(e){if(O(e)){let t=0;for(let n=0;n<e.length;n++)t|=1<<e[n];return t}return"number"==typeof e?e:0}function Ne(e,t){if("number"!=typeof e)return!1;const n=$e(t);return(e&n)===n}function Oe(e,t){if("number"!=typeof e)return!1;return 0===(e&$e(t))}function Ee(e,t){if("number"!=typeof e)return!1;return 0!==(e&$e(t))}function Ae(e,t){if("number"!=typeof e)return!1;const n=$e(t);return(e&n)!==n}function Ie(e,t){if(t.type){const n=O(e)?"array":null===e?"null":typeof e;if(t.type!==n)return!1}if(t.required&&O(t.required))for(let n=0;n<t.required.length;n++)if(!(t.required[n]in e))return!1;if(t.properties)for(const n in t.properties){if(!(n in e))return!1;const r=t.properties[n];if(!Ie(e[n],r))return!1}if(void 0!==t.minimum&&"number"==typeof e&&e<t.minimum)return!1;if(void 0!==t.maximum&&"number"==typeof e&&e>t.maximum)return!1;if(void 0!==t.minLength&&"string"==typeof e&&e.length<t.minLength)return!1;if(void 0!==t.maxLength&&"string"==typeof e&&e.length>t.maxLength)return!1;if(t.pattern&&"string"==typeof e){if(!new RegExp(t.pattern).test(e))return!1}return!(t.enum&&O(t.enum)&&!t.enum.includes(e))}function Se(e,t){return e instanceof g&&t instanceof g?e.equals(t):e==t}function Ce(e,t,n){let r=e,i=t;switch(e instanceof g&&(r=e.toString()),t instanceof g&&(i=t.toString()),n){case">":return r>i;case">=":return r>=i;case"<":return r<i;case"<=":return r<=i;default:return!1}}function De(e,t){if(void 0===e)return!1;if(null===e)return t(e);if(O(e)){for(var n=0;n<e.length;n++)if(t(e[n]))return!0;return!1}return t(e)}function Me(e){if("string"!=typeof e)return[];return me(e).map(e=>fe(e))}function Le(e,t){if("string"!=typeof e)return!1;const n=new Set(Me(e));return Me(t).some(e=>n.has(e))}function Te(e,t){try{if(!Array.isArray(t)||2!==t.length)return!1;const n=t[0][0],r=t[0][1],i=t[1][0];return je(e,n,i,t[1][1],r)}catch(n){return!1}}function je(e,t,n,r,i){if(!e)return!1;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){for(const s of e.features)if(s.geometry&&!je(s.geometry,t,n,r,i))return!1;return!0}if("Feature"===e.type&&e.geometry)return je(e.geometry,t,n,r,i);if("Point"===e.type&&e.coordinates){const[s,o]=e.coordinates;if("number"==typeof s&&"number"==typeof o)return s>=t&&s<=n&&o>=r&&o<=i}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){for(const s of e.coordinates)for(const e of s){const s=e[0],o=e[1];if(s<t||s>n||o<r||o>i)return!1}return!0}return!1}function ke(e){if(!e)return null;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){const t=e.features[0];if(t.geometry)return ke(t.geometry)}if("Feature"===e.type&&e.geometry)return ke(e.geometry);if("Point"===e.type&&e.coordinates){const[t,n]=e.coordinates;if("number"==typeof t&&"number"==typeof n)return{lat:n,lng:t}}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){const t=e.coordinates[0];if(t.length>0){let e=0,n=0;for(const r of t)n+=r[0],e+=r[1];return{lat:e/t.length,lng:n/t.length}}}return null}function Pe(e,t,n,r){const i=(n-e)*Math.PI/180,s=(r-t)*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}function Fe(e,t,n,r){const i=ke(e);if(!i)return!1;return 1e3*Pe(i.lat,i.lng,n,t)<=r}function Ue(e,t){if(!e||!t)return!1;const n=ke(t);if(!n)return!1;const r=ke(e);if(!r)return!1;if("Polygon"===t.type&&"Point"===e.type)return Be(r.lng,r.lat,t.coordinates[0]);if("Polygon"===e.type&&"Point"===t.type){const n=t.coordinates;return Be(n[0],n[1],e.coordinates[0])}if("Point"===e.type&&"Point"===t.type){return Pe(r.lat,r.lng,n.lat,n.lng)<.001}return!1}function Be(e,t,n){let r=!1;for(let i=0,s=n.length-1;i<n.length;s=i++){const o=n[i][0],a=n[i][1],c=n[s][0],l=n[s][1];a>t!=l>t&&e<(c-o)*(t-a)/(l-a)+o&&(r=!r)}return r}function Re(e,t){if("function"==typeof t)try{return t.call(e)}catch(n){return!1}else if("string"==typeof t)try{return new Function("return "+t).call(e)}catch(n){return!1}return!1}function ze(e,t){var n=Object.keys(t)[0],r=t[n];if("$"!=n.charAt(0))return qe(e,n,r);if("$and"==n)return Ve(e,r);if("$or"==n)return function(e,t){for(var n=0;n<t.length;n++)if(ze(e,t[n]))return!0;return!1}(e,r);if("$not"==n)return function(e,t){return!ze(e,t)}(e,r);if("$nor"==n)return function(e,t){for(var n=0;n<t.length;n++)if(ze(e,t[n]))return!1;return!0}(e,r);if("$where"==n)return Re(e,r);if("$comment"==n)return!0;if("$jsonSchema"==n)return Ie(e,r);if("$expr"!=n)throw{$err:"Can't canonicalize query: BadValue unknown top level operator: "+n,code:17287};try{return we(r,e)}catch(i){return!1}}function qe(e,t,n){var r=$(e,t);if("string"==typeof n)return De(r,function(e){return Se(e,n)});if("number"==typeof n)return De(r,function(e){return Se(e,n)});if("boolean"==typeof n)return De(r,function(e){return Se(e,n)});if(n instanceof g)return De(r,function(e){return Se(e,n)});if("object"==typeof n){if(n instanceof RegExp)return null!=r&&De(r,function(e){return e&&e.match(n)});if(O(n))return null!=r&&De(r,function(e){return e&&I(e,n)});var i=Object.keys(n);if("$"==i[0].charAt(0)){for(var s=0;s<i.length;s++){var o=Object.keys(n)[s],a=n[o];if("$eq"==o){if(!De(r,function(e){return Se(e,a)}))return!1}else if("$gt"==o){if(!De(r,function(e){return Ce(e,a,">")}))return!1}else if("$gte"==o){if(!De(r,function(e){return Ce(e,a,">=")}))return!1}else if("$lt"==o){if(!De(r,function(e){return Ce(e,a,"<")}))return!1}else if("$lte"==o){if(!De(r,function(e){return Ce(e,a,"<=")}))return!1}else if("$ne"==o){if(!De(r,function(e){return!Se(e,a)}))return!1}else if("$in"==o){if(!De(r,function(e){return A(e,a)}))return!1}else if("$nin"==o){if(De(r,function(e){return A(e,a)}))return!1}else if("$exists"==o){var c=v(e,t);if(a?null==c:null!=c)return!1}else if("$type"==o){if(void 0===r){if(6!==("number"==typeof a?a:_e[a]))return!1}else if(!ve(r,a))return!1}else if("$mod"==o){if(2!=a.length)throw{$err:"Can't canonicalize query: BadValue malformed mod, not enough elements",code:17287};if(!De(r,function(e){return null!=e&&e%a[0]==a[1]}))return!1}else if("$regex"==o){var l=a,u=n.$options||"",h="string"==typeof l?new RegExp(l,u):l;if(!De(r,function(e){return null!=e&&h.test(e)}))return!1}else{if("$options"==o)continue;if("$text"==o){if(!De(r,function(e){return null!=e&&Le(e,a)}))return!1}else if("$expr"==o)try{if(!we(a,e))return!1}catch(E){return!1}else if("$geoWithin"==o){if(!De(r,function(e){return null!=e&&Te(e,a)}))return!1}else if("$near"==o||"$nearSphere"==o){let e;if(a.$geometry?e=a.$geometry.coordinates:a.coordinates?e=a.coordinates:Array.isArray(a)&&(e=a),!(e&&e.length>=2))return!1;{const[t,n]=e,i=a.$maxDistance||1e6;if(!De(r,function(e){return null!=e&&Fe(e,t,n,i)}))return!1}}else if("$geoIntersects"==o){const e=a.$geometry||a;if(!De(r,function(t){return null!=t&&Ue(t,e)}))return!1}else if("$not"==o){if(qe(e,t,a))return!1}else if("$all"==o){if(null==(d=v(e,t))||!O(d))return!1;for(var f=0;f<a.length;f++)if(!A(a[f],d))return!1}else if("$elemMatch"==o){var d;if(null==(d=v(e,t))||!O(d))return!1;var p=!1;for(f=0;f<d.length;f++){var m=d[f];if("object"!=typeof m||O(m)){for(var y=!0,w=Object.keys(a),b=0;b<w.length;b++){var x=w[b],_=a[x];("$gte"!=x||m>=_)&&("$gt"!=x||m>_)&&("$lte"!=x||m<=_)&&("$lt"!=x||m<_)?"$eq"==x&&m!=_||"$ne"==x&&m==_?y=!1:"$in"!=x||A(m,_)?"$nin"==x&&A(m,_)&&(y=!1):y=!1:y=!1}if(y){p=!0;break}}else if(We(m,a)){p=!0;break}}if(!p)return!1}else if("$size"==o){var N=v(e,t);if(null==N||!O(N))return!1;if(N.length!=a)return!1}else if("$bitsAllSet"==o){if(!De(r,function(e){return Ne(e,a)}))return!1}else if("$bitsAllClear"==o){if(!De(r,function(e){return Oe(e,a)}))return!1}else if("$bitsAnySet"==o){if(!De(r,function(e){return Ee(e,a)}))return!1}else{if("$bitsAnyClear"!=o)throw{$err:"Can't canonicalize query: BadValue unknown operator: "+o,code:17287};if(!De(r,function(e){return Ae(e,a)}))return!1}}}return!0}return v(e,t)&&S(v(e,t),n)}}function Ve(e,t){for(var n=0;n<t.length;n++)if(!ze(e,t[n]))return!1;return!0}function We(e,t){return Ve(e,E(t))}function Ke(e,t){const n={};return{matched:He(e,E(t),n),arrayFilters:n}}function He(e,t,n){for(var r=0;r<t.length;r++)if(!Qe(e,t[r],n))return!1;return!0}function Qe(e,t,n){var r=Object.keys(t)[0],i=t[r];if("$"!=r.charAt(0))return function(e,t,n,r){const i=t.split(".")[0],s=$(e,t),o=(n,s)=>{if(void 0===n)return!1;if(null===n)return s(n);if(O(n)){if(O(v(e,i))){for(var o=0;o<n.length;o++)if(s(n[o]))return r[t]=o,!0;return!1}}return De(n,s)};if("string"==typeof n)return o(s,function(e){return Se(e,n)});if("number"==typeof n)return o(s,function(e){return Se(e,n)});if("boolean"==typeof n)return o(s,function(e){return Se(e,n)});if(n instanceof g)return o(s,function(e){return Se(e,n)});if("object"==typeof n){if(n instanceof RegExp)return null!=s&&o(s,function(e){return e&&e.match(n)});if(O(n))return null!=s&&o(s,function(e){return e&&I(e,n)});var a=Object.keys(n);if("$"==a[0].charAt(0)){for(var c=0;c<a.length;c++){var l=a[c],u=n[l];if("$eq"==l){if(!o(s,function(e){return Se(e,u)}))return!1}else if("$gt"==l){if(!o(s,function(e){return Ce(e,u,">")}))return!1}else if("$gte"==l){if(!o(s,function(e){return Ce(e,u,">=")}))return!1}else if("$lt"==l){if(!o(s,function(e){return Ce(e,u,"<")}))return!1}else if("$lte"==l){if(!o(s,function(e){return Ce(e,u,"<=")}))return!1}else if("$ne"==l){if(!o(s,function(e){return!Se(e,u)}))return!1}else if("$in"==l){if(!o(s,function(e){return A(e,u)}))return!1}else if("$nin"==l){if(o(s,function(e){return A(e,u)}))return!1}else{if("$elemMatch"==l){var h=v(e,t);if(null==h||!O(h))return!1;for(var f=0;f<h.length;f++){var d=h[f];if("object"!=typeof d||O(d)){for(var p=!0,m=Object.keys(u),y=0;y<m.length;y++){var w=m[y],b=u[w];("$gte"!=w||d>=b)&&("$gt"!=w||d>b)&&("$lte"!=w||d<=b)&&("$lt"!=w||d<b)?("$eq"==w&&d!=b||"$ne"==w&&d==b)&&(p=!1):p=!1}if(p)return r[t]=f,!0}else if(We(d,u))return r[t]=f,!0}return!1}if(!qe(e,t,n))return!1}}return!0}return null!=s&&o(s,function(e){return S(e,n)})}return!1}(e,r,i,n);if("$and"==r)return He(e,i,n);if("$or"==r)return function(e,t,n){for(var r=0;r<t.length;r++)if(Qe(e,t[r],n))return!0;return!1}(e,i,n);if("$not"==r)return!ze(e,i);if("$nor"==r)return function(e,t,n){for(var r=0;r<t.length;r++)if(Qe(e,t[r],n))return!1;return!0}(e,i,n);if("$where"==r)return Re(e,i);if("$comment"==r)return!0;if("$jsonSchema"==r)return Ie(e,i);if("$expr"!=r)throw{$err:"Can't canonicalize query: BadValue unknown top level operator: "+r,code:17287};try{return we(i,e)}catch(s){return!1}}class Je{constructor(e,t){0===arguments.length?(this.low=0,this.high=Math.floor(Date.now()/1e3)):1===arguments.length?"object"==typeof e&&null!==e?(this.low=e.low||0,this.high=e.high||0):(this.low=0,this.high=e):(this.low=e>>>0,this.high=t>>>0)}valueOf(){return 4294967296*this.high+this.low}toString(){return`Timestamp(${this.high}, ${this.low})`}toJSON(){return{$timestamp:{t:this.high,i:this.low}}}inspect(){return this.toString()}equals(e){return!!e&&((e instanceof Je||"object"==typeof e&&void 0!==e.low&&void 0!==e.high)&&this.low===e.low&&this.high===e.high)}getHighBits(){return this.high}getLowBits(){return this.low}toDate(){return new Date(1e3*this.high)}static fromDate(e){const t=Math.floor(e.getTime()/1e3);return new Je(0,t)}static now(){return new Je}}function Ge(e){return e.split(".").map(e=>{const t=function(e){const t=e.match(/^\$\[([^\]]+)\]$/);return t?t[1]:null}(e);return{segment:e,isFilteredPositional:null!==t,identifier:t}})}function Ye(e,t,n,r,i){!function e(s,o,a){if(o>=t.length)return;const c=t[o],l=o===t.length-1;if(c.isFilteredPositional){const a=c.identifier,u=i?i.find(e=>Object.keys(e).some(e=>e.startsWith(a+".")||e===a)):null;if(!i){if(!s[c.segment]){const e=t[o+1];e&&e.isFilteredPositional?s[c.segment]=[]:s[c.segment]={}}return void(l?Xe(s,c.segment,n,r):e(s[c.segment],o+1))}if(!O(s))return s[c.segment]||(s[c.segment]={}),void(l?Xe(s,c.segment,n,r):e(s[c.segment],o+1));for(let t=0;t<s.length;t++){const i=s[t];let c=!0;if(u){let e={},t=!1;if(Object.keys(u).forEach(n=>{if(n.startsWith(a+".")){const t=n.substring(a.length+1);e[t]=u[n]}else n===a&&(e=u[n],t=!0)}),t){c=We({value:i},{value:e})}else c=We(i,e)}c&&(l?Xe(s,t,n,r):null!=i&&e(s[t],o+1))}}else{if((void 0===s[c.segment]||null===s[c.segment])&&!l){const e=t[o+1];e&&e.isFilteredPositional?s[c.segment]=[]:s[c.segment]={}}l?Xe(s,c.segment,n,r):void 0!==s[c.segment]&&null!==s[c.segment]&&e(s[c.segment],o+1)}}(e,0)}function Xe(e,t,n,r){switch(r){case"$set":default:e[t]=n;break;case"$inc":void 0===e[t]&&(e[t]=0),e[t]+=n;break;case"$mul":e[t]=e[t]*n;break;case"$min":e[t]=Math.min(e[t],n);break;case"$max":e[t]=Math.max(e[t],n);break;case"$unset":delete e[t]}}function Ze(e){return/\$\[[^\]]+\]/.test(e)}function et(e){return-1!==e.indexOf("$[]")}function tt(e,t,n){for(var r=t.split("."),i=e,s=0;s<r.length;s++){var o=r[s];if("$[]"===o){if(!Array.isArray(i))return;for(var a=r.slice(s+1).join("."),c=0;c<i.length;c++)if(a)if(-1!==a.indexOf("$[]"))tt(i[c],a,n);else{var l=n(v(i[c],a));N(i[c],a,l)}else i[c]=n(i[c]);return}if(null==i||null==i)return;i=i[o]}}function nt(e,t){if(!t||!e.includes("$"))return e;const n=e.split("."),r=n.indexOf("$");if(-1===r)return e;const i=n.slice(0,r).join(".");let s=null;for(const o in t)if(o===i||o.startsWith(i+".")){s=t[o];break}return null!=s?(n[r]=s.toString(),n.join(".")):e}function rt(e,t,n,r,i){for(var s=Object.keys(e),o=0;o<s.length;o++){var a=s[o],c=e[a];if("$inc"==a)for(var l=Object.keys(c),u=0;u<l.length;u++){var h=nt(l[u],r),f=c[l[u]];if(Ze(h)){Ye(t,Ge(h),f,"$inc",i)}else if(et(h))tt(t,h,function(e){return(void 0===e?0:e)+f});else{null==(d=v(t,h))&&(d=0),N(t,h,d+f)}}else if("$mul"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r),f=c[l[u]];if(Ze(h)){Ye(t,Ge(h),f,"$mul",i)}else if(et(h))tt(t,h,function(e){return e*f});else{null==(d=v(t,h))&&(d=0),N(t,h,d*f)}}else if("$rename"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);t[nt(c[l[u]],r)]=t[h],delete t[h]}else if("$setOnInsert"==a&&n)for(l=Object.keys(c),u=0;u<l.length;u++){t[h=nt(l[u],r)]=c[l[u]]}else if("$set"==a)for(l=Object.keys(c),u=0;u<l.length;u++){if(Ze(h=nt(l[u],r))){Ye(t,Ge(h),c[l[u]],"$set",i)}else N(t,h,c[l[u]])}else if("$unset"==a)for(l=Object.keys(c),u=0;u<l.length;u++){delete t[h=nt(l[u],r)]}else if("$min"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r),f=c[l[u]];if(Ze(h)){Ye(t,Ge(h),f,"$min",i)}else if(et(h))tt(t,h,function(e){return Math.min(e,f)});else{var d=v(t,h);N(t,h,Math.min(d,f))}}else if("$max"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r),f=c[l[u]];if(Ze(h)){Ye(t,Ge(h),f,"$max",i)}else if(et(h))tt(t,h,function(e){return Math.max(e,f)});else{d=v(t,h);N(t,h,Math.max(d,f))}}else if("$currentDate"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);var p=c[l[u]];!0===p||"object"==typeof p&&"date"===p.$type?N(t,h,new Date):"object"==typeof p&&"timestamp"===p.$type?N(t,h,new Je):N(t,h,new Date)}else if("$addToSet"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);var g=c[l[u]];(T=v(t,h))&&Array.isArray(T)&&T.push(g)}else if("$pop"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);var m=c[l[u]];(T=v(t,h))&&Array.isArray(T)&&(1==m?T.pop():-1==m&&T.shift())}else if("$pull"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);var y=c[l[u]];if(null!=($=v(t,h))&&Array.isArray($)){for(var w=[],b=0;b<$.length;b++){var x=$[b],_=!1;if("object"!=typeof y||null===y||Array.isArray(y))_=x==y;else if("object"!=typeof x||null===x||Array.isArray(x))_=qe({__temp:x},"__temp",y);else _=We(x,y);_||w.push(x)}N(t,h,w)}}else if("$pullAll"==a)for(l=Object.keys(c),u=0;u<l.length;u++){var $=v(t,h=nt(l[u],r)),O=c[l[u]];for(w=[],b=0;b<$.length;b++){for(var E=!1,A=0;A<O.length;A++)if($[b]==O[A]){E=!0;break}E||w.push($[b])}N(t,h,w)}else if("$pushAll"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);var I=c[l[u]];if((T=v(t,h))&&Array.isArray(T))for(b=0;b<I.length;b++)T.push(I[b])}else if("$push"==a)for(l=Object.keys(c),u=0;u<l.length;u++){h=nt(l[u],r);var S=c[l[u]];if(null!==S&&"object"==typeof S&&(void 0!==S.$each||void 0!==S.$position||void 0!==S.$slice||void 0!==S.$sort)){(T=v(t,h))||N(t,h,T=[]);var C=void 0!==S.$each?S.$each:[S],D=void 0!==S.$position?S.$position:T.length;if(D<0&&(D=Math.max(0,T.length+D)),T.splice(D,0,...C),void 0!==S.$sort){var M=S.$sort;"number"==typeof M?T.sort(function(e,t){return e<t?M>0?-1:1:e>t?M>0?1:-1:0}):"object"==typeof M&&T.sort(function(e,t){for(var n=Object.keys(M),r=0;r<n.length;r++){var i=n[r],s=M[i],o=v(e,i),a=v(t,i);if(o<a)return s>0?-1:1;if(o>a)return s>0?1:-1}return 0})}if(void 0!==S.$slice){var L=S.$slice;if(L<0)N(t,h,T.slice(L));else if(0===L)N(t,h,[]);else{N(t,h,T.slice(0,L))}}}else{var T;(T=v(t,h))&&Array.isArray(T)&&T.push(S)}}else{if("$bit"!=a)throw"unknown update operator: "+a;h=nt((l=Object.keys(c))[0],r);var j=c[l[0]],k=Object.keys(j)[0],P=j[k];d=v(t,h);if("and"==k)N(t,h,d&P);else if("or"==k)N(t,h,d|P);else{if("xor"!=k)throw"unknown $bit operator: "+k;N(t,h,d^P)}}}}function it(e,t,n){for(var r={_id:n()},i=!0,s=Object.keys(t),o=0;o<s.length;o++)if("$"==s[o].charAt(0)){i=!1;break}if(i)for(o=0;o<s.length;o++)r[s[o]]=t[s[o]];else{var a=Object.keys(e);for(o=0;o<a.length;o++)r[a[o]]=e[a[o]];rt(t,r,!0)}return r}class st{constructor(e,t,n,r={}){this.name=e,this.keys=t,this.storage=n,this.options=r}add(e){throw new Error("add() must be implemented by subclass")}remove(e){throw new Error("remove() must be implemented by subclass")}update(e,t){this.remove(e),this.add(t)}query(e){throw new Error("query() must be implemented by subclass")}clear(){throw new Error("clear() must be implemented by subclass")}getSpec(){return{name:this.name,key:this.keys}}serialize(){throw new Error("serialize() must be implemented by subclass")}deserialize(e){throw new Error("deserialize() must be implemented by subclass")}}class ot extends st{constructor(e,t,n,r={}){super(e,t,n,r),this.data=new pe(n,50),this.isOpen=!1}async open(){if(!this.isOpen)try{await this.data.open(),this.isOpen=!0}catch(e){if(!e.message||!(e.message.includes("Unknown type byte")||e.message.includes("Failed to read metadata")||e.message.includes("Invalid tree file")))throw e;if("undefined"!=typeof navigator&&navigator.storage){const e=await navigator.storage.getDirectory();try{await e.removeEntry(this.storage)}catch(t){}}this.data=new pe(this.storage,50),await this.data.open(),this.isOpen=!0}}async close(){if(this.isOpen){try{await this.data.close()}catch(e){if(!e.message||!e.message.includes("File is not open"))throw e}this.isOpen=!1}}extractIndexKey(e){const t=Object.keys(this.keys);if(0===t.length)return null;if(1===t.length){const n=v(e,t[0]);return void 0===n?null:n}const n=[];for(let r=0;r<t.length;r++){const i=v(e,t[r]);if(void 0===i)return null;n.push(i)}return n.join("\0")}async add(e){this.isOpen||await this.open();const t=this.extractIndexKey(e);if(null!==t){const n=e._id.toString(),r=await this.data.search(t);let i;if(Array.isArray(r)){if(r.includes(n))return;i=[...r,n]}else i=r?r===n?[r]:[r,n]:[n];await this.data.add(t,i)}}async remove(e){this.isOpen||await this.open();const t=this.extractIndexKey(e);if(null!==t){const n=e._id.toString(),r=await this.data.search(t);if(Array.isArray(r)){const e=r.filter(e=>e!==n);e.length>0?await this.data.add(t,e):await this.data.delete(t)}else r===n&&await this.data.delete(t)}}async query(e){const t=Object.keys(e),n=Object.keys(this.keys);if(1!==n.length)return null;const r=n[0];if(-1===t.indexOf(r))return null;const i=e[r];if("object"!=typeof i||null===i){const e=i;return await this.data.search(e)||[]}return"object"!=typeof i||Array.isArray(i)?null:await this._queryWithOperators(r,i)}async _queryWithOperators(e,t){const n=Object.keys(t),r=new Set;if(n.some(e=>["$gt","$gte","$lt","$lte"].includes(e))){const e=n.includes("$gt")||n.includes("$gte"),i=n.includes("$lt")||n.includes("$lte");if(e&&i){const e=n.includes("$gte")?t.$gte:n.includes("$gt")?t.$gt:-1/0,i=n.includes("$lte")?t.$lte:n.includes("$lt")?t.$lt:1/0,s=await this.data.rangeSearch(e,i);for(const o of s){const e=o.key,i=o.value;let s=!0;!n.includes("$gt")||e>t.$gt||(s=!1),!n.includes("$gte")||e>=t.$gte||(s=!1),!n.includes("$lt")||e<t.$lt||(s=!1),!n.includes("$lte")||e<=t.$lte||(s=!1),s&&i&&(Array.isArray(i)?i.forEach(e=>r.add(e)):r.add(i))}return Array.from(r)}{const e=await this.data.toArray();for(const i of e){const e=i.key,s=i.value;let o=!0;for(const r of n){const n=t[r];("$gt"!==r||e>n)&&("$gte"!==r||e>=n)&&("$lt"!==r||e<n)&&("$lte"!==r||e<=n)?("$eq"===r&&e!==n||"$ne"===r&&e===n)&&(o=!1):o=!1}o&&s&&(Array.isArray(s)?s.forEach(e=>r.add(e)):r.add(s))}return Array.from(r)}}if(n.includes("$in")){const e=t.$in;if(Array.isArray(e)){for(const t of e){const e=await this.data.search(t);e&&(Array.isArray(e)?e.forEach(e=>r.add(e)):r.add(e))}return Array.from(r)}}if(n.includes("$eq")){const e=t.$eq,n=await this.data.search(e);return n?Array.isArray(n)?n:[n]:[]}if(n.includes("$ne")){const e=t.$ne,n=await this.data.toArray();for(const t of n)t.key!==e&&t.value&&(Array.isArray(t.value)?t.value.forEach(e=>r.add(e)):r.add(t.value));return Array.from(r)}return null}async clear(){this.isOpen&&await this.close(),this.data=new pe(this.data.filename,50),await this.open()}}class at extends st{constructor(e,t,n,r={}){super(e,t,n),this.textIndex=new ye({baseFilename:n}),this.isOpen=!1,this.indexedFields=[];for(const i in t)"text"===t[i]&&this.indexedFields.push(i);if(0===this.indexedFields.length)throw new Error('Text index must have at least one field with type "text"')}async open(){this.isOpen||(await this.textIndex.open(),this.isOpen=!0)}async close(){if(this.isOpen){try{await this.textIndex.close()}catch(e){if(!e.message||!e.message.includes("File is not open"))throw e}this.isOpen=!1}}_extractText(e){const t=[];for(const n of this.indexedFields){const r=v(e,n);null!=r&&t.push(String(r))}return t.join(" ")}async add(e){if(!e._id)throw new Error("Document must have an _id field");const t=this._extractText(e);t&&await this.textIndex.add(String(e._id),t)}async remove(e){e._id&&await this.textIndex.remove(String(e._id))}query(e){return null}async search(e,t={}){return await this.textIndex.query(e,{scored:!1,...t})}async clear(){this.isOpen&&await this.close(),this.textIndex=new ye({baseFilename:this.storage}),await this.open()}getSpec(){return{name:this.name,key:this.keys,textIndexVersion:3,weights:this._getWeights()}}_getWeights(){const e={};for(const t of this.indexedFields)e[t]=1;return e}}function ct(e,t,n,r){const i=(n-e)*Math.PI/180,s=(r-t)*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}function lt(e,t){return!(e.maxLat<t.minLat||e.minLat>t.maxLat||e.maxLng<t.minLng||e.minLng>t.maxLng)}function ut(e){return(e.maxLat-e.minLat)*(e.maxLng-e.minLng)}function ht(e,t){return{minLat:Math.min(e.minLat,t.minLat),maxLat:Math.max(e.maxLat,t.maxLat),minLng:Math.min(e.minLng,t.minLng),maxLng:Math.max(e.maxLng,t.maxLng)}}function ft(e,t){return ut(ht(e,t))-ut(e)}class dt{constructor(e,t){this.rtree=e,this.id=t.id,this.isLeaf=t.isLeaf,this.children=t.children||[],this.bbox=t.bbox}async updateBBox(){if(0===this.children.length)return void(this.bbox=null);let e=1/0,t=-1/0,n=1/0,r=-1/0;for(const i of this.children){let s;if(this.isLeaf)s=i.bbox;else{s=(await this.rtree._loadNode(i)).bbox}s&&(e=Math.min(e,s.minLat),t=Math.max(t,s.maxLat),n=Math.min(n,s.minLng),r=Math.max(r,s.maxLng))}this.bbox={minLat:e,maxLat:t,minLng:n,maxLng:r},await this.rtree._saveNode(this)}toJSON(){return{id:this.id,isLeaf:this.isLeaf,children:this.children,bbox:this.bbox}}}class pt{constructor(e,t=9){this.filename=e,this.maxEntries=t,this.minEntries=Math.max(2,Math.ceil(t/2)),this.rootPointer=null,this.nextId=1,this._size=0,this.file=new b(e),this.isOpen=!1}async open(){if(this.isOpen)throw new Error("R-tree file is already open");await this.file.exists()?(await this.file.open("rw"),await this._loadFromFile()):(await this.file.open("rw"),await this._initializeNewTree()),this.isOpen=!0}async close(){this.isOpen&&(await this._writeMetadata(),await this.file.close(),this.isOpen=!1)}async _initializeNewTree(){const e=new dt(this,{id:0,isLeaf:!0,children:[],bbox:null});this.nextId=1,this._size=0,this.rootPointer=await this._saveNode(e),await this._writeMetadata()}async _writeMetadata(){const e={version:1,maxEntries:this.maxEntries,minEntries:this.minEntries,size:this._size,rootPointer:this.rootPointer,nextId:this.nextId};await this.file.append(e)}async _loadFromFile(){const e=await this.file.getFileSize();if(e<135)throw new Error("Invalid R-tree file format: file too small for metadata");const t=e-135,n=await this.file.read(t);this.maxEntries=n.maxEntries,this.minEntries=n.minEntries,this._size=n.size,this.rootPointer=n.rootPointer,this.nextId=n.nextId}async _saveNode(e){const t=e.toJSON(),n=await this.file.getFileSize();return await this.file.append(t),new m(n)}async _loadNode(e){if(!(e instanceof m))throw new Error("Expected Pointer object");const t=e.valueOf(),n=await this.file.read(t);return new dt(this,n)}async _loadRoot(){return await this._loadNode(this.rootPointer)}async insert(e,t,n){if(!this.isOpen)throw new Error("R-tree file must be opened before use");const r={bbox:{minLat:e,maxLat:e,minLng:t,maxLng:t},lat:e,lng:t,objectId:n},i=await this._loadRoot(),s=await this._insert(r,i,1);if(s.split){const e=new dt(this,{id:this.nextId++,isLeaf:!1,children:s.pointers,bbox:null});await e.updateBBox(),this.rootPointer=await this._saveNode(e)}else this.rootPointer=s.pointer;this._size++,await this._writeMetadata()}async _insert(e,t,n){if(t.isLeaf){if(t.children.push(e),await t.updateBBox(),t.children.length>this.maxEntries){const[e,n]=await this._split(t);return{split:!0,pointers:[e,n]}}return{split:!1,pointer:await this._saveNode(t)}}{const r=await this._chooseSubtree(e.bbox,t),i=await this._loadNode(r),s=await this._insert(e,i,n+1);if(s.split){let e=-1;for(let n=0;n<t.children.length;n++)if(t.children[n].valueOf()===r.valueOf()){e=n;break}if(-1!==e?(t.children[e]=s.pointers[0],t.children.push(s.pointers[1])):(t.children.push(s.pointers[0]),t.children.push(s.pointers[1])),await t.updateBBox(),t.children.length>this.maxEntries){const[e,n]=await this._split(t);return{split:!0,pointers:[e,n]}}}else{let e=-1;for(let n=0;n<t.children.length;n++)if(t.children[n].valueOf()===r.valueOf()){e=n;break}-1!==e&&(t.children[e]=s.pointer),await t.updateBBox()}return{split:!1,pointer:await this._saveNode(t)}}}async _chooseSubtree(e,t){let n=1/0,r=1/0,i=null;for(const s of t.children){if(!(s instanceof m))throw new Error("Expected Pointer in _chooseSubtree, got: "+typeof s);const t=await this._loadNode(s),o=ft(t.bbox,e),a=ut(t.bbox);(o<n||o===n&&a<r)&&(n=o,r=a,i=s)}return i}async _split(e){const t=e.children,n=e.isLeaf;let r=-1/0,i=0,s=1;for(let c=0;c<t.length;c++)for(let e=c+1;e<t.length;e++){let o,a;if(n)o=t[c].bbox,a=t[e].bbox;else{const n=await this._loadNode(t[c]),r=await this._loadNode(t[e]);o=n.bbox,a=r.bbox}const l=ut(ht(o,a));l>r&&(r=l,i=c,s=e)}const o=new dt(this,{id:this.nextId++,isLeaf:n,children:[t[i]],bbox:null}),a=new dt(this,{id:this.nextId++,isLeaf:n,children:[t[s]],bbox:null});for(let c=0;c<t.length;c++){if(c===i||c===s)continue;const e=t[c];let r;if(n)r=e.bbox;else{r=(await this._loadNode(e)).bbox}await o.updateBBox(),await a.updateBBox();const l=o.bbox?ft(o.bbox,r):0,u=a.bbox?ft(a.bbox,r):0;l<u?o.children.push(e):u<l?a.children.push(e):o.children.length<=a.children.length?o.children.push(e):a.children.push(e)}await o.updateBBox(),await a.updateBBox();return[await this._saveNode(o),await this._saveNode(a)]}async searchBBox(e){if(!this.isOpen)throw new Error("R-tree file must be opened before use");const t=[],n=await this._loadRoot();return await this._searchBBox(e,n,t),t}async _searchBBox(e,t,n){if(t.bbox&&lt(e,t.bbox))if(t.isLeaf)for(const r of t.children)lt(e,r.bbox)&&n.push({objectId:r.objectId,lat:r.lat,lng:r.lng});else for(const r of t.children){const t=await this._loadNode(r);await this._searchBBox(e,t,n)}}async searchRadius(e,t,n){const r=function(e,t,n){const r=n/111,i=n/(111*Math.cos(e*Math.PI/180));return{minLat:e-r,maxLat:e+r,minLng:t-i,maxLng:t+i}}(e,t,n),i=await this._loadRoot(),s=[];await this._searchBBoxEntries(r,i,s);const o=[];for(const a of s){const r=ct(e,t,a.lat,a.lng);r<=n&&o.push({objectId:a.objectId,lat:a.lat,lng:a.lng,distance:r})}return o}async _searchBBoxEntries(e,t,n){if(t.bbox&&lt(e,t.bbox))if(t.isLeaf)for(const r of t.children)lt(e,r.bbox)&&n.push(r);else for(const r of t.children){const t=await this._loadNode(r);await this._searchBBoxEntries(e,t,n)}}async remove(e){if(!this.isOpen)throw new Error("R-tree file must be opened before use");const t=await this._loadRoot(),n=await this._remove(e,t);if(!n.found)return!1;if(n.underflow&&n.children)if(0===n.children.length){const e=new dt(this,{id:this.nextId++,isLeaf:!0,children:[],bbox:null});this.rootPointer=await this._saveNode(e)}else if(1!==n.children.length||n.isLeaf){const e=new dt(this,{id:t.id,isLeaf:n.isLeaf,children:n.children,bbox:null});await e.updateBBox(),this.rootPointer=await this._saveNode(e)}else this.rootPointer=n.children[0];else n.pointer&&(this.rootPointer=n.pointer);return this._size--,await this._writeMetadata(),!0}async _remove(e,t){if(t.isLeaf){const n=t.children.length;if(t.children=t.children.filter(t=>!t.objectId.equals(e)),t.children.length===n)return{found:!1};await t.updateBBox();const r=await this._saveNode(t);return{found:!0,underflow:t.children.length<this.minEntries&&t.children.length>0,pointer:r,children:t.children,isLeaf:!0}}{let n=[...t.children];for(let r=0;r<n.length;r++){const i=n[r],s=await this._loadNode(i),o=await this._remove(e,s);if(o.found){if(o.underflow){const e=await this._handleUnderflow(t,r,s,o);e.merged?n=e.children:n[r]=o.pointer}else n[r]=o.pointer;const e=new dt(this,{id:t.id,isLeaf:!1,children:n,bbox:null});await e.updateBBox();const i=await this._saveNode(e);return{found:!0,underflow:n.length<this.minEntries&&n.length>0,pointer:i,children:n,isLeaf:!1}}}return{found:!1}}}async _handleUnderflow(e,t,n,r){const i=[];if(t>0){const n=e.children[t-1],r=await this._loadNode(n);i.push({index:t-1,node:r,pointer:n})}if(t<e.children.length-1){const n=e.children[t+1],r=await this._loadNode(n);i.push({index:t+1,node:r,pointer:n})}for(const s of i)if(s.node.children.length>this.minEntries){const i=[...r.children,...s.node.children],o=Math.ceil(i.length/2),a=i.slice(0,o),c=i.slice(o),l=new dt(this,{id:n.id,isLeaf:r.isLeaf,children:a,bbox:null});await l.updateBBox();const u=new dt(this,{id:s.node.id,isLeaf:s.node.isLeaf,children:c,bbox:null});await u.updateBBox();const h=await this._saveNode(l),f=await this._saveNode(u),d=[...e.children],p=Math.min(t,s.index),g=Math.max(t,s.index);return d[p]=h,d[g]=f,{merged:!0,children:d}}if(i.length>0){const n=i[0],s=[...r.children,...n.node.children],o=new dt(this,{id:this.nextId++,isLeaf:r.isLeaf,children:s,bbox:null});await o.updateBBox();const a=await this._saveNode(o),c=e.children.filter((e,r)=>r!==t&&r!==n.index);return c.push(a),{merged:!0,children:c}}return{merged:!1}}size(){return this._size}async clear(){await this.close();const e=new b(this.filename);await e.open("rw"),await e.delete(),this.file=new b(this.filename),await this.open()}async compact(e){if(!this.isOpen)throw new Error("R-tree file must be opened before use");if(!e)throw new Error("Destination filename is required for compaction");await this._writeMetadata();const t=await this.file.getFileSize(),n=new pt(e,this.maxEntries);n.minEntries=this.minEntries,n.nextId=this.nextId,n._size=this._size,await n.file.open("rw"),n.isOpen=!0;const r=new Map,i=async e=>{const t=e.valueOf();if(r.has(t))return r.get(t);const s=await this._loadNode(e),o=[];if(s.isLeaf)for(const n of s.children)o.push(n);else for(const n of s.children){const e=await i(n);o.push(e)}const a=new dt(n,{id:s.id,isLeaf:s.isLeaf,children:o,bbox:s.bbox}),c=await n._saveNode(a);return r.set(t,c),c},s=await i(this.rootPointer);n.rootPointer=s,await n._writeMetadata(),await n.file.close(),n.isOpen=!1;const o=new b(e);await o.open("r");const a=await o.getFileSize();return await o.close(),{oldSize:t,newSize:a,bytesSaved:Math.max(0,t-a),newFilename:e}}}class gt extends st{constructor(e,t,n,r={}){super(e,t,n,r),this.rtree=new pt(n,9),this.isOpen=!1,this._idMap=new Map,this._objectIdMap=new Map,this.geoField=null;for(const i in t)if("2dsphere"===t[i]||"2d"===t[i]){this.geoField=i;break}if(!this.geoField)throw new Error('Geospatial index must have at least one field with type "2dsphere" or "2d"')}_normalizeObjectId(e){if(e instanceof g)return this._objectIdMap.set(e.toString(),e.toString()),e;const t=String(e);if(this._idMap.has(t))return this._idMap.get(t);let n;try{"string"==typeof e&&g.isValid(e)&&(n=new g(e))}catch(r){}return n||(n=this._createDeterministicObjectId(t)),this._idMap.set(t,n),this._objectIdMap.set(n.toString(),t),n}_toDocId(e){if(e instanceof g){const t=this._objectIdMap.get(e.toString());return void 0!==t?t:e.toString()}return e&&"object"==typeof e&&"objectId"in e?this._toDocId(e.objectId):String(e)}_createDeterministicObjectId(e){let t=2166136261;for(let i=0;i<e.length;i++)t^=e.charCodeAt(i),t=Math.imul(t,16777619);const n=(t>>>0).toString(16).padStart(8,"0"),r=(n+n+n).slice(0,24);return new g(r)}async open(){this.isOpen||(await this.rtree.open(),this.isOpen=!0)}async close(){if(this.isOpen){try{await this.rtree.close()}catch(e){if(!e.message||!e.message.includes("File is not open"))throw e}this.isOpen=!1}}_extractCoordinates(e){if(!e)return null;if("FeatureCollection"===e.type&&e.features&&e.features.length>0){const t=e.features[0];if(t.geometry)return this._extractCoordinates(t.geometry)}if("Feature"===e.type&&e.geometry)return this._extractCoordinates(e.geometry);if("Point"===e.type&&e.coordinates){const[t,n]=e.coordinates;if("number"==typeof t&&"number"==typeof n)return{lat:n,lng:t}}if("Polygon"===e.type&&e.coordinates&&e.coordinates.length>0){const t=e.coordinates[0];if(t.length>0){let e=0,n=0;for(const r of t)n+=r[0],e+=r[1];return{lat:e/t.length,lng:n/t.length}}}return null}async add(e){if(!e._id)throw new Error("Document must have an _id field");const t=v(e,this.geoField),n=this._extractCoordinates(t);if(n){const t=this._normalizeObjectId(e._id);await this.rtree.insert(n.lat,n.lng,t)}}async remove(e){if(!e._id)return;const t=this._normalizeObjectId(e._id);await this.rtree.remove(t)}async query(e){if(!e[this.geoField])return null;const t=e[this.geoField];if(t.$geoWithin){const e=t.$geoWithin;if(Array.isArray(e)&&2===e.length){const t=e[0][0],n=e[0][1],r=e[1][0],i=e[1][1];return(await this.rtree.searchBBox({minLat:i,maxLat:n,minLng:t,maxLng:r})).map(e=>this._toDocId(e.objectId))}}if(t.$near){const e=t.$near;let n;if(e.$geometry)n=e.$geometry.coordinates;else if(e.coordinates)n=e.coordinates;else{if(!Array.isArray(e))return null;n=e}if(!n||n.length<2)return null;const[r,i]=n,s=(e.$maxDistance||1e6)/1e3,o=await this.rtree.searchRadius(i,r,s);return o.sort((e,t)=>e.distance-t.distance),o.map(e=>this._toDocId(e.objectId))}if(t.$nearSphere){const e=t.$nearSphere;let n;if(e.$geometry)n=e.$geometry.coordinates;else if(e.coordinates)n=e.coordinates;else{if(!Array.isArray(e))return null;n=e}if(!n||n.length<2)return null;const[r,i]=n,s=(e.$maxDistance||1e6)/1e3,o=await this.rtree.searchRadius(i,r,s);return o.sort((e,t)=>e.distance-t.distance),o.map(e=>this._toDocId(e.objectId))}if(t.$geoIntersects){const e=t.$geoIntersects;let n;if(!e.$geometry)return null;if(n=e.$geometry,!n||!n.type)return null;if("Point"===n.type){const[e,t]=n.coordinates,r=1e-4;return(await this.rtree.searchBBox({minLat:t-r,maxLat:t+r,minLng:e-r,maxLng:e+r})).map(e=>this._toDocId(e.objectId))}if("Polygon"===n.type){const e=n.coordinates;if(!e||0===e.length)return null;const t=e[0];if(!t||t.length<3)return null;let r=1/0,i=-1/0,s=1/0,o=-1/0;for(const n of t){const[e,t]=n;r=Math.min(r,t),i=Math.max(i,t),s=Math.min(s,e),o=Math.max(o,e)}return(await this.rtree.searchBBox({minLat:r,maxLat:i,minLng:s,maxLng:o})).filter(e=>this._pointInPolygon(e.lat,e.lng,t)).map(e=>this._toDocId(e.objectId))}return null}return null}_haversineDistance(e,t,n,r){const i=(n-e)*Math.PI/180,s=(r-t)*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}_pointInPolygon(e,t,n){let r=!1;for(let i=0,s=n.length-1;i<n.length;s=i++){const[o,a]=n[i],[c,l]=n[s];a>e!=l>e&&t<(c-o)*(e-a)/(l-a)+o&&(r=!r)}return r}async clear(){this.isOpen||(await this.rtree.open(),this.isOpen=!0);try{await this.rtree.file.delete()}catch(e){if(!e||"NotFoundError"!==e.name)throw e}this.isOpen=!1,this.rtree=new pt(this.rtree.filename,9),await this.open()}getSpec(){return{name:this.name,key:this.keys,"2dsphereIndexVersion":3}}}class mt{constructor(){this.type="full_scan",this.indexes=[],this.indexScans=[],this.estimatedCost=1/0,this.indexOnly=!1}}class yt{constructor(e){this.indexes=e}plan(e){const t=new mt;if(!e||0===Object.keys(e).length)return t;const n=this._analyzeQuery(e);if(n.hasTextSearch){const t=this._planTextSearch(e,n);if(t)return t}if(n.hasGeoQuery){const t=this._planGeoQuery(e,n);if(t)return t}if("and"===n.type){const t=this._planAndQuery(e,n);if("full_scan"!==t.type)return t}if("or"===n.type){const t=this._planOrQuery(e,n);if("full_scan"!==t.type)return t}const r=this._planSimpleQuery(e);return"full_scan"!==r.type?r:t}_analyzeQuery(e){const t={type:"simple",fields:[],operators:{},hasTextSearch:!1,hasGeoQuery:!1,conditions:[]},n=Object.keys(e);if(1===n.length){const r=n[0];if("$and"===r){t.type="and",t.conditions=e.$and;for(const e of t.conditions){const n=this._analyzeQuery(e);t.fields.push(...n.fields),n.hasTextSearch&&(t.hasTextSearch=!0),n.hasGeoQuery&&(t.hasGeoQuery=!0)}return t}if("$or"===r){t.type="or",t.conditions=e.$or;for(const e of t.conditions){const n=this._analyzeQuery(e);t.fields.push(...n.fields),n.hasTextSearch&&(t.hasTextSearch=!0),n.hasGeoQuery&&(t.hasGeoQuery=!0)}return t}}for(const r of n){if(r.startsWith("$"))continue;t.fields.push(r);const n=e[r];if("object"==typeof n&&null!==n&&!Array.isArray(n)){const e=Object.keys(n);t.operators[r]=e,e.includes("$text")&&(t.hasTextSearch=!0),e.some(e=>["$geoWithin","$geoIntersects","$near","$nearSphere"].includes(e))&&(t.hasGeoQuery=!0)}}return n.length>1&&(t.type="and"),t}_planTextSearch(e,t){for(const[n,r]of this.indexes)if(r instanceof at){const t=this._extractTextQuery(e);if(t){const e=new mt;return e.type="index_scan",e.indexes=[n],e.indexScans=[{indexName:n,index:r,textQuery:t}],e.estimatedCost=100,e.indexOnly=!0,e}}return null}_extractTextQuery(e){for(const t in e){const n=e[t];if("object"==typeof n&&null!==n&&n.$text)return"string"==typeof n.$text?n.$text:n.$text.$search}return null}_planGeoQuery(e,t){for(const[n,r]of this.indexes)if(r instanceof gt){const t=new mt;return t.type="index_scan",t.indexes=[n],t.indexScans=[{indexName:n,index:r,query:e}],t.estimatedCost=100,t.indexOnly=!0,t}return null}_planAndQuery(e,t){const n=new mt;let r;r=e.$and?e.$and:Object.keys(e).map(t=>({[t]:e[t]}));const i=[];for(const s of r){const e=this._planSimpleQuery(s);"index_scan"===e.type&&i.push(e.indexScans[0])}return i.length>1?(n.type="index_intersection",n.indexScans=i,n.indexes=i.map(e=>e.indexName),n.estimatedCost=50,n):1===i.length?(n.type="index_scan",n.indexScans=[i[0]],n.indexes=[i[0].indexName],n.estimatedCost=50,n):n}_planOrQuery(e,t){const n=new mt;if(!e.$or)return n;const r=e.$or,i=[];for(const s of r){const e=this._planSimpleQuery(s);"index_scan"===e.type&&i.push(e.indexScans[0])}return i.length>0?(n.type="index_union",n.indexScans=i,n.indexes=i.map(e=>e.indexName),n.estimatedCost=100*i.length,n):n}_planSimpleQuery(e){const t=new mt;if(0===Object.keys(e).length)return t;for(const[n,r]of this.indexes)if(!(r instanceof at||r instanceof gt)&&this._canIndexHandleQuery(r,e))return t.type="index_scan",t.indexes=[n],t.indexScans=[{indexName:n,index:r,query:e}],t.estimatedCost=50,t;return t}async _executeIndexScan(e){const{index:t,query:n,textQuery:r}=e;if(void 0!==r)return await t.search(r);if(void 0!==n){const e=await t.query(n);return null!==e?e:[]}return void 0!==e.docIds?e.docIds:[]}_canIndexHandleQuery(e,t){const n=Object.keys(t),r=Object.keys(e.keys);if(1!==r.length)return!1;const i=r[0];return-1!==n.indexOf(i)}async execute(e){if("full_scan"===e.type)return null;if("index_scan"===e.type){const t=e.indexScans[0];return await this._executeIndexScan(t)}if("index_intersection"===e.type){if(0===e.indexScans.length)return null;const t=[];for(const i of e.indexScans)t.push({docIds:await this._executeIndexScan(i),indexName:i.indexName});const n=t.slice().sort((e,t)=>e.docIds.length-t.docIds.length);let r=new Set(n[0].docIds);for(let e=1;e<n.length;e++){const t=new Set(n[e].docIds);if(r=new Set([...r].filter(e=>t.has(e))),0===r.size)break}return Array.from(r)}if("index_union"===e.type){const t=new Set;for(const n of e.indexScans){(await this._executeIndexScan(n)).forEach(e=>t.add(e))}return Array.from(t)}return null}}class wt extends r.EventEmitter{constructor(e,t=[],n={}){super(),this.target=e,this.pipeline=t,this.options=n,this.closed=!1,this._listeners=new Map,this._changeCounter=0,this._startWatching()}_startWatching(){if(this.closed)return;const e=this._getCollectionsToWatch();for(const t of e)this._watchCollection(t);"DB"===this.target.constructor.name&&this._interceptDBCollectionCreation(),"MongoClient"===this.target.constructor.name&&this._interceptClientDBCreation()}_getCollectionsToWatch(){const e=[];if("MongoClient"===this.target.constructor.name)return this._monitorClient(),e;if("DB"===this.target.constructor.name){const t=this.target.getCollectionNames();for(const n of t){const t=this.target[n];t&&t.isCollection&&e.push(t)}this._monitorDB()}return this.target.isCollection&&e.push(this.target),e}_watchCollection(e){if(this.closed)return;if(!e)return;if("function"!=typeof e.on)return;if(!e.isCollection)return;if(this._listeners.has(e))return;const t={insert:t=>this._emitChange("insert",e,t),update:(t,n)=>this._emitChange("update",e,t,n),replace:t=>this._emitChange("replace",e,t),delete:t=>this._emitChange("delete",e,t)};this._listeners.set(e,t),e.on("insert",t.insert),e.on("update",t.update),e.on("replace",t.replace),e.on("delete",t.delete)}_emitChange(e,t,n,r=null){if(this.closed)return;const i=this._createChangeEvent(e,t,n,r);this._matchesPipeline(i)&&this.emit("change",i)}_createChangeEvent(e,t,n,r){const i={_id:{_data:Buffer.from(String(++this._changeCounter)).toString("base64")},operationType:e,clusterTime:new Date,ns:{db:t.db.dbName,coll:t.name},documentKey:{_id:n._id}};switch(e){case"insert":case"replace":i.fullDocument=n;break;case"update":i.updateDescription=r||{updatedFields:{},removedFields:[],truncatedArrays:[]},"updateLookup"===this.options.fullDocument&&(i.fullDocument=n)}return i}_matchesPipeline(e){if(!this.pipeline||0===this.pipeline.length)return!0;for(const t of this.pipeline)if(t.$match&&!We(e,t.$match))return!1;return!0}_getNestedValue(e,t){return t.split(".").reduce((e,t)=>e?.[t],e)}_monitorClient(){}_interceptClientDBCreation(){const e=this.target,t=e.db.bind(e),n=this;this._watchedDBs=new Map,e.db=function(e,r){const i=t(e,r),s=i.dbName;if(!n._watchedDBs.has(s)){n._watchedDBs.set(s,i);const e=i.getCollectionNames();for(const t of e){const e=i[t];e&&e.isCollection&&!n._listeners.has(e)&&n._watchCollection(e)}n._interceptDBCollectionCreationForClient(i)}return i},this._originalClientMethods={db:t}}_interceptDBCollectionCreationForClient(e){const t=e.collection.bind(e),n=e.createCollection.bind(e),r=this;e.collection=function(e){const n=t(e);return n&&n.isCollection&&!r._listeners.has(n)&&r._watchCollection(n),n},e.createCollection=function(t){n(t);const i=e[t];i&&i.isCollection&&!r._listeners.has(i)&&r._watchCollection(i)}}_monitorDB(){}_interceptDBCollectionCreation(){const e=this.target,t=e.collection.bind(e),n=e.createCollection.bind(e),r=this;e.collection=function(e){const n=t(e);return n&&n.isCollection&&!r._listeners.has(n)&&r._watchCollection(n),n},e.createCollection=function(t){n(t);const i=e[t];i&&i.isCollection&&!r._listeners.has(i)&&r._watchCollection(i)},this._originalDBMethods={collection:t,createCollection:n}}close(){if(!this.closed){this.closed=!0;for(const[e,t]of this._listeners)e.off("insert",t.insert),e.off("update",t.update),e.off("replace",t.replace),e.off("delete",t.delete);this._listeners.clear(),this._originalDBMethods&&"DB"===this.target.constructor.name&&(this.target.collection=this._originalDBMethods.collection,this.target.createCollection=this._originalDBMethods.createCollection),this._originalClientMethods&&"MongoClient"===this.target.constructor.name&&(this.target.db=this._originalClientMethods.db),this.emit("close"),this.removeAllListeners()}}get isClosed(){return this.closed}async*[Symbol.asyncIterator](){const e=[];let t=null,n=!1;const r=n=>{t?(t({value:n,done:!1}),t=null):e.push(n)},i=()=>{n=!0,t&&(t({done:!0}),t=null)},s=e=>{t&&(t(Promise.reject(e)),t=null)};this.on("change",r),this.on("close",i),this.on("error",s);try{for(;!n;)if(e.length>0)yield e.shift();else{const e=await new Promise(e=>{t=e,n&&e({done:!0})});if(e.done)break;yield e.value}}finally{this.off("change",r),this.off("close",i),this.off("error",s)}}async next(){return new Promise((e,t)=>{const n=t=>{s(),e(t)},r=()=>{s(),e(null)},i=e=>{s(),t(e)},s=()=>{this.off("change",n),this.off("close",r),this.off("error",i)};this.closed?e(null):(this.once("change",n),this.once("close",r),this.once("error",i))})}}class bt extends r.EventEmitter{constructor(e,t,n,r){super(),this.db=e,this.name=t,this.storage=n,this.idGenerator=r,this.indexes=new Map,this.queryPlanner=new yt(this.indexes),this.isCollection=!0,this._restoreIndexesFromStorage()}_restoreIndexesFromStorage(){if(this.storage&&this.storage.indexes&&"function"==typeof this.storage.indexes[Symbol.iterator])for(const[e,t]of this.storage.indexes){const n=t&&"function"==typeof t.getAllMeta?t.getAllMeta():null;if(!(n&&n.type&&n.baseFilename&&n.keys))continue;const r=n.name||e;let i;if("text"===n.type)i=new at(r,n.keys,n.baseFilename,n.options||{});else if("geospatial"===n.type){const e=n.storage||`${n.baseFilename}-geo.bjson`;i=new gt(r,n.keys,e,n.options||{})}else{const e=n.storage||`${n.baseFilename}.bjson`;i=new ot(r,n.keys,e,n.options||{})}this.indexes.set(r,i)}}async _ensureIndexOpen(e){e&&"function"==typeof e.open&&!e.isOpen&&await e.open()}async close(){for(const[e,t]of this.indexes)t&&"function"==typeof t.close&&await t.close()}generateIndexName(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&t.push(n+"_"+e[n]);return t.join("_")}isTextIndex(e){for(const t in e)if("text"===e[t])return!0;return!1}isGeospatialIndex(e){for(const t in e)if("2dsphere"===e[t]||"2d"===e[t])return!0;return!1}_getIndexBaseFilename(e){const t=e=>String(e).replace(/[^a-zA-Z0-9_-]/g,"_");return`${t(this.db.dbName||this.db.name||"db")}-${t(this.name)}-${t(e)}`}async buildIndex(e,t,n={}){let r;const i=this._getIndexBaseFilename(e);let s,o;this.isTextIndex(t)?(o="text",s=i,r=new at(e,t,s,n)):this.isGeospatialIndex(t)?(o="geospatial",s=`${i}-geo.bjson`,r=new gt(e,t,s,n)):(o="regular",s=`${i}.bjson`,r=new ot(e,t,s,n)),this.storage&&"function"==typeof this.storage.createIndexStore&&this.storage.createIndexStore(e,{name:e,keys:t,type:o,baseFilename:i,storage:s,options:n}),await r.open(),"function"==typeof r.clear&&await r.clear();const a=this.storage.getAllDocuments();for(const c of a)c&&await r.add(c);return this.indexes.set(e,r),r}async updateIndexesOnInsert(e){const t=[];for(const[n,r]of this.indexes)t.push((async()=>{await this._ensureIndexOpen(r),await r.add(e)})());t.length>0&&await Promise.all(t)}async updateIndexesOnDelete(e){const t=[];for(const[n,r]of this.indexes)t.push((async()=>{await this._ensureIndexOpen(r),await r.remove(e)})());t.length>0&&await Promise.all(t)}planQuery(e){const t=this.queryPlanner.plan(e);return{useIndex:"full_scan"!==t.type,planType:t.type,indexNames:t.indexes,docIds:null,estimatedCost:t.estimatedCost,indexOnly:t.indexOnly||!1}}async planQueryAsync(e){const t=this.queryPlanner.plan(e),n=await this.queryPlanner.execute(t);return{useIndex:"full_scan"!==t.type,planType:t.type,indexNames:t.indexes,docIds:n,estimatedCost:t.estimatedCost,indexOnly:t.indexOnly||!1}}getTextIndex(e){for(const[t,n]of this.indexes)if(n instanceof at&&n.indexedFields.includes(e))return n;return null}aggregate(e){if(!e||!O(e))throw new k("Pipeline must be an array",{collection:this.name,code:D.FAILED_TO_PARSE});let t=[];const n=this.find({});for(;n.hasNext();)t.push(n.next());for(let r=0;r<e.length;r++){const n=e[r],i=Object.keys(n);if(1!==i.length)throw new k("Each pipeline stage must have exactly one key",{collection:this.name,code:D.FAILED_TO_PARSE});const s=i[0],o=n[s];if("$match"===s){const e=[];for(let n=0;n<t.length;n++)We(t[n],o)&&e.push(t[n]);t=e}else if("$project"===s){const e=[];for(let n=0;n<t.length;n++)e.push(xt(o,t[n]));t=e}else if("$addFields"===s||"$set"===s){const e=[];for(let n=0;n<t.length;n++){const r=_(t[n]);for(const e in o){const i=o[e];r[e]=we(i,t[n])}e.push(r)}t=e}else if("$unset"===s){const e=[];let n=[];"string"==typeof o?n=[o]:Array.isArray(o)?n=o:"object"==typeof o&&(n=Object.keys(o));for(let r=0;r<t.length;r++){const i=_(t[r]);for(let e=0;e<n.length;e++){const t=n[e],r=t.split(".");if(1===r.length)delete i[t];else{let e=i;for(let t=0;t<r.length-1&&(null!=e&&null!=e);t++)e=e[r[t]];null!=e&&null!=e&&delete e[r[r.length-1]]}}e.push(i)}t=e}else if("$sort"===s){const e=Object.keys(o);t.sort(function(t,n){for(let r=0;r<e.length;r++){const i=e[r];if(void 0===t[i]&&void 0!==n[i])return-1*o[i];if(void 0!==t[i]&&void 0===n[i])return 1*o[i];if(t[i]<n[i])return-1*o[i];if(t[i]>n[i])return 1*o[i]}return 0})}else if("$limit"===s)t=t.slice(0,o);else if("$skip"===s)t=t.slice(o);else if("$group"===s){const e={},n=o._id;for(let i=0;i<t.length;i++){const r=t[i];let s;s=null==n?null:we(n,r);const o=JSON.stringify(s);e[o]||(e[o]={_id:s,docs:[],accumulators:{}}),e[o].docs.push(r)}const r=[];for(const t in e){const n=e[t],i={_id:n._id};for(const e in o){if("_id"===e)continue;const t=o[e],r=Object.keys(t);if(1!==r.length)continue;const s=r[0],a=t[s];if("$sum"===s){let t=0;for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);"number"==typeof r?t+=r:null!=r&&(t+=Number(r)||0)}i[e]=t}else if("$avg"===s){let t=0,r=0;for(let e=0;e<n.docs.length;e++){const i=we(a,n.docs[e]);null!=i&&(t+=Number(i)||0,r++)}i[e]=r>0?t/r:0}else if("$min"===s){let t;for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);void 0!==r&&(void 0===t||r<t)&&(t=r)}i[e]=t}else if("$max"===s){let t;for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);void 0!==r&&(void 0===t||r>t)&&(t=r)}i[e]=t}else if("$push"===s){const t=[];for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);t.push(r)}i[e]=t}else if("$addToSet"===s){const t={};for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);t[JSON.stringify(r)]=r}const r=[];for(const e in t)r.push(t[e]);i[e]=r}else if("$first"===s)n.docs.length>0&&(i[e]=we(a,n.docs[0]));else if("$last"===s)n.docs.length>0&&(i[e]=we(a,n.docs[n.docs.length-1]));else if("$stdDevPop"===s){const t=[];for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);"number"==typeof r&&t.push(r)}if(t.length>0){const n=t.reduce((e,t)=>e+t,0)/t.length,r=t.reduce((e,t)=>e+Math.pow(t-n,2),0)/t.length;i[e]=Math.sqrt(r)}else i[e]=0}else if("$stdDevSamp"===s){const t=[];for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);"number"==typeof r&&t.push(r)}if(t.length>1){const n=t.reduce((e,t)=>e+t,0)/t.length,r=t.reduce((e,t)=>e+Math.pow(t-n,2),0)/(t.length-1);i[e]=Math.sqrt(r)}else i[e]=0}else if("$mergeObjects"===s){const t={};for(let e=0;e<n.docs.length;e++){const r=we(a,n.docs[e]);"object"!=typeof r||null===r||Array.isArray(r)||Object.assign(t,r)}i[e]=t}}r.push(i)}t=r}else if("$count"===s)t=[{[o]:t.length}];else if("$unwind"===s){const e=[];let n=o;"string"==typeof n&&"$"===n.charAt(0)&&(n=n.substring(1));for(let r=0;r<t.length;r++){const i=t[r],s=v(i,n);if(s&&O(s)&&s.length>0)for(let t=0;t<s.length;t++){const r=_(i),o=n.split(".");let a=r;for(let e=0;e<o.length-1;e++)a[o[e]]||(a[o[e]]={}),a=a[o[e]];a[o[o.length-1]]=s[t],e.push(r)}}t=e}else if("$sortByCount"===s){const e={};for(let n=0;n<t.length;n++){const r=t[n],i=we(o,r),s=JSON.stringify(i);e[s]||(e[s]={_id:i,count:0}),e[s].count++}t=Object.values(e).sort((e,t)=>t.count-e.count)}else if("$replaceRoot"===s||"$replaceWith"===s){const e=[],n="$replaceRoot"===s?o.newRoot:o;for(let r=0;r<t.length;r++){const i=we(n,t[r]);if("object"!=typeof i||null===i||Array.isArray(i))throw new k("$replaceRoot expression must evaluate to an object",{collection:this.name,code:D.FAILED_TO_PARSE});e.push(i)}t=e}else if("$sample"===s){const e=o.size||1;if("number"!=typeof e||e<0)throw new k("$sample size must be a non-negative number",{collection:this.name,code:D.FAILED_TO_PARSE});const n=[...t];for(let t=n.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[n[t],n[e]]=[n[e],n[t]]}t=n.slice(0,Math.min(e,n.length))}else if("$bucket"===s){if(!o.groupBy||!o.boundaries)throw new k("$bucket requires groupBy and boundaries",{collection:this.name,code:D.FAILED_TO_PARSE});const e=o.boundaries,n=o.default,r=o.output||{count:{$sum:1}},i={};for(let t=0;t<e.length-1;t++){i[JSON.stringify(e[t])]={_id:e[t],docs:[]}}void 0!==n&&(i.default={_id:n,docs:[]});for(let a=0;a<t.length;a++){const r=t[a],s=we(o.groupBy,r);let c=!1;for(let t=0;t<e.length-1;t++)if(s>=e[t]&&s<e[t+1]){i[JSON.stringify(e[t])].docs.push(r),c=!0;break}c||void 0===n||i.default.docs.push(r)}const s=[];for(const t in i){const e=i[t];if(0===e.docs.length)continue;const n={_id:e._id};for(const t in r){const i=r[t],s=Object.keys(i);if(1!==s.length)continue;const o=s[0],a=i[o];if("$sum"===o){let r=0;for(let t=0;t<e.docs.length;t++){const n=we(a,e.docs[t]);"number"==typeof n?r+=n:null!=n&&(r+=Number(n)||0)}n[t]=r}else if("$avg"===o){let r=0,i=0;for(let t=0;t<e.docs.length;t++){const n=we(a,e.docs[t]);null!=n&&(r+=Number(n)||0,i++)}n[t]=i>0?r/i:0}else if("$push"===o){const r=[];for(let t=0;t<e.docs.length;t++){const n=we(a,e.docs[t]);r.push(n)}n[t]=r}else if("$addToSet"===o){const r={};for(let t=0;t<e.docs.length;t++){const n=we(a,e.docs[t]);r[JSON.stringify(n)]=n}n[t]=Object.values(r)}}s.push(n)}t=s.sort((e,t)=>e._id<t._id?-1:e._id>t._id?1:0)}else if("$bucketAuto"===s){if(!o.groupBy||!o.buckets)throw new k("$bucketAuto requires groupBy and buckets",{collection:this.name,code:D.FAILED_TO_PARSE});const e=o.buckets,n=o.output||{count:{$sum:1}};if(0===t.length)t=[];else{const r=t.map(e=>({value:we(o.groupBy,e),doc:e})).sort((e,t)=>e.value<t.value?-1:e.value>t.value?1:0),i=Math.ceil(r.length/e),s=[];for(let t=0;t<e&&t*i<r.length;t++){const e=t*i,n=Math.min((t+1)*i,r.length),o=r.slice(e,n);if(0===o.length)continue;const a={_id:{min:o[0].value,max:(r.length,o[o.length-1].value)},docs:o.map(e=>e.doc)};s.push(a)}const a=[];for(let e=0;e<s.length;e++){const t=s[e],r={_id:t._id};for(const e in n){const i=n[e],s=Object.keys(i);if(1!==s.length)continue;const o=s[0],a=i[o];if("$sum"===o){let n=0;for(let e=0;e<t.docs.length;e++){const r=we(a,t.docs[e]);"number"==typeof r?n+=r:null!=r&&(n+=Number(r)||0)}r[e]=n}else if("$avg"===o){let n=0,i=0;for(let e=0;e<t.docs.length;e++){const r=we(a,t.docs[e]);null!=r&&(n+=Number(r)||0,i++)}r[e]=i>0?n/i:0}else if("$push"===o){const n=[];for(let e=0;e<t.docs.length;e++){const r=we(a,t.docs[e]);n.push(r)}r[e]=n}}a.push(r)}t=a}}else if("$out"===s){const e=o;if("string"!=typeof e)throw new k("$out requires a string collection name",{collection:this.name,code:D.FAILED_TO_PARSE});this.db[e]&&this.db.dropCollection(e),this.db.createCollection(e);const n=this.db[e];for(let r=0;r<t.length;r++){const e=t[r],i=e._id,s="object"==typeof i&&i.toString?i.toString():String(i);n.storage.set(s,e)}t=[]}else if("$merge"===s){let e,n="_id",r="merge",i="insert";if("string"==typeof o?e=o:"object"==typeof o&&(e=o.into,n=o.on||n,r=o.whenMatched||r,i=o.whenNotMatched||i),!e)throw new k("$merge requires a target collection",{collection:this.name,code:D.FAILED_TO_PARSE});this.db[e]||this.db.createCollection(e);const s=this.db[e];for(let o=0;o<t.length;o++){const e=t[o],a="string"==typeof n?n:n[0],c=v(e,a),l=s.find({[a]:c}),u=l.hasNext()?l.next():null;if(u){if("replace"===r){const t=e._id,n="object"==typeof t&&t.toString?t.toString():String(t);s.storage.set(n,e)}else if("merge"===r){const t=Object.assign({},u,e),n=t._id,r="object"==typeof n&&n.toString?n.toString():String(n);s.storage.set(r,t)}else if("keepExisting"===r);else if("fail"===r)throw new k("$merge failed: duplicate key",{collection:this.name,code:D.DUPLICATE_KEY})}else if("insert"===i){const t=e._id,n="object"==typeof t&&t.toString?t.toString():String(t);s.storage.set(n,e)}else if("discard"===i);else if("fail"===i)throw new k("$merge failed: document not found",{collection:this.name,code:D.FAILED_TO_PARSE})}t=[]}else if("$lookup"===s){if(!(o.from&&o.localField&&o.foreignField&&o.as))throw new k("$lookup requires from, localField, foreignField, and as",{collection:this.name,code:D.FAILED_TO_PARSE});if(!this.db.getCollectionNames().includes(o.from))throw new k("$lookup: collection not found: "+o.from,{collection:this.name,code:D.NAMESPACE_NOT_FOUND});const e=this.db[o.from],n=[];for(let r=0;r<t.length;r++){const i=_(t[r]),s=v(i,o.localField),a=[],c=e.find({[o.foreignField]:s});for(;c.hasNext();)a.push(c.next());i[o.as]=a,n.push(i)}t=n}else if("$graphLookup"===s){if(!(o.from&&o.startWith&&o.connectFromField&&o.connectToField&&o.as))throw new k("$graphLookup requires from, startWith, connectFromField, connectToField, and as",{collection:this.name,code:D.FAILED_TO_PARSE});if(!this.db.getCollectionNames().includes(o.from))throw new k("$graphLookup: collection not found: "+o.from,{collection:this.name,code:D.NAMESPACE_NOT_FOUND});const e=this.db[o.from],n=void 0!==o.maxDepth?o.maxDepth:Number.MAX_SAFE_INTEGER,r=o.depthField,i=o.restrictSearchWithMatch,s=[];for(let a=0;a<t.length;a++){const c=_(t[a]),l=we(o.startWith,t[a]),u=new Set,h=[],f=[{value:l,depth:0}];for(;f.length>0;){const{value:t,depth:s}=f.shift();if(s>n)continue;const a=JSON.stringify(t);if(u.has(a))continue;u.add(a);let c={[o.connectToField]:t};i&&(c={$and:[c,i]});const l=e.find(c);for(;l.hasNext();){const e=l.next(),t=_(e);r&&(t[r]=s),h.push(t);const n=v(e,o.connectFromField);null!=n&&f.push({value:n,depth:s+1})}}c[o.as]=h,s.push(c)}t=s}else if("$facet"===s){if("object"!=typeof o||Array.isArray(o))throw new k("$facet requires an object with pipeline definitions",{collection:this.name,code:D.FAILED_TO_PARSE});const e={};for(const n in o){const r=o[n];if(!Array.isArray(r))throw new k("$facet pipeline must be an array",{collection:this.name,code:D.FAILED_TO_PARSE});let i=t.map(e=>_(e));for(let e=0;e<r.length;e++){const t=r[e],n=Object.keys(t);if(1!==n.length)throw new k("Each pipeline stage must have exactly one key",{collection:this.name,code:D.FAILED_TO_PARSE});const s=n[0],o=t[s];if("$match"===s){const e=[];for(let t=0;t<i.length;t++)We(i[t],o)&&e.push(i[t]);i=e}else if("$project"===s){const e=[];for(let t=0;t<i.length;t++)e.push(xt(o,i[t]));i=e}else if("$limit"===s)i=i.slice(0,o);else if("$skip"===s)i=i.slice(o);else if("$sort"===s){const e=Object.keys(o);i.sort(function(t,n){for(let r=0;r<e.length;r++){const i=e[r];if(void 0===t[i]&&void 0!==n[i])return-1*o[i];if(void 0!==t[i]&&void 0===n[i])return 1*o[i];if(t[i]<n[i])return-1*o[i];if(t[i]>n[i])return 1*o[i]}return 0})}else if("$count"===s)i=[{[o]:i.length}];else if("$group"===s){const e={},t=o._id;for(let r=0;r<i.length;r++){const n=i[r];let s;s=null==t?null:we(t,n);const o=JSON.stringify(s);e[o]||(e[o]={_id:s,docs:[],accumulators:{}}),e[o].docs.push(n)}const n=[];for(const r in e){const t=e[r],i={_id:t._id};for(const e in o){if("_id"===e)continue;const n=o[e],r=Object.keys(n);if(1!==r.length)continue;const s=r[0],a=n[s];if("$sum"===s){let n=0;for(let e=0;e<t.docs.length;e++){const r=we(a,t.docs[e]);"number"==typeof r?n+=r:null!=r&&(n+=Number(r)||0)}i[e]=n}else if("$avg"===s){let n=0,r=0;for(let e=0;e<t.docs.length;e++){const i=we(a,t.docs[e]);null!=i&&(n+=Number(i)||0,r++)}i[e]=r>0?n/r:0}else if("$max"===s){let n;for(let e=0;e<t.docs.length;e++){const r=we(a,t.docs[e]);void 0!==r&&(void 0===n||r>n)&&(n=r)}i[e]=n}}n.push(i)}i=n}else if("$sortByCount"===s){const e={};for(let t=0;t<i.length;t++){const n=i[t],r=we(o,n),s=JSON.stringify(r);e[s]||(e[s]={_id:r,count:0}),e[s].count++}i=Object.values(e).sort((e,t)=>t.count-e.count)}else if("$sample"===s){const e=o.size||1,t=[...i];for(let n=t.length-1;n>0;n--){const e=Math.floor(Math.random()*(n+1));[t[n],t[e]]=[t[e],t[n]]}i=t.slice(0,Math.min(e,t.length))}else if("$bucket"===s){const e=o.boundaries,t=o.default,n=o.output||{count:{$sum:1}},r={};for(let i=0;i<e.length-1;i++){r[JSON.stringify(e[i])]={_id:e[i],docs:[]}}void 0!==t&&(r.default={_id:t,docs:[]});for(let a=0;a<i.length;a++){const n=i[a],s=we(o.groupBy,n);let c=!1;for(let t=0;t<e.length-1;t++)if(s>=e[t]&&s<e[t+1]){r[JSON.stringify(e[t])].docs.push(n),c=!0;break}c||void 0===t||r.default.docs.push(n)}const s=[];for(const i in r){const e=r[i];if(0===e.docs.length)continue;const t={_id:e._id};for(const r in n){const i=n[r],s=Object.keys(i);if(1!==s.length)continue;const o=s[0],a=i[o];if("$sum"===o){let n=0;for(let t=0;t<e.docs.length;t++){const r=we(a,e.docs[t]);"number"==typeof r?n+=r:null!=r&&(n+=Number(r)||0)}t[r]=n}}s.push(t)}i=s.sort((e,t)=>e._id<t._id?-1:e._id>t._id?1:0)}}e[n]=i}t=[e]}else if("$redact"===s){const e=[];for(let n=0;n<t.length;n++){const r=t[n],i=we(o,r);if("$$DESCEND"===i)e.push(r);else{if("$$PRUNE"===i)continue;("$$KEEP"===i||i)&&e.push(r)}}t=e}else{if("$geoNear"!==s)throw new k("Unsupported aggregation stage: "+s,{collection:this.name,code:D.FAILED_TO_PARSE});{if(!o.near||!o.distanceField)throw new k("$geoNear requires near and distanceField",{collection:this.name,code:D.FAILED_TO_PARSE});const e=o.near,n=o.distanceField,r=o.maxDistance,i=o.minDistance||0,s=!1!==o.spherical,a=o.key||"location",c=[];for(let o=0;o<t.length;o++){const l=_(t[o]),u=v(l,a);if(!u||!Array.isArray(u)||u.length<2)continue;let h;if(s){const t=6371e3,n=e[1]*Math.PI/180,r=u[1]*Math.PI/180,i=(u[1]-e[1])*Math.PI/180,s=(u[0]-e[0])*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(n)*Math.cos(r)*Math.sin(s/2)*Math.sin(s/2);h=t*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}else{const t=u[0]-e[0],n=u[1]-e[1];h=Math.sqrt(t*t+n*n)}h>=i&&(!r||h<=r)&&(l[n]=h,c.push(l))}c.sort((e,t)=>e[n]-t[n]),t=o.limit?c.slice(0,o.limit):c}}}return t}bulkWrite(){throw new U("bulkWrite",{collection:this.name})}async count(){return this.storage.size()}async copyTo(e){this.db[e]||this.db.createCollection(e);const t=this.db[e];let n=0;const r=this.find({});for(;r.hasNext();)await t.insertOne(r.next()),n++;return n}async createIndex(e,t){if(!e||"object"!=typeof e||Array.isArray(e))throw new B("keys",e,"createIndex requires a key specification object",{collection:this.name});const n=t&&t.name?t.name:this.generateIndexName(e);if(this.indexes.has(n)){const t=this.indexes.get(n);if(JSON.stringify(t.keys)!==JSON.stringify(e))throw new T("Index with name '"+n+"' already exists with a different key specification",{code:D.INDEX_OPTIONS_CONFLICT,index:n,collection:this.name});return n}return await this.buildIndex(n,e,t),n}dataSize(){throw new U("dataSize",{collection:this.name})}async deleteOne(e){const t=await this.findOne(e);return t?(await this.updateIndexesOnDelete(t),this.storage.remove(t._id.toString()),this.emit("delete",{_id:t._id}),{deletedCount:1}):{deletedCount:0}}async deleteMany(e){const t=this.find(e),n=[],r=[];for(;t.hasNext();){const e=t.next();n.push(e._id),r.push(e)}const i=n.length;for(let s=0;s<n.length;s++)await this.updateIndexesOnDelete(r[s]),this.storage.remove(n[s].toString()),this.emit("delete",{_id:n[s]});return{deletedCount:i}}async distinct(e,t){const n={},r=this.find(t);for(;r.hasNext();){const t=r.next();t[e]&&(n[t[e]]=!0)}return Object.keys(n)}async drop(){for(const[e,t]of this.indexes)t&&"function"==typeof t.clear&&await t.clear();this.storage.clear()}dropIndex(e){if(!this.indexes.has(e))throw new j(e,{collection:this.name});return this.indexes.get(e).clear(),this.indexes.delete(e),{nIndexesWas:this.indexes.size+1,ok:1}}dropIndexes(){const e=this.indexes.size;for(const[t,n]of this.indexes)n.clear();return this.indexes.clear(),{nIndexesWas:e,msg:"non-_id indexes dropped",ok:1}}ensureIndex(){throw new U("ensureIndex",{collection:this.name})}explain(){throw new U("explain",{collection:this.name})}find(e,t){const n=null==e?{}:e,r=this._extractNearSpec(n);this.planQuery(n);const i=[],s={},o=this.storage.getAllDocuments();for(const a of o)!s[a._id]&&We(a,n)&&(s[a._id]=!0,i.push(a));return r&&this._sortByNearDistance(i,r),new R(this,n,t,i,z)}_extractNearSpec(e){for(const t of Object.keys(e||{})){if(t.startsWith("$"))continue;const n=e[t];if(n&&"object"==typeof n){if(n.$near){const e=this._parseNearCoordinates(n.$near);if(e)return{field:t,...e}}if(n.$nearSphere){const e=this._parseNearCoordinates(n.$nearSphere);if(e)return{field:t,...e}}}}return null}_parseNearCoordinates(e){let t;if(e&&"object"==typeof e&&(e.$geometry&&e.$geometry.coordinates?t=e.$geometry.coordinates:e.coordinates?t=e.coordinates:Array.isArray(e)&&(t=e)),!t||t.length<2)return null;const[n,r]=t;return"number"!=typeof r||"number"!=typeof n?null:{lat:r,lng:n}}_extractPointCoordinates(e){if(!e)return null;if("FeatureCollection"===e.type&&Array.isArray(e.features)&&e.features.length>0)return this._extractPointCoordinates(e.features[0].geometry);if("Feature"===e.type&&e.geometry)return this._extractPointCoordinates(e.geometry);if("Point"===e.type&&Array.isArray(e.coordinates)&&e.coordinates.length>=2){const[t,n]=e.coordinates;if("number"==typeof n&&"number"==typeof t)return{lat:n,lng:t}}return null}_sortByNearDistance(e,t){const{field:n,lat:r,lng:i}=t;e.sort((e,t)=>{const s=this._extractPointCoordinates(v(e,n)),o=this._extractPointCoordinates(v(t,n));return(s?this._haversineDistance(s.lat,s.lng,r,i):1/0)-(o?this._haversineDistance(o.lat,o.lng,r,i):1/0)})}_haversineDistance(e,t,n,r){const i=(n-e)*Math.PI/180,s=(r-t)*Math.PI/180,o=Math.sin(i/2)*Math.sin(i/2)+Math.cos(e*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))}findAndModify(){throw new U("findAndModify",{collection:this.name})}async findOne(e,t){const n=this.find(e,t);return n.hasNext()?n.next():null}async findOneAndDelete(e,t){let n=this.find(e);if(t&&t.sort&&(n=n.sort(t.sort)),!n.hasNext())return null;const r=n.next();return this.storage.remove(r._id.toString()),t&&t.projection?C(t.projection,r):r}async findOneAndReplace(e,t,n){let r=this.find(e);if(n&&n.sort&&(r=r.sort(n.sort)),!r.hasNext())return null;const i=r.next();return t._id=i._id,this.storage.set(i._id.toString(),t),n&&n.returnNewDocument?n&&n.projection?C(n.projection,t):t:n&&n.projection?C(n.projection,i):i}async findOneAndUpdate(e,t,n){let r=this.find(e);if(n&&n.sort&&(r=r.sort(n.sort)),!r.hasNext())return null;const i=r.next(),s=Object.assign({},i);return rt(t,s,!1,Ke(i,e).arrayFilters,n&&n.arrayFilters),this.storage.set(i._id.toString(),s),n&&n.returnNewDocument?n&&n.projection?C(n.projection,s):s:n&&n.projection?C(n.projection,i):i}getIndexes(){const e=[];for(const[t,n]of this.indexes)e.push(n.getSpec());return e}getShardDistribution(){throw new U("getShardDistribution",{collection:this.name})}getShardVersion(){throw new U("getShardVersion",{collection:this.name})}getStore(){return this.storage.getStore()}group(){throw new U("group",{collection:this.name})}async insert(e){return Array==e.constructor?await this.insertMany(e):await this.insertOne(e)}async insertOne(e){return null==e._id&&(e._id=this.idGenerator()),this.storage.set(e._id.toString(),e),await this.updateIndexesOnInsert(e),this.emit("insert",e),{insertedId:e._id}}async insertMany(e){const t=[];for(let n=0;n<e.length;n++){const r=await this.insertOne(e[n]);t.push(r.insertedId)}return{insertedIds:t}}isCapped(){throw new U("isCapped",{collection:this.name})}mapReduce(){throw new U("mapReduce",{collection:this.name})}reIndex(){throw new U("reIndex",{collection:this.name})}async replaceOne(e,t,n){const r={},i=this.find(e);if(r.matchedCount=i.count(),0==r.matchedCount){if(r.modifiedCount=0,n&&n.upsert){const e=t;e._id=this.idGenerator(),this.storage.set(e._id.toString(),e),await this.updateIndexesOnInsert(e),this.emit("insert",e),r.upsertedId=e._id}}else{r.modifiedCount=1;const e=i.next();await this.updateIndexesOnDelete(e),t._id=e._id,this.storage.set(e._id.toString(),t),await this.updateIndexesOnInsert(t),this.emit("replace",t)}return r}async remove(e,t){const n=this.find(e);if(n.hasNext())if(!0===t||t&&t.justOne){const e=n.next();await this.updateIndexesOnDelete(e),this.storage.remove(e._id.toString())}else for(;n.hasNext();){const e=n.next();await this.updateIndexesOnDelete(e),this.storage.remove(e._id.toString())}}renameCollection(){throw new U("renameCollection",{collection:this.name})}save(){throw new U("save",{collection:this.name})}stats(){throw new U("stats",{collection:this.name})}storageSize(){throw new U("storageSize",{collection:this.name})}totalSize(){throw new U("totalSize",{collection:this.name})}totalIndexSize(){throw new U("totalIndexSize",{collection:this.name})}async update(e,t,n){const r=this.find(e);if(r.hasNext())if(n&&n.multi)for(;r.hasNext();){const i=r.next(),s=Ke(i,e).arrayFilters,o=n&&n.arrayFilters;await this.updateIndexesOnDelete(i),rt(t,i,!1,s,o),this.storage.set(i._id.toString(),i),await this.updateIndexesOnInsert(i)}else{const i=r.next(),s=Ke(i,e).arrayFilters,o=n&&n.arrayFilters;await this.updateIndexesOnDelete(i),rt(t,i,!1,s,o),this.storage.set(i._id.toString(),i),await this.updateIndexesOnInsert(i)}else if(n&&n.upsert){const n=it(e,t,this.idGenerator);this.storage.set(n._id.toString(),n),await this.updateIndexesOnInsert(n)}}async updateOne(e,t,n){const r=this.find(e);if(r.hasNext()){const i=r.next(),s=JSON.parse(JSON.stringify(i)),o=Ke(i,e).arrayFilters,a=n&&n.arrayFilters;await this.updateIndexesOnDelete(i),rt(t,i,!1,o,a),this.storage.set(i._id.toString(),i),await this.updateIndexesOnInsert(i);const c=this._getUpdateDescription(s,i);this.emit("update",i,c)}else if(n&&n.upsert){const n=it(e,t,this.idGenerator);this.storage.set(n._id.toString(),n),await this.updateIndexesOnInsert(n),this.emit("insert",n)}}async updateMany(e,t,n){const r=this.find(e);if(r.hasNext())for(;r.hasNext();){const i=r.next(),s=JSON.parse(JSON.stringify(i)),o=Ke(i,e).arrayFilters,a=n&&n.arrayFilters;await this.updateIndexesOnDelete(i),rt(t,i,!1,o,a),this.storage.set(i._id.toString(),i),await this.updateIndexesOnInsert(i);const c=this._getUpdateDescription(s,i);this.emit("update",i,c)}else if(n&&n.upsert){const n=it(e,t,this.idGenerator);this.storage.set(n._id.toString(),n),await this.updateIndexesOnInsert(n),this.emit("insert",n)}}validate(){throw new U("validate",{collection:this.name})}_getUpdateDescription(e,t){const n={},r=[];for(const i in t)"_id"!==i&&JSON.stringify(e[i])!==JSON.stringify(t[i])&&(n[i]=t[i]);for(const i in e)"_id"!==i&&(i in t||r.push(i));return{updatedFields:n,removedFields:r,truncatedArrays:[]}}watch(e=[],t={}){return new wt(this,e,t)}}function xt(e,t){const n={},r=Object.keys(e);let i=!1,s=!1;for(const o of r){if("_id"===o)continue;const t=e[o];1===t||!0===t?i=!0:0===t||!1===t||(s=!0)}if(s||i){0!==e._id&&!1!==e._id&&(n._id=t._id);for(const i of r){const r=e[i];"_id"===i?0!==r&&!1!==r||delete n._id:n[i]=1===r||!0===r?v(t,i):we(r,t)}}else{for(const e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);for(const t of r)0!==e[t]&&!1!==e[t]||delete n[t]}return n}class _t{constructor(){this.data=new Map}clear(){this.data=new Map}keys(){return this.data.keys()}get(e){return this.data.get(e)}remove(e){this.data.delete(e)}set(e,t){this.data.set(e,t)}size(){return this.data.size}}class vt{constructor(e){if(this._meta=new Map,this._data=new Map,e)for(const[t,n]of Object.entries(e))this._meta.set(t,n)}getAllMeta(){const e={};for(const[t,n]of this._meta)e[t]=n;return e}setMeta(e,t){this._meta.set(e,t)}hasMeta(e){return this._meta.has(e)}getMeta(e){return this._meta.get(e)}hasDataMap(e){return this._data.has(e)}getDataMap(e){return this._data.has(e)||this._data.set(e,new Map),this._data.get(e)}}class $t{constructor(){this.documents=new _t,this.indexes=new Map}clear(){this.documents.clear(),this.indexes.clear()}documentKeys(){return this.documents.keys()}getAllDocuments(){return Array.from(this.documents.data.values())}get(e){if("string"!=typeof e)throw new Error("Document key must be a string");return this.documents.get(e)}set(e,t){if("string"!=typeof e)throw new Error("Document key must be a string");this.documents.set(e,t)}remove(e){if("string"!=typeof e)throw new Error("Document key must be a string");this.documents.remove(e)}size(){return this.documents.size()}getStore(){const e={};for(const t of this.documents.keys())e[t]=this.documents.get(t);return e}indexesCount(){return this.indexes.size}indexKeys(){return this.indexes.keys()}createIndexStore(e,t){return this.indexes.has(e)||this.indexes.set(e,new vt(t)),this.indexes.get(e)}}class Nt{constructor(){this.collections=new Map}collectionsCount(){return this.collections.size}collectionStoreKeys(){return this.collections.keys()}getCollectionStore(e){return this.collections.get(e)}createCollectionStore(e){if(this.collections.has(e))return this.collections.get(e);const t=new $t;return this.collections.set(e,t),t}removeCollectionStore(e){this.collections.delete(e)}save(){}}class Ot{constructor(e){return this.options=e||{},this.dbName=this.options.dbName||"default",this.storageEngine=this.options.storageEngine||new Nt,this._loadExistingCollections(),new Proxy(this,{get:(e,t,n)=>t in e?Reflect.get(e,t,n):"symbol"==typeof t||t.startsWith("_")?void 0:"string"==typeof t?(Object.prototype.hasOwnProperty.call(e,t)||e.createCollection(t),e[t]):void 0})}_log(e){this.options&&this.options.print?this.options.print(e):console.log(e)}_id(){return this.options&&this.options.id?this.options.id():new g}_loadExistingCollections(){for(const e of this.storageEngine.collectionStoreKeys()){const t=this.storageEngine.getCollectionStore(e);this[e]=new bt(this,e,t,this._id.bind(this))}}async close(){for(const e of Object.keys(this)){const t=this[e];t&&t.isCollection&&"function"==typeof t.close&&await t.close()}}cloneCollection(){throw new U("cloneCollection",{database:this.dbName})}cloneDatabase(){throw new U("cloneDatabase",{database:this.dbName})}commandHelp(){throw new U("commandHelp",{database:this.dbName})}copyDatabase(){throw new U("copyDatabase",{database:this.dbName})}createCollection(e){e&&(this[e]=new bt(this,e,this.storageEngine.createCollectionStore(e),this._id.bind(this)))}collection(e){if(!e)throw new Error("Collection name is required");return this[e]&&this[e].isCollection||this.createCollection(e),this[e]}currentOp(){throw new U("currentOp",{database:this.dbName})}async dropCollection(e){this[e]&&("function"==typeof this[e].drop&&await this[e].drop(),this.storageEngine.removeCollectionStore(e),delete this[e])}async dropDatabase(){const e=this.getCollectionNames();for(const t of e)this[t]&&"function"==typeof this[t].close&&await this[t].close(),this.storageEngine.removeCollectionStore(t),delete this[t]}eval(){throw new U("eval",{database:this.dbName})}fsyncLock(){throw new U("fsyncLock",{database:this.dbName})}fsyncUnlock(){throw new U("fsyncUnlock",{database:this.dbName})}getCollection(){throw new U("getCollection",{database:this.dbName})}getCollectionInfos(){throw new U("getCollectionInfos",{database:this.dbName})}getCollectionNames(){const e=[];for(const t in this)null!=this[t]&&this[t].isCollection&&e.push(t);return e}getLastError(){throw new U("getLastError",{database:this.dbName})}getLastErrorObj(){throw new U("getLastErrorObj",{database:this.dbName})}getLogComponents(){throw new U("getLogComponents",{database:this.dbName})}getMongo(){throw new U("getMongo",{database:this.dbName})}getName(){throw new U("getName",{database:this.dbName})}getPrevError(){throw new U("getPrevError",{database:this.dbName})}getProfilingLevel(){throw new U("getProfilingLevel",{database:this.dbName})}getProfilingStatus(){throw new U("getProfilingStatus",{database:this.dbName})}getReplicationInfo(){throw new U("getReplicationInfo",{database:this.dbName})}getSiblingDB(){throw new U("getSiblingDB",{database:this.dbName})}help(){this._log("        help mr                      mapreduce"),this._log("        db.foo.find()                list objects in collection foo"),this._log("        db.foo.find( { a : 1 } )     list objects in foo where a == 1"),this._log("        it                           result of the last line evaluated; use to further iterate")}hostInfo(){throw new U("hostInfo",{database:this.dbName})}isMaster(){throw new U("isMaster",{database:this.dbName})}killOp(){throw new U("killOp",{database:this.dbName})}listCommands(){throw new U("listCommands",{database:this.dbName})}loadServerScripts(){throw new U("loadServerScripts",{database:this.dbName})}logout(){throw new U("logout",{database:this.dbName})}printCollectionStats(){throw new U("printCollectionStats",{database:this.dbName})}printReplicationInfo(){throw new U("printReplicationInfo",{database:this.dbName})}printShardingStatus(){throw new U("printShardingStatus",{database:this.dbName})}printSlaveReplicationInfo(){throw new U("printSlaveReplicationInfo",{database:this.dbName})}repairDatabase(){throw new U("repairDatabase",{database:this.dbName})}resetError(){throw new U("resetError",{database:this.dbName})}runCommand(){throw new U("runCommand",{database:this.dbName})}serverBuildInfo(){throw new U("serverBuildInfo",{database:this.dbName})}serverCmdLineOpts(){throw new U("serverCmdLineOpts",{database:this.dbName})}serverStatus(){throw new U("serverStatus",{database:this.dbName})}setLogLevel(){throw new U("setLogLevel",{database:this.dbName})}setProfilingLevel(){throw new U("setProfilingLevel",{database:this.dbName})}shutdownServer(){throw new U("shutdownServer",{database:this.dbName})}stats(){throw new U("stats",{database:this.dbName})}version(){throw new U("version",{database:this.dbName})}upgradeCheck(){throw new U("upgradeCheck",{database:this.dbName})}upgradeCheckAllDBs(){throw new U("upgradeCheckAllDBs",{database:this.dbName})}watch(e=[],t={}){return new wt(this,e,t)}}class Et extends r.EventEmitter{constructor(e="mongodb://localhost:27017",t={}){super(),this.uri=e,this.options=Object.freeze({...t}),this._isConnected=!1,this._defaultDb=this._parseDefaultDbName(e),this._databases=new Map}static async connect(e,t={}){const n=new Et(e,t);return await n.connect(),n}async connect(){return this._isConnected||(this._isConnected=!0,this.emit("open",this)),this}db(e,t={}){const n=e||this._defaultDb;if(!n)throw new Error("No database name provided and no default in connection string");if(this._databases.has(n))return this._databases.get(n);const r={...this.options,...t,dbName:n},i=new Ot(r);return this._databases.set(n,i),i}async close(e=!1){if(this._isConnected){for(const[e,t]of this._databases)t&&"function"==typeof t.close&&await t.close();this._databases.clear(),this._isConnected=!1,this.emit("close")}}startSession(e={}){return{id:crypto.randomUUID(),endSession:()=>{},withTransaction:async e=>await e(this)}}async withSession(e,t){const n=this.startSession("function"==typeof e?{}:e),r="function"==typeof e?e:t;try{return await r(n)}finally{n.endSession()}}get readConcern(){return this.options.readConcern}get writeConcern(){return this.options.writeConcern}get readPreference(){return this.options.readPreference}watch(e=[],t={}){return new wt(this,e,t)}_parseDefaultDbName(e){const t=e.match(/\/([^/?]+)/);return t?t[1]:null}}e.BadValueError=B,e.BulkWriteError=class extends M{constructor(e=[],t={}){super(`Bulk write operation error: ${e.length} error(s)`,t),this.name="BulkWriteError",this.writeErrors=e,this.code=t.code||D.WRITE_CONFLICT}},e.CannotCreateIndexError=class extends T{constructor(e,t={}){super(`Cannot create index: ${e}`,{...t,code:D.CANNOT_CREATE_INDEX}),this.name="CannotCreateIndexError"}},e.ChangeStream=wt,e.CursorError=F,e.CursorNotFoundError=class extends F{constructor(e,t={}){super(`Cursor ${e} not found`,{...t,code:D.CURSOR_NOT_FOUND}),this.name="CursorNotFoundError",this.cursorId=e}},e.DuplicateKeyError=class extends L{constructor(e,t={}){const n=JSON.stringify(e);super(`E11000 duplicate key error${t.collection?` collection: ${t.collection}`:""} index: ${n} dup key: ${n}`,{...t,code:D.DUPLICATE_KEY}),this.name="DuplicateKeyError",this.keyPattern=e,this.keyValue=t.keyValue||e}},e.ErrorCodes=D,e.IndexError=T,e.IndexExistsError=class extends T{constructor(e,t={}){super(`Index with name '${e}' already exists`,{...t,code:D.INDEX_EXISTS}),this.name="IndexExistsError",this.indexName=e}},e.IndexNotFoundError=j,e.IndexedDbStorageEngine=class extends Nt{constructor(e="micro-mongo"){super(),this.dbName=e,this.db=null,this.indexedDBName=`micro-mongo-${e}`}async initialize(){return new Promise((e,t)=>{const n=indexedDB.open(this.indexedDBName,1);n.onerror=()=>{t(new Error("Failed to open IndexedDB: "+n.error))},n.onsuccess=()=>{this.db=n.result,e()},n.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains("collections")||t.createObjectStore("collections",{keyPath:"name"}),t.objectStoreNames.contains("metadata")||t.createObjectStore("metadata",{keyPath:"key"})}})}async saveDatabase(e){this.db||await this.initialize();const t=this.db.transaction(["metadata"],"readwrite").objectStore("metadata");await new Promise((n,r)=>{const i=t.put({key:"dbName",value:e.name});i.onsuccess=()=>n(),i.onerror=()=>r(i.error)});for(const n in e.collections)e.collections.hasOwnProperty(n)&&await this.saveCollection(e.name,n,e.collections[n])}async loadDatabase(e){this.db||await this.initialize();const t=this.db.transaction(["collections"],"readonly").objectStore("collections");return new Promise((n,r)=>{const i=t.getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.name]={documents:e.documents||[],indexes:e.indexes||[]};n({name:e,collections:t})},i.onerror=()=>r(i.error)})}async saveCollection(e,t,n){this.db||await this.initialize();const r=this.db.transaction(["collections"],"readwrite").objectStore("collections");return new Promise((e,i)=>{const s=r.put({name:t,documents:n.documents||[],indexes:n.indexes||[]});s.onsuccess=()=>e(),s.onerror=()=>i(s.error)})}async loadCollection(e,t){this.db||await this.initialize();const n=this.db.transaction(["collections"],"readonly").objectStore("collections");return new Promise((e,r)=>{const i=n.get(t);i.onsuccess=()=>{i.result?e({documents:i.result.documents||[],indexes:i.result.indexes||[]}):e(null)},i.onerror=()=>r(i.error)})}async deleteCollection(e,t){this.db||await this.initialize();const n=this.db.transaction(["collections"],"readwrite").objectStore("collections");return new Promise((e,r)=>{const i=n.delete(t);i.onsuccess=()=>e(),i.onerror=()=>r(i.error)})}async deleteDatabase(e){return this.db&&(this.db.close(),this.db=null),new Promise((e,t)=>{const n=indexedDB.deleteDatabase(this.indexedDBName);n.onsuccess=()=>e(),n.onerror=()=>t(n.error)})}async close(){this.db&&(this.db.close(),this.db=null)}},e.InvalidNamespaceError=class extends P{constructor(e,t,n={}){"object"!=typeof t||n||(n=t,t=void 0);super(t?`Invalid namespace '${e}': ${t}`:`Invalid namespace '${e}'`,{...n,code:D.INVALID_NAMESPACE}),this.name="InvalidNamespaceError",this.namespace=e}},e.MongoClient=Et,e.MongoDriverError=class extends M{constructor(e,t={}){super(e,t),this.name="MongoDriverError",this.code=t.code||D.INTERNAL_ERROR}},e.MongoError=M,e.MongoNetworkError=class extends M{constructor(e,t={}){super(e,t),this.name="MongoNetworkError",this.code=t.code||D.HOST_UNREACHABLE}},e.MongoServerError=class extends M{constructor(e,t={}){super(e,t),this.name="MongoServerError"}},e.NamespaceError=P,e.NamespaceNotFoundError=class extends P{constructor(e,t={}){super(`Namespace '${e}' not found`,{...t,code:D.NAMESPACE_NOT_FOUND}),this.name="NamespaceNotFoundError",this.namespace=e}},e.NotImplementedError=U,e.ObjectId=g,e.OperationNotSupportedError=class extends M{constructor(e,t,n={}){"object"!=typeof t||n||(n=t,t=void 0);super(t?`Operation '${e}' is not supported: ${t}`:`Operation '${e}' is not supported`,{...n,code:D.OPERATION_NOT_SUPPORTED,operation:e}),this.name="OperationNotSupportedError"}},e.QueryError=k,e.StorageEngine=Nt,e.Timestamp=Je,e.TypeMismatchError=class extends M{constructor(e,t,n,r={}){super(`Type mismatch for field '${e}': expected ${t}, got ${n}`,{...r,code:D.TYPE_MISMATCH,field:e}),this.name="TypeMismatchError",this.expectedType=t,this.actualType=n}},e.ValidationError=class extends M{constructor(e,t={}){super(e,t),this.name="ValidationError",this.code=t.code||D.DOCUMENT_VALIDATION_FAILURE,this.validationErrors=t.validationErrors||[]}},e.WriteError=L,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=micro-mongo-2.0.0.min.umd.js.map
